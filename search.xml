<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>多线程</title>
      <link href="/2022/03/10/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2022/03/10/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="程序、进程、线程"><a href="#程序、进程、线程" class="headerlink" title="程序、进程、线程"></a>程序、进程、线程</h2><p><strong>程序(program)  <strong>是为完成特定任务、用某种语言编写的一组指令的集合。即指一段</strong>静态的代码</strong>，静态对象。  </p><p>**进程(process)  **是程序的一次执行过程，或是正在运行的一个程序。是一个动态的过程：有它自身的产生、存在和消亡的过程。 ——生命周期</p><ul><li>如：运行中的QQ，运行中的MP3播放器</li><li><strong>程序是静态的，进程是动态的</strong></li><li><strong>进程作为资源分配的单位</strong>， 系统在运行时会为每个进程分配不同的内存区域  </li></ul><p><strong>线程(thread)</strong>  进程可进一步细化为线程，<strong>是一个程序内部的一条执行路径</strong>。如main方法</p><ul><li>若一个进程同一时间并行执行多个线程，就是支持多线程的  </li><li><strong>线程作为调度和执行的单位</strong>，**每个线程拥有独立的运行栈和程序计数器(pc)**，线程切换的开销小  </li><li><strong>一个进程中的多个线程共享相同的内存单元/内存地址空间 -</strong>——-&gt;  它们从同一堆中分配对象，可以访问相同的变量和对象。这就使得线程间通信更简便、高效。但多个线程操作共享的系统资源可能就会带来安全的隐患（<strong>线程安全问题</strong>）。  </li></ul><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220310110154827.png" alt="image-20220310110154827" style="zoom: 67%;" /><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><input checked="" disabled="" type="checkbox"> <strong>进程是资源分配的基本单位；线程是程序执行的基本单位</strong></li></ul><p>一个<strong>进程</strong>一个<strong>方法区和堆</strong>，一个<strong>线程</strong>一个<strong>虚拟机栈和程序计数器</strong>。因为一个进程一个方法区和堆，所以一个进程中的多个线程会共享方法区和堆。   ———-&gt;   因为多个线程会共享资源，所以就会有线程安全问题。</p><p>Java应用程序中的线程：一个Java应用程序java.exe，其实至少有三个线程： <strong>main()主线程， gc()垃圾回收线程，异常处理线程</strong>。当然如果发生异常，会影响主线程。  </p><h2 id="并行与并发"><a href="#并行与并发" class="headerlink" title="并行与并发"></a><strong>并行与并发</strong></h2><p>并行： 多个CPU同时执行多个任务。比如：多个人同时做不同的事。<br>并发： 一个CPU(采用时间片) <strong>“同时”</strong> 执行多个任务。比如：秒杀、多个人做同一件事。  </p><h2 id="为什么要使用多线程呢"><a href="#为什么要使用多线程呢" class="headerlink" title="为什么要使用多线程呢?"></a>为什么要使用多线程呢?</h2><p>举例：在单核CPU的情况下，我们需要将C盘1G的资源移动到D盘，将E盘1G的资源移动到F盘，下面两种方式哪种快？为啥？</p><p>方式一：先将 C ———&gt;  D，然后立马 E ———&gt; F</p><p>方式二：同时C ———&gt;  D 和 E ———&gt; F  （多线程）</p><p>方式一快，多线程反而慢。因为多线程会存在线程上下文切换，导致程序执行速度变慢。多线程不会提高程序的执行速度，反而会降低速度。但是对于用户来说，可以<strong>减少用户的等待响应时间，提高了资源的利用效率</strong></p><h3 id="多线程程序的优点"><a href="#多线程程序的优点" class="headerlink" title="多线程程序的优点"></a>多线程程序的优点</h3><ul><li>提高应用程序的响应。对图形化界面更有意义，可增强用户体验。  <strong>以使用杀毒软件的场景为例，在杀毒木马的同时进行清理垃圾。</strong></li><li>提高计算机系统CPU的利用率    单线程之间还要有时间间隔</li><li>改善程序结构。将既长又复杂的进程分为多个线程，独立运行，利于理解和修改  </li></ul><h2 id="线程的创建和启动"><a href="#线程的创建和启动" class="headerlink" title="线程的创建和启动"></a>线程的创建和启动</h2><p>Java语言的JVM允许程序运行多个线程，它通过<code>java.lang.Thread</code>类来体现。  </p><p><strong>Thread类的特性</strong></p><ul><li>每个线程都是通过某个特定Thread对象的run()方法来完成操作的，经常把run()方法的主体称为线程体</li><li> 通过该<strong>Thread对象的start()方法</strong>来启动这个线程，而非直接调用run()  </li></ul><h3 id="多线程的创建"><a href="#多线程的创建" class="headerlink" title="多线程的创建"></a>多线程的创建</h3><h4 id="方式一：继承Thread类"><a href="#方式一：继承Thread类" class="headerlink" title="方式一：继承Thread类"></a>方式一：继承Thread类</h4><ol><li>定义子类继承Thread类。</li><li><strong>子类中重写Thread类中的run方法。</strong>——-&gt;  将此线程执行的操作声明在run() 中,就是你想用这个线程干啥事</li><li>创建Thread子类对象，即创建了线程对象。</li><li>调用线程对象start（）方法：启动线程，调用run方法。  </li></ol><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220310203640713.png" alt="image-20220310203640713"></p><p>此时为两个线程 <code>TestThread</code>和<code>MyThread</code></p><p><strong>注意点：</strong></p><ul><li><p><strong>如果自己手动调用run()方法，那么就只是普通方法，没有启动多线程模式</strong>。</p><p>为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？</p><p>new 一个 Thread，线程进入了<strong>新建状态</strong>。调用 <code>start()</code>方法，会启动一个线程并使线程进入了<strong>就绪状态</strong>，当分配到时间片后就可以开始运行了。 <code>start()</code> 会执行线程的相应准备工作，然后自动执行 <code>run()</code> 方法的内容，这是真正的多线程工作。 但是，<strong>直接执行 <code>run()</code> 方法，会把 <code>run()</code> 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</strong></p><p><strong>总结： 调用 <code>start()</code> 方法方可启动线程并使线程进入就绪状态，直接执行 <code>run()</code> 方法的话不会以多线程的方式执行。</strong></p></li><li><p>run()方法由JVM调用，什么时候调用，执行的过程控制都有操作系统的CPU调度决定。</p></li><li><p><strong>想要启动多线程，必须调用start方法。</strong></p></li><li><p><strong>一个线程对象只能调用一次start()方法</strong>启动，如果重复调用了，则将抛出以上的异常“IllegalThreadStateException” 。  </p></li></ul><h5 id="练-习"><a href="#练-习" class="headerlink" title="练 习"></a>练 习</h5><p>创建两个分线程，让其中一个线程输出1-100之间的偶数，另一个线程输出1-100之间的奇数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> practice;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ykangli</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/3/10 20:55</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ThreadA</span> <span class="variable">threadA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadA</span>();</span><br><span class="line">        <span class="type">ThreadB</span> <span class="variable">threadB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadB</span>();</span><br><span class="line">        threadA.start();</span><br><span class="line">        threadB.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadA</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadB</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方式二：实现Runnable接口"><a href="#方式二：实现Runnable接口" class="headerlink" title="方式二：实现Runnable接口"></a>方式二：实现Runnable接口</h4><ol><li>定义子类，实现Runnable接口。</li><li>子类中<strong>重写Runnable接口中的run方法</strong>。</li><li>通过Thread类含参构造器创建线程对象。</li><li>将Runnable接口的子类对象作为实际参数传递给Thread类的构造器中。</li><li>调用Thread类的start方法：开启线程， 调用Runnable子类接口的run方法。  </li></ol><h5 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h5><p>模拟火车站售票程序，开启三个窗口售票，总票数为100张，使用Runnable接口的方式实现。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> practice;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ykangli</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/3/10 21:31</span></span><br><span class="line"><span class="comment"> * 存在线程安全的问题</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Ticket</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Window</span> <span class="variable">window</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Window</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(window);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(window);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(window);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread3.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Window</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>  <span class="type">int</span> <span class="variable">ticketNum</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(ticketNum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+ <span class="string">&quot;卖票号：&quot;</span> + ticketNum);</span><br><span class="line">                ticketNum--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="两种多线程创建方式对比"><a href="#两种多线程创建方式对比" class="headerlink" title="两种多线程创建方式对比"></a>两种多线程创建方式对比</h3><p>public class Thread extends Object implements Runnable</p><p><strong>区别</strong></p><ul><li>继承Thread：线程代码存放Thread子类run方法中。</li><li>实现Runnable：线程代码存在接口的子类的run方法。</li></ul><p><strong>实现方式的好处</strong></p><ul><li>避免了单继承的局限性</li><li>多个线程可以共享同一个接口实现类的对象，非常适合多个相同线</li><li>程来处理同一份资源。  </li></ul><h2 id="线程的调度"><a href="#线程的调度" class="headerlink" title="线程的调度"></a>线程的调度</h2><h4 id="调度策略"><a href="#调度策略" class="headerlink" title="调度策略"></a><strong>调度策略</strong></h4><p>抢占式： 高优先级的线程抢占CPU  </p><h4 id="Java的调度方法"><a href="#Java的调度方法" class="headerlink" title="Java的调度方法"></a><strong>Java的调度方法</strong></h4><ul><li>同优先级线程组成先进先出队列（先到先服务），使用时间片策略</li><li>对高优先级，使用优先调度的抢占式策略  </li></ul><h4 id="线程的优先级等级"><a href="#线程的优先级等级" class="headerlink" title="线程的优先级等级"></a>线程的优先级等级</h4><ul><li>MAX_PRIORITY： 10</li><li>MIN _PRIORITY： 1</li><li>NORM_PRIORITY： 5</li></ul><p><strong>涉及的方法</strong></p><ul><li>getPriority() ： 返回线程优先值</li><li>setPriority(int newPriority) ： 改变线程的优先级</li></ul><p> <strong>说明</strong></p><p>线程创建时继承父线程的优先级</p><p>低优先级只是获得调度的概率低，并非一定是在高优先级线程之后才被调用  </p><h2 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h2><p>JDK中用Thread.State类定义了线程的几种状态要想实现多线程，必须在主线程中创建新的线程对象。Java语言使用Thread类及其子类的对象来表示线程，在它的一个完整的生命周期中通常要经历如下的五种状态:</p><ol><li>新建:当一个Thread类或其子类的对象被声明并创建时，新生的线程对象处于新建状态</li><li>就绪:处于新建状态的线程被<strong>start()后</strong>，将进入线程队列等待CPU时间片，此时它已具备了运行的条件，只是没分配到CPU资源</li><li>运行:当就绪的线程被调度并<strong>获得CPU资源时</strong>,便进入运行状态，run()方法定义了线程的操作和功能</li><li>阻塞:在某种特殊情况下，被人为挂起或执行输入输出操作时，<strong>让出CPU并临时中止自己的执行，进入阻塞状态</strong></li><li>死亡:线程完成了它的全部工作或线程被提前强制性地中止或出现异常导致结束 </li></ol><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220310215928462.png" alt="image-20220310215928462"></p><h2 id="线程的同步"><a href="#线程的同步" class="headerlink" title="线程的同步"></a>线程的同步</h2><p><strong>问题的提出</strong> —–&gt; 线程安全问题</p><ul><li>多个线程执行的不确定性引起执行结果的不稳定</li><li>多个线程对账本的共享，会造成操作的不完整性，会破坏数据。  </li></ul><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220311091936432.png" alt="image-20220311091936432"></p><p><strong>问题出现的原因：</strong></p><p>当多条语句在操作同一个<strong>线程共享数据</strong>时，一个线程对多条语句只执行了一部分，还没有执行完，另一个线程参与进来执行。导致共享数据的错误。  </p><p><strong>解决办法：</strong><br>对多条操作共享数据的语句，只能让一个线程都执行完，在执行过程中，其他线程不可以参与执行。  </p><h3 id="同步机制解决线程安全问题"><a href="#同步机制解决线程安全问题" class="headerlink" title="同步机制解决线程安全问题"></a>同步机制解决线程安全问题</h3><h4 id="方法一：同步代码块"><a href="#方法一：同步代码块" class="headerlink" title="方法一：同步代码块"></a>方法一：同步代码块</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (同步监视器)&#123;</span><br><span class="line"><span class="comment">// 需要被同步的代码；</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><ol><li>操作共享数据的代码，即为需要被同步的代码</li><li>共享数据：多个线程共同操作的遍量，比如：ticket就是共享数据。</li><li>同步监视器， 俗称：锁。  任何一个类的对象都可以充当锁。  要求：<strong>多个线程必须要共用同一把锁。</strong></li></ol><h5 id="练习-1"><a href="#练习-1" class="headerlink" title="练习 1"></a>练习 1</h5><p>利用同步代码块解决线程安全问题（多线程是用实现Runnable接口实现）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> practice;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ykangli</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/3/10 21:31</span></span><br><span class="line"><span class="comment"> * 存在线程安全的问题</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Ticket</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Window</span> <span class="variable">window</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Window</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(window);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(window);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(window);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread3.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Window</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>  <span class="type">int</span> <span class="variable">ticketNum</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//Object object = new Object(); 不能将锁放在这里，因为所有线程要共用一把锁。</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">                <span class="comment">//或者 synchronized (this)  this就是当前对象，也就是Window的实例window，上面只创建了一个</span></span><br><span class="line">                <span class="keyword">if</span>(ticketNum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+ <span class="string">&quot;卖票号：&quot;</span> + ticketNum);</span><br><span class="line">                    ticketNum--;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="练习-2"><a href="#练习-2" class="headerlink" title="练习 2"></a>练习 2</h5><p>利用同步代码块解决线程安全问题（多线程是用继承Thread类实现）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> practice;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ykangli</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/3/11 10:15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TicketThread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Window2</span> <span class="variable">windowA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Window2</span>();</span><br><span class="line">        <span class="type">Window2</span> <span class="variable">windowB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Window2</span>();</span><br><span class="line">        <span class="type">Window2</span> <span class="variable">windowC</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Window2</span>();</span><br><span class="line"></span><br><span class="line">        windowA.start();</span><br><span class="line">        windowB.start();</span><br><span class="line">        windowC.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Window2</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">ticketNum</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">                <span class="comment">//以下是错误的，因为this不唯一，使得锁不唯一</span></span><br><span class="line">                <span class="comment">//synchronized (this) &#123;  </span></span><br><span class="line">                <span class="comment">//可以这样写，因为Class clazz = Window2.class;</span></span><br><span class="line">                <span class="comment">//synchronized (Window2.class) &#123;  </span></span><br><span class="line">                <span class="keyword">if</span> (ticketNum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;卖票号：&quot;</span> + ticketNum);</span><br><span class="line">                    ticketNum--;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法二：同步方法"><a href="#方法二：同步方法" class="headerlink" title="方法二：同步方法"></a>方法二：同步方法</h4><p>如果操作共享数据的代码完整的声明在一个方法中，我们不妨将此方法声明为<strong>同步方法</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">show</span> <span class="params">(String name)</span>&#123;</span><br><span class="line">…</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="练习-1-1"><a href="#练习-1-1" class="headerlink" title="练习 1"></a>练习 1</h5><p>利用同步方法解决线程安全问题（多线程是用实现Runnable接口实现）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> practice;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ykangli</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/3/10 21:31</span></span><br><span class="line"><span class="comment"> * 存在线程安全的问题</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Ticket</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Window</span> <span class="variable">window</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Window</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(window);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(window);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(window);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Window</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">ticketNum</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//Object object = new Object(); 不能将锁放在这里，因为所有线程要共用一把锁。</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            show();</span><br><span class="line">        &#125; <span class="keyword">while</span> (ticketNum &gt; <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(ticketNum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+ <span class="string">&quot;卖票号：&quot;</span> + ticketNum);</span><br><span class="line">            ticketNum--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="练习-2-1"><a href="#练习-2-1" class="headerlink" title="练习 2"></a>练习 2</h5><p>利用同步方法解决线程安全问题（多线程是用继承Thread类实现）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> practice;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ykangli</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/3/11 10:15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TicketThread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Window2</span> <span class="variable">windowA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Window2</span>();</span><br><span class="line">        <span class="type">Window2</span> <span class="variable">windowB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Window2</span>();</span><br><span class="line">        <span class="type">Window2</span> <span class="variable">windowC</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Window2</span>();</span><br><span class="line"></span><br><span class="line">        windowA.start();</span><br><span class="line">        windowB.start();</span><br><span class="line">        windowC.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Window2</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">ticketNum</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            show();</span><br><span class="line">            <span class="keyword">if</span>(ticketNum &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//以下错误，不是同一把锁。可以加static实现同一把锁</span></span><br><span class="line">    <span class="comment">//private synchronized void show() &#123; </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ticketNum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;卖票号：&quot;</span> + ticketNum);</span><br><span class="line">            ticketNum--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法三：Lock-锁"><a href="#方法三：Lock-锁" class="headerlink" title="方法三：Lock(锁)"></a>方法三：Lock(锁)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReenTrantLock</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m</span><span class="params">()</span> &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//保证线程安全的代码;</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>锁【reentrantLock.lock】必须紧跟try代码块，且unlock要放到finally第一行。</p><h5 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> practice;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ykangli</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/3/11 14:38</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Window3</span> <span class="variable">window3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Window3</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(window3);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(window3);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadC</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(window3);</span><br><span class="line"></span><br><span class="line">        threadA.start();</span><br><span class="line">        threadB.start();</span><br><span class="line">        threadC.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Window3</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">ticketNum</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">ReentrantLock</span> <span class="variable">reentrantLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            reentrantLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (ticketNum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;卖票号：&quot;</span> + ticketNum);</span><br><span class="line">                    ticketNum--;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                reentrantLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="synchronized-与-Lock-的对比"><a href="#synchronized-与-Lock-的对比" class="headerlink" title="synchronized 与 Lock 的对比"></a>synchronized 与 Lock 的对比</h3><ul><li>Lock是显式锁（手动开启和关闭锁，别忘记关闭锁）， synchronized是隐式锁，出了作用域自动释放</li><li>Lock只有代码块锁， synchronized有代码块锁和方法锁</li><li>使用Lock锁， JVM将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性（提供更多的子类）  </li></ul><p>优先使用顺序：<br>Lock —–&gt; 同步代码块（已经进入了方法体，分配了相应资源）—–&gt;  同步方法（在方法体之外）  </p><h5 id="练习-2"><a href="#练习-2" class="headerlink" title="练习"></a>练习</h5><p>银行有一个账户。有两个储户分别向同一个账户存3000元， 每次存1000， 存3次。每次存完打印账户余额。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> practice;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ykangli</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/3/11 15:06</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Account</span> <span class="variable">account</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Account</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Customer</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Customer</span>(account);</span><br><span class="line">        <span class="type">Customer</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Customer</span>(account);</span><br><span class="line">        c1.setName(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        c2.setName(<span class="string">&quot;B&quot;</span>);</span><br><span class="line"></span><br><span class="line">        c1.start();</span><br><span class="line">        c2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> balance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Account</span><span class="params">(<span class="type">double</span> balance)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.balance = balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deposit</span><span class="params">(<span class="type">double</span> amt)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (amt &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            balance += amt;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+ <span class="string">&quot;存钱成功，余额为：&quot;</span> + balance);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Customer</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Account account;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Customer</span><span class="params">(Account account)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.account = account;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">                account.deposit(<span class="number">1000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="同步机制中的锁"><a href="#同步机制中的锁" class="headerlink" title="同步机制中的锁"></a>同步机制中的锁</h3><p><strong>同步锁机制：</strong></p><p>在《Thinking in Java》 中， 是这么说的：对于并发工作， 你需要某种方式来防止两个任务访问相同的资源（其实就是共享资源竞争） 。 防止这种冲突的方法就是当资源被一个任务使用时， 在其上加锁。 第一个访问某项资源的任务必须锁定这项资源， 使其他任务在其被解锁之前， 就无法访问它了， 而在其被解锁之时， 另一个任务就可以锁定并使用它了。</p><p><strong>synchronized的锁是什么？</strong></p><ul><li>任意对象都可以作为同步锁。 所有对象都自动含有单一的锁（监视器） 。</li><li>同步方法的锁：静态方法（类名.class） 、 非静态方法（this）</li><li>同步代码块：自己指定， 很多时候也是指定为this或类名.class</li></ul><p><strong>注意：</strong></p><ul><li>必须确保使用同一个资源的多个线程共用一把锁， 这个非常重要， 否则就无法保证共享资源的安全</li><li>一个线程类中的所有静态方法共用同一把锁（类名.class） ， 所有非静态方法共用同一把锁（this） ， 同步代码块（指定需谨慎）  </li></ul><h2 id="线程的死锁问题"><a href="#线程的死锁问题" class="headerlink" title="线程的死锁问题"></a>线程的死锁问题</h2><p><strong>死锁</strong>  </p><ul><li>不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁  </li></ul><p>​        如下图所示，线程 A 持有资源 2，线程 B 持有资源 1，他们<strong>同时都想申请对方的资源</strong>，所以这两个线程就会互相等待而进入死锁状        态。</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220311110615861.png" alt="image-20220311110615861"></p><ul><li>出现死锁后，<strong>不会出现异常，不会出现提示</strong>，只是所有的线程都处于阻塞状态，无法继续  </li></ul><h3 id="举例（代码来源于《并发编程之美》）"><a href="#举例（代码来源于《并发编程之美》）" class="headerlink" title="举例（代码来源于《并发编程之美》）"></a>举例（代码来源于《并发编程之美》）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLockDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">resource1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();<span class="comment">//资源 1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">resource2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();<span class="comment">//资源 2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resource1) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;get resource1&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;waiting get resource2&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (resource2) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">&quot;get resource2&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;线程 1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resource2) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;get resource2&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;waiting get resource1&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (resource1) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">&quot;get resource1&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;线程 2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Output</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Thread[线程 1,5,main]get resource1</span><br><span class="line">Thread[线程 2,5,main]get resource2</span><br><span class="line">Thread[线程 1,5,main]waiting get resource2</span><br><span class="line">Thread[线程 2,5,main]waiting get resource1</span><br></pre></td></tr></table></figure><p>说明：线程 A 通过 <code>synchronized (resource1)</code> 获得 <code>resource1</code> 的监视器锁，然后通过<code>Thread.sleep(1000);</code>让线程 A 休眠 1s 为的是让线程 B 得到执行然后获取到 <code>resource2 </code>的监视器锁。此时，线程A和线程B分别拿到了 <code>resource1</code> 和 <code>resource2 </code>。之后，线程 A 和线程 B 休眠结束了都开始企图请求获取对方的资源，然后这两个线程就会陷入互相等待的状态（因为两个线程都用锁锁上了自己所拥有的资源，也就是还在Sychronized代码块中，<strong>各自都没有释放目前各自所拥有的资源，对方自然也就拿不到</strong>），这也就产生了死锁。上面的例子符合产生死锁的四个必要条件。</p><h3 id="死锁必须具备的四个条件"><a href="#死锁必须具备的四个条件" class="headerlink" title="死锁必须具备的四个条件"></a>死锁必须具备的四个条件</h3><ol><li>互斥条件：该资源任意一个时刻只由一个线程占用。</li><li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li><li>不剥夺条件:线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</li><li>循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。</li></ol><p><strong>解决方法</strong>  </p><ul><li>专门的算法、原则  </li><li>尽量减少同步资源的定义  </li><li>尽量避免嵌套同步  </li></ul><h2 id="线程的通信"><a href="#线程的通信" class="headerlink" title="线程的通信"></a>线程的通信</h2><p><strong>wait() 与 notify() 和 notifyAll()</strong>  </p><ul><li>wait()：令当前线程挂起并放弃CPU、 同步资源并等待， 使别的线程可访问并修改共享资源，而当前线程排队等候其他线程调用notify()或notifyAll()方法唤醒，唤醒后等待重新获得对监视器的所有权后才能继续执行。  </li><li>notify()：唤醒正在排队等待同步资源的线程中优先级最高者结束等待  </li><li>notifyAll ()：唤醒正在排队等待资源的所有线程结束等待  </li></ul><h3 id="练习-3"><a href="#练习-3" class="headerlink" title="练习"></a>练习</h3><p>使用两个线程打印 1-100。线程1, 线程2 交替打印  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> practice;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ykangli</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/3/11 20:28</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadCommunication</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Communication</span> <span class="variable">communication</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Communication</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(communication);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(communication);</span><br><span class="line"></span><br><span class="line">        threadA.start();</span><br><span class="line">        threadB.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Communication</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                notify();</span><br><span class="line">                <span class="keyword">if</span> (i &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i++);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>wait() 与 notify() 和 notifyAll()</strong></p><ul><li>wait()：令当前线程<strong>挂起并放弃CPU、 同步资源</strong>并等待， 使别的线程可访问并修改共享资源，而当前线程排队等候其他线程调用notify()或notifyAll()方法唤醒，唤醒后等待重新获得对监视器的所有权后才能继续执行。</li><li>notify()：唤醒正在排队等待同步资源的线程中优先级最高者结束等待</li><li>notifyAll ()：唤醒正在排队等待资源的所有线程结束等待.  </li></ul><p>这三个方法只有在synchronized方法或synchronized代码块中才能使用，否则会报java.lang.IllegalMonitorStateException异常。  </p><p>这三个方法的调用者必须是同步代码块或者同步方法中的同步监视器。</p><p>wait() 与 notify() 和 notifyAll()  是定义在Object中</p><h2 id="sleep-方法和-wait-方法的异同"><a href="#sleep-方法和-wait-方法的异同" class="headerlink" title="sleep() 方法和 wait() 方法的异同"></a>sleep() 方法和 wait() 方法的异同</h2><p><strong>相同：</strong></p><p>两者都可以暂停线程的执行，使得当前的线程进入阻塞状态。</p><p><strong>区别：</strong></p><p>两者最主要的区别在于：**<code>sleep()</code> 方法没有释放锁，而 <code>wait()</code> 方法释放了锁** 。</p><ul><li><strong>sleep方法：</strong>是Thread类的静态方法，当前线程将睡眠n毫秒，线程进入阻塞状态。当<strong>睡眠时间到了，会解除阻塞</strong>，进入可运行状态，等待CPU的到来。睡眠不释放锁（如果有的话）。</li><li><strong>wait方法：</strong>是Object的方法，必须与synchronized关键字一起使用，线程进入阻塞状态，当notify或者notifyall被调用后，会解除阻塞。但是，只有<strong>重新占用互斥锁</strong>之后才会进入可运行状态。睡眠时，会释放<strong>互斥锁</strong>。</li></ul><h2 id="join-方法和yield-方法"><a href="#join-方法和yield-方法" class="headerlink" title="join () 方法和yield()  方法"></a>join () 方法和yield()  方法</h2><p><strong>join 方法：</strong>当前线程调用，则其它线程全部停止，等待当前线程执行完毕，接着执行。</p><p><strong>yield 方法：</strong>该方法使得线程放弃当前分得的 CPU 时间。但是不使线程阻塞，即线程仍处于可执行状态，随时可能再次分得 CPU 时间。</p><h2 id="线程池（JDK-5-0）"><a href="#线程池（JDK-5-0）" class="headerlink" title="线程池（JDK 5.0）"></a>线程池（JDK 5.0）</h2><p>思路： 提前创建好多个线程，放入线程池中，使用时直接获取，<strong>使用完放回池中。可以避免频繁创建销毁、实现重复利用</strong>。类似生活中的公共交通工具。  </p><p>好处：  </p><ul><li>提高响应速度（减少了创建新线程的时间）</li><li>降低资源消耗（重复利用线程池中线程，不需要每次都创建）</li><li>便于线程管理  </li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>滑动窗口</title>
      <link href="/2022/03/09/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
      <url>/2022/03/09/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="76-最小覆盖子串"><a href="#76-最小覆盖子串" class="headerlink" title="76. 最小覆盖子串"></a>76. 最小覆盖子串</h2><p>难度困难</p><p>给你一个字符串 <code>s</code> 、一个字符串 <code>t</code> 。返回 <code>s</code> 中涵盖 <code>t</code> 所有字符的最小子串。如果 <code>s</code> 中不存在涵盖 <code>t</code> 所有字符的子串，则返回空字符串 <code>&quot;&quot;</code> 。</p><p><strong>注意：</strong></p><ul><li>对于 <code>t</code> 中重复字符，我们寻找的子字符串中该字符数量必须不少于 <code>t</code> 中该字符数量。</li><li>如果 <code>s</code> 中存在这样的子串，我们保证它是唯一的答案。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;ADOBECODEBANC&quot;, t = &quot;ABC&quot;</span><br><span class="line">输出：&quot;BANC&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;a&quot;, t = &quot;a&quot;</span><br><span class="line">输出：&quot;a&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;a&quot;, t = &quot;aa&quot;</span><br><span class="line">输出: &quot;&quot;</span><br><span class="line">解释: t 中两个字符 &#x27;a&#x27; 均应包含在 s 的子串中，</span><br><span class="line">因此没有符合条件的子字符串，返回空字符串。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length, t.length &lt;= 105</code></li><li><code>s</code> 和 <code>t</code> 由英文字母组成</li></ul><p><strong>进阶：</strong>你能设计一个在 <code>o(n)</code> 时间内解决此问题的算法吗？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">minWindow</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="comment">//用于记录窗口符合条件字符的情况</span></span><br><span class="line">        Map&lt;Character, Integer&gt; windowMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//用于记录t中各字符的个数</span></span><br><span class="line">        Map&lt;Character, Integer&gt; tMap =  <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//遍历将t中各字符情况记录在tMap中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; t.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">a</span> <span class="operator">=</span> t.charAt(i);</span><br><span class="line">            tMap.put(a, tMap.getOrDefault(a, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>; </span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//用来记录窗口中字符是否已经覆盖t，当valid == tMap.size()时就是已经覆盖</span></span><br><span class="line">        <span class="comment">//即使出现重复的同一个字符也满足，比如&quot;aa&quot;，由于只有当tMap和windowMap中a的记录数都相同时才加一，</span></span><br><span class="line">        <span class="comment">//也就是当会tMap中以a为键的值为2，windowMap以a为键的值也为2时，valid才回加一.</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">valid</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//记录最小覆盖子串的起始索引及长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">minLength</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//扩大窗口</span></span><br><span class="line">        <span class="keyword">while</span>(right &lt; s.length()) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(right);</span><br><span class="line">            right++;</span><br><span class="line">            <span class="keyword">if</span>(tMap.containsKey(c)) &#123;</span><br><span class="line">                windowMap.put(c, windowMap.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(tMap.get(c).equals(windowMap.get(c))) &#123;</span><br><span class="line">                    valid++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//缩小窗口</span></span><br><span class="line">            <span class="keyword">while</span>(valid == tMap.size()) &#123;</span><br><span class="line">                <span class="comment">//目前窗口里的子串符合条件，那么就记录下来</span></span><br><span class="line">                <span class="keyword">if</span>(right - left &lt; minLength) &#123;</span><br><span class="line">                    minLength = right - left;</span><br><span class="line">                    start = left;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//移动左指针去掉一个字符</span></span><br><span class="line">                <span class="type">char</span> <span class="variable">d</span> <span class="operator">=</span> s.charAt(left);</span><br><span class="line">                left++;</span><br><span class="line">                <span class="comment">//去掉的字符是tMap中的字符时候,需要对窗口内的数据进行一系列更新</span></span><br><span class="line">                <span class="keyword">if</span>(tMap.containsKey(d)) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(tMap.get(d).equals(windowMap.get(d))) &#123;</span><br><span class="line">                        valid--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    windowMap.put(d, windowMap.get(d) - <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">return</span> <span class="variable">minLength</span> <span class="operator">=</span>= Integer.MAX_VALUE ? <span class="string">&quot;&quot;</span> : s.substring(start, start + minLength);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="567-字符串的排列"><a href="#567-字符串的排列" class="headerlink" title="567. 字符串的排列"></a>567. 字符串的排列</h2><p>难度中等</p><p>给你两个字符串 <code>s1</code> 和 <code>s2</code> ，写一个函数来判断 <code>s2</code> 是否包含 <code>s1</code> 的排列。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p>换句话说，<code>s1</code> 的排列之一是 <code>s2</code> 的 <strong>子串</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s1 = &quot;ab&quot; s2 = &quot;eidbaooo&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：s2 包含 s1 的排列之一 (&quot;ba&quot;).</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s1= &quot;ab&quot; s2 = &quot;eidboaoo&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s1.length, s2.length &lt;= 104</code></li><li><code>s1</code> 和 <code>s2</code> 仅包含小写字母</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkInclusion</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line">        Map&lt;Character, Integer&gt; windowMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        Map&lt;Character, Integer&gt; s1Map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s1.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">a</span> <span class="operator">=</span> s1.charAt(i);</span><br><span class="line">            s1Map.put(a, s1Map.getOrDefault(a, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">valid</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(right &lt; s2.length()) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s2.charAt(right);</span><br><span class="line">            right++;</span><br><span class="line">            <span class="keyword">if</span>(s1Map.containsKey(c)) &#123;</span><br><span class="line">                windowMap.put(c, windowMap.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(s1Map.get(c).equals(windowMap.get(c))) &#123;</span><br><span class="line">                    valid++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//若窗口的长度等于s1.length()时还没找到，说明以当前left开始的子串就不满足条件，此时就要缩小窗口。</span></span><br><span class="line">            <span class="keyword">while</span>(right - left == s1.length()) &#123;</span><br><span class="line">                <span class="keyword">if</span>(valid == s1Map.size()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">char</span> <span class="variable">d</span> <span class="operator">=</span> s2.charAt(left);</span><br><span class="line">                left++;</span><br><span class="line">                <span class="keyword">if</span>(s1Map.containsKey(d)) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(s1Map.get(d).equals(windowMap.get(d))) &#123;</span><br><span class="line">                        valid--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    windowMap.put(d, windowMap.get(d) - <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于这道题的解法代码，基本上和最小覆盖子串一模一样，只需要改变两个地方：</p><p>1、本题移动 <code>left</code> 缩小窗口的时机是窗口长度等于 <code>t.size()</code> 时，应为排列嘛，显然长度应该是一样的。</p><p>2、当发现 <code>valid == need.size()</code> 时，就说明窗口中就是一个合法的排列，所以立即返回 <code>true</code>。</p><p>至于如何处理窗口的扩大和缩小，和最小覆盖子串完全相同。</p><h2 id="438-找到字符串中所有字母异位词"><a href="#438-找到字符串中所有字母异位词" class="headerlink" title="438. 找到字符串中所有字母异位词"></a>438. 找到字符串中所有字母异位词</h2><p>难度中等</p><p>给定两个字符串 <code>s</code> 和 <code>p</code>，找到 <code>s</code> 中所有 <code>p</code> 的 <strong>异位词</strong> 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。</p><p><strong>异位词</strong> 指由相同字母重排列形成的字符串（包括相同的字符串）。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;cbaebabacd&quot;, p = &quot;abc&quot;</span><br><span class="line">输出: [0,6]</span><br><span class="line">解释:</span><br><span class="line">起始索引等于 0 的子串是 &quot;cba&quot;, 它是 &quot;abc&quot; 的异位词。</span><br><span class="line">起始索引等于 6 的子串是 &quot;bac&quot;, 它是 &quot;abc&quot; 的异位词。</span><br></pre></td></tr></table></figure><p> <strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;abab&quot;, p = &quot;ab&quot;</span><br><span class="line">输出: [0,1,2]</span><br><span class="line">解释:</span><br><span class="line">起始索引等于 0 的子串是 &quot;ab&quot;, 它是 &quot;ab&quot; 的异位词。</span><br><span class="line">起始索引等于 1 的子串是 &quot;ba&quot;, 它是 &quot;ab&quot; 的异位词。</span><br><span class="line">起始索引等于 2 的子串是 &quot;ab&quot;, 它是 &quot;ab&quot; 的异位词。</span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>1 &lt;= s.length, p.length &lt;= 3 * 104</code></li><li><code>s</code> 和 <code>p</code> 仅包含小写字母</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">findAnagrams</span><span class="params">(String s, String p)</span> &#123;</span><br><span class="line">        Map&lt;Character, Integer&gt; windowMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        Map&lt;Character, Integer&gt; pMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; p.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">a</span> <span class="operator">=</span> p.charAt(i);</span><br><span class="line">            pMap.put(a, pMap.getOrDefault(a, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">valid</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//所有的起始位置构成的集合</span></span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(right &lt; s.length()) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(right);</span><br><span class="line">            right++;</span><br><span class="line">            <span class="keyword">if</span>(pMap.containsKey(c)) &#123;</span><br><span class="line">                windowMap.put(c, windowMap.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(pMap.get(c).equals(windowMap.get(c))) &#123;</span><br><span class="line">                    valid++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(right - left == p.length()) &#123;</span><br><span class="line">                <span class="keyword">if</span>(valid == pMap.size()) &#123;</span><br><span class="line">                    res.add(left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">char</span> <span class="variable">d</span> <span class="operator">=</span> s.charAt(left);</span><br><span class="line">                left++;</span><br><span class="line">                <span class="keyword">if</span>(pMap.containsKey(d)) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(pMap.get(d).equals(windowMap.get(d))) &#123;</span><br><span class="line">                        valid--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    windowMap.put(d, windowMap.get(d) - <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a>3. 无重复字符的最长子串</h2><p>难度中等</p><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= s.length &lt;= 5 * 104</code></li><li><code>s</code> 由英文字母、数字、符号和空格组成</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxLength</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//先加进窗口中，再看有没有重复的   map中元素可能是  a:2,表示a重复</span></span><br><span class="line">        <span class="keyword">while</span>(right &lt; s.length()) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(right);</span><br><span class="line">            right++;</span><br><span class="line">            map.put(c, map.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span>(map.get(c) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="type">char</span> <span class="variable">d</span> <span class="operator">=</span> s.charAt(left);</span><br><span class="line">                left++;</span><br><span class="line">                <span class="comment">//从左边移除窗口元素</span></span><br><span class="line">                map.put(d, map.get(d) - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            maxLength = Math.max(maxLength, right - left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>代码随想录-回溯算法</title>
      <link href="/2022/03/08/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
      <url>/2022/03/08/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="回溯算法理论"><a href="#回溯算法理论" class="headerlink" title="回溯算法理论"></a>回溯算法理论</h2><h3 id="什么是回溯算法"><a href="#什么是回溯算法" class="headerlink" title="什么是回溯算法 ?"></a>什么是回溯算法 ?</h3><p>其实回溯算法其实就是我们常说的 DFS 算法，本质上就是一种暴力穷举算法。</p><p><strong>解决一个回溯问题，实际上就是一个决策树的遍历过程</strong>。你只需要思考 3 个问题：</p><p>1、<strong>路径：</strong>也就是已经做出的选择。</p><p>2、<strong>选择列表：</strong>也就是你当前可以做的选择。</p><p>3、<strong>结束条件：</strong>也就是到达决策树底层，无法再做选择的条件。</p><h3 id="回溯算法的框架"><a href="#回溯算法的框架" class="headerlink" title="回溯算法的框架"></a>回溯算法的框架</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">result = []</span><br><span class="line">def <span class="title function_">backtrack</span><span class="params">(路径, 选择列表)</span>:</span><br><span class="line">    <span class="keyword">if</span> 满足结束条件:</span><br><span class="line">        result.add(路径)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> 选择 in 选择列表:</span><br><span class="line">        做选择</span><br><span class="line">        backtrack(路径, 选择列表)</span><br><span class="line">        撤销选择</span><br></pre></td></tr></table></figure><p><strong>其核心就是 for 循环里面的递归，在递归调用之前「做选择」，在递归调用之后「撤销选择」</strong>。</p><h3 id="全排列问题"><a href="#全排列问题" class="headerlink" title="全排列问题"></a>全排列问题</h3><p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 <em>所有可能的全排列</em> 。你可以 <strong>按任意顺序</strong> 返回答案。</p><p>比方说给三个数 <code>[1,2,3]</code>，你肯定不会无规律地乱穷举，一般是这样：先固定第一位为 1，然后第二位可以是 2，那么第三位只能是 3；然后可以把第二位变成 3，第三位就只能是 2 了；然后就只能变化第一位，变成 2，然后再穷举后两位……</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220313112106938.png" alt="image-20220313112106938"></p><p>只要从根遍历这棵树，记录路径上的数字，其实就是所有的全排列。<strong>我们不妨把这棵树称为回溯算法的「决策树」</strong>。</p><p><strong>为啥说这是决策树呢，因为你在每个节点上其实都在做决策</strong>。比如说你站在下图的红色节点上：</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220313112136017.png" alt="image-20220313112136017"></p><p>你现在就在做决策，可以选择 1 那条树枝，也可以选择 3 那条树枝。为啥只能在 1 和 3 之中选择呢？因为 2 这个树枝在你身后，这个选择你之前做过了，而全排列是不允许重复使用数字的。</p><p><strong>现在可以解答开头的几个名词：<code>[2]</code> 就是「路径」，记录你已经做过的选择；<code>[1,3]</code> 就是「选择列表」，表示你当前可以做出的选择；「结束条件」就是遍历到树的底层，在这里就是选择列表为空的时候</strong>。</p><p><strong>「路径」和「选择」列表为决策树上每个节点的属性</strong>，比如下图列出了几个节点的属性：</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/Snipaste_2022-03-13_11-22-43.png" alt="Snipaste_2022-03-13_11-22-43"></p><p>我们定义的 <code>backtrack</code> 函数其实就像一个指针，在这棵树上游走，同时要正确维护每个节点的属性，<strong>每当走到树的底层，其「路径」就是一个全排列</strong>。</p><p>所谓的前序遍历和后序遍历，他们只是两个很有用的时间点：</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220313112445414.png" alt="image-20220313112445414"></p><p><strong>前序遍历的代码在进入某一个节点之前的那个时间点执行，后序遍历代码在离开某个节点之后的那个时间点执行</strong>。</p><p>「路径」和「选择」是每个节点的属性，函数在树上游走要正确维护节点的属性，那么就要在这两个特殊时间点进行操作：</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/Snipaste_2022-03-13_11-25-39.png" alt="Snipaste_2022-03-13_11-25-39"></p><p>回溯算法的核心框架就应该如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 选择 in 选择列表:</span><br><span class="line">    # 做选择</span><br><span class="line">    将该选择从选择列表移除</span><br><span class="line">    路径.add(选择)</span><br><span class="line">    backtrack(路径, 选择列表)</span><br><span class="line">    # 撤销选择</span><br><span class="line">    路径.remove(选择)</span><br><span class="line">    将该选择再加入选择列表</span><br></pre></td></tr></table></figure><h4 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a>46. 全排列</h4><p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 <em>所有可能的全排列</em> 。你可以 <strong>按任意顺序</strong> 返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,1]</span><br><span class="line">输出：[[0,1],[1,0]]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1]</span><br><span class="line">输出：[[1]]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 6</code></li><li><code>-10 &lt;= nums[i] &lt;= 10</code></li><li><code>nums</code> 中的所有整数 <strong>互不相同</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(); </span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">//记录路径</span></span><br><span class="line">        LinkedList&lt;Integer&gt; track = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">boolean</span> used[] = <span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length];</span><br><span class="line">        backtrack(nums, track, used);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span>[] nums, LinkedList&lt;Integer&gt; track, <span class="type">boolean</span> used[])</span> &#123;</span><br><span class="line">        <span class="comment">//递归结束条件  到达叶子节点，也就是路径长度等于 nums.length</span></span><br><span class="line">        <span class="keyword">if</span>(track.size() == nums.length) &#123;</span><br><span class="line">            <span class="comment">//将一个完整的路径添加到结果集中  注意添加方式 new LinkedList&lt;&gt;(track)</span></span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(track));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">//给下一次标记路径中存在的元素</span></span><br><span class="line">            <span class="keyword">if</span>(used[i] == <span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//做选择</span></span><br><span class="line">            track.add(nums[i]);</span><br><span class="line">            used[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">//递归到下一层</span></span><br><span class="line">            <span class="comment">//nums和used的作用就是 [选择列表]， track是[路径]</span></span><br><span class="line">            backtrack(nums, track, used);</span><br><span class="line">            <span class="comment">//撤销选择</span></span><br><span class="line">            track.removeLast();</span><br><span class="line">            used[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="组合问题"><a href="#组合问题" class="headerlink" title="组合问题"></a>组合问题</h3><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220313162551648.png" alt="image-20220313162551648"></p><p>可以看出这个棵树，一开始集合是 1，2，3，4， 从左向右取数，取过的数，不在重复取。</p><p>第一次取1，集合变为2，3，4 ，因为k为2，我们只需要再取一个数就可以了，分别取2，3，4，得到集合[1,2] [1,3] [1,4]，以此类推。</p><p><strong>图中可以发现n相当于树的宽度，k相当于树的深度</strong>。</p><p>那么如何在这个树上遍历，然后收集到我们要的结果集呢？</p><p><strong>图中每次搜索到了叶子节点，我们就找到了一个结果</strong>。相当于只需要把达到叶子节点的结果收集起来，就可以求得 n个数中k个数的组合集合。</p><p>如何进行选择范围的收缩，也就是在集合[1,2,3,4]取1之后，下一层递归，就要在[2,3,4]中取数了，那么下一层递归如何知道从[2,3,4]中取数呢？</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220313162800790.png" alt="image-20220313162800790"></p><p>每次从集合中选取元素，可选择的范围随着选择的进行而收缩，调整可选择的范围，<strong>就是要靠start</strong>。所以需要startIndex来记录下一层递归，搜索的起始位置。</p><ul><li><strong>递归函数的返回值以及参数</strong></li></ul><p>track 用来存放符合条件单一结果，res 用来存放符合条件结果的集合。</p><p>start用来收缩可选范围</p><ul><li><strong>回溯函数终止条件</strong></li></ul><p>到达叶子节点</p><ul><li><strong>单层搜索的过程</strong></li></ul><p>回溯法的搜索过程就是一个树型结构的遍历过程，在如下图中，可以看出<strong>for循环用来横向遍历</strong>，<strong>递归的过程是纵向遍历。</strong></p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220313163909076.png" alt="image-20220313163909076"></p><h4 id="77-组合"><a href="#77-组合" class="headerlink" title="77. 组合"></a>77. 组合</h4><p>给定两个整数 <code>n</code> 和 <code>k</code>，返回范围 <code>[1, n]</code> 中所有可能的 <code>k</code> 个数的组合。</p><p>你可以按 <strong>任何顺序</strong> 返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 4, k = 2</span><br><span class="line">输出：</span><br><span class="line">[</span><br><span class="line">  [2,4],</span><br><span class="line">  [3,4],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  [1,3],</span><br><span class="line">  [1,4],</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 1, k = 1</span><br><span class="line">输出：[[1]]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 20</code></li><li><code>1 &lt;= k &lt;= n</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Integer&gt; track = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combine</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        backtrack(n, k , <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用 start 参数控制树枝的生长避免产生重复的子集</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k, <span class="type">int</span> start)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(track.size() == k) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(track));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= n; i++) &#123;</span><br><span class="line">            track.add(i);</span><br><span class="line">            backtrack(n, k, i + <span class="number">1</span>);</span><br><span class="line">            track.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17. 电话号码的字母组合"></a>17. 电话号码的字母组合</h4><p>给定一个仅包含数字 <code>2-9</code> 的字符串，返回所有它能表示的字母组合。答案可以按 <strong>任意顺序</strong> 返回。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/200px-telephone-keypad2svg.png" alt="img"></p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：digits = &quot;23&quot;</span><br><span class="line">输出：[&quot;ad&quot;,&quot;ae&quot;,&quot;af&quot;,&quot;bd&quot;,&quot;be&quot;,&quot;bf&quot;,&quot;cd&quot;,&quot;ce&quot;,&quot;cf&quot;]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：digits = &quot;&quot;</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：digits = &quot;2&quot;</span><br><span class="line">输出：[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= digits.length &lt;= 4</code></li><li><code>digits[i]</code> 是范围 <code>[&#39;2&#39;, &#39;9&#39;]</code> 的一个数字。</li></ul><h4 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39. 组合总和"></a>39. 组合总和</h4><p>给你一个 <strong>无重复元素</strong> 的整数数组 <code>candidates</code> 和一个目标整数 <code>target</code> ，找出 <code>candidates</code> 中可以使数字和为目标数 <code>target</code> 的 <em>所有</em> <strong>不同组合</strong> ，并以列表形式返回。你可以按 <strong>任意顺序</strong> 返回这些组合。</p><p><code>candidates</code> 中的 <strong>同一个</strong> 数字可以 <strong>无限制重复被选取</strong> 。如果至少一个数字的被选数量不同，则两种组合是不同的。 </p><p>对于给定的输入，保证和为 <code>target</code> 的不同组合数少于 <code>150</code> 个。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：candidates = [2,3,6,7], target = 7</span><br><span class="line">输出：[[2,2,3],[7]]</span><br><span class="line">解释：</span><br><span class="line">2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。</span><br><span class="line">7 也是一个候选， 7 = 7 。</span><br><span class="line">仅有这两种组合。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: candidates = [2,3,5], target = 8</span><br><span class="line">输出: [[2,2,2,2],[2,3,3],[3,5]]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: candidates = [2], target = 1</span><br><span class="line">输出: [] </span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= candidates.length &lt;= 30</code></li><li><code>1 &lt;= candidates[i] &lt;= 200</code></li><li><code>candidate</code> 中的每个元素都 <strong>互不相同</strong></li><li><code>1 &lt;= target &lt;= 500</code></li></ul><p>元素可以重复取，所以递归时候不需要 start + 1，但仍然需要参数start。下一层从当前位置 i 开始，因为是组合，和顺序无关，前面的位置不能再取。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Integer&gt; track = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">pathSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        backtrack(candidates, target, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target, <span class="type">int</span> start)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(pathSum &gt; target) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pathSum == target) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(track));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; candidates.length; i++) &#123;</span><br><span class="line">            track.add(candidates[i]);</span><br><span class="line">            pathSum += candidates[i];</span><br><span class="line">            backtrack(candidates, target, i);</span><br><span class="line">            track.removeLast();</span><br><span class="line">            pathSum -= candidates[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="40-组合总和-II"><a href="#40-组合总和-II" class="headerlink" title="40. 组合总和 II"></a>40. 组合总和 II</h4><p>给定一个候选人编号的集合 <code>candidates</code> 和一个目标数 <code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为 <code>target</code> 的组合。</p><p><code>candidates</code> 中的每个数字在每个组合中只能使用 <strong>一次</strong> 。</p><p><strong>注意：</strong>解集不能包含重复的组合。 </p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: candidates = [10,1,2,7,6,1,5], target = 8,</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">[1,1,6],</span><br><span class="line">[1,2,5],</span><br><span class="line">[1,7],</span><br><span class="line">[2,6]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: candidates = [2,5,2,1,2], target = 5,</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">[1,2,2],</span><br><span class="line">[5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>1 &lt;= candidates.length &lt;= 100</code></li><li><code>1 &lt;= candidates[i] &lt;= 50</code></li><li><code>1 &lt;= target &lt;= 30</code></li></ul><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/Snipaste_2022-03-15_10-12-08.png" alt="Snipaste_2022-03-15_10-12-08"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Integer&gt; track = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">pathSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum2</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="comment">//为了将重复的数字都放到一起，所以先进行排序</span></span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        backtrack(candidates, target, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target, <span class="type">int</span> start)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(pathSum &gt; target) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pathSum == target) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(track));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; candidates.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 要对同一树层使用过的元素进行跳过</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; start &amp;&amp; candidates[i] == candidates[i - <span class="number">1</span>] ) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            track.add(candidates[i]);</span><br><span class="line">            pathSum += candidates[i];</span><br><span class="line">            backtrack(candidates, target, i + <span class="number">1</span>);<span class="comment">// 和39.组合总和的区别1，这里是i+1，每个数字在每个组合中只能使用一次</span></span><br><span class="line">            track.removeLast();</span><br><span class="line">            pathSum -= candidates[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="组合与排列的区别"><a href="#组合与排列的区别" class="headerlink" title="组合与排列的区别"></a>组合与排列的区别</h4><p>排列：</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220314201834535.png" alt="image-20220314201834535"></p><p>组合：</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220314202152282.png" alt="image-20220314202151440"></p><p>组合需要 start 来使得选择列表越来越少，如上提所示</p><h3 id="子集问题"><a href="#子集问题" class="headerlink" title="子集问题"></a>子集问题</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>类加载器及类加载过程</title>
      <link href="/2022/03/08/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%8F%8A%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/"/>
      <url>/2022/03/08/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%8F%8A%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="类加载子系统作用"><a href="#类加载子系统作用" class="headerlink" title="类加载子系统作用"></a>类加载子系统作用</h2><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220308192526085.png" alt="image-20220308192526085"></p><p>类加载子系统负责从文件系统或者网络中加载Class文件，class文件在文件开头有特定标识。 </p><p><strong>ClassLoader只负责class文件的加载</strong>，至于它是否可以运行，则由ExecutionEngine决定。</p><p>加载的类信息存放于一块称为方法区的内存空间。除了类的信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是Class文件中常量池部分的内存映射)</p><h2 id="类加载器ClassLoader角色"><a href="#类加载器ClassLoader角色" class="headerlink" title="类加载器ClassLoader角色"></a>类加载器ClassLoader角色</h2><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220308192853175.png" alt="image-20220308192853175"></p><ol><li>class file存在于本地硬盘上，可以理解为设计师画在纸上的模板，而最终这个模板在执行的时候是要加载到JVM当中来根据这个文件实例化出n个一模一样的实例。</li><li>class file 加载到JVM中，被称为DNA元数据模板，放在方法区。</li><li>在.class文件-&gt; JVM-&gt;最终成为元数据模板,此过程就要一个运输工具(类装载器class Loader),扮演一个快递员的角色。</li></ol><h2 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h2><p>一个类的完整生命周期如下：</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220308194525353.png" alt="image-20220308194525353"></p><p>类加载过程：<strong>加载-&gt;链接-&gt;初始化</strong>。</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220308193107754.png" alt="image-20220308193107754"></p><p>链接过程又可分为三步：<strong>验证-&gt;准备-&gt;解析</strong>。</p><h3 id="类的加载过程一——加载（Loading）"><a href="#类的加载过程一——加载（Loading）" class="headerlink" title="类的加载过程一——加载（Loading）"></a>类的加载过程一——加载（Loading）</h3><p>加载:<br>1．通过一个类的全限定名获取定义此类的二进制字节流<br>2．将这个字节流所代表的静态存储结构转化为方区的运行时数据结构<br>3．<strong>在内存中生成一个代表这个类的java.lang.class对象</strong>，作为方法区这个类的各种数据的访问入口</p><p><strong>补充:加载.class文件的方式</strong></p><ul><li>从本地系统中直接加载</li><li>通过网络获取，典型场景: web Applet</li><li>从zip压缩包中读取，成为日后jar、war格式的基础运行时计算生成，使用最多的是:动态代理技术Ⅰ由其他文件生成，典型场景:JSP应用</li><li>从专有数据库中提取.class文件，比较少见</li><li>从加密文件中获取，典型的防Class文件被反编译的保护措施</li></ul><p>一个非数组类的加载阶段（加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，这一步我们可以去自定义类加载器去控制字节流的获取方式（重写一个类加载器的 <code>loadClass()</code> 方法）。数组类型不通过类加载器创建，它由 Java 虚拟机直接创建。</p><p>所有的类都由类加载器加载，<strong>加载的作用就是将 <code>.class</code>文件加载到内存。</strong></p><h3 id="类的加载过程二——链接（Linking）"><a href="#类的加载过程二——链接（Linking）" class="headerlink" title="类的加载过程二——链接（Linking）"></a>类的加载过程二——链接（Linking）</h3><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220308194905019.png" alt="image-20220308194905019"></p><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p><strong>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段</strong>，这些内存都将在<strong>方法区</strong>中分配。</p><h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符 7 类符号引用进行。</p><p>符号引用就是一组符号来描述目标，可以是任何字面量。<strong>直接引用</strong>就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。在程序实际运行时，只有符号引用是不够的，举个例子：在程序执行方法时，系统需要明确知道这个方法所在的位置。Java 虚拟机为每个类都准备了一张方法表来存放类中所有的方法。当需要调用一个类的方法的时候，只要知道这个方法在方法表中的偏移量就可以直接调用该方法了。通过解析操作符号引用就可以直接转变为目标方法在类中方法表的位置，从而使得方法可以被调用。</p><p>综上，解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，也就是得到类或者字段、方法在内存中的指针或者偏移量。</p><h3 id="类的加载过程三——初始化（Initialization）"><a href="#类的加载过程三——初始化（Initialization）" class="headerlink" title="类的加载过程三——初始化（Initialization）"></a>类的加载过程三——初始化（Initialization）</h3><p><strong>类中的静态代码块就是在 类的初始化（Initialization）阶段被调用，还有静态变量的赋值，都是在这个阶段！！！</strong></p><p>初始化阶段是执行初始化方法 <code>&lt;clinit&gt; ()</code>方法的过程，是类加载的最后一步，<strong>这一步 JVM 才开始真正执行类中定义的 Java 程序代码(字节码)。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">说明： &lt;clinit&gt; ()方法是编译之后自动生成的。</span><br></pre></td></tr></table></figure><p>对于初始化阶段，虚拟机严格规范了有且只有 5 种情况下，必须对类进行初始化(只有主动去使用类才会初始化类)：</p><ol><li>当遇到new 、getstatic、putstatic或invokestatic这 4 条直接码指令时，比如 new一个类，读取一个静态字段(未被 final 修饰)、或调用一个类的静态方法时。<ul><li>当 jvm 执行 <code>new</code> 指令时会初始化类。即当程序创建一个类的实例对象。</li><li>当 jvm 执行 <code>getstatic</code> 指令时会初始化类。即程序访问类的静态变量(不是静态常量，常量会被加载到运行时常量池)。</li><li>当 jvm 执行 <code>putstatic</code> 指令时会初始化类。即程序给类的静态变量赋值。</li><li>当 jvm 执行 <code>invokestatic</code> 指令时会初始化类。即程序调用类的静态方法。</li></ul></li><li>使用 <code>java.lang.reflect</code> 包的方法对类进行反射调用时如 <code>Class.forname(&quot;...&quot;)</code>, <code>newInstance()</code> 等等。如果类没初始化，需要触发其初始化。</li><li>初始化一个类，如果其父类还未初始化，则先触发该父类的初始化。</li><li>当虚拟机启动时，用户需要定义一个要执行的主类 (包含 <code>main</code> 方法的那个类)，虚拟机会先初始化这个类。</li><li><code>MethodHandle</code> 和 <code>VarHandle</code> 可以看作是轻量级的反射调用机制，而要想使用这 2 个调用， 就必须先使用 <code>findStaticVarHandle</code> 来初始化要调用的类。</li><li><strong>「补充，来自<a href="https://github.com/Snailclimb/JavaGuide/issues/745">issue745open in new window</a>」</strong> 当一个接口中定义了 JDK8 新加入的默认方法（被 default 关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。</li></ol><h2 id="类加载器的分类"><a href="#类加载器的分类" class="headerlink" title="类加载器的分类"></a>类加载器的分类</h2><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220308195946102.png" alt="image-20220308195946102"></p><p>这里四者的关系是<strong>包含关系</strong>。不是上层下层，也<strong>不是子父的继承关系</strong>。</p><p>JVM 中内置了三个重要的 ClassLoader，<strong>除了 BootstrapClassLoader 其他类加载器均由 Java 实现且全部继承自<code>java.lang.ClassLoader</code>：</strong></p><ol><li><p><strong>BootstrapClassLoader(启动类加载器)</strong> ：<strong>最顶层的加载类</strong>，由 C++实现，负责加载 <code>%JAVA_HOME%/lib</code>目录下的 jar 包和类或者被 <code>-Xbootclasspath</code>参数指定的路径中的所有类。 </p><p>用来加载Java的核心类库，比如String.</p><p>如果某一个类的加载器是null，说明该加载器是 <strong>BootstrapClassLoader(启动类加载器)</strong> </p></li><li><p><strong>ExtensionClassLoader(扩展类加载器)</strong> ：主要负责加载 <code>%JRE_HOME%/lib/ext</code> 目录下的 jar 包和类，或被 <code>java.ext.dirs</code> 系统变量所指定的路径下的 jar 包。</p></li><li><p><strong>AppClassLoader 或 SystemClassLoader(应用程序类加载器)</strong> ：面向我们用户的加载器，负责加载当前应用 classpath 下的所有 jar 包和类。</p></li></ol><p>注：</p><p>System class loader is a different name for Application class loader.</p><p>Source: <a href="https://blogs.oracle.com/sundararajan/entry/understanding_java_class_loading">https://blogs.oracle.com/sundararajan/entry/understanding_java_class_loading</a></p><h2 id="用户自定义的类加载器"><a href="#用户自定义的类加载器" class="headerlink" title="用户自定义的类加载器"></a>用户自定义的类加载器</h2><p>为什么要自定义的类加载器？</p><ul><li>修改类加载的方式</li><li>扩展加载源</li><li>防止源码泄露   有了字节码文件.class很容易被反编译</li></ul><p><strong>用户自定义类加载器实现步骤:</strong></p><p>1.开发人员可以通过继承抽象类java.lang.classLoader类的方式，实现自己的类加载器，以满足一些特殊的需求</p><p>2.在JDK1.2之前，在自定义类加载器时，总会去继承classLoader类并重写loadclass ()方法，从而实现自定义的类加载类，但是在JDK1.2之后已不再建议用户去覆盖loadclass ()方法，而是建议把自定义的类加载逻辑写在findclass ()方法中</p><p>3．在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承<br>URLClassLoader类，这样就可以避免自己去编写findclass()方法及其获取字节码流的方式，使自定义类加载器编写更加简洁。</p><h2 id="ClassLoader的常用方法及其获取方式"><a href="#ClassLoader的常用方法及其获取方式" class="headerlink" title="ClassLoader的常用方法及其获取方式"></a>ClassLoader的常用方法及其获取方式</h2><p>除了 BootstrapClassLoader 其他类加载器均由 Java 实现且全部继承自<code>java.lang.ClassLoader</code>。</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220308203649887.png" alt="image-20220308203649887"></p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220308203746184.png" alt="image-20220308203746184"></p><h2 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h2><p><strong><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220308204323759.png" alt="image-20220308204323759"></strong></p><p><strong>工作原理</strong></p><ol><li>如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行;</li><li>如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归,请求最终将到达顶层的启动类加载器;</li><li>如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模</li></ol><h3 id="举例解释："><a href="#举例解释：" class="headerlink" title="举例解释："></a><strong>举例解释：</strong></h3><p>如果自定义一个类String，并把它放在项目的java.lang包中，然后我们去创建String对象，那么到底是使用我们自己定义的String类呢，还是使用JDK中的String呢？？？</p><p>1.自定义一个String</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220308205202923.png" alt="image-20220308205202923"></p><p>2.测试到底使用了哪个String类？？？</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220308205058863.png" alt="image-20220308205058863"></p><p>上图打印结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello,atguigu.com</span><br></pre></td></tr></table></figure><p>没有执行自己定义String类里面静态代码块，证明是使用了JDK核心库里面的String类，也解释了双亲委派机制。</p><p>因为加载自己定义的类是使用AppClassLoader（应用程序类加载器)，但其不会立马自己去加载，而实先去把这个请求委托给父类的加载器，一直向上到了<strong>BootstrapClassLoader(启动类加载器)</strong> ，BootstrapClassLoader(启动类加载器)可以<strong>java.lang包</strong>中的类，所以加载的是核心API中的String，而不是我们自己定义的。</p><h3 id="双亲委派模型的优势"><a href="#双亲委派模型的优势" class="headerlink" title="双亲委派模型的优势"></a>双亲委派模型的优势</h3><p>双亲委派模型保证了 Java 程序的稳定运行，可以<strong>避免类的重复加载</strong>。（JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类），也保证了 Java 的核心 API 不被篡改。如果没有使用双亲委派模型，而是每个类加载器加载自己的话就会出现一些问题，比如我们编写一个称为 <code>java.lang.String</code> 类的话，那么程序运行的时候，系统就会出现多个不同的 <code>String</code> 类。</p><p>附录：</p><p>深入理解Java虚拟机》P228：对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。这句话可以表达得更通俗一些：<strong>比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个Class文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那么这两个类必定不相等</strong>。接口类是一种特殊类，因此对于同一接口不同的类装载器装载所获得的类是不相同的。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>代码随想录-二叉树</title>
      <link href="/2022/02/09/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2022/02/09/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="二叉树理论基础篇"><a href="#二叉树理论基础篇" class="headerlink" title="二叉树理论基础篇"></a>二叉树理论基础篇</h1><h2 id="二叉树的种类"><a href="#二叉树的种类" class="headerlink" title="二叉树的种类"></a>二叉树的种类</h2><p>在我们解题过程中二叉树有两种主要的形式：满二叉树和完全二叉树。</p><h3 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a><strong>满二叉树</strong></h3><p>如果一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树。如图所示：</p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/20200806185805576.png" alt="img" style="zoom:67%;" /><p>这棵二叉树为满二叉树，也可以说深度为k，有2^k-1个节点的二叉树。</p><h3 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a><strong>完全二叉树</strong></h3><p>如果二叉树中除去最后一层节点为满二叉树，且最后一层的结点依次从左到右分布，则此二叉树被称为完全二叉树。</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/2-1Q22620003J18.gif" alt="完全二叉树示意图"></p><h3 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h3><p>前面介绍的树，都没有数值的，而二叉搜索树是有数值的了，<strong>二叉搜索树是一个有序树</strong>。</p><ul><li>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li><li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li><li>它的左、右子树也分别为二叉排序树</li></ul><p>下图这两棵树都是搜索树。</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/20200806190304693.png" alt="img"></p><h3 id="平衡二叉搜索树"><a href="#平衡二叉搜索树" class="headerlink" title="平衡二叉搜索树"></a>平衡二叉搜索树</h3><p>平衡二叉搜索树：又被称为AVL（Adelson-Velsky and Landis）树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。如图：</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/20200806190511967.png" alt="img"></p><p>最后一棵 不是平衡二叉树，因为它的左右两个子树的高度差的绝对值超过了1。</p><h2 id="二叉树的存储方式"><a href="#二叉树的存储方式" class="headerlink" title="二叉树的存储方式"></a>二叉树的存储方式</h2><p><strong>二叉树可以链式存储，也可以顺序存储。</strong></p><p>那么链式存储方式就用指针， 顺序存储的方式就是用数组。</p><p>顾名思义就是顺序存储的元素在内存是连续分布的，而链式存储则是通过指针把分布在散落在各个地址的节点串联一起。</p><h3 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h3><p>链式存储如图：</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/2020092019554618.png" alt="img"></p><h3 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h3><p>链式存储是大家很熟悉的一种方式，那么我们来看看如何顺序存储呢？其实就是用数组来存储二叉树，顺序存储的方式如图：</p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/20200920200429452.png" alt="img" style="zoom:67%;" /><p>用数组来存储二叉树如何遍历的呢？<strong>如果父节点的数组下标是 i，那么它的左孩子就是 i * 2 + 1，右孩子就是 i * 2 + 2。</strong></p><p>但是用链式表示的二叉树，更有利于我们理解，所以<strong>一般我们都是用链式存储二叉树。</strong></p><h2 id="二叉树的定义"><a href="#二叉树的定义" class="headerlink" title="二叉树的定义"></a>二叉树的定义</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="二叉树的遍历方式"><a href="#二叉树的遍历方式" class="headerlink" title="二叉树的遍历方式"></a>二叉树的遍历方式</h2><p><strong>面试必考非递归方式！！！！</strong></p><p>二叉树主要有两种遍历方式：</p><ol><li>深度优先遍历<ul><li>前序遍历（递归法，迭代法）</li><li>中序遍历（递归法，迭代法）</li><li>后序遍历（递归法，迭代法）</li></ul></li><li>广度优先遍历<ul><li>层次遍历（迭代法）</li></ul></li></ol><p><strong>这里前中后，其实指的就是中间节点的遍历顺序</strong>。</p><ul><li>前序遍历：中左右</li><li>中序遍历：左中右</li><li>后序遍历：左右中</li></ul><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/20200806191109896.png" alt="img" style="zoom:67%;" /><p><strong>之前我们讲栈与队列的时候，就说过栈其实就是递归的一种是实现结构</strong>，也就说前中后序遍历的逻辑其实都是可以<strong>借助栈使用非递归</strong>的方式来实现的。</p><p>而<strong>广度优先遍历</strong>的实现一般使用<strong>队列</strong>来实现，这也是队列先进先出的特点所决定的，因为需要先进先出的结构，才能一层一层的来遍历二叉树。</p><h3 id="深度优先遍历（前中后-递归）"><a href="#深度优先遍历（前中后-递归）" class="headerlink" title="深度优先遍历（前中后-递归）"></a>深度优先遍历（前中后-递归）</h3><p>深度优先遍历包括<strong>前序遍历、中序遍历、后序遍历</strong>，面试可能会让写递归、迭代两种方法。</p><ul><li><strong>滴滴一面要求迭代方法</strong></li></ul><h4 id="145-二叉树的后序遍历"><a href="#145-二叉树的后序遍历" class="headerlink" title="145. 二叉树的后序遍历"></a>145. 二叉树的后序遍历</h4><p>给你一棵二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>后序遍历</strong> 。</p><p><strong>示例 1：</strong></p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/pre1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,null,2,3]</span><br><span class="line">输出：[3,2,1]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1]</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点的数目在范围 <code>[0, 100]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><p><strong>进阶：</strong>递归算法很简单，你可以通过迭代算法完成吗？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 中序遍历</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        res.addAll(postorderTraversal(root.left));</span><br><span class="line">        res.addAll(postorderTraversal(root.right));</span><br><span class="line">        res.add(root.val);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前、中序的递归遍历同理。</p><h3 id="深度优先遍历（前中后-迭代）"><a href="#深度优先遍历（前中后-迭代）" class="headerlink" title="深度优先遍历（前中后-迭代）"></a>深度优先遍历（前中后-迭代）</h3><ul><li><strong>利用迭代方法实现遍历非常重要，面试必考！！！</strong></li></ul><p>为什么可以用<strong>迭代</strong>实现二叉树的前中后序遍历？</p><p><strong>递归的实现就是：每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中</strong>，然后递归返回的时候，从栈顶弹出上一次递归的各项参数，所以这就是递归为什么可以返回上一层位置的原因。因此，可以利用栈来模拟递归来实现二叉树的前中后序遍历。</p><h4 id="前序遍历（迭代方法利用栈）："><a href="#前序遍历（迭代方法利用栈）：" class="headerlink" title="前序遍历（迭代方法利用栈）："></a>前序遍历（迭代方法利用栈）：</h4><p>前序遍历是中左右，每次先处理的是中间节点，那么先将根节点放入栈中，然后将右孩子加入栈，再加入左孩子。</p><p>为什么要<strong>先加入右孩子，再加入左孩子</strong>呢？ 因为这样出栈的时候才是中左右的顺序。</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/008eGmZEly1gnbmss7603g30eq0d4b2a.gif" alt="二叉树前序遍历（迭代法）"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty()) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> stack.pop(); <span class="comment">//中   根节点先访问，前序过程中根节点先出</span></span><br><span class="line">            res.add(node.val);</span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                stack.push(node.right); <span class="comment">//右（空节点不入栈）</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                stack.push(node.left); <span class="comment">// 左（空节点不入栈）</span></span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="后序遍历（迭代方法利用栈）："><a href="#后序遍历（迭代方法利用栈）：" class="headerlink" title="后序遍历（迭代方法利用栈）："></a>后序遍历（迭代方法利用栈）：</h4><p>后序遍历，先序遍历是<strong>中左右</strong>，后续遍历是<strong>左右中</strong>，那么我们只需要调整一下先序遍历的代码顺序，就变成<strong>中右左</strong>的遍历顺序，然后在反转result数组，输出的结果顺序就是<strong>左右中</strong>了，如下图：</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/20200808200338924.png" alt="前序到后序"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty()) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> stack.pop(); <span class="comment">//中</span></span><br><span class="line">            res.add(node.val);</span><br><span class="line">            <span class="comment">//空结点不能入栈</span></span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                stack.push(node.left); <span class="comment">//右（空节点不入栈）</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                stack.push(node.right); <span class="comment">// 左（空节点不入栈）</span></span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="中序遍历（迭代方法利用栈）："><a href="#中序遍历（迭代方法利用栈）：" class="headerlink" title="中序遍历（迭代方法利用栈）："></a>中序遍历（迭代方法利用栈）：</h4><p>为了解释清楚，我说明一下 刚刚在迭代的过程中，其实我们有两个操作：</p><ol><li><strong>处理：将元素放进result数组中</strong></li><li><strong>访问：遍历节点</strong></li></ol><p>分析一下为什么刚刚写的前序遍历的代码，不能和中序遍历通用呢，因为前序遍历的顺序是中左右，先访问的元素是中间节点，要处理的元素也是中间节点，所以刚刚才能写出相对简洁的代码，<strong>因为要访问的元素和要处理的元素顺序是一致的，都是中间节点。</strong></p><p>那么再看看中序遍历，中序遍历是左中右，先访问的是二叉树顶部的节点，然后一层一层向下访问，直到到达树左面的最底部，再开始处理节点（也就是在把节点的数值放进result数组中），这就造成了<strong>处理顺序和访问顺序是不一致的。</strong></p><p>那么<strong>在使用迭代法写中序遍历，就需要借用指针的遍历来帮助访问节点，栈则用来处理节点上的元素。</strong></p><p>动画如下：</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/008eGmZEly1gnbmuj244bg30eq0d4kjm.gif" alt="二叉树中序遍历（迭代法）"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中序遍历顺序: 左-中-右 入栈顺序： 左-右</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//从根节点开始</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">           <span class="keyword">if</span> (cur != <span class="literal">null</span>)&#123; <span class="comment">// 指针来访问节点，一直往左下方走，访问到最左下的节点</span></span><br><span class="line">               stack.push(cur); <span class="comment">// 将访问的节点放进栈</span></span><br><span class="line">               cur = cur.left;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               cur = stack.pop(); <span class="comment">// 从栈里弹出的数据，就是要处理的数据（放进result数组里的数据）</span></span><br><span class="line">               result.add(cur.val); <span class="comment">// 中</span></span><br><span class="line">               cur = cur.right; <span class="comment">// 右</span></span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>左边找完，就添加自己，然后找右边。</p><p><strong>中序的迭代遍历最难写 !!!!</strong>   </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>字符串</title>
      <link href="/2022/02/06/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2022/02/06/%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>代码随想录-栈与队列</title>
      <link href="/2022/02/06/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"/>
      <url>/2022/02/06/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-Deque-接口"><a href="#Java-Deque-接口" class="headerlink" title="Java Deque 接口"></a>Java Deque 接口</h1><p>在本教程中，我们将学习Deque接口，如何使用它及其方法。</p><p>Java集合框架的Deque接口提供了双端队列(Deque)的功能。它继承了Queue接口。</p><h2 id="双端队列的工作原理"><a href="#双端队列的工作原理" class="headerlink" title="双端队列的工作原理"></a>双端队列的工作原理</h2><p>在常规队列中，元素是从后面添加的，而从前面删除的。但是，在双端队列中，我们可以<strong>从前后插入和删除元素</strong>。</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/working-of-deque.png" alt="双端队列数据结构的工作"></p><h2 id="实现Deque的类"><a href="#实现Deque的类" class="headerlink" title="实现Deque的类"></a>实现Deque的类</h2><p>为了使用Deque接口的功能，我们需要使用实现接口的类：</p><ul><li><a href="https://www.cainiaojc.com/java/java-arraydeque.html">ArrayDeque</a></li><li><a href="https://www.cainiaojc.com/java/java-linkedlist.html">LinkedList</a></li></ul><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/deque-implemention-classes.png" alt="ArrayDeque和Linkedlist实现Deque"></p><h3 id="ArrayDeque与-LinkedList类"><a href="#ArrayDeque与-LinkedList类" class="headerlink" title="ArrayDeque与 LinkedList类"></a>ArrayDeque与 LinkedList类</h3><p>ArrayDeque和<a href="https://www.cainiaojc.com/java/java-linkedlist.html">Java的LinkedList都</a>实现了Deque接口。但是，它们之间存在一些差异。</p><ul><li>LinkedList支持空元素，而ArrayDeque不支持。</li><li>链表中的每个节点都包含到其他节点的链接。这就是LinkedList比ArrayDeque需要更多存储空间的原因。</li><li>如果<strong>要实现队列或双端队列数据结构，则ArrayDeque可能比LinkedList快</strong>。</li></ul><h2 id="如何使用Deque？"><a href="#如何使用Deque？" class="headerlink" title="如何使用Deque？"></a>如何使用Deque？</h2><p>在Java中，我们必须导入要使用Deque的包 java.util.Deque 。·</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;String&gt; animal1 = new ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">Deque&lt;String&gt; animal2 = new LinkedList&lt;&gt;();</span><br></pre></td></tr></table></figure><p>在这里，我们分别创建了类ArrayDeque和LinkedList的对象animal1和animal2。 这些对象可以使用Deque接口的功能。</p><h2 id="双端队列的方法"><a href="#双端队列的方法" class="headerlink" title="双端队列的方法"></a>双端队列的方法</h2><p>由于<strong>Deque继承了Queue接口</strong>，因此它继承<a href="https://www.cainiaojc.com/java/java-queue.html">了Queue接口的</a>所有方法。</p><p>除了Queue接口中可用的方法之外，Deque界面还包括以下方法：</p><ul><li><strong>addFirst()</strong> - 在双端队列的开头添加指定的元素。如果双端队列已满，则引发异常。</li><li><strong>addLast()</strong> - 在双端队列的末尾添加指定的元素。如果双端队列已满，则引发异常。</li><li><strong>offerFirst()</strong> - 在双端队列的开头添加指定的元素。如果双端队列已满，则返回false。</li><li><strong>offerLast()</strong> - 在双端队列的末尾添加指定的元素。如果双端队列已满，则返回false。</li><li><strong>getFirst()</strong> - 返回双端队列的第一个元素。如果双端队列为空，则引发异常。</li><li><strong>getLast()</strong> - 返回双端队列的最后一个元素。如果双端队列为空，则引发异常。</li><li><strong>peekFirst()</strong> - 返回双端队列的第一个元素。如果双端队列为空，则返回null。</li><li><strong>peekLast()</strong> - 返回双端队列的最后一个元素。如果双端队列为空，则返回null。</li><li><strong>removeFirst()</strong> - 返回并删除双端队列的第一个元素。如果双端队列为空，则引发异常。</li><li><strong>removeLast()</strong> - 返回并删除双端队列的最后一个元素。如果双端队列为空，则引发异常。</li><li><strong>pollFirst()</strong> - 返回并删除双端队列的第一个元素。如果双端队列为空，则返回null。</li><li><strong>pollLast()</strong> - 返回并删除双端队列的最后一个元素。如果双端队列为空，则返回null。</li></ul><h2 id="双端队列作为堆栈数据结构"><a href="#双端队列作为堆栈数据结构" class="headerlink" title="双端队列作为堆栈数据结构"></a>双端队列作为堆栈数据结构</h2><p>Java Collections框架的Stack类提供了堆栈的实现。</p><p>但是，**建议Deque用作堆栈而不是<a href="https://www.cainiaojc.com/java/java-stack.html">Stack类</a>**。这是因为Stack的方法是同步的。</p><p>以下是Deque接口提供的用于实现堆栈的方法：</p><ul><li>push() - 在双端队列的开头添加元素</li><li>pop() - 从双端队列的开头删除元素</li><li>peek() - 从双端队列的开头返回一个元素</li></ul><h2 id="ArrayDeque类中Deque的实现"><a href="#ArrayDeque类中Deque的实现" class="headerlink" title="ArrayDeque类中Deque的实现"></a>ArrayDeque类中Deque的实现</h2><p>示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Deque;</span><br><span class="line">import java.util.ArrayDeque;</span><br><span class="line"></span><br><span class="line">class Main &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 使用ArrayDeque类创建Deque </span><br><span class="line">        Deque&lt;Integer&gt; numbers = new ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        //添加元素到Deque</span><br><span class="line">        numbers.offer(1);</span><br><span class="line">        numbers.offerLast(2);</span><br><span class="line">        numbers.offerFirst(3);</span><br><span class="line">        System.out.println(&quot;Deque: &quot; + numbers);</span><br><span class="line"></span><br><span class="line">        //访问Deque的元素</span><br><span class="line">        int firstElement = numbers.peekFirst();</span><br><span class="line">        System.out.println(&quot;第一个元素： &quot; + firstElement);</span><br><span class="line"></span><br><span class="line">        int lastElement = numbers.peekLast();</span><br><span class="line">        System.out.println(&quot;最后一个元素： &quot; + lastElement);</span><br><span class="line"></span><br><span class="line">        //从Deque 移除元素</span><br><span class="line">        int removedNumber1 = numbers.pollFirst();</span><br><span class="line">        System.out.println(&quot;移除第一个元素： &quot; + removedNumber1);</span><br><span class="line"></span><br><span class="line">        int removedNumber2 = numbers.pollLast();</span><br><span class="line">        System.out.println(&quot;移除最后一个元素： &quot; + removedNumber2);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;更新后的Deque： &quot; + numbers);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出结果</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Deque: [3, 1, 2]</span><br><span class="line">第一个元素： 3</span><br><span class="line">最后一个元素： 2</span><br><span class="line">移除第一个元素： 3</span><br><span class="line">移除最后一个元素： 2</span><br><span class="line">更新后的Deque： [1]</span><br></pre></td></tr></table></figure><h1 id="232-用栈实现队列"><a href="#232-用栈实现队列" class="headerlink" title="232. 用栈实现队列"></a><a href="https://leetcode-cn.com/problems/implement-queue-using-stacks/">232. 用栈实现队列</a></h1><p>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（<code>push</code>、<code>pop</code>、<code>peek</code>、<code>empty</code>）：</p><p>实现 <code>MyQueue</code> 类：</p><ul><li><code>void push(int x)</code> 将元素 x 推到队列的末尾</li><li><code>int pop()</code> 从队列的开头移除并返回元素</li><li><code>int peek()</code> 返回队列开头的元素</li><li><code>boolean empty()</code> 如果队列为空，返回 <code>true</code> ；否则，返回 <code>false</code></li></ul><p><strong>说明：</strong></p><ul><li>你 <strong>只能</strong> 使用标准的栈操作 —— 也就是只有 <code>push to top</code>, <code>peek/pop from top</code>, <code>size</code>, 和 <code>is empty</code> 操作是合法的。</li><li>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。 </li></ul><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;MyQueue&quot;, &quot;push&quot;, &quot;push&quot;, &quot;peek&quot;, &quot;pop&quot;, &quot;empty&quot;]</span><br><span class="line">[[], [1], [2], [], [], []]</span><br><span class="line">输出：</span><br><span class="line">[null, null, null, 1, 1, false]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">MyQueue myQueue = new MyQueue();</span><br><span class="line">myQueue.push(1); // queue is: [1]</span><br><span class="line">myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)</span><br><span class="line">myQueue.peek(); // return 1</span><br><span class="line">myQueue.pop(); // return 1, queue is [2]</span><br><span class="line">myQueue.empty(); // return false</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= x &lt;= 9</code></li><li>最多调用 <code>100</code> 次 <code>push</code>、<code>pop</code>、<code>peek</code> 和 <code>empty</code></li><li>假设所有操作都是有效的 （例如，一个空的队列不会调用 <code>pop</code> 或者 <code>peek</code> 操作）</li></ul><p><strong>进阶：</strong></p><ul><li>你能否实现每个操作均摊时间复杂度为 <code>O(1)</code> 的队列？换句话说，执行 <code>n</code> 个操作的总时间复杂度为 <code>O(n)</code> ，即使其中一个操作可能花费较长时间。</li></ul><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>需要两个栈<strong>一个输入栈，一个输出栈</strong>。输出栈最上面的就是模拟的队列的头。</p><p>在push数据的时候，只要数据放进输入栈就好，<strong>但在pop的时候，操作就复杂一些，输出栈如果为空，就把进栈数据全部导入进来（注意是全部导入）</strong>，再从出栈弹出数据，如果输出栈不为空，则直接从出栈弹出数据就可以了。</p><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line">    Stack&lt;Integer&gt; stackIn;<span class="comment">// 负责进栈</span></span><br><span class="line">    Stack&lt;Integer&gt; stackOut;<span class="comment">// 负责出栈</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stackIn = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="built_in">this</span>.stackOut = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        stackIn.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(!stackOut.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> stackOut.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!stackIn.isEmpty()) &#123;</span><br><span class="line">            stackOut.push(stackIn.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stackOut.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(!stackOut.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> stackOut.peek();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!stackIn.isEmpty()) &#123;</span><br><span class="line">            stackOut.push(stackIn.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stackOut.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stackIn.isEmpty() &amp;&amp; stackOut.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyQueue obj = new MyQueue();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.peek();</span></span><br><span class="line"><span class="comment"> * boolean param_4 = obj.empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h1 id="225-用队列实现栈"><a href="#225-用队列实现栈" class="headerlink" title="225. 用队列实现栈"></a><a href="https://leetcode-cn.com/problems/implement-stack-using-queues/">225. 用队列实现栈</a></h1><p>请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（<code>push</code>、<code>top</code>、<code>pop</code> 和 <code>empty</code>）。</p><p>实现 <code>MyStack</code> 类：</p><ul><li><code>void push(int x)</code> 将元素 x 压入栈顶。</li><li><code>int pop()</code> 移除并返回栈顶元素。</li><li><code>int top()</code> 返回栈顶元素。</li><li><code>boolean empty()</code> 如果栈是空的，返回 <code>true</code> ；否则，返回 <code>false</code> 。</li></ul><p><strong>注意：</strong></p><ul><li>你只能使用队列的基本操作 —— 也就是 <code>push to back</code>、<code>peek/pop from front</code>、<code>size</code> 和 <code>is empty</code> 这些操作。</li><li>你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。</li></ul><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;MyStack&quot;, &quot;push&quot;, &quot;push&quot;, &quot;top&quot;, &quot;pop&quot;, &quot;empty&quot;]</span><br><span class="line">[[], [1], [2], [], [], []]</span><br><span class="line">输出：</span><br><span class="line">[null, null, null, 2, 2, false]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">MyStack myStack = new MyStack();</span><br><span class="line">myStack.push(1);</span><br><span class="line">myStack.push(2);</span><br><span class="line">myStack.top(); // 返回 2</span><br><span class="line">myStack.pop(); // 返回 2</span><br><span class="line">myStack.empty(); // 返回 False</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= x &lt;= 9</code></li><li>最多调用<code>100</code> 次 <code>push</code>、<code>pop</code>、<code>top</code> 和 <code>empty</code></li><li>每次调用 <code>pop</code> 和 <code>top</code> 都保证栈不为空 </li></ul><p><strong>进阶：</strong>你能否仅用一个队列来实现栈。</p><h2 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h2><p>核心思想就是<strong>一个队列在模拟栈弹出元素的时候只要将队列头部的元素（除了最后一个元素外） 重新添加到队列尾部，此时在去弹出元素就是栈的顺序了。</strong> （这时栈顶元素就在实际队列的最前面，利用队列的移除操作就行）</p><h2 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 使用一个队列来实现栈</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line">    Deque&lt;Integer&gt; queue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStack</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.queue = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        queue.offer(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">        <span class="keyword">if</span>(size == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> queue.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(size &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            queue.offer(queue.poll());</span><br><span class="line">            size--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> queue.poll();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> queue.peekLast();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> queue.size() == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyStack obj = new MyStack();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * boolean param_4 = obj.empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>双端队列的长度如何表示：queue.size()</p><p>双端队列末尾元素：queue.peekLast();</p><h1 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a><a href="https://leetcode-cn.com/problems/valid-parentheses/">20. 有效的括号</a></h1><p>难度简单2948收藏分享切换为英文接收动态反馈</p><p>给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;&#123;&#39;</code>，<code>&#39;&#125;&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串 <code>s</code> ，判断字符串是否有效。</p><p>有效字符串需满足：</p><ol><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li></ol><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;()&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;()[]&#123;&#125;&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;(]&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;([)]&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;&#123;[]&#125;&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 104</code></li><li><code>s</code> 仅由括号 <code>&#39;()[]&#123;&#125;&#39;</code> 组成</li></ul><h2 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h2><p>规律就是右括号要和最近的左括号匹配。所以遇到左括号就入栈，遇到右括号就去栈里找。匹配完成后，栈为空。</p><h2 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length() % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Deque&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        Map&lt;Character, Character&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&#x27;&#125;&#x27;</span>, <span class="string">&#x27;&#123;&#x27;</span>);</span><br><span class="line">        map.put(<span class="string">&#x27;]&#x27;</span>, <span class="string">&#x27;[&#x27;</span>);</span><br><span class="line">        map.put(<span class="string">&#x27;)&#x27;</span>, <span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;&#123;&#x27;</span> || c == <span class="string">&#x27;(&#x27;</span> || c == <span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">                stack.push(c);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">Character</span> <span class="variable">temp</span> <span class="operator">=</span> map.get(c);</span><br><span class="line">                <span class="keyword">if</span>(stack.isEmpty() || !temp.equals(stack.pop())) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="150-逆波兰表达式求值"><a href="#150-逆波兰表达式求值" class="headerlink" title="150. 逆波兰表达式求值"></a><a href="https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/">150. 逆波兰表达式求值</a></h1><p>难度中等456收藏分享切换为英文接收动态反馈</p><p>根据<a href="https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F/128437"> 逆波兰表示法</a>，求表达式的值。</p><p>有效的算符包括 <code>+</code>、<code>-</code>、<code>*</code>、<code>/</code> 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。</p><p><strong>注意</strong> 两个整数之间的除法只保留整数部分。</p><p>可以保证给定的逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：tokens = [&quot;2&quot;,&quot;1&quot;,&quot;+&quot;,&quot;3&quot;,&quot;*&quot;]</span><br><span class="line">输出：9</span><br><span class="line">解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：tokens = [&quot;4&quot;,&quot;13&quot;,&quot;5&quot;,&quot;/&quot;,&quot;+&quot;]</span><br><span class="line">输出：6</span><br><span class="line">解释：该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：tokens = [&quot;10&quot;,&quot;6&quot;,&quot;9&quot;,&quot;3&quot;,&quot;+&quot;,&quot;-11&quot;,&quot;*&quot;,&quot;/&quot;,&quot;*&quot;,&quot;17&quot;,&quot;+&quot;,&quot;5&quot;,&quot;+&quot;]</span><br><span class="line">输出：22</span><br><span class="line">解释：该算式转化为常见的中缀算术表达式为：</span><br><span class="line">  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5</span><br><span class="line">= ((10 * (6 / (12 * -11))) + 17) + 5</span><br><span class="line">= ((10 * (6 / -132)) + 17) + 5</span><br><span class="line">= ((10 * 0) + 17) + 5</span><br><span class="line">= (0 + 17) + 5</span><br><span class="line">= 17 + 5</span><br><span class="line">= 22</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= tokens.length &lt;= 104</code></li><li><code>tokens[i]</code> 是一个算符（<code>&quot;+&quot;</code>、<code>&quot;-&quot;</code>、<code>&quot;*&quot;</code> 或 <code>&quot;/&quot;</code>），或是在范围 <code>[-200, 200]</code> 内的一个整数</li></ul><p><strong>逆波兰表达式：</strong></p><p>逆波兰表达式的特点是：没有括号，运算符总是放在和它相关的操作数之后。因此，逆波兰表达式也称后缀表达式。</p><ul><li>平常使用的算式则是一种中缀表达式，如 <code>( 1 + 2 ) * ( 3 + 4 )</code> 。</li><li>该算式的逆波兰表达式写法为 <code>( ( 1 2 + ) ( 3 4 + ) * )</code> 。</li></ul><p>逆波兰表达式主要有以下两个优点：</p><ul><li>去掉括号后表达式无歧义，上式即便写成 <code>1 2 + 3 4 + * </code>也可以依据次序计算出正确结果。</li><li><strong>适合用栈操作运算</strong>：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中</li></ul><h2 id="思路：-3"><a href="#思路：-3" class="headerlink" title="思路："></a>思路：</h2><p>逆波兰表达式严格遵循「从左到右」的运算。计算逆波兰表达式的值时，使用一个栈存储操作数，从左到右遍历逆波兰表达式，进行如下操作：</p><ul><li><p>如果遇到<strong>操作数</strong>，则将操作数<strong>入栈</strong>；</p></li><li><p>如果遇到运算符，则将两个操作数出栈，其中<strong>先出栈的是右操作数，后出栈的是左操作数</strong>，使用运算符对两个操作数进行运算，将运算得到的新操作数入栈。</p></li></ul><p>整个逆波兰表达式遍历完毕之后，栈内只有一个元素，该元素即为逆波兰表达式的值。</p><h2 id="代码：-3"><a href="#代码：-3" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">evalRPN</span><span class="params">(String[] tokens)</span> &#123;</span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; tokens.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;+&quot;</span>.equals(tokens[i])) &#123;</span><br><span class="line">                stack.push(stack.pop() + stack.pop());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;-&quot;</span>.equals(tokens[i])) &#123;</span><br><span class="line">                stack.push(-stack.pop() + stack.pop());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;*&quot;</span>.equals(tokens[i])) &#123;</span><br><span class="line">                stack.push(stack.pop() * stack.pop());</span><br><span class="line">            <span class="comment">//除法要注意顺序</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;/&quot;</span>.equals(tokens[i])) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                stack.push(left / right);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//String 转为 Integer</span></span><br><span class="line">                stack.push(Integer.valueOf(tokens[i]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="347-前-K-个高频元素"><a href="#347-前-K-个高频元素" class="headerlink" title="347. 前 K 个高频元素"></a><a href="https://leetcode-cn.com/problems/top-k-frequent-elements/">347. 前 K 个高频元素</a></h1><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你返回其中出现频率前 <code>k</code> 高的元素。你可以按 <strong>任意顺序</strong> 返回答案。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,1,1,2,2,3], k = 2</span><br><span class="line">输出: [1,2]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1], k = 1</span><br><span class="line">输出: [1]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>k</code> 的取值范围是 <code>[1, 数组中不相同的元素的个数]</code></li><li>题目数据保证答案唯一，换句话说，数组中前 <code>k</code> 个高频元素的集合是唯一的 </li></ul><p><strong>进阶：</strong>你所设计算法的时间复杂度 <strong>必须</strong> 优于 <code>O(n log n)</code> ，其中 <code>n</code> 是数组大小。</p><h2 id="思路：-4"><a href="#思路：-4" class="headerlink" title="思路："></a>思路：</h2><ul><li>借助 哈希表 来建立数字和其出现次数的映射，遍历一遍数组统计元素的频率</li><li>维护一个元素数目为 k 的最小（小顶）堆</li><li>每次都将新的元素与堆顶元素（堆中频率最小的元素）进行比较</li><li>如果新的元素的频率比堆顶端的元素大，则弹出堆顶端的元素，将新的元素添加进堆中</li><li>最终，堆中的 k个元素即为前 k个高频元素</li></ul><p>为什么用小顶堆呢，而不是大顶堆？</p><p>有的同学一想，题目要求前 K 个高频元素，那么果断用大顶堆啊。</p><p>那么问题来了，定义一个大小为k的大顶堆，在每次移动更新大顶堆的时候，每次弹出都把最大的元素弹出去了，那么怎么保留下来前K个高频元素呢。</p><p>而且使用大顶堆就要把所有元素都进行排序，那能不能<strong>只排序k个元素呢</strong>？</p><p><strong>所以我们要用小顶堆，因为要统计最大前k个元素，只有小顶堆每次将最小的元素弹出，最后小顶堆里积累的才是前k个最大元素。</strong></p><h2 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h2><p>比较器的写法细节，如何建立小顶堆，如何建立大顶堆</p><h2 id="代码：-4"><a href="#代码：-4" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] topKFrequent(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//遍历数组，统计数字的频率</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            map.put(nums[i], map.getOrDefault(nums[i], <span class="number">0</span>) + <span class="number">1</span>);  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//建立小根堆，将map中统计的各元素频率插入堆中，堆元素个数大于 k 时将堆顶元素删除，最后剩下的</span></span><br><span class="line">        <span class="comment">//就是 频率前 k 高的元素  用Comparator来决定谁是最‘重要的元素’</span></span><br><span class="line">        <span class="comment">// PriorityQueue&lt;Map.Entry&lt;Integer, Integer&gt;&gt; queue = new PriorityQueue&lt;&gt;(new Comparator&lt;Map.Entry&lt;Integer, Integer&gt;&gt;()&#123;</span></span><br><span class="line">        <span class="comment">//     @Override</span></span><br><span class="line">        <span class="comment">//     public int compare(Map.Entry&lt;Integer, Integer&gt; a, Map.Entry&lt;Integer, Integer&gt; b) &#123;</span></span><br><span class="line">        <span class="comment">//         return a.getValue() - b.getValue();</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">// &#125;);</span></span><br><span class="line">        <span class="comment">//此为正则表达式写法</span></span><br><span class="line">        PriorityQueue&lt;Map.Entry&lt;Integer, Integer&gt;&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a, b)-&gt; a.getValue() - b.getValue());</span><br><span class="line">        <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">        <span class="comment">//遍历map，最后该小顶堆中的就是频率前 k 个  z</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class="line">            queue.offer(entry);</span><br><span class="line">            <span class="keyword">if</span> (queue.size() &gt; k) &#123;</span><br><span class="line">                queue.poll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            result[i] = queue.poll().getKey();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>双端队列的长度：<strong>queue.size()</strong></p><h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><h2 id="Deque-接口"><a href="#Deque-接口" class="headerlink" title="Deque 接口"></a>Deque 接口</h2><p>熟悉 Deque 接口，如何去实现 <strong>栈</strong> 和 <strong>队列</strong></p><h2 id="队列："><a href="#队列：" class="headerlink" title="队列："></a><strong>队列：</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><h2 id="栈："><a href="#栈：" class="headerlink" title="栈："></a><strong>栈：</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;Integer&gt; stack = new LinkedList&lt;&gt;();</span><br></pre></td></tr></table></figure><h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList:"></a><strong>LinkedList:</strong></h2><p><code>LinkedList</code>真是一个全能选手，它即是<code>List</code>，又是<code>Queue</code>，还是<code>Deque</code>。但是我们在使用的时候，总是用特定的接口来引用它，这是因为持有接口说明代码的抽象层次更高，而且接口本身定义的方法代表了特定的用途。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 不推荐的写法:</span><br><span class="line">LinkedList&lt;String&gt; d1 = new LinkedList&lt;&gt;();</span><br><span class="line">d1.offerLast(&quot;z&quot;);</span><br><span class="line">// 推荐的写法：</span><br><span class="line">Deque&lt;String&gt; d2 = new LinkedList&lt;&gt;();</span><br><span class="line">d2.offerLast(&quot;z&quot;);</span><br></pre></td></tr></table></figure><p>可见面向抽象编程的一个原则就是：尽量持有接口，而不是具体的实现类。</p><h1 id="Java-PriorityQueue-优先队列-堆"><a href="#Java-PriorityQueue-优先队列-堆" class="headerlink" title="Java PriorityQueue(优先队列)(堆)"></a>Java PriorityQueue(优先队列)(堆)</h1><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/java-priorityqueue-implementation.png" alt="Java PriorityQueue类实现Queue接口。"></p><p>PriorityQueue类<strong>提供堆数据结构的功能</strong>。</p><p>什么是优先级队列呢？</p><p>实际上是一个堆（不指定Comparator时<strong>默认为最小堆，队头就是堆顶</strong>），因为优先级队列对外接口只是从队头取元素，从队尾添加元素，再无其他取元素的方式，看起来就是一个队列。</p><p>队列既可以根据元素的自然顺序来排序，也可以根据 Comparator来设置排序规则。</p><p>队列的头是按指定排序方式的最小元素。如果多个元素都是最小值，则头是其中一个元素。</p><p>新建对象的时候可以指定一个初始容量，其容量会自动增加。</p><p><strong>注意1：</strong></p><p>该队列是用数组实现，但是数组大小可以动态增加，容量无限。</p><p><strong>注意2：</strong></p><p>队列的实现不是同步的，是<strong>线程不安全</strong>的。如果多个线程中的任意线程从结构上修改了列表， 则这些线程不应同时访问 PriorityQueue实例。保证线程安全可以使用PriorityBlockingQueue 类。</p><p><strong>注意3：</strong></p><p>不允许使用 null 元素。</p><p><strong>注意4：</strong></p><p>插入方法（<code>offer()、poll()、remove() 、add()</code> 方法）时间复杂度为O(log(n)) ；<br><code>remove(Object) </code>和 <code>contains(Object) </code>时间复杂度为O(n)；<br>检索方法（peek、element 和 size）时间复杂度为常量。</p><p><strong>注意5</strong>：</p><p>方法iterator()中提供的迭代器并不保证以有序的方式遍历优先级队列中的元素。（原因可参考PriorityQueue的内部实现）<br>如果需要按顺序遍历，可用Arrays.sort(pq.toArray())。</p><p><strong>注意6：</strong></p><p>可以在构造函数中指定如何排序。如：<br><code>PriorityQueue()</code><br>     使用默认的初始容量（11）创建一个 PriorityQueue，并根据其自然顺序来排序其元素（使用 Comparable）。<br><code>PriorityQueue(int initialCapacity)</code><br>     使用指定的初始容量创建一个 PriorityQueue，并根据其自然顺序来排序其元素（使用 Comparable）。<br><code>PriorityQueue(int initialCapacity, Comparator&lt;? super E&gt; comparator)</code><br>     使用指定的初始容量创建一个 PriorityQueue，并根据指定的比较器comparator来排序其元素。</p><p><strong>注意7：</strong></p><p>此类及其迭代器实现了 Collection 和 Iterator 接口的所有可选 方法。</p><p>PriorityQueue对元素采用的是堆排序，头是按指定排序方式的最小元素。堆排序只能保证根是最大（最小），<strong>整个堆并不是有序的</strong>。<br>方法iterator()中提供的迭代器可能只是对整个数组的依次遍历。也就<strong>只能保证数组的第一个元素是最小的</strong>。</p><h2 id="PriorityQueue方法"><a href="#PriorityQueue方法" class="headerlink" title="PriorityQueue方法"></a>PriorityQueue方法</h2><p>PriorityQueue类提供了Queue接口中存在的所有方法的实现。</p><h3 id="将元素插入PriorityQueue"><a href="#将元素插入PriorityQueue" class="headerlink" title="将元素插入PriorityQueue"></a>将元素插入PriorityQueue</h3><ul><li>add() - 将指定的元素插入队列。如果队列已满，则会引发异常。</li><li>offer() - 将指定的元素插入队列。如果队列已满，则返回false。</li></ul><p>例如，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line">class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        //创建优先队列</span><br><span class="line">        PriorityQueue&lt;Integer&gt; numbers = new PriorityQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        //使用add()方法</span><br><span class="line">        numbers.add(4);</span><br><span class="line">        numbers.add(2);</span><br><span class="line">        System.out.println(&quot;PriorityQueue: &quot; + numbers);</span><br><span class="line"></span><br><span class="line">        //使用offer()方法</span><br><span class="line">        numbers.offer(1);</span><br><span class="line">        System.out.println(&quot;更新后的PriorityQueue: &quot; + numbers);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出结果</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PriorityQueue: [2, 4]</span><br><span class="line">更新后的PriorityQueue: [1, 4, 2]</span><br></pre></td></tr></table></figure><p>在这里，我们创建了一个名为的优先级队列numbers。我们已将4和2插入队列。</p><p>虽然4被插入到2之前，但队列的头是2。这是因为优先级队列的头是队列中最小的元素。</p><p>然后，我们将1插入队列。 现在重新排列了队列，以将最小的元素1存储到队列的开头。</p><h3 id="访问PriorityQueue元素"><a href="#访问PriorityQueue元素" class="headerlink" title="访问PriorityQueue元素"></a>访问PriorityQueue元素</h3><p>要从优先级队列访问元素，我们可以使用peek()方法。此方法返回队列的头部。例如，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line">class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        // 创建优先级队列</span><br><span class="line">        PriorityQueue&lt;Integer&gt; numbers = new PriorityQueue&lt;&gt;();</span><br><span class="line">        numbers.add(4);</span><br><span class="line">        numbers.add(2);</span><br><span class="line">        numbers.add(1);</span><br><span class="line">        System.out.println(&quot;PriorityQueue: &quot; + numbers);</span><br><span class="line"></span><br><span class="line">        //使用 peek() 方法</span><br><span class="line">        int number = numbers.peek();</span><br><span class="line">        System.out.println(&quot;访问元素: &quot; + number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出结果</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PriorityQueue: [1, 4, 2]</span><br><span class="line">访问元素: 1</span><br></pre></td></tr></table></figure><h3 id="删除PriorityQueue元素"><a href="#删除PriorityQueue元素" class="headerlink" title="删除PriorityQueue元素"></a>删除PriorityQueue元素</h3><ul><li>remove() - 从队列中删除指定的元素</li><li>poll() - 返回并删除队列的开头</li></ul><p>例如，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line">class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        // 创建优先队列</span><br><span class="line">        PriorityQueue&lt;Integer&gt; numbers = new PriorityQueue&lt;&gt;();</span><br><span class="line">        numbers.add(4);</span><br><span class="line">        numbers.add(2);</span><br><span class="line">        numbers.add(1);</span><br><span class="line">        System.out.println(&quot;PriorityQueue: &quot; + numbers);</span><br><span class="line"></span><br><span class="line">        //使用remove()方法</span><br><span class="line">        boolean result = numbers.remove(2);</span><br><span class="line">        System.out.println(&quot;元素2是否已删除? &quot; + result);</span><br><span class="line"></span><br><span class="line">        //使用poll()方法</span><br><span class="line">        int number = numbers.poll();</span><br><span class="line">        System.out.println(&quot;使用poll()删除的元素: &quot; + number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出结果</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PriorityQueue: [1, 4, 2]</span><br><span class="line">元素2是否已删除? true</span><br><span class="line">使用poll()删除的元素: 1</span><br></pre></td></tr></table></figure><h3 id="遍历PriorityQueue"><a href="#遍历PriorityQueue" class="headerlink" title="遍历PriorityQueue"></a>遍历PriorityQueue</h3><p>要遍历优先级队列的元素，我们可以使用iterator()方法。为了使用此方法，我们必须导入java.util.Iterator包。例如，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import java.util.PriorityQueue;</span><br><span class="line">import java.util.Iterator;</span><br><span class="line"></span><br><span class="line">class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        //创建优先级队列</span><br><span class="line">        PriorityQueue&lt;Integer&gt; numbers = new PriorityQueue&lt;&gt;();</span><br><span class="line">        numbers.add(4);</span><br><span class="line">        numbers.add(2);</span><br><span class="line">        numbers.add(1);</span><br><span class="line">        System.out.print(&quot;使用iterator()遍历PriorityQueue : &quot;);</span><br><span class="line"></span><br><span class="line">        //使用iterator()方法</span><br><span class="line">        Iterator&lt;Integer&gt; iterate = numbers.iterator();</span><br><span class="line">        while(iterate.hasNext()) &#123;</span><br><span class="line">            System.out.print(iterate.next());</span><br><span class="line">            System.out.print(&quot;, &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出结果</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用iterator()遍历PriorityQueue : 1, 4, 2,</span><br></pre></td></tr></table></figure><h3 id="PriorityQueue其他方法"><a href="#PriorityQueue其他方法" class="headerlink" title="PriorityQueue其他方法"></a>PriorityQueue其他方法</h3><table><thead><tr><th align="left">方法</th><th align="left">内容描述</th></tr></thead><tbody><tr><td align="left">contains(element)</td><td align="left">在优先级队列中搜索指定的元素。如果找到该元素，则返回true，否则返回false。</td></tr><tr><td align="left">size()</td><td align="left">返回优先级队列的长度。</td></tr><tr><td align="left">toArray()</td><td align="left">将优先级队列转换为数组，并返回它。</td></tr></tbody></table><h2 id="实现大根堆的方式"><a href="#实现大根堆的方式" class="headerlink" title="实现大根堆的方式"></a>实现大根堆的方式</h2><p>因为Java中的优先队列默认是小根堆，要实现大根堆可以使用自定义比较器。我们需要创建自己的comparator类，它实现了Comparator接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建优先级队列</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; numbers = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">CustomComparator</span>());</span><br><span class="line">        numbers.add(<span class="number">4</span>);</span><br><span class="line">        numbers.add(<span class="number">2</span>);</span><br><span class="line">        numbers.add(<span class="number">1</span>);</span><br><span class="line">        numbers.add(<span class="number">3</span>);</span><br><span class="line">        System.out.print(<span class="string">&quot;PriorityQueue: &quot;</span> + numbers);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CustomComparator</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer number1, Integer number2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span>  number1.compareTo(number2);</span><br><span class="line">        <span class="comment">//元素以相反的顺序排序</span></span><br><span class="line">        <span class="keyword">if</span> (value &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (value &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出结果</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PriorityQueue: [<span class="number">4</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br></pre></td></tr></table></figure><p>在上面的示例中，我们创建了一个优先级队列，将CustomComparator类作为参数传递。</p><p>CustomComparator类实现了Comparator接口。</p><p>然后，我们重写compare()方法。该方法现在使元素的头成为最大的数。</p><h2 id="堆属性"><a href="#堆属性" class="headerlink" title="堆属性"></a>堆属性</h2><p>堆分为两种：<em>最大堆</em>和<em>最小堆</em>，两者的差别在于节点的排序方式。</p><p>在最大堆中，父节点的值比每一个子节点的值都要大。在最小堆中，父节点的值比每一个子节点的值都要小。这就是所谓的“堆属性”，并且这个属性对堆中的每一个节点都成立。</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/4064751-14a6cde25bdff968.png" alt="img"></p><p>这是一个最大堆，，因为每一个父节点的值都比其子节点要大。<code>10</code> 比 <code>7</code> 和 <code>2</code> 都大。<code>7</code> 比 <code>5</code> 和 <code>1</code>都大。</p><p>根据这一属性，那么最大堆总是将其中的最大值存放在树的根节点。而对于最小堆，根节点中的元素总是树中的最小值。堆属性非常有用，因为堆常常被当做优先队列使用，因为可以快速地访问到“<strong>最重要”的元素</strong>。</p><blockquote><p><strong>注意：</strong>堆的根节点中存放的是最大或者最小元素，<strong>但是其他节点的排序顺序是未知的</strong>。例如，在一个最大堆中，最大的那一个元素总是位于 index 0 的位置，但是最小的元素则未必是最后一个元素。</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2-手写数据库之Data Manager(数据管理器)</title>
      <link href="/2022/02/04/2-Data-Manager/"/>
      <url>/2022/02/04/2-Data-Manager/</url>
      
        <content type="html"><![CDATA[<h1 id="2-手写数据库之Data-Manager-数据管理器"><a href="#2-手写数据库之Data-Manager-数据管理器" class="headerlink" title="2-手写数据库之Data Manager(数据管理器)"></a>2-手写数据库之Data Manager(数据管理器)</h1><p>DM为KangDB中最底层的模块，直接管理数据库文件(DB, database)和日志文件(LF, log file)。 </p><p>DM的主要职责大致有下面这些: </p><ol><li>对DB进行Cache, 提高KangDB访问的速率; </li><li>管理日志文件，保证KangDB的可恢复性（在发生错误时可以根据日志进行恢复）; </li><li>分页管理DB, 并提供适当的抽象给上层模块, 使上层模块不用关心DB的读写细节。</li></ol><p><strong>数据库模型如下图：</strong></p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220127112245276.png" alt="数据库模型"></p>]]></content>
      
      
      <categories>
          
          <category> project </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>maven配置多仓库</title>
      <link href="/2022/02/04/maven%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%BB%93%E5%BA%93/"/>
      <url>/2022/02/04/maven%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%BB%93%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<p><a href="%5Bhttp://repo1.maven.org/maven2/%5D(http://link.zhihu.com/?target=http://repo1.maven.org/maven2/)">maven官方仓库</a>国内访问较慢，一般配置<a href="https://maven.aliyun.com/repository/public">maven镜像阿里云仓库</a>，但阿里maven仓库有些依赖找不到，还得去官方仓库中去找，因此我们需要配置多个仓库，当第一个仓库没有时候就去第二个仓库中找，确保项目的依赖都可以成功下载。</p><p>下面为具体的maven配置指南：</p><ol><li>打开 maven 的配置文件（ windows 机器一般在 maven 安装目录的<strong>conf/settings.xml</strong>），在<mirrors></mirrors>标签中添加 mirror 子节点，加入阿里仓库作为中央仓库</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">id</span>&gt;</span>aliyun<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://maven.aliyun.com/repository/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>在<profiles></profiles>标签里加入需要的私人仓库</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--profile和repository里的id唯一，不可重复--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>gf<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">id</span>&gt;</span>maven-default<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://repo1.maven.org/maven2/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">updatePolicy</span>&gt;</span>always<span class="tag">&lt;/<span class="name">updatePolicy</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">id</span>&gt;</span>jdk-1.8<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">jdk</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">jdk</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">maven.compiler.compilerVersion</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.compilerVersion</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>在最后的<code>&lt;/setting&gt;</code>标签里填入</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">activeProfiles</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">activeProfile</span>&gt;</span>aliyun<span class="tag">&lt;/<span class="name">activeProfile</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">activeProfile</span>&gt;</span>gf<span class="tag">&lt;/<span class="name">activeProfile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activeProfiles</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Maven </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>代码随想录-双指针法</title>
      <link href="/2022/02/04/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95/"/>
      <url>/2022/02/04/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="代码随想录之双指针法"><a href="#代码随想录之双指针法" class="headerlink" title="代码随想录之双指针法"></a>代码随想录之双指针法</h1><h2 id="19-删除链表的倒数第N个节点"><a href="#19-删除链表的倒数第N个节点" class="headerlink" title="19.删除链表的倒数第N个节点"></a>19.删除链表的倒数第N个节点</h2><p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</p><p>进阶：你能尝试使用一趟扫描实现吗？</p><p>示例 1：</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/20210510085957392.png" alt="19.删除链表的倒数第N个节点"></p><p>输入：head = [1,2,3,4,5], n = 2 输出：[1,2,3,5] 示例 2：</p><p>输入：head = [1], n = 1 输出：[] 示例 3：</p><p>输入：head = [1,2], n = 1 输出：[1]</p><h3 id="先想到的解法"><a href="#先想到的解法" class="headerlink" title="先想到的解法"></a>先想到的解法</h3><p>思路：<strong>倒数第n个结点是正数第（链表长度length - n + 1）个结点</strong>（双指针解法也用到这个关系，也就是最后快慢指针相隔n个结点，快指针指向结尾的null，慢指针指向倒数第n+1个结点），但链表要遍历一遍才能知道链表的长度，因此想到先将链表反转，然后从后往前数第n个结点，最后再将链表反转回来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head.next == <span class="literal">null</span> || head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newNode</span> <span class="operator">=</span> reverseList(head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummyNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>, newNode);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> dummyNode;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">curr</span> <span class="operator">=</span> newNode;</span><br><span class="line">        <span class="keyword">while</span>(count != n &amp;&amp; curr != <span class="literal">null</span>) &#123;</span><br><span class="line">            pre = curr;</span><br><span class="line">            curr = curr.next;</span><br><span class="line">            <span class="comment">//别忘记 count++!!!!</span></span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        pre.next = curr.next;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">res</span> <span class="operator">=</span> reverseList(dummyNode.next);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newNode</span> <span class="operator">=</span> reverseList(head.next);</span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> newNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双指针解法"><a href="#双指针解法" class="headerlink" title="双指针解法"></a>双指针解法</h3><p>核心就是如何利用两个指针<strong>找到倒数第n+1个结点</strong>（方便删除），慢指针出发时要和快指针隔 <strong>n</strong> 个结点。</p><p>那么快指针从哪里出发？ 先走多少步？慢指针从哪里出发？慢指针什么时候停止？为什么？</p><ol><li><p><strong>快指针从 dummyNode出发</strong>（伪结点的设置是为了方便删除，不需要考虑边界问题）</p></li><li><p>快指针从 dummyNode出发<strong>先走 n + 1步</strong>，也就是走到原来链表的正数第 n 个位置。此时，慢指针与快指针<strong>相隔n个结点</strong>。</p><p>因为两个指针始终相隔 n 个结点，所以当快指针走到链表末尾NULL时，慢指针就会指向倒数第 n + 1 个结点，就可以指向删除倒数第 n 个结点的操作了。</p></li><li><p>慢指针从dymmyNode出发</p></li><li><p>当快指针走到链表末尾NULL时，慢指针停止，此时指向原链表倒数第 n + 1 个结点。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummyNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>, head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> dummyNode;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> dummyNode;</span><br><span class="line">        <span class="comment">//fast结点从dummyNode开始先走n+1步</span></span><br><span class="line">        <span class="keyword">while</span>(n &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当fast == null时，slow刚好为倒数第 n+1 个结点</span></span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">null</span>) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//删除倒数第 N 个结点</span></span><br><span class="line">        slow.next = slow.next.next;</span><br><span class="line">        <span class="keyword">return</span> dummyNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160. 相交链表"></a><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">160. 相交链表</a></h2><p>难度简单1525收藏分享切换为英文接收动态反馈</p><p>给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 <code>null</code> 。</p><p>图示两个链表在节点 <code>c1</code> 开始相交<strong>：</strong></p><p><a href="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png"><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/160_statement.png" alt="img"></a></p><p>题目数据 <strong>保证</strong> 整个链式结构中不存在环。</p><p><strong>注意</strong>，函数返回结果后，链表必须 <strong>保持其原始结构</strong> 。</p><p><strong>自定义评测：</strong></p><p><strong>评测系统</strong> 的输入如下（你设计的程序 <strong>不适用</strong> 此输入）：</p><ul><li><code>intersectVal</code> - 相交的起始节点的值。如果不存在相交节点，这一值为 <code>0</code></li><li><code>listA</code> - 第一个链表</li><li><code>listB</code> - 第二个链表</li><li><code>skipA</code> - 在 <code>listA</code> 中（从头节点开始）跳到交叉节点的节点数</li><li><code>skipB</code> - 在 <code>listB</code> 中（从头节点开始）跳到交叉节点的节点数</li></ul><p>评测系统将根据这些输入创建链式数据结构，并将两个头节点 <code>headA</code> 和 <code>headB</code> 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 <strong>视作正确答案</strong> 。</p><p><strong>示例 1：</strong></p><p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png"><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/160_example_1_1.png" alt="img"></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3</span><br><span class="line">输出：Intersected at &#x27;8&#x27;</span><br><span class="line">解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。</span><br><span class="line">从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。</span><br><span class="line">在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_2.png"><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/160_example_2.png" alt="img"></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1</span><br><span class="line">输出：Intersected at &#x27;2&#x27;</span><br><span class="line">解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。</span><br><span class="line">从各自的表头开始算起，链表 A 为 [1,9,1,2,4]，链表 B 为 [3,2,4]。</span><br><span class="line">在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png"><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/160_example_3.png" alt="img"></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2</span><br><span class="line">输出：null</span><br><span class="line">解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。</span><br><span class="line">由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。</span><br><span class="line">这两个链表不相交，因此返回 null 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>listA</code> 中节点数目为 <code>m</code></li><li><code>listB</code> 中节点数目为 <code>n</code></li><li><code>1 &lt;= m, n &lt;= 3 * 104</code></li><li><code>1 &lt;= Node.val &lt;= 105</code></li><li><code>0 &lt;= skipA &lt;= m</code></li><li><code>0 &lt;= skipB &lt;= n</code></li><li>如果 <code>listA</code> 和 <code>listB</code> 没有交点，<code>intersectVal</code> 为 <code>0</code></li><li>如果 <code>listA</code> 和 <code>listB</code> 有交点，<code>intersectVal == listA[skipA] == listB[skipB]</code></li></ul><p><strong>进阶：</strong>你能否设计一个时间复杂度 <code>O(m + n)</code> 、仅用 <code>O(1)</code> 内存的解决方案？</p><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>双指针，两个指针走完自己的链表，就去遍历另一个的。如果有交点，两个指针一定会相遇。（同时开始的话，由于长度一样，速度一样）<br>注意一些特殊情况，某一个链表为空。<br><strong>走完自己的路，再去走她走过的路，相爱的人迟早会相遇！！！</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(headB == <span class="literal">null</span> || headA == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p1</span> <span class="operator">=</span> headA;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p2</span> <span class="operator">=</span> headB;</span><br><span class="line">        <span class="comment">//不会因为两个链表没有结点而造成死循环，因为没有交点时，p1,p2最后都会指向null，跳出循环</span></span><br><span class="line">        <span class="keyword">while</span>(p1 != p2) &#123;</span><br><span class="line">            p1 = p1 == <span class="literal">null</span> ? headB : p1.next;</span><br><span class="line">            p2 = p2 == <span class="literal">null</span> ? headA : p2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意判断下一个节点是什么的条件：</p><p>是 <code>p1 == null ?</code> 而不是 p1.next == null ，后者会造成死循环</p><h2 id="141-环形链表-I"><a href="#141-环形链表-I" class="headerlink" title="141. 环形链表 I"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle/">141. 环形链表 I</a></h2><p>难度简单1341收藏分享切换为英文接收动态反馈</p><p>给你一个链表的头节点 <code>head</code> ，判断链表中是否有环。</p><p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。<strong>注意：<code>pos</code> 不作为参数进行传递</strong> 。仅仅是为了标识链表的实际情况。</p><p><em>如果链表中存在环</em> ，则返回 <code>true</code> 。 否则，返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/circularlinkedlist.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [3,2,0,-4], pos = 1</span><br><span class="line">输出：true</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/circularlinkedlist_test2.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2], pos = 0</span><br><span class="line">输出：true</span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/circularlinkedlist_test3.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1], pos = -1</span><br><span class="line">输出：false</span><br><span class="line">解释：链表中没有环。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点的数目范围是 <code>[0, 104]</code></li><li><code>-105 &lt;= Node.val &lt;= 105</code></li><li><code>pos</code> 为 <code>-1</code> 或者链表中的一个 <strong>有效索引</strong> 。</li></ul><p><strong>进阶：</strong>你能用 <code>O(1)</code>（即，常量）内存解决此问题吗？</p><h3 id="Floyd判圈算法"><a href="#Floyd判圈算法" class="headerlink" title="Floyd判圈算法"></a>Floyd判圈算法</h3><p><strong>Floyd判圈算法</strong>(Floyd Cycle Detection Algorithm)，又称龟兔赛跑算法(Tortoise and Hare Algorithm)，是一个可以在有限状态机、迭代函数或者链表上判断<strong>是否存在环</strong>，<strong>求出该环的起点与长度</strong>的算法。该算法据高德纳称由美国科学家罗伯特·弗洛伊德发明，但这一算法并没有出现在罗伯特·弗洛伊德公开发表的著作中。<br> 如果有限状态机、迭代函数或者链表上存在环，那么在某个环上以<strong>不同速度</strong>前进的<strong>2个指针</strong>必定会在某个时刻相遇。同时显然地，如果从同一个起点(即使这个起点不在某个环上)同时开始以不同速度前进的2个指针最终相遇，那么可以判定存在一个环，<strong>且可以求出二者相遇处所在的环的起点与长度。</strong></p><h4 id="算法描述："><a href="#算法描述：" class="headerlink" title="算法描述："></a><strong>算法描述：</strong></h4><h5 id="判断是否存在环路："><a href="#判断是否存在环路：" class="headerlink" title="判断是否存在环路："></a><strong>判断是否存在环路：</strong></h5><p>如果有限状态机、迭代函数或者链表存在环，那么一定存在一个起点可以到达某个环的某处(这个起点也可以在某个环上)。</p><p>初始状态下，假设已知某个起点节点为节点S。现设两个指针t和h，将它们均指向S。接着，同时让t和h往前推进，但是二者的速度不同：<strong>t 每前进1步，h 前进2步</strong>。只要二者都可以前进而且没有相遇，就如此保持二者的推进。当h无法前进，即到达某个没有后继的节点时，就可以确定从S出发不会遇到环。反之当t与h再次相遇时，就可以确定从S出发一定会进入某个环，设其为环C。如果确定了存在某个环，就可以求此环的起点与长度。</p><h5 id="求解环路的长度："><a href="#求解环路的长度：" class="headerlink" title="求解环路的长度："></a><strong>求解环路的长度：</strong></h5><p>上述算法刚判断出存在环C时，显然t和h位于同一节点，设其为节点M。显然，<strong>仅需令h不动，而t不断推进，最终又会返回节点M，统计这一次t推进的步数，显然这就是环C的长度</strong>。</p><h5 id="求解环路的起点："><a href="#求解环路的起点：" class="headerlink" title="求解环路的起点："></a><strong>求解环路的起点：</strong></h5><p>为了求出环C的起点，只要令h仍均位于节点M，而<strong>令t返回起始点节点S，此时h与t之间距为环C长度的整数倍</strong>。随后，同时让t和h往前推进，<strong>且保持二者的速度相同：t每前进1步，h前进1步</strong>。持续该过程直至t与h再一次相遇，设此次相遇时位于同一节点P，则节点P即为从节点S出发所到达的环C的第一个节点，即环C的一个起点。</p><h5 id="对于环路起点算法的解释："><a href="#对于环路起点算法的解释：" class="headerlink" title="对于环路起点算法的解释："></a><strong>对于环路起点算法的解释：</strong></h5><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/885804-20170813223929242-1014504085.png" alt="img"></p><p>假设出发起点到环起点的距离为m，已经确定有环，环的周长为n，（第一次）相遇点距离环的起点的距离是k。那么当两者相遇时，慢指针（t）移动的总距离i = m + a * n + k，快指针（h）的移动距离为2i，2i = m + b * n + k。其中，a和b分别为t和h在第一次相遇时转过的圈数。让两者相减（快减慢），那么有i = (b - a) * n。即i是圈长度的倍数。</p><p>将一个指针移到出发起点S，另一个指针仍呆在相遇节点M处两者同时移动，每次移动一步。当第一个指针前进了m，即到达环起点时，另一个指针距离链表起点为i + m。考虑到i为圈长度的倍数，可以理解为指针从链表起点出发，走到环起点，然后绕环转了几圈，所以第二个指针也必然在环的起点。即两者相遇点就是环的起点。</p><h5 id="更容易理解的解释："><a href="#更容易理解的解释：" class="headerlink" title="更容易理解的解释："></a>更容易理解的解释：</h5><p>为什么fast 走两个节点，slow走一个节点，有环的话，一定会在环内相遇呢，而不是永远的错开呢？</p><p>首先第一点： <strong>fast指针一定先进入环中，如果fast 指针和slow指针相遇的话，一定是在环中相遇，这是毋庸置疑的。</strong></p><p>那么来看一下，<strong>为什么fast指针和slow指针一定会相遇呢？</strong></p><p>可以画一个环，然后让 fast指针在任意一个节点开始追赶slow指针。</p><p>会发现最终都是这种情况， 如下图：</p><p><img src="https://code-thinking.cdn.bcebos.com/pics/142%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A81.png" alt="img"></p><p>fast和slow各自再走一步， fast和slow就相遇了</p><p>这是因为fast是走两步，slow是走一步，其实<strong>相对于slow来说，fast是一个节点一个节点的靠近slow的，所以fast一定可以和slow重合</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            <span class="keyword">if</span>(slow == fast) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142. 环形链表 II"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">142. 环形链表 II</a></h2><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 <code>null</code>。</p><p>思路：见上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">//判断是否成环</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">flag</span> <span class="operator">=</span> hasCycle(head);</span><br><span class="line">        <span class="comment">//无环</span></span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//fast在两个指针相遇的地方，slow回到开始的地方，同样的速度向前走，再次相遇就是环的起点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> flag;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(slow != fast) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *  判断是否成环，如果成环就返回判断时两个指针相遇的结点。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            <span class="keyword">if</span>(fast == slow) &#123;</span><br><span class="line">                <span class="keyword">return</span> slow;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="15-三数之和之再理解"><a href="#15-三数之和之再理解" class="headerlink" title="15.三数之和之再理解"></a>15.三数之和之再理解</h2><p>滑动窗口的前置条件？最外层是谁？几个位置去重？</p><ol><li>先对数组排序</li><li>最外层是最左边的元素，窗口由后两个元素组成</li><li>两个位置进行去重。<ul><li>最左边元素往后遍历时</li><li>当找到符合条件的元素时，缩小窗口时要进行去重（也就是移动 i 和 j 找到下一个不重复的位置） <strong>有移动到真正的下一个不重复的细节</strong></li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="literal">null</span> || nums.length &lt; <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//使用滑动窗口先排序</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; nums.length; k++) &#123;</span><br><span class="line">            <span class="comment">//经过排序后若第一个数字大于0，则三数之和必然大于0 </span></span><br><span class="line">            <span class="keyword">if</span>(nums[k] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//去重</span></span><br><span class="line">            <span class="keyword">if</span>(k &gt; <span class="number">0</span> &amp;&amp; nums[k - <span class="number">1</span>] == nums[k]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k + <span class="number">1</span>, j = nums.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; j) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums[k] + nums[i] + nums[j];</span><br><span class="line">                <span class="keyword">if</span>(sum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    j--;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    result.add(Arrays.asList(nums[k], nums[i], nums[j]));</span><br><span class="line">                    <span class="comment">//找下个不重复的i，while循环结束找到的是最后一个重复的，所以后面还有再移动一次</span></span><br><span class="line">                    <span class="keyword">while</span>(i &lt; j &amp;&amp; nums[i] == nums[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                        i++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//找下个不重复的j，while循环结束找到的是最后一个重复的，所以后面还有再移动一次</span></span><br><span class="line">                    <span class="keyword">while</span>(i &lt; j &amp;&amp; nums[j] == nums[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                        j--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//到达下一个不重复的地方</span></span><br><span class="line">                    i++;</span><br><span class="line">                    j--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="18-四数之和之再理解"><a href="#18-四数之和之再理解" class="headerlink" title="18. 四数之和之再理解"></a>18. 四数之和之再理解</h2><p>滑动窗口的前置条件？最外层是谁？次外层是谁？几个位置去重？与三数之和不同的地方？</p><ol><li><p>先对数组排序</p></li><li><p>最外层是最左边的元素</p></li><li><p>次外层是第二个元素</p></li><li><p>三个位置去重</p><ul><li><p>最外层</p></li><li><p>次外层</p></li><li><p>当找到符合条件的元素时，缩小窗口时要进行去重（也就是移动 i 和 j 找到下一个不重复的位置） <strong>有移动到真正的下一个不重复的细节</strong></p></li></ul></li><li><p>不能像三数之和一样根据当前层元素与 target比大小直接判断是否符合条件来进行剪枝</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这种剪枝是错误的，因为target是任意值</span></span><br><span class="line"><span class="comment">//if(nums[m] &gt; target) &#123;</span></span><br><span class="line"><span class="comment">//    break;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这种剪枝是错误的，因为target是任意值</span></span><br><span class="line"><span class="comment">//例： nums[m] == -3, nums[n] == -2 ,target = -6</span></span><br><span class="line"><span class="comment">// if(nums[m] + nums[n] &gt; target) &#123;</span></span><br><span class="line"><span class="comment">//     break;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">fourSum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="literal">null</span> || nums.length &lt; <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">0</span>; m &lt; nums.length; m++) &#123;</span><br><span class="line">            <span class="comment">//这种剪枝是错误的，因为target是任意值</span></span><br><span class="line">            <span class="comment">//if(nums[m] &gt; target) &#123;</span></span><br><span class="line">            <span class="comment">//    break;</span></span><br><span class="line">            <span class="comment">//&#125;</span></span><br><span class="line">            <span class="keyword">if</span>(m &gt; <span class="number">0</span> &amp;&amp; nums[m] == nums[m - <span class="number">1</span>] ) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> m + <span class="number">1</span>; n &lt; nums.length; n++) &#123;</span><br><span class="line">                <span class="comment">//这种剪枝是错误的，因为target是任意值</span></span><br><span class="line">                <span class="comment">//例： nums[m] == -3, nums[n] == -2 ,target = -6</span></span><br><span class="line">                <span class="comment">// if(nums[m] + nums[n] &gt; target) &#123;</span></span><br><span class="line">                <span class="comment">//     break;</span></span><br><span class="line">                <span class="comment">// &#125;</span></span><br><span class="line">                <span class="keyword">if</span>(n &gt; m + <span class="number">1</span> &amp;&amp; nums[n] == nums[n - <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n + <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(i &lt; j) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums[m] + nums[n] + nums[i] + nums[j];</span><br><span class="line">                    <span class="keyword">if</span>(sum &lt; target) &#123;</span><br><span class="line">                        i++;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(sum &gt; target) &#123;</span><br><span class="line">                        j--;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        res.add(Arrays.asList(nums[m] , nums[n] , nums[i] , nums[j]));</span><br><span class="line">                        <span class="comment">//去重</span></span><br><span class="line">                        <span class="keyword">while</span>(i &lt; j &amp;&amp; nums[i] == nums[++i]) &#123;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//去重</span></span><br><span class="line">                        <span class="keyword">while</span>(i &lt; j &amp;&amp; nums[j] == nums[--j]) &#123;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Git学习笔记</title>
      <link href="/2022/02/03/Git/"/>
      <url>/2022/02/03/Git/</url>
      
        <content type="html"><![CDATA[<h1 id="Git学习笔记"><a href="#Git学习笔记" class="headerlink" title="Git学习笔记"></a>Git学习笔记</h1><h2 id="Git-Commit"><a href="#Git-Commit" class="headerlink" title="Git Commit"></a>Git Commit</h2><p>Git 仓库中的提交记录保存的是你的目录下所有文件的快照，就像是把整个目录复制，然后再粘贴一样，但比复制粘贴优雅许多！</p><p>Git 希望提交记录尽可能地轻量，因此在你每次进行提交时，它并不会盲目地复制整个目录。条件允许的情况下，它会将当前版本与仓库中的上一个版本进行对比，并把所有的差异打包到一起作为一个提交记录。</p><p>Git 还保存了提交的历史记录。这也是为什么大多数提交记录的上面都有父节点的原因 —— 我们会在图示中用箭头来表示这种关系。对于项目组的成员来说，维护提交历史对大家都有好处。</p><p>实际操作一下，看看提交记录是怎样的。右边展示了一个（小型）Git 代码库。当前有两个提交记录 —— 初始提交 <code>C0</code> 和其后可能包含某些有用修改的提交 <code>C1</code>。</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220203160058760.png" alt="image-20220203160058760"></p><p>此时执行 <code>git commit</code>后：</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220203160141577.png" alt="image-20220203160141577"></p><p>我们刚才修改了代码库，并把这些修改保存成了一个提交记录 <code>C2</code>。<code>C2</code> 的父节点是 <code>C1</code>，父节点是当前提交中变更的基础。</p><h2 id="Git-Branch"><a href="#Git-Branch" class="headerlink" title="Git Branch"></a>Git Branch</h2><p>Git 的分支也非常轻量。它们只是简单地指向某个提交纪录 —— 仅此而已。所以许多 Git 爱好者传颂：早建分支！多用分支！</p><p>这是因为即使创建再多的分支也不会造成储存或内存上的开销，并且按逻辑分解工作到不同的分支要比维护那些特别臃肿的分支简单多了。在将分支和提交记录结合起来后，我们会看到两者如何协作。现在只要记住使用分支其实就相当于在说：“我想基于这个提交以及它所有的父提交进行新的工作。”</p><p>目前状态如下：</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220203160301341.png" alt="image-20220203160301341"></p><p>接下来，我们将要创建一个到名为 <code>newImage</code> 的分支。 执行 <code>git branch newImage</code>:</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220203160348072.png" alt="image-20220203160348072"></p><p>新创建的分支 <code>newImage</code> 指向的是提交记录 <code>C1</code>。</p><p>现在执行<code>git commit</code>:</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220203160429885.png" alt="image-20220203160429885"></p><p>为什么 <code>main</code> 分支前进了，但 <code>newImage</code> 分支还待在原地呢？！这是因为我们没有“在”这个新分支上，看到 <code>main</code> 分支上的那个星号（*）了吗？这表示当前所在的分支是 <code>main</code>。</p><p>现在咱们告诉 Git 我们想要切换到新的分支上</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220203160532244.png" alt="image-20220203160532244"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout &lt;name&gt;</span><br></pre></td></tr></table></figure><p>下面的命令会让我们在提交修改之前先切换到新的分支上</p><p><code>git checkout newImage</code></p><p><code>git commit</code></p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220203160619999.png" alt="image-20220203160619999"></p><p>这就对了！我们的修改已经保存到新的分支里了。</p><p><strong>注意</strong>：在 Git 2.23 版本中，引入了一个名为 <code>git switch</code> 的新命令，最终会取代 <code>git checkout</code>，因为 <code>checkout</code> 作为单个命令有点超载（它承载了很多独立的功能）。 </p><p>如果你想<strong>创建一个新的分支同时切换到新创建的分支</strong>的话，可以通过 <code>git checkout -b &lt;your-branch-name&gt;</code> 来实现。</p><h2 id="分支与合并"><a href="#分支与合并" class="headerlink" title="分支与合并"></a>分支与合并</h2><p>太好了! 我们已经知道如何提交以及如何使用分支了。接下来咱们看看如何将两个分支合并到一起。就是说我们新建一个分支，在其上开发某个新功能，开发完成后再合并回主线。</p><h3 id="Git-Merge"><a href="#Git-Merge" class="headerlink" title="Git Merge"></a>Git Merge</h3><p>咱们先来看一下第一种方法 —— <code>git merge</code>。在 Git 中合并两个分支时会产生一个特殊的提交记录，它有两个父节点。翻译成自然语言相当于：“我要把这两个父节点本身及它们所有的祖先都包含进来。”</p><p>我们准备了两个分支，每个分支上各有一个独有的提交。这意味着没有一个分支包含了我们修改的所有内容。咱们通过合并这两个分支来解决这个问题。</p><p>我们要把 <code>bugFix</code> 合并到 <code>main</code> 里</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220203160846947.png" alt="image-20220203160846947"></p><p>此时执行<code>git merge bugFix</code>：</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220203160942439.png" alt="image-20220203160942439"></p><p>首先，<code>main</code> 现在指向了一个拥有两个父节点的提交记录。假如从 <code>main</code> 开始沿着箭头向上看，在到达起点的路上会经过所有的提交记录。这意味着 <code>main</code> 包含了对代码库的所有修改。</p><p>还有，看见各个提交记录的颜色变化了吗？为了帮助学习理解，我引入了颜色搭配。每个分支都有不同的颜色，而每个提交记录的颜色是所有包含该提交记录的分支的颜色混合之后的颜色。</p><p>所以，<code>main</code> 分支的颜色被混入到所有的提交记录，但 <code>bugFix</code> 没有。下面咱们让它也改变一下颜色。</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220203161059572.png" alt="image-20220203161059572"></p><p>此时执行以下命令：</p><p><code>git checkout bugFix</code></p><p><code>git merge main</code></p><p>因为 <code>main</code> 继承自 <code>bugFix</code>，Git 什么都不用做，只是简单地把 <code>bugFix</code> 移动到 <code>main</code> 所指向的那个提交记录。</p><p>现在所有提交记录的颜色都一样了，这表明每一个分支都包含了代码库的所有修改！大功告成！</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220203161159155.png" alt="image-20220203161159155"></p><h3 id="Git-Rebase"><a href="#Git-Rebase" class="headerlink" title="Git Rebase"></a>Git Rebase</h3><p>第二种合并分支的方法是 <code>git rebase</code>。Rebase 实际上就是取出一系列的提交记录，“复制”它们，然后在另外一个地方逐个的放下去。</p><p>Rebase 的优势就是可以创造更线性的提交历史，这听上去有些难以理解。如果只允许使用 Rebase 的话，代码库的提交历史将会变得异常清晰。</p><p>还是准备了两个分支；注意当前所在的分支是 bugFix（星号标识的是当前分支）</p><p>我们想要把 bugFix 分支里的工作直接移到 main 分支上。移动以后会使得两个分支的功能看起来像是按顺序开发，但实际上它们是并行开发的。咱们这次用 <code>git rebase</code> 实现此目标</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220203161306271.png" alt="image-20220203161306271"></p><p>此时执行<code>git rebase main</code> :</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220203161517867.png" alt="image-20220203161517867"></p><p>现在 bugFix 分支上的工作在 main 的最顶端，同时我们也得到了一个更线性的提交序列。</p><p>注意，提交记录 C3 依然存在（树上那个半透明的节点），而 C3’ 是我们 Rebase 到 main 分支上的 C3 的副本。</p><p>现在唯一的问题就是 main 还没有更新，下面咱们就来更新它吧……</p><p>现在我们切换到了 <code>main</code> 上。</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220203161632301.png" alt="image-20220203161632301"></p><p>此时执行<code>git rebase bugFix</code>:</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220203161713269.png" alt="image-20220203161713269"></p><p>由于 <code>bugFix</code> 继承自 <code>main</code>，所以 Git 只是简单的把 <code>main</code> 分支的引用向前移动了一下而已。</p><h2 id="Git-Fetch"><a href="#Git-Fetch" class="headerlink" title="Git Fetch"></a>Git Fetch</h2><p>Git 远程仓库相当的操作实际可以归纳为两点：向远程仓库传输数据以及从远程仓库获取数据。既然我们能与远程仓库同步，那么就可以分享任何能被 Git 管理的更新（因此可以分享代码、文件、想法、情书等等）。</p><p>如何从远程仓库获取数据，它就是 <code>git fetch</code>。当我们从远程仓库获取数据时, 远程分支也会更新以反映最新的远程仓库。</p><p>在解释 <code>git fetch</code> 前，我们先看看实例。这里我们有一个远程仓库, 它有两个我们本地仓库中没有的提交。</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220203155737157.png" alt="image-20220203155737157"></p><p>此时执行 <code>git fetch</code>后，状态如下：</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220203155833869.png" alt="image-20220203155833869"></p><p>就是这样了! <code>C2</code>,<code>C3</code> 被下载到了本地仓库，同时远程分支 <code>o/main</code> 也被更新，反映到了这一变化</p><h3 id="git-fetch-做了些什么"><a href="#git-fetch-做了些什么" class="headerlink" title="git fetch 做了些什么"></a>git fetch 做了些什么</h3><p><code>git fetch</code> 完成了仅有的但是很重要的两步:</p><ul><li>从远程仓库下载本地仓库中缺失的提交记录</li><li>更新远程分支指针(如 <code>o/main</code>)</li></ul><p><code>git fetch</code> 实际上将本地仓库中的远程分支更新成了远程仓库相应分支最新的状态。</p><p>如果你还记得上一节课程中我们说过的，远程分支反映了远程仓库在你<strong>最后一次与它通信时</strong>的状态，<code>git fetch</code> 就是你与远程仓库通信的方式了！希望我说的够明白了，你已经了解 <code>git fetch</code> 与远程分支之间的关系了吧。</p><p><code>git fetch</code> 通常通过互联网（使用 <code>http://</code> 或 <code>git://</code> 协议) 与远程仓库通信。</p><h3 id="git-fetch-不会做的事"><a href="#git-fetch-不会做的事" class="headerlink" title="git fetch 不会做的事"></a>git fetch 不会做的事</h3><p><code>git fetch</code> <strong>并不会改变你本地仓库的状态</strong>。它不会更新你的 <code>main</code> 分支，也<strong>不会修改你磁盘上的文件</strong>。</p><p>理解这一点很重要，因为许多开发人员误以为执行了 <code>git fetch</code> 以后，他们本地仓库就与远程仓库同步了。它可能已经将进行这一操作所需的所有数据都下载了下来，但是<strong>并没有</strong>修改你本地的文件。我们在后面的课程中将会讲解能完成该操作的命令 :D</p><p>所以, 你可以将 <code>git fetch</code> 的理解为单纯的下载操作。</p><h2 id="偏离的工作"><a href="#偏离的工作" class="headerlink" title="偏离的工作"></a>偏离的工作</h2><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>假设你周一克隆了一个仓库，然后开始研发某个新功能。到周五时，你新功能开发测试完毕，可以发布了。但是 —— 天啊！你的同事这周写了一堆代码，还改了许多你的功能中使用的 API，这些变动会导致你新开发的功能变得不可用。但是他们已经将那些提交推送到远程仓库了，因此你的工作就变成了基于项目<strong>旧版</strong>的代码，与远程仓库最新的代码不匹配了。</p><p>这种情况下, <code>git push</code> 就不知道该如何操作了。如果你执行 <code>git push</code>，Git 应该让远程仓库回到星期一那天的状态吗？还是直接在新代码的基础上添加你的代码，亦或由于你的提交已经过时而直接忽略你的提交？</p><p>因为这情况（历史偏离）有许多的不确定性，Git 是不会允许你 <code>push</code> 变更的。实际上它会强制你先合并远程最新的代码，然后才能分享你的工作。</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220203164347886.png" alt="image-20220203164347886"></p><p>此时若执行 <code>git push</code>:</p><p>看见了吧？什么都没有变，因为命令失败了！<code>git push</code> 失败是因为你最新提交的 <code>C3</code> 基于远程分支中的 <code>C1</code>。而远程仓库中该分支已经更新到 <code>C2</code> 了，所以 Git 拒绝了你的推送请求。</p><p>那该如何解决这个问题呢？很简单，你需要做的就是<strong>使你的工作基于最新的远程分支</strong>。</p><p>有许多方法做到这一点呢，不过最直接的方法就是通过 rebase 调整你的工作。咱们继续，看看怎么 rebase！</p><p>此时执行:</p><p><code>git fetch </code></p><p><code>git rebase o/main</code></p><p><code>git push</code></p><p>上面三条命令相当于 <code>git pull --rebase; git push</code></p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220203164655199.png" alt="image-20220203164655199"></p><p>我们用 <code>git fetch</code> 更新了本地仓库中的远程分支，然后用 rebase 将我们的工作移动到最新的提交记录下，最后再用 <code>git push</code> 推送到远程仓库。</p><p>还可以用 merge 替换 rebase。</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220203164347886.png" alt="image-20220203164347886"></p><p>此时执行:</p><p><code>git fetch </code></p><p><code>git merge o/main</code></p><p><code>git push</code></p><p>上面三条命令相当于 <code>git pull; git push</code></p><p>我们用 <code>git fetch</code> 更新了本地仓库中的远程分支，然后<strong>合并</strong>了新变更到我们的本地分支（为了包含远程仓库的变更），最后我们用 <code>git push</code> 把工作推送到远程仓库</p><p><strong>命令：</strong></p><p><code>git pull</code> 就是 fetch 和 merge 的简写，类似的 <code>git pull --rebase</code> 就是 fetch 和 rebase 的简写！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java-NIO</title>
      <link href="/2022/02/02/Java-NIO/"/>
      <url>/2022/02/02/Java-NIO/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章-BIO、NIO、AIO课程介绍"><a href="#第一章-BIO、NIO、AIO课程介绍" class="headerlink" title="第一章 BIO、NIO、AIO课程介绍"></a>第一章 BIO、NIO、AIO课程介绍</h1><h2 id="1-1-课程说明"><a href="#1-1-课程说明" class="headerlink" title="1.1 课程说明"></a>1.1 课程说明</h2><p> 在Java的软件设计开发中，通信架构是不可避免的，我们在进行不同系统或者不同进程之间的数据交互，或者在高并发下的通信场景下都需要用到网络通信相关的技术，对于一些经验丰富的程序员来说，Java早期的网络通信架构存在一些缺陷，<strong>其中最令人恼火的是基于性能低下的同步阻塞式的I/O通信（BIO）</strong>，随着互联网开发下通信性能的高要求，Java在2002年开始支持了非阻塞式的I/O通信技术(NIO)。大多数读者在学习网络通信相关技术的时候，都只是接触到零碎的通信技术点，没有完整的技术体系架构，以至于对于Java的通信场景总是没有清晰的解决方案。本次课程将通过大量清晰直接的案例从最基础的BIO式通信开始介绍到NIO , AIO，读者可以清晰的了解到阻塞、同步、异步的现象、概念和特征以及优缺点。本课程结合了大量的案例让读者可以快速了解每种通信架构的使用。</p><h2 id="1-2-本课程学习要求"><a href="#1-2-本课程学习要求" class="headerlink" title="1.2 本课程学习要求"></a>1.2 本课程学习要求</h2><ul><li>本课程不太适合完全0基础学员。</li><li>至少需要掌握: Java SE基础编程，如Java多线程，Java IO流编程，Java网络基础知识（如：IP , 端口，协议），常用的Java设计模式要有一定的了解。</li><li>能熟练掌握Java OOP编程，有一定的编程思维。</li></ul><h2 id="1-3-通信技术整体解决的问题"><a href="#1-3-通信技术整体解决的问题" class="headerlink" title="1.3 通信技术整体解决的问题"></a>1.3 通信技术整体解决的问题</h2><ul><li>局域网内的通信要求。</li><li>多系统间的底层消息传递机制。</li><li>高并发下，大数据量的通信场景需要。</li><li>游戏行业。无论是手游服务端，还是大型的网络游戏，Java语言都得到越来越广泛的应用。</li></ul><h1 id="第二章-Java的I-O演进之路"><a href="#第二章-Java的I-O演进之路" class="headerlink" title="第二章 Java的I/O演进之路"></a>第二章 Java的I/O演进之路</h1><h2 id="2-1-I-O-模型基本说明"><a href="#2-1-I-O-模型基本说明" class="headerlink" title="2.1 I/O 模型基本说明"></a>2.1 I/O 模型基本说明</h2><p>I/O 模型：就是用什么样的通道或者说是通信模式和架构进行数据的传输和接收，很大程度上决定了程序通信的性能，Java 共支持 3 种网络编程的/IO 模型：<strong>BIO、NIO、AIO</strong> 实际通信需求下，要根据不同的业务场景和性能需求决定选择不同的I/O模型</p><h2 id="2-2-I-O模型"><a href="#2-2-I-O模型" class="headerlink" title="2.2 I/O模型"></a>2.2 I/O模型</h2><h4 id="Java-BIO"><a href="#Java-BIO" class="headerlink" title="Java BIO"></a>Java BIO</h4><p><strong>同步并阻塞</strong>(传统阻塞型)，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器 端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销 【简单示意图】</p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220202150239257.png" alt="image-20220202150239257" style="zoom:67%;" /><h4 id="Java-NIO"><a href="#Java-NIO" class="headerlink" title="Java NIO"></a>Java NIO</h4><p>Java NIO ： <strong>同步非阻塞</strong>，服务器实现模式为一个线程处理多个请求(连接)，即客户端发送的连接请求都会注 册到多路复用器上，多路复用器轮询到连接有 I/O 请求就进行处理 【简单示意图】</p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220202150345643.png" alt="image-20220202150345643" style="zoom:67%;" /><h4 id="Java-AIO"><a href="#Java-AIO" class="headerlink" title="Java AIO"></a>Java AIO</h4><p>Java AIO(NIO.2) ：<strong>异步非阻塞</strong>，服务器实现模式为一个有效请求一个线程，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理，一般适用于连接数较多且连接时间较长的应用</p><h2 id="2-3-BIO、NIO、AIO-适用场景分析"><a href="#2-3-BIO、NIO、AIO-适用场景分析" class="headerlink" title="2.3 BIO、NIO、AIO 适用场景分析"></a>2.3 BIO、NIO、AIO 适用场景分析</h2><p>1、<strong>BIO</strong> 方式适用于<strong>连接数目比较小且固定的架构</strong>，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序简单易理解。 </p><p>2、<strong>NIO</strong> 方式适用于<strong>连接数目多且连接比较短（轻操作）</strong>的架构，比如聊天服务器，弹幕系统，服务器间通讯等。 编程比较复杂，JDK1.4 开始支持。</p><p>3、<strong>AIO</strong> 方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用 OS 参与并发操作， 编程比较复杂，JDK7 开始支持。</p><h1 id="第三章-JAVA-BIO深入剖析"><a href="#第三章-JAVA-BIO深入剖析" class="headerlink" title="第三章 JAVA BIO深入剖析"></a>第三章 JAVA BIO深入剖析</h1><h2 id="3-1-Java-BIO-基本介绍"><a href="#3-1-Java-BIO-基本介绍" class="headerlink" title="3.1 Java BIO 基本介绍"></a>3.1 Java BIO 基本介绍</h2><ul><li>Java BIO 就是传统的 java io 编程，其相关的类和接口在 java.io</li><li>BIO(blocking I/O) ： 同步阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，可以通过<strong>线程池机制</strong>改善(实现多个客户连接服务器).</li></ul><h2 id="3-2-Java-BIO-工作机制"><a href="#3-2-Java-BIO-工作机制" class="headerlink" title="3.2 Java BIO 工作机制"></a>3.2 Java BIO 工作机制</h2><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220202151042311.png" alt="image-20220202151042311" style="zoom: 80%;" /><h2 id="3-3-传统的BIO编程实例回顾"><a href="#3-3-传统的BIO编程实例回顾" class="headerlink" title="3.3 传统的BIO编程实例回顾"></a>3.3 传统的BIO编程实例回顾</h2><p> 网络编程的基本模型是Client/Server模型，也就是两个进程之间进行相互通信，其中服务端提供位置信（绑定IP地址和端口），客户端通过连接操作向服务端监听的端口地址发起连接请求，基于TCP协议下进行三次握手连接，连接成功后，双方通过网络套接字（Socket）进行通信。</p><p> 传统的同步阻塞模型开发中，服务端ServerSocket负责绑定IP地址，启动监听端口；客户端Socket负责发起连接操作。连接成功后，双方通过输入和输出流进行<strong>同步阻塞式通信</strong>。 基于BIO模式下的通信，客户端 - 服务端是完全同步，完全耦合的。</p><h3 id="客户端案例如下"><a href="#客户端案例如下" class="headerlink" title="客户端案例如下"></a>客户端案例如下</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima._02bio01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    目标: Socket网络编程。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Java提供了一个包：java.net下的类都是用于网络通信。</span></span><br><span class="line"><span class="comment">    Java提供了基于套接字（端口）Socket的网络通信模式，我们基于这种模式就可以直接实现TCP通信。</span></span><br><span class="line"><span class="comment">    只要用Socket通信，那么就是基于TCP可靠传输通信。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    功能1：客户端发送一个消息，服务端接口一个消息，通信结束！！</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    创建客户端对象：</span></span><br><span class="line"><span class="comment">        （1）创建一个Socket的通信管道，请求与服务端的端口连接。</span></span><br><span class="line"><span class="comment">        （2）从Socket管道中得到一个字节输出流。</span></span><br><span class="line"><span class="comment">        （3）把字节流改装成自己需要的流进行数据的发送</span></span><br><span class="line"><span class="comment">    创建服务端对象：</span></span><br><span class="line"><span class="comment">        （1）注册端口</span></span><br><span class="line"><span class="comment">        （2）开始等待接收客户端的连接,得到一个端到端的Socket管道</span></span><br><span class="line"><span class="comment">        （3）从Socket管道中得到一个字节输入流。</span></span><br><span class="line"><span class="comment">        （4）把字节输入流包装成自己需要的流进行数据的读取。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Socket的使用：</span></span><br><span class="line"><span class="comment">        构造器：public Socket(String host, int port)</span></span><br><span class="line"><span class="comment">        方法：  public OutputStream getOutputStream()：获取字节输出流</span></span><br><span class="line"><span class="comment">               public InputStream getInputStream() :获取字节输入流</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ServerSocket的使用：</span></span><br><span class="line"><span class="comment">        构造器：public ServerSocket(int port)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    小结：</span></span><br><span class="line"><span class="comment">        通信是很严格的，对方怎么发你就怎么收，对方发多少你就只能收多少！！</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;==客户端的启动==&quot;</span>);</span><br><span class="line">        <span class="comment">// （1）创建一个Socket的通信管道，请求与服务端的端口连接。</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">8888</span>);</span><br><span class="line">        <span class="comment">// （2）从Socket通信管道中得到一个字节输出流。</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        <span class="comment">// （3）把字节流改装成自己需要的流进行数据的发送</span></span><br><span class="line">        <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(os);</span><br><span class="line">        <span class="comment">// （4）开始发送消息</span></span><br><span class="line">        ps.println(<span class="string">&quot;我是客户端，我想约你吃小龙虾！！！&quot;</span>);</span><br><span class="line">        ps.flush();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="服务端案例如下"><a href="#服务端案例如下" class="headerlink" title="服务端案例如下"></a>服务端案例如下</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima._02bio01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务端</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;==服务器的启动==&quot;</span>);</span><br><span class="line">        <span class="comment">// （1）注册端口</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8888</span>);</span><br><span class="line">        <span class="comment">//（2）开始在这里暂停等待接收客户端的连接,得到一个端到端的Socket管道</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">        <span class="comment">//（3）从Socket管道中得到一个字节输入流。</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="comment">//（4）把字节输入流包装成自己需要的流进行数据的读取。</span></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(is));</span><br><span class="line">        <span class="comment">//（5）读取数据</span></span><br><span class="line">        String line ;</span><br><span class="line">        <span class="keyword">while</span>((line = br.readLine())!=<span class="literal">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;服务端收到：&quot;</span>+line);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li>在以上通信中，服务端会一直等待客户端的消息，如果客户端没有进行消息的发送，服务端将一直进入阻塞状态。</li><li>同时服务端是按照行获取消息的，这意味着客户端也必须按照行进行消息的发送，否则服务端将进入等待消息的阻塞状态！</li></ul><h2 id="3-4-BIO模式下多发和多收消息"><a href="#3-4-BIO模式下多发和多收消息" class="headerlink" title="3.4 BIO模式下多发和多收消息"></a>3.4 BIO模式下多发和多收消息</h2><p>在1.3的案例中，<strong>只能实现客户端发送消息，服务端接收消息</strong>，并不能实现反复的收消息和反复的发消息，我们只需要在客户端案例中，加上反复按照行发送消息的逻辑即可！案例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima._03bio02;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    目标: Socket网络编程。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    功能1：客户端可以反复发消息，服务端可以反复收消息</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    小结：</span></span><br><span class="line"><span class="comment">        通信是很严格的，对方怎么发你就怎么收，对方发多少你就只能收多少！！</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;==客户端的启动==&quot;</span>);</span><br><span class="line">        <span class="comment">// （1）创建一个Socket的通信管道，请求与服务端的端口连接。</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">8888</span>);</span><br><span class="line">        <span class="comment">// （2）从Socket通信管道中得到一个字节输出流。</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        <span class="comment">// （3）把字节流改装成自己需要的流进行数据的发送</span></span><br><span class="line">        <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(os);</span><br><span class="line">        <span class="comment">// （4）开始发送消息</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;请说:&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line">            ps.println(msg);</span><br><span class="line">            ps.flush();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="服务端代码如下"><a href="#服务端代码如下" class="headerlink" title="服务端代码如下"></a>服务端代码如下</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima._03bio02;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务端</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;886&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;886&quot;</span>.equals(s));</span><br><span class="line">        System.out.println(<span class="string">&quot;==服务器的启动==&quot;</span>);</span><br><span class="line">        <span class="comment">//（1）注册端口</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8888</span>);</span><br><span class="line">        <span class="comment">//（2）开始在这里暂停等待接收客户端的连接,得到一个端到端的Socket管道</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">        <span class="comment">//（3）从Socket管道中得到一个字节输入流。</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="comment">//（4）把字节输入流包装成  自己需要的流进行数据的读取。</span></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(is));</span><br><span class="line">        <span class="comment">//（5）读取数据</span></span><br><span class="line">        String line ;</span><br><span class="line">        <span class="keyword">while</span>((line = br.readLine())!=<span class="literal">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;服务端收到：&quot;</span>+line);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><ul><li>本案例中确实可以实现客户端多发多收</li><li>但是<strong>服务端只能处理一个客户端的请求</strong>，因为服务端是单线程的。<strong>一次只能与一个客户端进行消息通信</strong>。</li></ul><h2 id="3-5-BIO模式下接收多个客户端"><a href="#3-5-BIO模式下接收多个客户端" class="headerlink" title="3.5 BIO模式下接收多个客户端"></a>3.5 BIO模式下接收多个客户端</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>在上述的案例中，一个服务端只能接收一个客户端的通信请求，<strong>那么如果服务端需要处理很多个客户端的消息通信请求应该如何处理呢</strong>，此时我们就需要<strong>在服务端引入线程</strong>了，也就是说<strong>客户端每发起一个请求，服务端就创建一个新的线程</strong>来处理这个客户端的请求，这样就实现了一个客户端一个线程的模型，图解模式如下：</p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220202152550833.png" alt="image-20220202152550833" style="zoom: 80%;" /><h3 id="客户端案例代码如下"><a href="#客户端案例代码如下" class="headerlink" title="客户端案例代码如下"></a>客户端案例代码如下</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    目标: 实现服务端可以同时接受多个客户端的Socket通信需求</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    思路：是服务端每接受一个客户端socket请求对象之后都交给一个独立的线程来处理客户端的数据交互需求</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;==客户端的启动==&quot;</span>);</span><br><span class="line">        <span class="comment">// （1）创建一个Socket的通信管道，请求与服务端的端口连接。</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">7777</span>);</span><br><span class="line">        <span class="comment">// （2）从Socket通信管道中得到一个字节输出流。</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        <span class="comment">// （3）把字节流改装成自己需要的流进行数据的发送</span></span><br><span class="line">        <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(os);</span><br><span class="line">        <span class="comment">// （4）开始发送消息</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;请说:&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line">            ps.println(msg);</span><br><span class="line">            ps.flush();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="服务端案例代码如下"><a href="#服务端案例代码如下" class="headerlink" title="服务端案例代码如下"></a>服务端案例代码如下</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    服务端</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;==服务器的启动==&quot;</span>);</span><br><span class="line">        <span class="comment">// （1）注册端口</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">7777</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="comment">//（2）开始在这里暂停等待接收客户端的连接,得到一个端到端的Socket管道</span></span><br><span class="line">            <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ServerReadThread</span>(socket).start();</span><br><span class="line">            System.out.println(socket.getRemoteSocketAddress()+<span class="string">&quot;上线了！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ServerReadThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ServerReadThread</span><span class="params">(Socket socket)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.socket = socket;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//（3）从Socket管道中得到一个字节输入流。</span></span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">            <span class="comment">//（4）把字节输入流包装成自己需要的流进行数据的读取。</span></span><br><span class="line">            <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(is));</span><br><span class="line">            <span class="comment">//（5）读取数据</span></span><br><span class="line">            String line ;</span><br><span class="line">            <span class="keyword">while</span>((line = br.readLine())!=<span class="literal">null</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;服务端收到：&quot;</span>+socket.getRemoteSocketAddress()+<span class="string">&quot;:&quot;</span>+line);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            System.out.println(socket.getRemoteSocketAddress()+<span class="string">&quot;下线了！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><ul><li>1.每个Socket接收到，都会创建一个线程，线程的竞争、切换上下文影响性能；</li><li>2.每个线程都会占用栈空间和CPU资源；</li><li>3.并不是每个socket都进行IO操作，无意义的线程处理；</li><li>4.客户端的并发访问增加时。服务端将呈现1:1的线程开销，访问量越大，系统将发生线程栈溢出，线程创建失败，最终导致进程宕机或者僵死，从而不能对外提供服务。</li></ul><h2 id="3-6-伪异步I-O编程"><a href="#3-6-伪异步I-O编程" class="headerlink" title="3.6 伪异步I/O编程"></a>3.6 伪异步I/O编程</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>在上述案例中：客户端的并发访问增加时。服务端将呈现1:1的线程开销，访问量越大，系统将发生线程栈溢出，线程创建失败，最终导致进程宕机或者僵死，从而不能对外提供服务。</p><p>接下来我们采用一个伪异步I/O的通信框架，采用<strong>线程池</strong>和<strong>任务队列</strong>实现，当客户端接入时，将客户端的Socket封装成一个Task(该任务实现java.lang.Runnable线程任务接口)交给后端的线程池中进行处理。JDK的线程池维护一个消息队列和N个活跃的线程，对消息队列中Socket任务进行处理，由于线程池可以设置消息队列的大小和最大线程数，因此，它的资源占用是可控的，无论多少个客户端并发访问，都不会导致资源的耗尽和宕机。</p><p>图示如下:</p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220202153828332.png" alt="image-20220202153828332" style="zoom:80%;" /><h3 id="客户端源码分析"><a href="#客户端源码分析" class="headerlink" title="客户端源码分析"></a>客户端源码分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 1.简历一个与服务端的Socket对象：套接字</span></span><br><span class="line">         <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">9999</span>);</span><br><span class="line">         <span class="comment">// 2.从socket管道中获取一个输出流，写数据给服务端 </span></span><br><span class="line">         <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream() ;</span><br><span class="line">         <span class="comment">// 3.把输出流包装成一个打印流 </span></span><br><span class="line">         <span class="type">PrintWriter</span> <span class="variable">pw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(os);</span><br><span class="line">         <span class="comment">// 4.反复接收用户的输入 </span></span><br><span class="line">         <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">         <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> <span class="literal">null</span> ;</span><br><span class="line">         <span class="keyword">while</span>((line = br.readLine()) != <span class="literal">null</span>)&#123;</span><br><span class="line">            pw.println(line);</span><br><span class="line">            pw.flush();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程池处理类"><a href="#线程池处理类" class="headerlink" title="线程池处理类"></a>线程池处理类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程池处理类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HandlerSocketThreadPool</span> &#123;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 线程池 </span></span><br><span class="line">   <span class="keyword">private</span> ExecutorService executor;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">HandlerSocketThreadPool</span><span class="params">(<span class="type">int</span> maxPoolSize, <span class="type">int</span> queueSize)</span>&#123;</span><br><span class="line">      </span><br><span class="line">      <span class="built_in">this</span>.executor = <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">            <span class="number">3</span>, <span class="comment">// 8</span></span><br><span class="line">            maxPoolSize,  </span><br><span class="line">            <span class="number">120L</span>, </span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;Runnable&gt;(queueSize) );</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable task)</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.executor.execute(task);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="服务端源码分析"><a href="#服务端源码分析" class="headerlink" title="服务端源码分析"></a>服务端源码分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">目标：开发实现伪异步通信架构</span></span><br><span class="line"><span class="comment">/</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">public class Server &#123;</span></span><br><span class="line"><span class="comment">   public static void main(String[] args) &#123;</span></span><br><span class="line"><span class="comment">      try &#123;</span></span><br><span class="line"><span class="comment">         System.out.println(&quot;----------服务端启动成功------------&quot;);</span></span><br><span class="line"><span class="comment">         ServerSocket ss = new ServerSocket(9999);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         // 一个服务端只需要对应一个线程池</span></span><br><span class="line"><span class="comment">         HandlerSocketThreadPool handlerSocketThreadPool =</span></span><br><span class="line"><span class="comment">               new HandlerSocketThreadPool(3, 1000);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         // 客户端可能有很多个</span></span><br><span class="line"><span class="comment">         while(true)&#123;</span></span><br><span class="line"><span class="comment">            Socket socket = ss.accept() ; // 阻塞式的！</span></span><br><span class="line"><span class="comment">            System.out.println(&quot;有人上线了！！&quot;);</span></span><br><span class="line"><span class="comment">            // 每次收到一个客户端的socket请求，都需要为这个客户端分配一个</span></span><br><span class="line"><span class="comment">            // 独立的线程 专门负责对这个客户端的通信！！</span></span><br><span class="line"><span class="comment">            handlerSocketThreadPool.execute(new ReaderClientRunnable(socket));</span></span><br><span class="line"><span class="comment">         &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      &#125; catch (Exception e) &#123;</span></span><br><span class="line"><span class="comment">         e.printStackTrace();</span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment">   &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">class ReaderClientRunnable implements Runnable&#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   private Socket socket ;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   public ReaderClientRunnable(Socket socket) &#123;</span></span><br><span class="line"><span class="comment">      this.socket = socket;</span></span><br><span class="line"><span class="comment">   &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   <span class="doctag">@Override</span></span></span><br><span class="line"><span class="comment">   public void run() &#123;</span></span><br><span class="line"><span class="comment">      try &#123;</span></span><br><span class="line"><span class="comment">         // 读取一行数据</span></span><br><span class="line"><span class="comment">         InputStream is = socket.getInputStream() ;</span></span><br><span class="line"><span class="comment">         // 转成一个缓冲字符流</span></span><br><span class="line"><span class="comment">         Reader fr = new InputStreamReader(is);</span></span><br><span class="line"><span class="comment">         BufferedReader br = new BufferedReader(fr);</span></span><br><span class="line"><span class="comment">         // 一行一行的读取数据</span></span><br><span class="line"><span class="comment">         String line = null ;</span></span><br><span class="line"><span class="comment">         while((line = br.readLine())!=null)&#123; // 阻塞式的！！</span></span><br><span class="line"><span class="comment">            System.out.println(&quot;服务端收到了数据：&quot;+line);</span></span><br><span class="line"><span class="comment">         &#125;</span></span><br><span class="line"><span class="comment">      &#125; catch (Exception e) &#123;</span></span><br><span class="line"><span class="comment">         System.out.println(&quot;有人下线了&quot;);</span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment">   &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><ul><li>伪异步io采用了线程池实现，因此避免了为每个请求创建一个独立线程造成线程资源耗尽的问题，但由于底层依然是采用的同步阻塞模型，因此无法从根本上解决问题。</li><li>如果单个消息处理的缓慢，或者服务器线程池中的全部线程都被阻塞，那么后续socket的i/o消息都将在队列中排队。新的Socket请求将被拒绝，客户端会发生大量连接超时。</li></ul><h2 id="3-7-基于BIO形式下的文件上传"><a href="#3-7-基于BIO形式下的文件上传" class="headerlink" title="3.7 基于BIO形式下的文件上传"></a>3.7 基于BIO形式下的文件上传</h2><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>支持任意类型文件形式的上传。</p><h3 id="客户端开发"><a href="#客户端开发" class="headerlink" title="客户端开发"></a>客户端开发</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.file;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.DataOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    目标：实现客户端上传任意类型的文件数据给服务端保存起来。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span>(</span><br><span class="line">                <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;C:\\Users\\dlei\\Desktop\\BIO,NIO,AIO\\文件\\java.png&quot;</span>);</span><br><span class="line">        )&#123;</span><br><span class="line">            <span class="comment">//  1、请求与服务端的Socket链接</span></span><br><span class="line">            <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span> , <span class="number">8888</span>);</span><br><span class="line">            <span class="comment">//  2、把字节输出流包装成一个数据输出流</span></span><br><span class="line">            <span class="type">DataOutputStream</span> <span class="variable">dos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(socket.getOutputStream());</span><br><span class="line">            <span class="comment">//  3、先发送上传文件的后缀给服务端</span></span><br><span class="line">            dos.writeUTF(<span class="string">&quot;.png&quot;</span>);</span><br><span class="line">            <span class="comment">//  4、把文件数据发送给服务端进行接收</span></span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> len;</span><br><span class="line">            <span class="keyword">while</span>((len = is.read(buffer)) &gt; <span class="number">0</span> )&#123;</span><br><span class="line">                dos.write(buffer , <span class="number">0</span> , len);</span><br><span class="line">            &#125;</span><br><span class="line">            dos.flush();</span><br><span class="line">            Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="服务端开发"><a href="#服务端开发" class="headerlink" title="服务端开发"></a>服务端开发</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.file;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    目标：服务端开发，可以实现接收客户端的任意类型文件，并保存到服务端磁盘。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8888</span>);</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> ss.accept();</span><br><span class="line">                <span class="comment">// 交给一个独立的线程来处理与这个客户端的文件通信需求。</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ServerReaderThread</span>(socket).start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.file;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.DataInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerReaderThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ServerReaderThread</span><span class="params">(Socket socket)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.socket = socket;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">// 1、得到一个数据输入流读取客户端发送过来的数据</span></span><br><span class="line">            <span class="type">DataInputStream</span> <span class="variable">dis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(socket.getInputStream());</span><br><span class="line">            <span class="comment">// 2、读取客户端发送过来的文件类型</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">suffix</span> <span class="operator">=</span> dis.readUTF();</span><br><span class="line">            System.out.println(<span class="string">&quot;服务端已经成功接收到了文件类型：&quot;</span> + suffix);</span><br><span class="line">            <span class="comment">// 3、定义一个字节输出管道负责把客户端发来的文件数据写出去</span></span><br><span class="line">            <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;C:\\Users\\dlei\\Desktop\\BIO,NIO,AIO\\文件\\server\\&quot;</span>+</span><br><span class="line">                    UUID.randomUUID().toString()+suffix);</span><br><span class="line">            <span class="comment">// 4、从数据输入流中读取文件数据，写出到字节输出流中去</span></span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> len;</span><br><span class="line">            <span class="keyword">while</span>((len = dis.read(buffer)) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                os.write(buffer,<span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">            os.close();</span><br><span class="line">            System.out.println(<span class="string">&quot;服务端接收文件保存成功！&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h3><p>客户端怎么发，服务端就怎么接收</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>1-手写数据库之Transaction Manager(事务管理器)</title>
      <link href="/2022/01/27/1-Transaction-Manager/"/>
      <url>/2022/01/27/1-Transaction-Manager/</url>
      
        <content type="html"><![CDATA[<h1 id="1-手写数据库之Transaction-Manager-事务管理器"><a href="#1-手写数据库之Transaction-Manager-事务管理器" class="headerlink" title="1-手写数据库之Transaction Manager(事务管理器)"></a>1-手写数据库之Transaction Manager(事务管理器)</h1><p>TM对事务进行管理, 能够让其他模块查询事务的状态。</p><p><strong>数据库模型如下图：</strong></p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220127112245276.png" alt="数据库模型"></p><p>TM是怎么样标识各个事务的呢? TM会为每个事务, 分配一个特定的XID, 作为其标识. 且这个XID是递增的, 后开始的事务XID要大于先开始的事务。<strong>Transaction Manager（TM） 通过维护 XID 文件来维护事务的状态</strong>，并提供接口供其他模块来查询某个事务的状态。</p><h2 id="XID文件"><a href="#XID文件" class="headerlink" title="XID文件"></a>XID文件</h2><p>在KangDB 中，每一个事务都有一个 <strong>XID</strong>，这个 ID <strong>唯一标识</strong>了这个事务。事务的 XID 从 <strong>1</strong> 开始标号，并自增，不可重复。并特殊规定 <strong>XID 0 是一个超级事务（Super Transaction）</strong>。因此如果上级模块想在不申请事务的情况下, 对数据库做一些修改, 则它可以将XID设置为0。<strong>XID 为 0 的事务的状态永远是 committed</strong>。 </p><p><strong>Transaction Manager 维护了一个 XID 格式的文件，用来记录各个事务的状态</strong>。KangDB 中，每个事务都有下面的三种状态：</p><ul><li><p><strong>active</strong>    事务正在进行，尚未结束</p></li><li><p><strong>committed</strong>    事务已提交 </p></li><li><p><strong>aborted</strong>    事务回滚，进入中止状态</p><p><strong>关于事务状态的具体内容详见 《数据库系统概念-第六版》P634</strong></p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220114115758371.png" alt="事务的状态"  /></li></ul><p>XID 文件给每个事务分配了 <strong>1</strong> 个字节的空间，用来<strong>保存其状态</strong>。同时，在 XID 文件的头部，还保存了一个 <strong>8</strong> 字节的数字 (<strong>用 long 类型来记录，Java中 long 类型占8个字节</strong> )，记录了这个 XID 文件管理的事务的个数。于是，事务 xid 在文件中的状态就存储在 (xid-1)+8 字节处，xid-1 是因为 xid 0（Super XID） 的状态不需要记录。</p><h3 id="TransactionManager-接口"><a href="#TransactionManager-接口" class="headerlink" title="TransactionManager 接口"></a>TransactionManager 接口</h3><p>TransactionManager 提供了一些接口供其他模块调用，用来创建事务和查询事务状态。具体如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> kangdb.backend.tm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> kangdb.backend.utils.Panic;</span><br><span class="line"><span class="keyword">import</span> kangdb.common.Error;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.RandomAccessFile;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ykangli</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/1/27 20:04</span></span><br><span class="line"><span class="comment"> * TransactionManager 对事务进行管理, 能够让其他模块查询事务的状态。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TransactionManager</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 开始一个事务，并返回XID</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> xid  (每一个事务都有一个 XID，这个 ID 唯一标识了这个事务)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">long</span> <span class="title function_">begin</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提交xid事务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> xid 事务的xid</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">commit</span><span class="params">(<span class="type">long</span> xid)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 回滚xid事务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> xid 事务的xid</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">abort</span><span class="params">(<span class="type">long</span> xid)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询一个事务的状态是否是正在进行的状态</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> xid 事务的xid</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> java.lang.boolean</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isActive</span><span class="params">(<span class="type">long</span> xid)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  查询一个事务的状态是否是已提交</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> xid 事务的xid</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> java.lang.boolean</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isCommitted</span><span class="params">(<span class="type">long</span> xid)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询一个事务的状态是否是已取消</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> xid 事务的xid</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> java.lang.boolean</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isAborted</span><span class="params">(<span class="type">long</span> xid)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 关闭TM</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个 xid 文件并创建 Transaction Manager(TM)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path xid文件路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> TransactionManagerImpl对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> TransactionManagerImpl <span class="title function_">create</span><span class="params">(String path)</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(path + TransactionManagerImpl.XID_SUFFIX);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建文件失败</span></span><br><span class="line">            <span class="keyword">if</span> (!file.createNewFile()) &#123;</span><br><span class="line">                Panic.panic(Error.FileExistsException);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            Panic.panic(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//该函数确定程序是否可以读取或写入由抽象路径名表示的文件。</span></span><br><span class="line">        <span class="keyword">if</span>(!file.canRead() || !file.canWrite()) &#123;</span><br><span class="line">            Panic.panic(Error.FileCannotRWException);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">FileChannel</span> <span class="variable">fc</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">RandomAccessFile</span> <span class="variable">raf</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            raf = <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(file, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">            fc = raf.getChannel();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            Panic.panic(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//写只有前8字节Header的空文件，即设置 xidCounter 为 0</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.wrap(<span class="keyword">new</span> <span class="title class_">byte</span>[TransactionManagerImpl.LEN_XID_HEADER_LENGTH]);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fc.position(<span class="number">0</span>);</span><br><span class="line">            fc.write(buffer);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            Panic.panic(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TransactionManagerImpl</span>(raf, fc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>public static TransactionManagerImpl create(String path)</strong></li></ul><p>创建<code>xxx.xid</code> 文件，并创建 TM，设置xidCounter 为0。</p><ul><li><strong>public static TransactionManagerImpl open(String path)</strong></li></ul><p>从一个已有的 xid 文件来创建 TM。</p><h3 id="TransactionManagerImpl实现类"><a href="#TransactionManagerImpl实现类" class="headerlink" title="TransactionManagerImpl实现类"></a>TransactionManagerImpl实现类</h3><ul><li><strong><a href="http://c.biancheng.net/view/1137.html">Java RandomAccessFile类</a>：动态读取文件内容</strong></li></ul><p>所谓动态读取是指从文件的<strong>任意位置开始访问文件</strong>，而不是必须从文件开始位置读取到文件末尾。动态读取需要用到 Java 中的 RandomAccessFile 类。</p><p>RandomAccessFile 是 Java 输入/输出流体系中功能最丰富的文件内容访问类，它提供了众多的方法来访问文件内容，它既可以读取文件内容，也可以向文件输出数据。由于 <strong>RandomAccessFile 可以从任意位置访问文件</strong>，所以在只需要访问文件部分内容的情况下，使用 RandonAccessFile 类是一个很好的选择。</p><p>RandomAccessFile 对象包含了一个记录指针，用以标识当前读写处的位置，当程序新创建一个 RandomAccessFile 对象时，该对象的文件记录指针位于文件头（也就是 0 处），<strong>当读/写了 n 个字节后，文件记录指针将会向后移动 n 个字节</strong>。除此之外，RandonAccessFile <strong>可以自由移动该记录指针</strong>，既可以向前移动，也可以向后移动。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.io.RandomAccessFile.length()方法 返回当前文件的长度，以字节为单位</span><br></pre></td></tr></table></figure><ul><li><strong>NIO</strong></li></ul><p>文件读写都采用了 NIO 方式的 FileChannel</p><ul><li><strong>private void checkXIDCounter()</strong></li></ul><p>在构造函数创建了一个 TransactionManager 之后，首先要对 XID 文件进行校验，以保证这是一个合法的 XID 文件。校验的方式也很简单，通过文件头的 8 字节数字**(long 类型) **反推文件的理论长度，与文件的实际长度做对比。如果不同则认为 XID 文件不合法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检查XID文件是否合法</span></span><br><span class="line"><span class="comment">     * 读取XID_FILE_HEADER中的xidcounter，根据它计算文件的理论长度，对比实际长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">checkXIDCounter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">fileLen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//文件的实际长度</span></span><br><span class="line">            fileLen = file.length();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e1) &#123;</span><br><span class="line">            Panic.panic(Error.BadXIDFileException);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (fileLen &lt; LEN_XID_HEADER_LENGTH) &#123;</span><br><span class="line">            Panic.panic(Error.BadXIDFileException);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从堆空间中分配一个容量大小为 LEN_XID_HEADER_LENGTH 的byte数组作为缓冲区的byte数据存储器</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buf</span> <span class="operator">=</span> ByteBuffer.allocate(LEN_XID_HEADER_LENGTH);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fc.position(<span class="number">0</span>);</span><br><span class="line">            fc.read(buf);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            Panic.panic(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//初始时 xidCounter应该为0，刚开始没有事务开启</span></span><br><span class="line">        <span class="built_in">this</span>.xidCounter = Parser.parseLong(buf.array());</span><br><span class="line">        <span class="comment">//理论上文件的长度</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> getXidPosition(<span class="built_in">this</span>.xidCounter + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (end != fileLen) &#123;</span><br><span class="line">            Panic.panic(Error.BadXIDFileException);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>初始时，该 <code>xxx.xid</code> 文件的长度就为 <strong>8</strong>个字节，记录的xidCounter = 0。 当开启事务时，<code>xxx.xid</code> 文件的前八个字节就会变化，相应的xidCounter 也就会变化。</p><p>对于校验没有通过的，会直接通过 panic 方法，强制停机。在一些基础模块中出现错误都会如此处理，无法恢复的错误只能直接停机。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> kangdb.backend.utils;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ykangli</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/1/27 21:30</span></span><br><span class="line"><span class="comment"> * 通过 panic 方法，强制停机。（终止当前正在运行的Java虚拟机）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Panic</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">panic</span><span class="params">(Exception err)</span> &#123;</span><br><span class="line">        err.printStackTrace();</span><br><span class="line">        <span class="comment">// status 为 0：表示正常退出程序，也就是结束当前正在运行中的java虚拟机。</span></span><br><span class="line">        <span class="comment">// status 为 1 或 -1 或 任何其他非零值 ：表示非正常退出当前程序。</span></span><br><span class="line">        System.exit(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;l</span><br></pre></td></tr></table></figure><ul><li><strong>private long getXidPosition(long xid)</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据事务xid取得其在xid文件中对应的位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">long</span> <span class="title function_">getXidPosition</span><span class="params">(<span class="type">long</span> xid)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> LEN_XID_HEADER_LENGTH + (xid - <span class="number">1</span>) * XID_FIELD_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事务 xid 在文件中的状态就存储在 (xid-1)+8 字节处，xid-1 是因为 xid 0（Super XID） 的状态不需要记录。</p><ul><li><strong>private void updateXID(long xid, byte status)</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 更新xid事务的状态为status</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updateXID</span><span class="params">(<span class="type">long</span> xid, <span class="type">byte</span> status)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">offset</span> <span class="operator">=</span> getXidPosition(xid);</span><br><span class="line">    <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[XID_FIELD_SIZE];</span><br><span class="line">    bytes[<span class="number">0</span>] = status;</span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.wrap(bytes);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        fc.position(offset);</span><br><span class="line">        fc.write(buffer);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        Panic.panic(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//nio中方法，强制同步缓存内容到文件中</span></span><br><span class="line">        fc.force(<span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        Panic.panic(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有文件操作，在执行后都<strong>需要立刻刷入文件中</strong>，防止在崩溃后文件丢失数据，<strong>fileChannel</strong> 的<code>force()</code>方法，强制同步缓存内容到文件中，类似于 BIO 中的 flush() 方法。force 方法的参数是一个布尔，表示是否同步文件的元数据（例如最后修改时间等）。</p><ul><li><strong>public long begin()</strong></li></ul><p><code>begin()</code> 方法会开始一个事务，更具体的，首先设置 xidCounter+1 事务的状态为 committed，随后 xidCounter 自增，并更新文件头。</p><p>最后利用 <code>TransactionManagerImpl</code> 来实现两个方法<code>public static TransactionManagerImpl create(String path)</code> 和 <code>public static TransactionManagerImpl open(String path)</code>，分别表示创建一个 xid 文件并创建 TM 和从一个已有的 xid 文件来创建 TM。</p><p>为了方便管理和使用，没有将这两个方法写在实现类 <code>TransactionManagerImpl</code> 里面，而是将其写在接口<code>TransactionManager</code>里，也就是<strong>静态方法</strong>，详见 <code>TransactionManagerImpl</code> 中的代码。</p>]]></content>
      
      
      <categories>
          
          <category> project </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>0-手写数据库之准备工作</title>
      <link href="/2022/01/27/0-%E7%94%A8Java%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/"/>
      <url>/2022/01/27/0-%E7%94%A8Java%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>​        作为非科班转码小菜鸡，一直感觉计算机的专业知识是自己的短板，而且只看视频学习很难真正理解和掌握相关指点，始终有一种好像懂了，又好像没懂的感觉，况且自己是那种不实践就不能深刻理解知识点的人，那么【造轮子】对自己来说好像是一个不错的方法了吧……著名带逛大师 <strong>轮子哥（vczh）</strong>将绝大部分时间都花在了「轮子」上，为了学习轮子哥的<del>带逛本领</del>编程能力，利用寒假时间从0 开始手写一个简单的数据库。恰好最近某天无聊逛牛客时，看到有大佬 [<a href="https://www.nowcoder.com/discuss/825665?source_id=profile_create_nctrack&channel=-1">何人听我楚狂声 MYDB——一个简易的数据库实现完整教程</a>使用Java手写了数据库，有源码+文档，那还说啥，赶紧利用寒假在家的时间撸起来！！！</p><p>​        就叫它 <strong>KangDB</strong> 吧~</p><h2 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h2><p>​        KangDB分为后端和前端，前后端通过 socket 进行交互。</p><h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><p>​        前端（客户端）就是读取用户输入，并发送到后端执行，输出返回结果，并等待下一次输入。</p><h3 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h3><p>​        KangDB后端则需要解析 SQL，如果是合法的 SQL，就尝试执行并返回结果。不包括解析器，KangDB的后端划分为<strong>五个模块</strong>，每个模块都又一定的职责，通过接口向其依赖的模块提供方法。五个模块如下所示：</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220127112245276.png" alt="image-20220127112245276"></p><p>每个模块的职责如下：</p><ul><li><p> TM 通过维护 XID 文件来维护事务的状态，并提供接口供其他模块来查询某个事务的状态。 </p></li><li><p>DM 直接管理数据库 DB 文件和日志文件。</p><p>DM 的主要职责有：</p><ol><li>分页管理 DB 文件，并进行缓存；</li></ol><ol start="2"><li>管理日志文件，保证在发生错误时可以根据日志进行恢复；</li><li>抽象 DB 文件为 DataItem 供上层模块使用，并提供缓存。 </li></ol></li><li><p>VM 基于<strong>两段锁协议</strong>实现了调度序列的可串行化，并实现了 <strong>MVCC</strong> 以消除读写阻塞，同时实现了两种隔离级别（<strong>READ COMMITTED</strong> 和 <strong>REPEATABLE READ</strong> ）。</p></li><li><p> IM 实现了基于 B+ 树的索引，目前 where 只支持已索引字段。 </p></li><li><p>TBM 实现了对字段和表的管理。同时，解析 SQL 语句，并根据语句操作表。</p></li></ul><h2 id="开发环境和运行环境"><a href="#开发环境和运行环境" class="headerlink" title="开发环境和运行环境"></a>开发环境和运行环境</h2><p>​        项目开发时使用的 <strong>WSL2</strong> 和 <strong>JDK17</strong>，如果要在 Windows 上执行，请替换启动参数中的路径为 Windows，<strong>JDK 版本要保证在 11 或以上，不兼容 JDK 8</strong>。</p><h3 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h3><p>​        一般电脑都安装有JDK 8，关于如何在电脑中已有 JDK 8 的基础上再安装其他版本的 JDK ，并且能随意切换，详细教程见 <a href="https://ykangli.top/2022/01/26/JDK-Configuration/">电脑已有jdk 8，再配置一个jdk 17</a></p><h3 id="WSL"><a href="#WSL" class="headerlink" title="WSL"></a>WSL</h3><p>​        <strong>WSL</strong> 全称 <strong>Windows Subsystem for Linux</strong>，官方翻译“<strong>适用于Linux的Windows子系统</strong>”。以下是微软官方对WSL的描述:</p><p>您可以：</p><ul><li><a href="https://aka.ms/wslstore">在 Microsoft Store</a> 中选择你偏好的 GNU/Linux 分发版。</li><li>运行常用的命令行软件工具（例如 <code>grep</code>、<code>sed</code>、<code>awk</code>）或其他 ELF-64 二进制文件。</li><li>运行 Bash shell 脚本和 GNU/Linux 命令行应用程序，包括：<ul><li>工具：vim、emacs、tmux</li><li>语言：<a href="https://docs.microsoft.com/zh-cn/windows/nodejs/setup-on-wsl2">NodeJS</a>、Javascript、<a href="https://docs.microsoft.com/zh-cn/windows/python/web-frameworks">Python</a>、Ruby、C/C++、C# 与 F#、Rust、Go 等</li><li>服务：SSHD、<a href="https://docs.microsoft.com/zh-cn/windows/wsl/tutorials/wsl-database">MySQL</a>、Apache、lighttpd、<a href="https://docs.microsoft.com/zh-cn/windows/wsl/tutorials/wsl-database">MongoDB</a>、<a href="https://docs.microsoft.com/zh-cn/windows/wsl/tutorials/wsl-database">PostgreSQL</a>。</li></ul></li><li>使用自己的 GNU/Linux 分发包管理器安装其他软件。</li><li>使用类似于 Unix 的命令行 shell 调用 Windows 应用程序。</li><li>在 Windows 上调用 GNU/Linux 应用程序。</li></ul><h4 id="什么是-WSL-2？"><a href="#什么是-WSL-2？" class="headerlink" title="什么是 WSL 2？"></a>什么是 WSL 2？</h4><p>​        WSL 2 是适用于 Linux 的 Windows 子系统体系结构的一个新版本，它支持适用于 Linux 的 Windows 子系统在 Windows 上运行 ELF64 Linux 二进制文件。 它的主要目标是<strong>提高文件系统性能</strong>，以及添加<strong>完全的系统调用兼容性</strong>。</p><p>​        这一新的体系结构改变了这些 Linux 二进制文件与Windows 和计算机硬件进行交互的方式，但仍然提供与 WSL 1（当前广泛可用的版本）中相同的用户体验。</p><p>​        单个 Linux 分发版可以在 WSL 1 或 WSL 2 体系结构中运行。 每个分发版可随时升级或降级，并且你可以并行运行 WSL 1 和 WSL 2 分发版。 WSL 2 使用全新的体系结构，该体系结构受益于运行真正的 Linux 内核。</p><h4 id="为什么要使用WSL-amp-WSL-2-？"><a href="#为什么要使用WSL-amp-WSL-2-？" class="headerlink" title="为什么要使用WSL&amp;WSL 2 ？"></a>为什么要使用WSL&amp;WSL 2 ？</h4><p>​        我们日常工作学习中有很多涉及与Linux系统的交互，课程中也有大量的以Linux为基础的知识和命令，如果我们日常工作与使用环境就是Linux那还好，无需切换就可无缝对接。但Windows毕竟是市场占有率最高的操作系统，有大量的人群办公\日常环境需Windows，而开发环境需要Linux。这就产生了一些<strong>在Windows环境下使用Linux的需求</strong>。面对这个需求目前有如下集中常用解决方案：</p><table><thead><tr><th>方案</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>单主机安装双系统</td><td>真正的操作系统</td><td>切换麻烦需要重启</td></tr><tr><td>双主机安装双系统</td><td>物理隔离</td><td>成本高需要两台PC</td></tr><tr><td>远程服务器</td><td>真实的操作系统</td><td>性能、带宽等局限</td></tr><tr><td>虚拟机安装Linux</td><td>完整的使用体验</td><td>资源消耗大、启动慢、运行效率低</td></tr><tr><td>WSL</td><td>资源消耗小、启动快、无缝衔接</td><td>使用体验可能不完整，某些Linux软件不支持</td></tr></tbody></table><p>WSL方案是微软近两年拥抱开源后推出的一个非常棒的解决方案；使用WSL，Windows与Linux子系统将共用同一文件系统，Windows创建的文件Linux子系统也可以访问并修改，反之亦然。我们可以在WSL中使用三剑客命令查询分析windows文档、日志、使用shell命令或者bash脚本运行存储在windows中的linux程序、甚至在WSL中创建docker容器，在windows下使用docker desktop进行可视化管理。特别方便有双系统环境来回切换需求的人。总之<strong>使用WSL既可以使用windows的图形化操作界面又可以使用Linux便捷的命令行工具</strong>，很好的满足了我在windows下使用linux的需求。接下来我将介绍如何打造及使用Winux系统。</p><h4 id="安装WSL"><a href="#安装WSL" class="headerlink" title="安装WSL"></a>安装WSL</h4><p>参照官方文档<a href="https://docs.microsoft.com/zh-cn/windows/wsl/install">安装 WSL</a></p>]]></content>
      
      
      <categories>
          
          <category> project </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>电脑已有jdk 8，再配置一个jdk 17</title>
      <link href="/2022/01/26/JDK-Configuration/"/>
      <url>/2022/01/26/JDK-Configuration/</url>
      
        <content type="html"><![CDATA[<p>如何安装两个以上版本jdk，并可以自由切换。以jdk1.8和jdk-17为例</p><h2 id="一、目标："><a href="#一、目标：" class="headerlink" title="一、目标："></a>一、目标：</h2><p>现在用的 jdk1.8 做开发，私下里想了解和测试最新版 jdk-17 的特性，所以需要两个(甚至多个)版本的 jdk（以 jdk1.8 和 jdk-17 和为例），而且要做到可以随时切换版本。</p><h2 id="二、当前情况"><a href="#二、当前情况" class="headerlink" title="二、当前情况"></a>二、当前情况</h2><p>目前电脑中已有一个 jdk1.8</p><h2 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h2><ol><li>将 jdk 17 压缩包解压</li><li>打开环境变量，找到系统变量中的<strong>Path</strong></li><li>点击编辑把<code>%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin;</code>复制到变量值的最前面，然后确定</li></ol><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126225728779.png" alt="image-20220126225728779"></p><ol start="4"><li>新建两个JAVA_HOME，值为jdk的路径</li></ol><table><thead><tr><th>变量</th><th>值</th><th>说明</th></tr></thead><tbody><tr><td>JAVA_HOME</td><td>%JAVA_HOME8%</td><td>修改此处变量值中的数字来达到启用所对应的jdk</td></tr><tr><td>JAVA_HOME17</td><td>jdk17路径</td><td>12为我的jdk版本；后面的路径是你自己jdk的主目录</td></tr><tr><td>JAVA_HOME8</td><td>jdk8路径</td><td>8也为我的jdk版本；后面的路径是你自己jdk的主目录</td></tr></tbody></table><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126225556573.png" alt="image-20220126225556573"></p><h3 id="切换jdk"><a href="#切换jdk" class="headerlink" title="切换jdk"></a>切换jdk</h3><p>修改JAVA_HOME变量值中的数字来达到启用所对应的jdk</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126225831540.png" alt="image-20220126225831540"></p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>WIN+R输入cmd打开命令提示符，键入<br><code>java -version</code></p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126225911133.png" alt="image-20220126225911133"></p><p>切换版本后，要打开一个新的cmd进行测试</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126225938216.png" alt="image-20220126225938216"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL事务日志</title>
      <link href="/2022/01/26/MySQL%E4%BA%8B%E5%8A%A1%E6%97%A5%E5%BF%97/"/>
      <url>/2022/01/26/MySQL%E4%BA%8B%E5%8A%A1%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL事务日志"><a href="#MySQL事务日志" class="headerlink" title="MySQL事务日志"></a>MySQL事务日志</h1><p>事务有4种特性：原子性、一致性、隔离性和持久性。那么事务的四种特性到底是基于什么机制实现呢？</p><p>事务的<strong>隔离性</strong>由 <strong>锁机制</strong> 实现。</p><p>而事务的<strong>原子性、一致性和持久性</strong>由事务的 <strong>redo 日志和undo 日志</strong>来保证。</p><ul><li>REDO LOG 称为 <strong>重做日志</strong> ，提供再写入操作，恢复提交事务修改的页操作，用来保证事务的<strong>持久性</strong>。</li><li>UNDO LOG 称为 <strong>回滚日志</strong> ，回滚行记录到某个特定版本，用来保证事务的<strong>原子性、一致性</strong>。</li></ul><p>有人或许会认为UNDO是REDO的逆过程，其实不然。REDO 和 UNDO 都可以视为是一种<strong>恢复操作</strong>，但是:</p><ul><li> <strong>redo log</strong>:    是<strong>存储引擎层(innodb)生成的日志</strong>，记录的是”<strong>物理级别</strong>“上的页修改操作，比如页号xx、偏移量y写入了’zzz’数据。主要为了保证数据的可靠性;</li><li><strong>undo log</strong>:    是存储引擎层(innodb)生成的日志，记录的是<strong>逻辑操作</strong>日志，比如对某一行数据进行了INSERT语句操作，那么undo log就记录一条与之相反的DELETE操作。主要用于<strong>事务的回滚</strong>(undo log记录的是每个修改操作的<strong>逆操作</strong>)和<strong>一致性非锁定读</strong>(undo log回滚行记录到某种特定的版本—MVCC，即多版本并发控制)</li></ul><h2 id="1-redo日志"><a href="#1-redo日志" class="headerlink" title="1. redo日志"></a>1. redo日志</h2><p>InnoDB存储引擎是<strong>以页为单位</strong>来管理存储空间的。在真正访问页面之前，需要把在<strong>磁盘上</strong>的页缓存到内存中的<strong>Buffer Pool</strong>之后才可以访问。所有的变更都必须<strong>先更新缓冲池中的数据</strong>，然后缓冲池中的<strong>脏页</strong>会以一定的频率被刷入磁盘（<strong>checkPoint机制</strong>），通过缓冲池来优化CPu和磁盘之间的鸿沟，这样就可以保证整体的性能不会下降太快。</p><h3 id="1-1-为什么需要REDO日志"><a href="#1-1-为什么需要REDO日志" class="headerlink" title="1.1 为什么需要REDO日志"></a>1.1 为什么需要REDO日志</h3><p>一方面，缓冲池可以帮助我们消除CPU和磁盘之间的鸿沟，checkpoint机制可以保证数据的最终落盘，然而由于checkpoint 并不是每次变更的时候就触发 的，而是<strong>master线程隔一段时间去处理的</strong>。</p><p><strong>所以最坏的情况</strong>就是事务提交后，刚写完缓冲池，还没将数据刷新到磁盘（内存中完成了，但磁盘中未完成），数据库宕机了，那么这段数据就是丢失的，无法恢复。</p><p>另一方面，事务包含 <strong>持久性</strong> 的特性，就是说对于一个已经提交的事务，在事务提交后即使系统发生了崩溃，这个事务对数据库中所做的更改也不能丢失。</p><p>那么如何保证这个持久性呢？ <strong>一个简单的做法</strong> ：在事务提交完成之前把该事务所修改的所有页面都刷新到磁盘，但是这个简单粗暴的做法有些问题：</p><ul><li><strong>修改量与刷新磁盘工作量严重不成比例</strong></li></ul><p>有时候我们仅仅修改了某个页面中的一个字节，但是我们知道在InnoDB中是<strong>以页为单位来进行磁盘IO的</strong>，也就是说我们在该事务提交时<strong>不得不将一个完整的页面从内存中刷新到磁盘</strong>，我们又知道一个页面默认是16KB大小，只修改一个字节就要刷新16KB的数据到磁盘上显然是太小题大做了。</p><ul><li><strong>随机lO刷新较慢</strong></li></ul><p>一个事务可能包含很多语句，即使是一条语句也可能修改许多页面，假如该事务修改的这些页面可能并不相邻，这就意味着在将某个事务修改的Buffer Pool中的页面刷新到磁盘时，需要进行很多的随机IO，随机IO比顺序IO要慢，尤其对于传统的机械硬盘来说。</p><p><strong>另一个解决的思路</strong> ：我们只是想让已经提交了的事务对数据库中数据所做的修改永久生效，即使后来系统崩溃，在重启后也能把这种修改恢复出来。所以我们其实没有必要在每次事务提交时就把该事务在内存中修改过的全部页面刷新到磁盘，只需要把<strong>修改了哪些东西记录一下就好</strong>。比如，某个事务将系统表空间中 第10号 页面中偏移量为 100 处的那个字节的值 1 改成 2 。我们只需要记录一下：将第0号表空间的10号页面的偏移量为100处的值更新为 2 。  </p><p>InnoDB引擎的事务采用了WAL技术（<code>Write-Ahead Logging</code>)，这种技术的思想就是<strong>先写日志，再写磁盘</strong>，<strong>只有日志写入成功，才算事务提交成功</strong>，这里的日志就是<strong>redo log</strong>。当发生宕机且数据未刷到磁盘的时候，可以通过redo log来恢复，保证ACID中的D，这就是redo log的作用。</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126162713847.png" alt="image-20220126162713847"></p><h3 id="1-2-REDO日志的好处、特点"><a href="#1-2-REDO日志的好处、特点" class="headerlink" title="1.2 REDO日志的好处、特点"></a>1.2 REDO日志的好处、特点</h3><p><strong>好处：</strong></p><ul><li>redo日志降低了刷盘频率</li><li>redo日志占用的空间非常小</li></ul><p>存储表空间ID、页号、偏移量以及需要更新的值，所需要的存储空间是很小的，刷盘快。</p><p><strong>特点：</strong></p><ul><li>redo日志是顺序写入磁盘的</li></ul><p>在执行事务的过程中，每执行一条语句，就可能产生若干条redo日志，这些日志是按照<strong>产生的顺序写入磁盘的</strong>，也就是使用顺序lo，效率比随机IO快。</p><ul><li>事务执行过程中，redo log不断记录  </li></ul><p>redo log跟bin log的区别，redo log是<strong>存储引擎层</strong>产生的，而<strong>bin log是数据库层</strong>产生的。假设一个事务，对表做10万行的记录插入，在这个过程中，一直不断的往redo log顺序记录，而bin log不会记录，直到这个事务提交，才会一次写入到bin log文件中。</p><h3 id="1-3-redo的组成"><a href="#1-3-redo的组成" class="headerlink" title="1.3 redo的组成"></a>1.3 redo的组成</h3><p>Redo log可以简单分为以下两个部分：</p><ul><li>重做日志的缓冲 (redo log buffer) ，保存在内存中，是易失的。</li></ul><p>在服务器启动时就向操作系统申请了一大片称之为redo log buffer的<strong>连续内存</strong>空间，翻译成中文就是redo日志缓冲区。这片内存空间被划分成若干个连续的redo log block。一个redo log block占用512字节大小。</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126164247620.png" alt="image-20220126164244593"></p><p><strong>参数设置：innodb_log_buffer_size：</strong>  </p><p>redo log buffer 大小，默认 16M ，最大值是4096M，最小值为1M。 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%innodb_log_buffer_size%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">------------------------+----------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------------+----------+</span></span><br><span class="line"><span class="operator">|</span> innodb_log_buffer_size <span class="operator">|</span> <span class="number">16777216</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------------+----------+   </span></span><br></pre></td></tr></table></figure><ul><li>重做日志文件 (redo log file) ，保存在硬盘中，是持久的。  </li></ul><p>REDO日志文件如图所示，其中的ib_logfile0和ib_logfile1即为REDO日志。</p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126164528296.png" alt="image-20220126164528296" style="zoom:67%;" /><h3 id="1-4-redo的整体流程"><a href="#1-4-redo的整体流程" class="headerlink" title="1.4 redo的整体流程"></a>1.4 redo的整体流程</h3><p>以一个更新事务为例，redo log 流转过程，如下图所示：  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126164659436.png" alt="image-20220126164659436"></p><ul><li>第1步：先将原始数据从磁盘中读入内存中来，修改数据的内存拷贝</li><li>第2步：生成一条重做日志并写入redo log buffer，记录的是数据被修改后的值</li><li>第3步：当事务commit时，将redo log buffer中的内容刷新到 redo log file，对 redo log file采用追加写的方式</li><li>第4步：定期将内存中修改的数据刷新到磁盘中  </li></ul><h3 id="1-5-redo-log的刷盘策略"><a href="#1-5-redo-log的刷盘策略" class="headerlink" title="1.5 redo log的刷盘策略"></a>1.5 redo log的刷盘策略</h3><p>redo log的写入并不是直接写入磁盘的，InnoDB引擎会在写redo log的时候先写redo log buffer，之后以 <strong>一定的频率</strong> 刷入到真正的redo log file 中。这里的一定频率怎么看待呢？这就是我们要说的刷盘策略。  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126164801521.png" alt="image-20220126164801521"></p><p>注意，redo log buffer刷盘到redo log file的过程并不是真正的刷到磁盘中去，只是刷入到 <strong>文件系统缓存（page cache）</strong>中去（这是现代<strong>操作系统</strong>为了提高文件写入效率做的一个优化），真正的写入会交给系统自己来决定（比如page cache足够大了）。那么对于InnoDB来说就存在一个问题，如果交给系统来同步，同样如果<strong>操作系统系统宕机</strong>，那么数据也丢失了（虽然整个系统宕机的概率还是比较小的）。<br>针对这种情况，InnoDB给出 innodb_flush_log_at_trx_commit 参数，该参数控制 commit提交事务时，如何将 redo log buffer 中的日志刷新到 redo log file 中。它支持三种策略：  </p><ul><li>设置为0 ：表示每次事务提交时不进行刷盘操作。（系统默认master thread每隔1s进行一次重做日志的同步）</li><li>设置为1 ：表示<strong>每次事务提交时都将进行同步，刷盘操作</strong>（ <strong>默认值</strong> ）</li><li>设置为2 ：表示每次事务提交时都只把 redo log buffer 内容写入 page cache，不进行同步。由os自己决定什么时候同步到磁盘文件。  </li></ul><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126165353406.png" alt="image-20220126165353406"></p><p>另外，InnoDB存储引擎有一个后台线程，每隔1秒，就会把 redo log buffer 中的内容写到文件系统缓存( page cache ) ，然后调用刷盘操作。</p><h3 id="1-6-不同刷盘策略演示"><a href="#1-6-不同刷盘策略演示" class="headerlink" title="1.6 不同刷盘策略演示"></a>1.6 不同刷盘策略演示</h3><h4 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h4><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126165559699.png" alt="image-20220126165559699"></p><p><strong>小结</strong>: <code>innodb_flush_log_at_trx_commit=1</code></p><p>为1时，只要事务提交成功,redo log记录就一定在硬盘里，不会有任何数据丢失。</p><p>如果事务执行期间MySQL挂了或宕机，这部分日志丢了，但是事务并没有提交，所以日志丢了也不会有损失。可以保证ACID的D，数据绝对不会丢失，但是<strong>效率最差</strong>的。</p><p>建议使用默认值，虽然操作系统宕机的概率理论小于数据库宕机的概率，但是一般既然使用了事务，那么数据的安全相对来说更重要些。|</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126170043228.png" alt="image-20220126170043228"></p><p><strong>小结</strong>:  <code>innodb_flush_log_at_trx_commit=2</code></p><p>为2时，只要事务提交成功，redo log buffer中的内容只写入文件系统缓存（ page cache )</p><p>如果仅仅只是MysQL挂了不会有任何数据丢失（page cache不归内存管了），但是<strong>操作系统宕机可能会有1秒数据的丢失</strong>，这种情况下无法满足ACID中的D。但是数值2肯定是效率最高的。</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126170251477.png" alt="image-20220126170251477"></p><p><strong>小结</strong>:  <code> innodb_flush_log_at_trx_commit=0</code> </p><p>为0时，master thread中每1秒进行一次重做日志的fsync操作，因此实例crash最多丢失1秒钟内的事务。(master thread是负责将缓冲池中的数据异步刷新到磁盘，保证数据的一致性)</p><p>数值0的话，是一种折中的做法，它的IO效率理论是高于1的，低于2的，这种策略也有丢失数据的风险，这种情况下也无法满足ACID中的D。</p><h3 id="1-7-写入redo-log-buffer-过程"><a href="#1-7-写入redo-log-buffer-过程" class="headerlink" title="1.7 写入redo log buffer 过程"></a>1.7 写入redo log buffer 过程</h3><h4 id="1-补充概念-Mini-Transaction"><a href="#1-补充概念-Mini-Transaction" class="headerlink" title="1.补充概念: Mini-Transaction"></a>1.补充概念: Mini-Transaction</h4><p>MysQL把对底层页面中的一次原子访问的过程称之为一个<strong>Mini-Transaction</strong>，简称<strong>mtr</strong>，比如，<strong>向某个索引对应的B+树中插入一条记录的过程就是一个Mini-Transaction</strong>。一个所谓的mtr可以包含一组redo日志在进行崩溃恢复时这一组redo日志作为一个不可分割的整体。</p><p>一个事务可以包含若干条语句，每一条语句其实是由若干个mtr组成，每一个mtr又可以包含若干条redo日志，画个图表示它们的关系就是这样:</p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126172158478.png" alt="image-20220126172158478" style="zoom:60%;" /><h4 id="2-redo-日志写入log-buffer"><a href="#2-redo-日志写入log-buffer" class="headerlink" title="2. redo 日志写入log buffer"></a>2. redo 日志写入log buffer</h4><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126172413359.png" alt="image-20220126172413359"></p><p>每个mtr都会产生一组redo日志，用示意图来描述一下这些mtr产生的日志情况：  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126172424274.png" alt="image-20220126172424274"></p><p>不同的事务可能是 并发 执行的，所以 T1 、 T2 之间的 mtr 可能是 交替执行 的。  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126172438820.png" alt="image-20220126172438820"></p><h4 id="3-redo-log-block的结构图"><a href="#3-redo-log-block的结构图" class="headerlink" title="3. redo log block的结构图"></a>3. redo log block的结构图</h4><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126172453846.png" alt="image-20220126172453846"></p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126172501143.png" alt="image-20220126172501143"></p><h3 id="1-8-redo-log-file"><a href="#1-8-redo-log-file" class="headerlink" title="1.8 redo log file"></a>1.8 redo log file</h3><h4 id="1-相关参数设置"><a href="#1-相关参数设置" class="headerlink" title="1. 相关参数设置"></a>1. 相关参数设置</h4><ul><li><strong>innodb_log_group_home_dir</strong> ：指定 redo log 文件组所在的路径，默认值为 ./ ，表示在数据库的数据目录下。MySQL的默认数据目录（ var/lib/mysql ）下默认有两个名为 ib_logfile0 和ib_logfile1 的文件，log buffer中的日志默认情况下就是刷新到这两个磁盘文件中。此redo日志文件位置还可以修改。</li><li><strong>innodb_log_files_in_group</strong>：指明redo log file的个数，命名方式如：ib_logfile0，iblogfile1…iblogfilen。默认2个，最大100个。  </li></ul><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126172627228.png" alt="image-20220126172627228"></p><ul><li><strong>innodb_flush_log_at_trx_commit</strong>：控制 redo log 刷新到磁盘的策略，默认为1。</li><li><strong>innodb_log_file_size</strong>：单个 redo log 文件设置大小，默认值为 48M 。最大值为512G，注意最大值指的是整个 redo log 系列文件之和，即（innodb_log_files_in_group * innodb_log_file_size ）不能大于最大值512G。  </li></ul><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126172718213.png" alt="image-20220126172718213"></p><p>根据业务修改其大小，以便容纳较大的事务。编辑my.cnf文件并重启数据库生效，如下所示  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vim /etc/my.cnf</span><br><span class="line">innodb_log_file_size=200M  </span><br></pre></td></tr></table></figure><h4 id="2-日志文件组"><a href="#2-日志文件组" class="headerlink" title="2. 日志文件组"></a>2. 日志文件组</h4><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126172743759.png" alt="image-20220126172743759"></p><p>总共的redo日志文件大小其实就是： <code>innodb_log_file_size × innodb_log_files_in_group </code>。</p><p>采用循环使用的方式向redo日志文件组里写数据的话，会导致后写入的redo日志覆盖掉前边写的redo日志？当然！所以InnoDB的设计者提出了checkpoint的概念。  </p><h4 id="3-checkpoint"><a href="#3-checkpoint" class="headerlink" title="3. checkpoint"></a>3. checkpoint</h4><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126172808119.png" alt="image-20220126172808119"></p><p>如果 write pos 追上 checkpoint ，表示<strong>日志文件组满了</strong>，这时候不能再写入新的 redo log记录，MySQL 得停下来，清空一些记录，把 checkpoint 推进一下。  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126172825343.png" alt="image-20220126172825343"></p><h3 id="1-9-redo-log小结"><a href="#1-9-redo-log小结" class="headerlink" title="1.9 redo log小结"></a>1.9 redo log小结</h3><p>相信大家都知道redo log的作用和它的刷盘时机、存储形式:</p><p>InnoDB的更新操作采用的是<strong>Write Ahead Log</strong>(预先日志持久化)策略，即<strong>先写日志，再写入磁盘</strong>。</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126173138431.png" alt="image-20220126173138431"></p><h2 id="2-Undo日志"><a href="#2-Undo日志" class="headerlink" title="2. Undo日志"></a>2. Undo日志</h2><p><strong>redo log</strong>是事务<strong>持久性</strong>的保证，<strong>undo log</strong>是事务<strong>原子性</strong>的保证。在事务中 <strong>更新数据</strong> 的 <strong>前置操作</strong> 其实是要先写入一个 undo log 。</p><h3 id="2-1-如何理解Undo日志"><a href="#2-1-如何理解Undo日志" class="headerlink" title="2.1 如何理解Undo日志"></a>2.1 如何理解Undo日志</h3><p>事务需要保证 <strong>原子性</strong> ，也就是事务中的操作<strong>要么全部完成，要么什么也不做</strong>。但有时候事务执行到一半会出现一些情况，比如：</p><ul><li>情况一：事务执行过程中可能遇到各种错误，比如 <strong>服务器本身的错误</strong> ， <strong>操作系统错误</strong> ，甚至是突然<strong>断电</strong>导致的错误。</li><li>情况二：程序员可以在事务执行过程中手动输入 <strong>ROLLBACK</strong> 语句结束当前事务的执行。</li></ul><p>以上情况出现，我们需要把数据改回原先的样子，这个过程称之为 <strong>回滚</strong> ，这样就可以造成一个假象：这个事务看起来什么都没做，所以符合 <strong>原子性</strong> 要求。  </p><p>每当我们要对一条记录做改动时(这里的<strong>改动</strong>可以指<strong>INSERT、DELETE、UPDATE</strong>)，都需要”留一手”—-把回滚时所需的东西记下来。比如:</p><ul><li>你<strong>插入一条记录</strong>时，至少要把这条记录的主键值记下来，之后回滚的时候只需要把这个主键值对应的记录删掉就好了。(对于每个INSERT,InnoDB存储引擎会完成一个DELETE)</li><li>你<strong>删除了一条记录</strong>，至少要把这条记录中的内容都记下来，这样之后回滚时再把由这些内容组成的记录插入到表中就好了。(对于每个DELETE,InnoDB存储引擎会执行一个INSERT)</li><li>你<strong>修改了一条记录</strong>，至少要把修改这条记录前的旧值都记录下来，这样之后回滚时再把这条记录更新为旧值就好了。(对于每个UPDATE，InnoDB存储引擎会执行一个相反的UPDATE，将修改前的行放回去)</li></ul><p>MysQL把这些为了回滚而记录的这些内容称之为<strong>撤销日志</strong>或者<strong>回滚日志</strong>(即undo log)。注意，由于查询操作( SELECT）并不会修改任何用户记录，所以<strong>在查询操作执行时，并不需要记录相应的undo日志</strong>。</p><p>此外，undo log <strong>会产生redo log</strong>，也就是undo log的产生会伴随着redo log的产生，这是因为undo log也需要持久性的保护。</p><h3 id="2-2-Undo日志的作用"><a href="#2-2-Undo日志的作用" class="headerlink" title="2.2 Undo日志的作用"></a>2.2 Undo日志的作用</h3><ul><li><strong>作用1：回滚数据</strong></li></ul><p>用户对undo日志可能有误解:undo用于将数据库物理地恢复到执行语句或事务之前的样子。但事实并非如此。undo是逻辑日志，因此只是将数据库逻辑地恢复到原来的样子。所有修改都被逻辑地取消了，但是<strong>数据结构和页本身在回滚之后可能大不相同</strong>。</p><p>这是因为在多用户并发系统中，可能会有数十、数百甚至数千个并发事务。数据库的主要任务就是协调对数据记录的并发访问。比如，一个事务在修改当前一个页中某几条记录，同时还有别的事务在对同一个页中另几条记录进行修改。因此，不能将一个页回滚到事务开始的样子，因为这样会影响其他事务正在进行的工作。</p><ul><li><strong>作用2：MVCC</strong>  </li></ul><p>undo的另一个作用是MVCC，即在InnoDB存储引擎中MIcc的实现是通过undo来完成。当用户读取一行记录时，若该记录已经被其他事务占用，当前事务可以通过undo读取之前的行版本信息，以此实现非锁定读取。</p><h3 id="2-3-undo的存储结构"><a href="#2-3-undo的存储结构" class="headerlink" title="2.3 undo的存储结构"></a>2.3 undo的存储结构</h3><h4 id="1-回滚段与undo页"><a href="#1-回滚段与undo页" class="headerlink" title="1. 回滚段与undo页"></a>1. 回滚段与undo页</h4><p>InnoDB对undo log的管理采用段的方式，也就是 <strong>回滚段（rollback segment）</strong> 。每个回滚段记录了<strong>1024</strong> 个 <strong>undo log segment</strong> ，而在每个undo log segment段中进行 undo页 的申请。</p><ul><li>在 InnoDB1.1版本之前 （不包括1.1版本），只有一个rollback segment，因此支持同时在线的事务限制为 1024 。虽然对绝大多数的应用来说都已经够用。</li><li>从1.1版本开始InnoDB支持最大 <strong>128个rollback segment</strong> ，故其支持同时在线的事务限制提高到了 <strong>128*1024</strong> 。  </li></ul><h4 id="2-回滚段与事务"><a href="#2-回滚段与事务" class="headerlink" title="2. 回滚段与事务"></a>2. 回滚段与事务</h4><ol><li><p>每个事务只会使用一个回滚段，一个回滚段在同一时刻可能会服务于多个事务。</p></li><li><p>当一个事务开始的时候，会制定一个回滚段，在事务进行的过程中，当数据被修改时，原始的数据会被复制到回滚段。</p></li><li><p>在回滚段中，事务会不断填充盘区，直到事务结束或所有的空间被用完。如果当前的盘区不够用，事务会在段中请求扩展下一个盘区，如果所有已分配的盘区都被用完，事务会覆盖最初的盘区或者在回滚段允许的情况下扩展新的盘区来使用。</p></li><li><p>回滚段存在于undo表空间中，在数据库中可以存在多个undo表空间，但同一时刻只能使用一个undo表空间。</p></li><li><p>当事务提交时，InnoDB存储引擎会做以下两件事情：</p><p>将undo log放入列表中，以供之后的purge操作</p><p>判断undo log所在的页是否可以重用，若可以分配给下个事务使用</p></li><li><p> 回滚段中的数据分类  </p></li></ol><h4 id="3-回滚段中的数据分类"><a href="#3-回滚段中的数据分类" class="headerlink" title="3. 回滚段中的数据分类"></a>3. 回滚段中的数据分类</h4><ol><li><strong>未提交的回滚数据(uncommitted undo information)</strong>:该数据所关联的事务并未提交，用于实现读一致性，所以该数据不能被其他事务的数据覆盖。</li><li>**已经提交但未过期的回滚数据(committed undo information):**该数据关联的事务已经提交，但是仍受到undo retention参数的保持时间的影响。</li><li>**事务已经提交并过期的数据(expired undo information)**∶事务已经提交，而且数据保存时间已经超过undo retention参数指定的时间，属于已经过期的数据。当回滚段满了之后，会优先覆盖”事务已经提交并过期的数据”。</li></ol><p>事务提交后并不能马上删除undo log及undo log所在的页。这是因为可能还有其他事务需要通过undo log来得到行记录之前的版本。故事务提交时将undo log放入一个链表中，是否可以最终删除undo log及undo log所在页由purge线程来判断。</p><h3 id="2-4-undo的类型"><a href="#2-4-undo的类型" class="headerlink" title="2.4 undo的类型"></a>2.4 undo的类型</h3><p>在InnoDB存储引擎中，undo log分为：</p><ul><li>insert undo log</li><li>update undo log</li></ul><h3 id="2-5-undo-log的生命周期"><a href="#2-5-undo-log的生命周期" class="headerlink" title="2.5 undo log的生命周期"></a>2.5 undo log的生命周期</h3><h4 id="1-简要生成过程"><a href="#1-简要生成过程" class="headerlink" title="1. 简要生成过程"></a>1. 简要生成过程</h4><p><strong>只有Buffer Pool的流程：</strong>  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126192950145.png" alt="image-20220126192950145"></p><p><strong>有了Redo Log和Undo Log之后：</strong>  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126193014963.png" alt="image-20220126193014963"></p><h4 id="2-详细生成过程"><a href="#2-详细生成过程" class="headerlink" title="2. 详细生成过程"></a>2. 详细生成过程</h4><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126193323589.png" alt="image-20220126193323589"></p><p>当我们执行INSERT时：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span> (name) <span class="keyword">VALUES</span> (&quot;tom&quot;);  </span><br></pre></td></tr></table></figure><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126193345615.png" alt="image-20220126193345615"></p><p><strong>当我们执行UPDATE时：</strong>  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126193356469.png" alt="image-20220126193356469"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">user</span> <span class="keyword">SET</span> id<span class="operator">=</span><span class="number">2</span> <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;  </span><br></pre></td></tr></table></figure><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126193411418.png" alt="image-20220126193411418"></p><h4 id="3-undo-log是如何回滚的"><a href="#3-undo-log是如何回滚的" class="headerlink" title="3. undo log是如何回滚的"></a>3. undo log是如何回滚的</h4><p>以上面的例子来说，假设执行rollback，那么对应的流程应该是这样：</p><ol><li>通过undo no=3的日志把id=2的数据删除</li><li>通过undo no=2的日志把id=1的数据的deletemark还原成0</li><li>通过undo no=1的日志把id=1的数据的name还原成Tom</li><li>通过undo no=0的日志把id=1的数据删除  </li></ol><h4 id="4-undo-log的删除"><a href="#4-undo-log的删除" class="headerlink" title="4. undo log的删除"></a>4. undo log的删除</h4><ul><li>针对于insert undo log</li></ul><p>因为insert操作的记录，只对事务本身可见，对其他事务不可见。故该undo log可以在事务提交后直接删除，不需要进行purge操作。</p><ul><li>针对于update undo log</li></ul><p>该undo log可能需要提供MVCC机制，因此不能在事务提交时就进行删除。提交时放入undo log链表，等待purge线程进行最后的删除。  </p><h3 id="2-6-小结"><a href="#2-6-小结" class="headerlink" title="2.6 小结"></a>2.6 小结</h3><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126193510769.png" alt="image-20220126193510769"></p><p><strong>undo log是逻辑日志</strong>，对事务回滚时，只是将数据库<strong>逻辑地恢复到原来的样子</strong>。<br><strong>redo log是物理日志</strong>，记录的是数据页的物理变化，undo log不是redo log的逆过程。  </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MVCC</title>
      <link href="/2022/01/26/MVCC/"/>
      <url>/2022/01/26/MVCC/</url>
      
        <content type="html"><![CDATA[<h1 id="多版本并发控制-MVCC"><a href="#多版本并发控制-MVCC" class="headerlink" title="多版本并发控制  (MVCC)"></a>多版本并发控制  (MVCC)</h1><h2 id="1-什么是MVCC"><a href="#1-什么是MVCC" class="headerlink" title="1. 什么是MVCC"></a>1. 什么是MVCC</h2><p>MVCC （Multiversion Concurrency Control），多版本并发控制。顾名思义，MVCC 是通过数据行的多个版本管理来实现数据库的 <strong>并发控制</strong> 。这项技术使得在InnoDB的事务隔离级别下执行 <strong>一致性读</strong> 操作有了保证。换言之，就是为了查询一些正在被另一个事务更新的行，并且可以看到它们<strong>被更新之前的值</strong>，这样在做查询的时候就不用等待另一个事务释放锁。  </p><p>MVCC 没有正式的标准，在不同的DBMS中MVCC的实现方式可能是不同的，也不是普遍使用的(大家可以参考相关的DBMS文档)。这里讲解InnoDB中MVcC的实现机制(MySQL其它的存储引擎并不支持它)。</p><h2 id="2-快照读与当前读"><a href="#2-快照读与当前读" class="headerlink" title="2. 快照读与当前读"></a>2. 快照读与当前读</h2><p>MVCC在MySQL InnoDB中的实现主要是为了提高数据库并发性能，用更好的方式去处理 <strong>读-写冲突</strong> ，做到即使有读写冲突时，也能做到 不加锁 ， <strong>非阻塞并发读</strong> ，而这个读指的就是 <strong>快照读</strong> , 而非 <strong>当前读</strong> 。当前读实际上是一种加锁的操作，是悲观锁的实现。而MVCC本质是采用<strong>乐观锁</strong>思想的一种方式。  </p><h3 id="2-1-快照读"><a href="#2-1-快照读" class="headerlink" title="2.1 快照读"></a>2.1 快照读</h3><p><strong>快照读</strong>又叫<strong>一致性读</strong>，读取的是快照数据。不加锁的简单的 SELECT 都属于快照读，即不加锁的非阻塞读；比如这样：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> player <span class="keyword">WHERE</span> ...  </span><br></pre></td></tr></table></figure><p>之所以出现快照读的情况，是基于提高并发性能的考虑，<strong>快照读的实现是基于MVCC</strong>，它在很多情况下，避免了加锁操作，降低了开销。</p><p>既然是基于多版本，那么<strong>快照读可能读到的并不一定是数据的最新版本，而有可能是之前的历史版本。</strong></p><p>快照读的前提是隔离级别不是串行级别，串行级别下的快照读会退化成当前读。  </p><h3 id="2-2-当前读"><a href="#2-2-当前读" class="headerlink" title="2.2 当前读"></a>2.2 当前读</h3><p><strong>当前读</strong>读取的是记录的<strong>最新版本</strong>（最新数据，而不是历史版本的数据），读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。加锁的 SELECT，或者对数据进行增删改都会进行当前读。比如：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student LOCK <span class="keyword">IN</span> SHARE MODE; # 共享锁</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>; # 排他锁</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> student <span class="keyword">values</span> ... # 排他锁</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> ... # 排他锁</span><br><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">SET</span> ... # 排他锁  </span><br></pre></td></tr></table></figure><h2 id="3-复习"><a href="#3-复习" class="headerlink" title="3. 复习"></a>3. 复习</h2><h3 id="3-1-再谈隔离级别"><a href="#3-1-再谈隔离级别" class="headerlink" title="3.1 再谈隔离级别"></a>3.1 再谈隔离级别</h3><p>我们知道事务有 4 个隔离级别，可能存在三种并发问题：  </p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126194428047.png" alt="image-20220126194428047" style="zoom: 40%;" /><p>在MysQL中，<strong>默认的隔离级别是可重复读</strong>，可以解决脏读和不可重复读的问题，如果仅从定义的角度来看，它并不能解决幻读问题。如果我们想要解决幻读问题，就需要采用串行化的方式，也就是将隔离级别提升到最高，但这样一来就会大幅降低数据库的事务并发能力。</p><p>MVCC 可以不采用锁机制，而是<strong>通过乐观锁的方式来解决不可重复读和幻读问题</strong>!它可以在大多数情况下替代行级锁，降低系统的开销。</p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126194642571.png" alt="image-20220126194642571" style="zoom:40%;" /><p>3.2 隐藏字段、Undo Log版本链</p><p>回顾一下undo日志的版本链，对于使用 InnoDB 存储引擎的表来说，它的聚簇索引记录中都包含两个必要的隐藏列。</p><ul><li>trx_id ：每次一个事务对某条聚簇索引记录进行改动时，都会把该事务的 事务id 赋值给trx_id 隐藏列。</li><li>roll_pointer ：每次对某条聚簇索引记录进行改动时，都会把旧的版本写入到 undo日志 中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。  </li></ul><p>假设插入该记录的<strong>事务id为8</strong>，那么此刻该条记录示意图如下所示：</p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126202340372.png" alt="image-20220126202340372" style="zoom:50%;" /><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert undo只在事务回滚时起作用，当事务提交后，该类型的undo日志就没用了，它占用的Undo LogSegment也会被系统回收（也就是该undo日志占用的Undo页面链表要么被重用，要么被释放)</span><br></pre></td></tr></table></figure><p>假设之后两个<strong>事务id分别为10，20</strong>的事务对这条记录进行 UPDATE 操作，操作流程如下：  </p><table><thead><tr><th>发生时间 顺序</th><th>事务10</th><th>事务20</th></tr></thead><tbody><tr><td>1</td><td>BEGIN;</td><td></td></tr><tr><td>2</td><td></td><td>BEGIN;</td></tr><tr><td>3</td><td>UPDATE student SET name=”李四” WHERE id=1;</td><td></td></tr><tr><td>4</td><td>UPDATE student SET name=”王五” WHERE id=1;</td><td></td></tr><tr><td>5</td><td>COMMIT;</td><td></td></tr><tr><td>6</td><td></td><td>UPDATE student SET name=”钱七” WHERE id=1;</td></tr><tr><td>7</td><td></td><td>UPDATE student SET name=”宋八” WHERE id=1;</td></tr><tr><td>8</td><td></td><td>COMMIT;</td></tr></tbody></table><p>每次对记录进行改动，都会记录一条undo日志，每条undo日志也都有一个 <strong>roll_pointer</strong> 属性（ <strong>INSERT</strong> 操作对应的undo日志没有该属性，因为该记录并没有更早的版本），可以将这些 <strong>undo日志</strong>都连起来，串成一个链表：  </p><p><strong>能不能在两个事务中交叉更新同一条记录呢?</strong> 不能!    这不就是一个事务修改了另一个未提交事务修改过的数据，<strong>脏写</strong>。<br>InnoDB<strong>使用锁来保证不会有脏写</strong>情况的发生，也就是在第一个事务更新了某条记录后，就会给这条记录加锁，另一个事务再次更新时就需要等待第一个事务提交了，把锁释放之后才可以继续更新。</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126202751482.png" alt="image-20220126202751482"></p><p>对该记录每次更新后，都会将旧值放到一条 <strong>undo日志</strong> 中，就算是该记录的一个旧版本，随着更新次数的增多，所有的版本都会被 <strong>roll_pointer</strong> 属性连接成一个链表，我们把这个链表称之为 <strong>版本链</strong> ，版本链的<strong>头节点就是当前记录最新的值。</strong></p><p>每个版本中还包含生成该版本时对应的 <strong>事务id</strong> 。  </p><h2 id="4-MVCC实现原理之ReadView"><a href="#4-MVCC实现原理之ReadView" class="headerlink" title="4. MVCC实现原理之ReadView"></a>4. MVCC实现原理之ReadView</h2><p>MVCC 的实现依赖于：<strong>隐藏字段（trx_id ，roll_pointer）、Undo Log、Read View</strong>。  </p><h3 id="4-1-什么是ReadView"><a href="#4-1-什么是ReadView" class="headerlink" title="4.1 什么是ReadView"></a>4.1 什么是ReadView</h3><p>在MVCC机制中，多个事务对同一个行记录进行更新会产生多个历史快照，这些<strong>历史快照</strong>保存在<strong>Undo Log</strong>里。如果一个事务想要查询这个行记录，需要读取哪个版本的行记录呢?这时就需要用到ReadView了，它帮我们解决了行的可见性问题。</p><p>ReadView就是事务A (ReadView和事务是一对一的关系) 在使用MVCC机制进行快照读操作时产生的读视图。当事务启动时，会生成数据库系统当前的一个快照，InnoDB为每个事务构造了一个数组，用来记录并维护系统当前<strong>活跃事务</strong>的ID(<strong>“活跃”指的就是，启动了但还没提交</strong>)。</p><h3 id="4-2-设计思路"><a href="#4-2-设计思路" class="headerlink" title="4.2 设计思路"></a>4.2 设计思路</h3><p>使用 <strong>READ UNCOMMITTED</strong> 隔离级别的事务，由于可以读到未提交事务修改过的记录（<strong>脏读</strong>），所以直接读取记录的最新版本就好了。</p><p>使用 <strong>SERIALIZABLE</strong> 隔离级别的事务，InnoDB规定使用<strong>加锁</strong>的方式来访问记录。</p><p>使用 <strong>READ COMMITTED</strong> 和 <strong>REPEATABLE READ</strong> 隔离级别的事务，都必须保证读到 <strong>已经提交了的</strong> 事务修改过的记录。假如另一个事务已经修改了记录但是尚未提交，是不能直接读取最新版本的记录的，核心问题就是<strong>需要判断一下版本链中的哪个版本是当前事务可见的</strong>，这是ReadView要解决的主要问题。</p><p>这个ReadView中主要包含<strong>4个比较重要的内容</strong>，分别如下：</p><ol><li><strong>creator_trx_id</strong> ，创建这个 Read View 的事务 ID。  </li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">说明：只有在对表中的记录做改动时（执行INSERT、DELETE、UPDATE这些语句时）才会为事务分配事务id，否则在一个只读事务中的事务id值都默认为0。  </span><br></pre></td></tr></table></figure><ol start="2"><li><p><strong>trx_ids</strong> ，表示在生成ReadView时当前系统中活跃的读写事务的 <strong>事务id列表</strong> 。  <strong>“活跃”指的就是，启动了但还没提交 !!!</strong></p></li><li><p><strong>up_limit_id</strong> ，活跃的事务中最小的事务 ID。  </p></li><li><p><strong>low_limit_id</strong> ，表示生成ReadView时系统中<strong>应该分配给下一个事务的 id 值</strong>。low_limit_id 是系统最大的事务id值，这里要注意是系统中的事务id，需要区别于正在活跃的事务ID。  </p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意：low_limit_id并不是trx_ids中的最大值，事务id是递增分配的。比如，现在有id为1，2，3这三个事务，之后id为3的事务提交了。那么一个新的读事务在生成ReadView时，trx_ids就包括1和2，up_limit_id的值就是1，low_limit_id的值就是4。  </span><br></pre></td></tr></table></figure><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126204438809.png" alt="image-20220126204438809" style="zoom:70%;" /><h3 id="4-3-ReadView的规则"><a href="#4-3-ReadView的规则" class="headerlink" title="4.3 ReadView的规则"></a>4.3 ReadView的规则</h3><ul><li><p>有了这个ReadView，这样在访问某条记录时，只需要按照下边的步骤判断记录的某个版本是否可见。</p></li><li><p>如果被访问版本的trx_id属性值与ReadView中的 <strong>creator_trx_id</strong> 值相同，意味着当前事务在访问它自己修改过的记录，所以该版本可以被当前事务访问。</p></li><li><p>如果被访问版本的trx_id属性值小于ReadView中的 <strong>up_limit_id</strong> 值，表明生成该版本的事务在当前事务生成ReadView前已经提交，所以该版本可以被当前事务访问。</p></li><li><p>如果被访问版本的trx_id属性值大于或等于ReadView中的 <strong>low_limit_id</strong> 值，表明生成该版本的事务在当前事务生成ReadView后才开启，所以该版本不可以被当前事务访问。</p></li><li><p>如果被访问版本的trx_id属性值在ReadView的 <strong>up_limit_id 和 low_limit_id 之间</strong>，那就需要判断一下trx_id属性值<strong>是不是在 trx_ids 列表中。</strong></p><ul><li><p>如果<strong>在</strong>，说明创建ReadView时生成该版本的<strong>事务还是活跃的，该版本不可以被访问</strong>。</p></li><li><p>如果不在，说明创建ReadView时生成该版本的事务已经被提交，该版本可以被访问。  </p></li></ul></li></ul><h3 id="4-4-MVCC整体操作流程"><a href="#4-4-MVCC整体操作流程" class="headerlink" title="4.4 MVCC整体操作流程"></a>4.4 MVCC整体操作流程</h3><p>了解了这些概念之后，我们来看下当查询一条记录的时候，系统如何通过MVCC找到它：</p><ol><li>首先获取事务自己的版本号，也就是事务 ID；</li><li>获取 ReadView；</li><li>查询得到的数据，然后与 ReadView 中的事务版本号进行比较；</li><li>如果不符合 ReadView 规则，就需要从 Undo Log 中获取历史快照；</li><li>最后返回符合规则的数据。</li></ol><p>在隔离级别为读已提交（Read Committed）时，一个事务中的每一次 SELECT 查询都会重新获取一次Read View。</p><p>如表所示：  </p><table><thead><tr><th>事务</th><th>说明</th></tr></thead><tbody><tr><td>begin;</td><td></td></tr><tr><td>select * from student where id &gt;2;</td><td>获取一次Read View</td></tr><tr><td>………</td><td></td></tr><tr><td>select * from student where id &gt;2;</td><td>获取一次Read View</td></tr><tr><td>commit;</td><td></td></tr></tbody></table><p>注意，此时同样的查询语句都会重新获取一次 Read View，这时如果 Read View 不同，就可能产生不可重复读或者幻读的情况。</p><p>当隔离级别为可重复读的时候，就避免了不可重复读，这是因为一个事务只在第一次 SELECT 的时候会获取一次 Read View，而后面所有的 SELECT 都会复用这个 Read View，如下表所示：  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126211628720.png" alt="image-20220126211628720"></p><h2 id="5-举例说明"><a href="#5-举例说明" class="headerlink" title="5. 举例说明"></a>5. 举例说明</h2><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126205017653.png" alt="image-20220126205017653" style="zoom:80%;" /><h3 id="5-1-READ-COMMITTED隔离级别下"><a href="#5-1-READ-COMMITTED隔离级别下" class="headerlink" title="5.1 READ COMMITTED隔离级别下"></a>5.1 READ COMMITTED隔离级别下</h3><p><strong>READ COMMITTED ：每次读取数据前都生成一个ReadView。</strong></p><p>现在有两个 事务id 分别为 <strong>10 、 20</strong> 的事务在执行：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Transaction <span class="number">10</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">SET</span> name<span class="operator">=</span>&quot;李四&quot; <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">SET</span> name<span class="operator">=</span>&quot;王五&quot; <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"># Transaction <span class="number">20</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"># 更新了一些别的表的记录</span><br><span class="line">...  </span><br></pre></td></tr></table></figure><p>此刻，表student 中 id 为 1 的记录得到的版本链表如下所示：  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126205759475.png" alt="image-20220126205759475"></p><p>假设现在有一个使用 <strong>READ COMMITTED</strong> 隔离级别的事务开始执行：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 使用READ COMMITTED隔离级别的事务</span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"># SELECT1：Transaction <span class="number">10</span>、<span class="number">20</span>未提交</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>; # 得到的列name的值为<span class="string">&#x27;张三&#x27;</span>  </span><br></pre></td></tr></table></figure><p>这个<strong>SELECT1</strong>的执行过程如下:</p><ul><li>步骤1∶在执行SELECT语句时会先生成一个<strong>ReadView</strong> ,ReadView的<strong>trx_ids</strong>列表的内容就是**[10，20]**，up_limit_id为10,    low_limit_id为21,   creator_trx_id为0。</li><li>步骤2:从版本链中挑选可见的记录，从图中看出，最新版本的列name的内容是’王五’，该版本的trx_id值为<strong>10</strong>，在<strong>trx_ids</strong>列表内，所以不符合可见性要求(<strong>trx_ids</strong>列表内为未提交的)，根据roll_pointer跳到下一个版本。</li><li>步骤3:下一个版本的列name的内容是’李四’，该版本的trx_id值也为10，<strong>也在trx_ids列表内</strong>，所以也不符合要求，继续跳到下一个版本。</li><li>步骤4∶下一个版本的列name的内容是’张三’，该版本的trx_id值为8，小于ReadView中的up_limit_id值10，所以这个版本是符合要求的，最后返回给用户的版本就是这条列name为‘张三’的记录。</li></ul><p>之后，我们把 事务id 为 <strong>10</strong> 的事务提交一下：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Transaction <span class="number">10</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">SET</span> name<span class="operator">=</span>&quot;李四&quot; <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">SET</span> name<span class="operator">=</span>&quot;王五&quot; <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;  </span><br></pre></td></tr></table></figure><p>然后再到 事务id 为 <strong>20</strong> 的事务中更新一下表 student 中 id 为 1 的记录：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Transaction <span class="number">20</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"># 更新了一些别的表的记录</span><br><span class="line">...</span><br><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">SET</span> name<span class="operator">=</span>&quot;钱七&quot; <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">SET</span> name<span class="operator">=</span>&quot;宋八&quot; <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;  </span><br></pre></td></tr></table></figure><p>此刻，表student中 id 为 1 的记录的版本链就长这样：  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126212223762.png" alt="image-20220126212223762"></p><p>然后再到刚才使用 READ COMMITTED 隔离级别的事务中继续查找这个 id 为 1 的记录，如下  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 使用READ COMMITTED隔离级别的事务</span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"># SELECT1：Transaction <span class="number">10</span>、<span class="number">20</span>均未提交</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>; # 得到的列name的值为<span class="string">&#x27;张三&#x27;</span></span><br><span class="line"># SELECT2：Transaction <span class="number">10</span>提交，Transaction <span class="number">20</span>未提交</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>; # 得到的列name的值为<span class="string">&#x27;王五&#x27;</span>  </span><br></pre></td></tr></table></figure><p>这个<strong>SELECT2</strong>的执行过程如下:</p><ul><li>步骤1:在执行SELECT语句时会又会<strong>单独生成一个ReadView</strong>，该ReadView的trx_ids列表的内容就是[20]，up_limit_id为20，low_limit_id为21, creator_trx_id为0。</li><li>步骤2:从版本链中挑选可见的记录，从图中看出，最新版本的列name 的内容是’宋八’，该版本的trx_id值为20，在trx_ids列表内，所以不符合可见性要求，根据roll_pointer跳到下一个版本。</li><li>步骤3:下一个版本的列name的内容是’钱七’，该版本的trx_id值为20，也在trx_ids列表内，所以也不符合要求，继续跳到下一个版本。</li><li>步骤4:下一个版本的列name的内容是’王五’，该版本的trx_id值为<strong>10</strong>，小于ReadView中的up_limit_id值20，所以这个版本是符合要求的，最后返回给用户的版本就是这条列name为’王五’的记录。</li><li>以此类推，如果之后事务id为20的记录也提交了，再次在使用READ COMMITTED隔离级别的事务中查询表student中id值为1的记录时，得到的结果就是‘宋八’了，具体流程我们就不分析了。</li></ul><p><strong>强调</strong>:    使用READ COMMITTED隔离级别的事务在每次查询开始时都会生成一个独立的ReadView。</p><h3 id="5-2-REPEATABLE-READ隔离级别下"><a href="#5-2-REPEATABLE-READ隔离级别下" class="headerlink" title="5.2 REPEATABLE READ隔离级别下"></a>5.2 REPEATABLE READ隔离级别下</h3><p>使用 <strong>REPEATABLE READ</strong> 隔离级别的事务来说，<strong>只会在第一次执行查询语句时生成一个 ReadView</strong> ，之后的查询就不会重复生成了。</p><p>比如，系统里有两个 事务id 分别为 10 、 20 的事务在执行：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Transaction <span class="number">10</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">SET</span> name<span class="operator">=</span>&quot;李四&quot; <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">SET</span> name<span class="operator">=</span>&quot;王五&quot; <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"># Transaction <span class="number">20</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"># 更新了一些别的表的记录</span><br><span class="line">...  </span><br></pre></td></tr></table></figure><p>此刻，表student 中 id 为 1 的记录得到的版本链表如下所示：  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126213111591.png" alt="image-20220126213111591"></p><p>假设现在有一个使用 REPEATABLE READ 隔离级别的事务开始执行：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 使用REPEATABLE READ隔离级别的事务</span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"># SELECT1：Transaction <span class="number">10</span>、<span class="number">20</span>未提交</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>; # 得到的列name的值为<span class="string">&#x27;张三&#x27;</span>  </span><br></pre></td></tr></table></figure><p>这个<strong>SELECT1</strong>的执行过程如下：</p><ul><li>步骤1∶在执行SELECT语句时会先生成一个ReadView ,ReadView的trx_ids列表的内容就是[10,20]，up_limit_id为10, low_limit_id为21, creator_trx_id为0。</li><li>步骤2:然后从版本链中挑选可见的记录，从图中看出，最新版本的列 name的内容是’王五’，该版本的trx_id值为10，在trx_ids列表内，所以不符合可见性要求，根 据roll_pointer跳到下一个版本。</li><li>步骤3:下一个版本的列name的内容是’李四’，该版本的trx_id值也为10，也在trx_ids列表内列内是符合要求，继续跳到下一个版本。</li><li>步骤4:下一个版本的列name的内容是‘张三’，该版本的trx_id值为8，小于ReadView中的up_limit_id值10，所以这个版本是符合要求的，最后返回给用户的版本就是这条列name为’张三’的记录。</li></ul><p>之后，我们把事务id为<strong>10</strong>的事务提交一下，就像这样:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Transaction <span class="number">10</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">SET</span> name<span class="operator">=</span>&quot;李四&quot; <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">SET</span> name<span class="operator">=</span>&quot;王五&quot; <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;  </span><br></pre></td></tr></table></figure><p>然后再到 事务id 为 20 的事务中更新一下表 student 中 id 为 1 的记录：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Transaction <span class="number">20</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"># 更新了一些别的表的记录</span><br><span class="line">...</span><br><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">SET</span> name<span class="operator">=</span>&quot;钱七&quot; <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">SET</span> name<span class="operator">=</span>&quot;宋八&quot; <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>此刻，表student 中 id 为 1 的记录的版本链长这样：  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126213955053.png" alt="image-20220126213955053"></p><p>然后再到刚才使用 REPEATABLE READ 隔离级别的事务中继续查找这个 id 为 1 的记录，如下：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 使用REPEATABLE READ隔离级别的事务</span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"># SELECT1：Transaction <span class="number">10</span>、<span class="number">20</span>均未提交</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>; # 得到的列name的值为<span class="string">&#x27;张三&#x27;</span></span><br><span class="line"># SELECT2：Transaction <span class="number">10</span>提交，Transaction <span class="number">20</span>未提交</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>; # 得到的列name的值仍为<span class="string">&#x27;张三&#x27;</span>  </span><br></pre></td></tr></table></figure><p>SELECT2的执行过程如下:</p><ul><li>步骤1∶因为当前事务的隔离级别为<strong>REPEATABLE READ</strong>，而之前在执行SELECT1时<strong>已经生成过ReadView了</strong>，所以此时直接<strong>复用之前的ReadView</strong>，之前的ReadView的trx_ids列表的内容就是[10, 20]，up_limit_id为10,low_limit_id为21, creator_trx_id为0。</li><li>步骤2∶然后从版本链中挑选可见的记录，从图中可以看出，最新版本的列name的内容是’宋八’，该版本的trx_id值为20，在trx_ids列表内，所以不符合可见性要求，根据roll_pointer跳到下一个版本。步骤3:下一个版本的列name的内容是’钱七’，该版本的trx_id值为20，也在trx_ids列表内,所以也不符合要求，继续跳到下一个版本。</li><li>步骤4:下一个版本的列 name的内容是’王五’，该版本的trx_id值为10，而trx_ids列表中是包含值为10的事务id的，所以该版本也不符合要求，同理下一个列name的内容是’‘李四’的版本也不符合要求继续跳到下一个版本。</li><li>步骤5∶下一个版本的列 name的内容是‘张三’，该版本的trx_id值为80，小于ReadView中的up_limit_id值10，所以这个版本是符合要求的，最后返回给用户的版本就是这条列c为’张三’的记录。</li></ul><p><strong>实现重复读：</strong>    <strong>两次SELECT</strong>查询得到的结果是<strong>重复的</strong>，记录的列c值都是‘张三’，这就是<strong>可重复读的含义</strong>。如果我们之后再把事务id为20的记录提交了，然后再到刚才使用<strong>REPEATABLE READ</strong>隔离级别的事务中继续查找这个id为1的记录，得到的结果还是‘张三’，具体执行过程大家可以自己分析一下。</p><h3 id="5-3-如何解决幻读"><a href="#5-3-如何解决幻读" class="headerlink" title="5.3 如何解决幻读"></a>5.3 如何解决幻读</h3><p><strong>幻读</strong>：对于两个事务Session A、Session B, Session A 从一个表中 <strong>读取</strong> 了一个字段, 然后 Session B 在该表中 <strong>插入</strong> 了一些新的行。 之后, 如果 Session A 再次读取 <strong>同一个表</strong>, 就会<strong>多出几行</strong>。那就意味着发生了幻读。</p><p>接下来说明InnoDB 是如何解决幻读的（在<strong>REPEATABLE READ隔离级别</strong>下实现）。</p><p>假设现在表 student 中只有一条数据，数据内容中，主键 id=1，隐藏的 trx_id=10，它的 undo log 如下图所示。  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126214744710.png" alt="image-20220126214744710"></p><p>假设现在有事务 A 和事务 B 并发执行， <strong>事务 A</strong> 的事务 id 为 <strong>20</strong> ， <strong>事务 B</strong> 的事务 id 为 <strong>30</strong> 。</p><p>步骤1：事务 A 开始第一次查询数据，查询的 SQL 语句如下。  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student <span class="keyword">where</span> id <span class="operator">&gt;=</span> <span class="number">1</span>;  </span><br></pre></td></tr></table></figure><p>在开始查询之前，MySQL 会为事务 A 产生一个 ReadView，此时 ReadView 的内容如下： <strong>trx_ids=[20,30] ， up_limit_id=20 ， low_limit_id=31 ， creator_trx_id=20</strong> 。</p><p>由于此时表 student 中只有一条数据，且符合 where id&gt;=1 条件，因此会查询出来。然后根据 ReadView机制，发现该行数据的trx_id=10，小于事务 A 的 ReadView 里 up_limit_id，这表示这条数据是事务 A 开启之前，其他事务就已经提交了的数据，因此事务 A 可以读取到。</p><p>结论：事务 A 的第一次查询，能读取到一条数据，id=1。</p><p>步骤2：接着<strong>事务 B(trx_id=30)<strong>，往表 student 中</strong>新插入两条数据</strong>，<strong>并提交事务。</strong>  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student(id,name) <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">&#x27;李四&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student(id,name) <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">&#x27;王五&#x27;</span>);  </span><br></pre></td></tr></table></figure><p>此时表student 中就有三条数据了，对应的 undo 如下图所示：  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126215023440.png" alt="image-20220126215023440"></p><p>步骤3：接着事务 A 开启第二次查询，根据可重复读隔离级别的规则，此时<strong>事务 A 并不会再重新生成ReadView</strong>。此时表 student 中的 3 条数据都满足 where id&gt;=1 的条件，因此会先查出来。然后根据ReadView 机制，<strong>判断每条数据是不是都可以被事务 A 看到</strong>。</p><p>1）首先 id=1 的这条数据，前面已经说过了，可以被事务 A 看到。</p><p>2）然后是 id=2 的数据，它的 trx_id=30，此时事务 A 发现，这个值处于 up_limit_id 和 low_limit_id 之间，因此还需要再判断 30 是否处于 trx_ids 数组内。由于事务 A 的 **trx_ids=[20,30]**，因此在数组内，这表示 id=2 的这条数据是与事务 A 在同一时刻启动的其他事务提交的，所以这条数据不能让事务 A 看到。</p><p>3）同理，id=3 的这条数据，trx_id 也为 30，因此也不能被事务 A 看见。  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126215044078.png" alt="image-20220126215044078"></p><p><strong>结论</strong>：最终事务 A 的第二次查询，只能查询出 id=1 的这条数据。这和事务 A 的第一次查询的结果是一样的，因此没有出现幻读现象，所以说<strong>在 MySQL 的可重复读隔离级别下，不存在幻读问题</strong>。  </p><h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h2><p>这里介绍了 MVCC 在 READ COMMITTD 、 REPEATABLE READ 这两种隔离级别的事务在执行快照读操作时访问记录的版本链的过程。这样使不同事务的 读-写 、 写-读 操作并发执行，从而提升系统性能。</p><p>核心点在于 ReadView 的原理， READ COMMITTD 、 REPEATABLE READ 这两个隔离级别的一个很大不同就是<strong>生成ReadView的时机不同</strong>：</p><ul><li>READ COMMITTD 在<strong>每一次进行普通SELECT操作前都会生成一个ReadView</strong></li><li>REPEATABLE READ <strong>只在第一次进行普通SELECT操作前生成一个ReadView</strong>，<strong>之后</strong>的查询操作<strong>都重复使用这个ReadView</strong>就好了。  </li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">说明:我们之前说执行DELETE语句或者更新主键的UPDATE语句并不会立即把对应的记录完全从页面中删除,而是执行一个所谓的delete mark操作，相当于只是对记录打上了一个删除标志位，这主要就是为MVCC服务的。</span><br></pre></td></tr></table></figure><p><strong>通过MVCC 我们可以解决:</strong></p><p>1.<strong>读写之间阻塞的问题</strong>。通过MVCC可以让读写互相不阻塞，即读不阻塞写，写不阻塞读，这样就可以提升事务并发处理能力。</p><p>2.<strong>降低了死锁的概率</strong>。这是因为MCC采用了乐观锁的方式，读取数据时并不需要加锁，对于写操作，也只锁定必要的行。</p><p>3.<strong>解决快照读的问题</strong>。当我们查询数据库在某个时间点的快照时，只能看到这个时间点之前事务提交更新的结果，而不能看到这个时间点之后事务提交的更新结果。</p>]]></content>
      
      
      <categories>
          
          <category> database </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL数据类型</title>
      <link href="/2022/01/26/MySQL%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2022/01/26/MySQL%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL数据类型精讲"><a href="#MySQL数据类型精讲" class="headerlink" title="MySQL数据类型精讲"></a>MySQL数据类型精讲</h1><h2 id="1-MySQL中的数据类型"><a href="#1-MySQL中的数据类型" class="headerlink" title="1. MySQL中的数据类型"></a>1. MySQL中的数据类型</h2><table><thead><tr><th>类型</th><th>类型举例</th></tr></thead><tbody><tr><td>整数类型</td><td>TINYINT、SMALLINT、MEDIUMINT、INT(或INTEGER)、BIGINT</td></tr><tr><td>浮点类型</td><td>FLOAT、DOUBLE</td></tr><tr><td>定点数类型</td><td>DECIMAL</td></tr><tr><td>位类型</td><td>BIT</td></tr><tr><td>日期时间类型</td><td>YEAR、TIME、DATE、DATETIME、TIMESTAMP</td></tr><tr><td>文本字符串类型</td><td>CHAR、VARCHAR、TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT</td></tr><tr><td>枚举类型</td><td>ENUM</td></tr><tr><td>集合类型</td><td>SET</td></tr><tr><td>二进制字符串类 型</td><td>BINARY、VARBINARY、TINYBLOB、BLOB、MEDIUMBLOB、LONGBLOB</td></tr><tr><td>JSON类型</td><td>JSON对象、JSON数组</td></tr><tr><td>空间数据类型</td><td>单值类型：GEOMETRY、POINT、LINESTRING、POLYGON； 集合类型：MULTIPOINT、MULTILINESTRING、MULTIPOLYGON、 GEOMETRYCOLLECTION</td></tr></tbody></table><p>常见数据类型的属性，如下：  </p><table><thead><tr><th>MySQL关键字</th><th>含义</th></tr></thead><tbody><tr><td>NULL</td><td>数据列可包含NULL值</td></tr><tr><td>NOT NULL</td><td>数据列不允许包含NULL值</td></tr><tr><td>DEFAULT</td><td>默认值</td></tr><tr><td>PRIMARY KEY</td><td>主键</td></tr><tr><td>AUTO_INCREMENT</td><td>自动递增，适用于整数类型</td></tr><tr><td>UNSIGNED</td><td>无符号</td></tr><tr><td>CHARACTER SET name</td><td>指定一个字符集</td></tr></tbody></table><h2 id="2-整数类型"><a href="#2-整数类型" class="headerlink" title="2.整数类型"></a>2.整数类型</h2><h3 id="2-1-类型介绍"><a href="#2-1-类型介绍" class="headerlink" title="2.1 类型介绍"></a>2.1 类型介绍</h3><p>整数类型一共有 5 种，包括 TINYINT、SMALLINT、MEDIUMINT、INT（INTEGER）和 BIGINT。它们的区别如下表所示：  </p><table><thead><tr><th>整数类型</th><th>字节</th><th>有符号数取值范围</th><th>无符号数取值范围</th></tr></thead><tbody><tr><td>TINYINT</td><td>1</td><td>-128~127 （1byte=8bit 共2^8个）</td><td>0~255</td></tr><tr><td>SMALLINT</td><td>2</td><td>-32768~32767</td><td>0~65535</td></tr><tr><td>MEDIUMINT</td><td>3</td><td>-8388608~8388607</td><td>0~16777215</td></tr><tr><td>INT、INTEGER</td><td>4</td><td>-2147483648~2147483647</td><td>0~4294967295</td></tr><tr><td>BIGINT</td><td>8</td><td>-9223372036854775808~9223372036854775807</td><td>0~18446744073709551615</td></tr></tbody></table><p><strong>超出范围会报错</strong>：<code>Out of range value for column &#39;f1&#39; at row 1</code></p><h3 id="2-2-可选属性"><a href="#2-2-可选属性" class="headerlink" title="2.2 可选属性"></a>2.2 可选属性</h3><p><strong>整数类型的可选属性有三个：</strong>  </p><h4 id="2-2-1-M"><a href="#2-2-1-M" class="headerlink" title="2.2.1 M"></a>2.2.1 M</h4><p>M : 表示<strong>显示宽度</strong>，M的取值范围是(0, 255)。例如，int(5)：当数据宽度小于5位的时候在数字前面需要用字符填满宽度。该项功能需要配合“ <strong>ZEROFILL</strong> ”使用，<strong>表示用“0”填满宽度</strong>，否则指定显示宽度无效。例如: TINYINT有符号数取值范围为 -128 ~ 127，TINYINT的默认显示宽度M=4，因为符号占1位，数字占3位。</p><p>如果设置了显示宽度，那么插入的数据宽度超过显示宽度限制，会不会截断或插入失败？</p><p>答案：不会对插入的数据有任何影响，还是按照类型的实际宽度进行保存，<strong>只要不超过该类型的范围</strong>，即 <strong>显示宽度与类型可以存储的值范围无关</strong> 。<strong>从MySQL 8.0.17开始，整数数据类型不推荐使用显示宽度属性。</strong></p><p>整型数据类型可以在定义表结构时指定所需要的显示宽度，如果不指定，则系统为每一种类型指定默认的宽度值。</p><p>举例：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test_int1 ( x TINYINT, y <span class="type">SMALLINT</span>, z MEDIUMINT, m <span class="type">INT</span>, n <span class="type">BIGINT</span> );  </span><br></pre></td></tr></table></figure><p>查看表结构 （MySQL5.7中显式如下，MySQL8中不再显式范围）  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126110751054.png" alt="image-20220126110751054"></p><h4 id="2-2-2-UNSIGNED"><a href="#2-2-2-UNSIGNED" class="headerlink" title="2.2.2 UNSIGNED"></a>2.2.2 UNSIGNED</h4><p>UNSIGNED : 无符号类型（非负），所有的整数类型都有一个可选的属性UNSIGNED（无符号属性），无符号整数类型的最小取值为0。所以，如果需要在MySQL数据库中保存非负整数值时，可以将整数类型设置为无符号类型。</p><p>int类型默认显示宽度为int(11)，无符号int类型默认显示宽度为int(10)。  </p><h4 id="2-2-3-ZEROFILL"><a href="#2-2-3-ZEROFILL" class="headerlink" title="2.2.3 ZEROFILL"></a>2.2.3 ZEROFILL</h4><p>ZEROFILL : 0填充,（如果某列是ZEROFILL，那么MySQL会自动为当前列添加UNSIGNED属性），如果指定了ZEROFILL只是表示不够M位时，用0在左边填充，如果超过M位，只要不超过数据存储范围即可。</p><p>原来，在 int(M) 中，<strong>M 的值跟 int(M) 所占多少存储空间并无任何关系</strong>。 int(3)、int(4)、int(8) 在磁盘上<strong>都是占用 4 byte</strong> 的存储空间。也就是说，<strong>int(M)，必须和UNSIGNED ZEROFILL一起使用才有意义</strong>。如果整数值超过M位，就<strong>按照实际位数存储</strong>。只是无须再用字符 0 进行填充。  </p><h3 id="2-3-适用场景"><a href="#2-3-适用场景" class="headerlink" title="2.3 适用场景"></a>2.3 适用场景</h3><ul><li><strong>TINYINT</strong> ：一般用于枚举数据，比如系统设定取值范围很小且固定的场景。</li><li><strong>SMALLINT</strong> ：可以用于较小范围的统计数据，比如统计工厂的固定资产库存数量等。</li><li><strong>MEDIUMINT</strong> ：用于较大整数的计算，比如车站每日的客流量等。</li><li><strong>INT（INTEGER）</strong> ：取值范围足够大，一般情况下不用考虑超限问题，用得最多。比如商品编号。</li><li><strong>BIGINT</strong> ：只有当你处理特别巨大的整数时才会用到。比如双十一的交易量、大型门户网站点击量、证券公司衍生产品持仓等。  </li></ul><h3 id="2-4-如何选择？"><a href="#2-4-如何选择？" class="headerlink" title="2.4 如何选择？"></a>2.4 如何选择？</h3><p>在评估用哪种整数类型的时候，你需要考虑 存储空间 和 可靠性 的平衡问题：一方 面，用占用字节数少的整数类型可以节省存储空间；另一方面，要是为了节省存储空间， 使用的整数类型取值范围太小，一旦遇到超出取值范围的情况，就可能引起 系统错误 ，影响可靠性。</p><p>举个例子，商品编号采用的数据类型是 INT。原因就在于，客户门店中流通的商品种类较多，而且，每天都有旧商品下架，新商品上架，这样不断迭代，日积月累。</p><p>如果使用 SMALLINT 类型，虽然占用字节数比 INT 类型的整数少，但是却不能保证数据不会超出范围65535。相反，使用 INT，就能确保有足够大的取值范围，不用担心数据超出范围影响可靠性的问题。你要注意的是，在实际工作中，<strong>系统故障产生的成本远远超过增加几个字段存储空间所产生的成本。</strong>因此，我建议你首先确保数据不会超过取值范围，在这个前提之下，再去考虑如何节省存储空间。  </p><h2 id="3-浮点类型"><a href="#3-浮点类型" class="headerlink" title="3.浮点类型"></a>3.浮点类型</h2><h3 id="3-1-类型介绍"><a href="#3-1-类型介绍" class="headerlink" title="3.1 类型介绍"></a>3.1 类型介绍</h3><p>浮点数和定点数类型的特点是可以 <strong>处理小数</strong> ，你可以把整数看成小数的一个特例。因此，浮点数和定点数的使用场景，比整数大多了。 MySQL支持的浮点数类型，分别是 FLOAT、DOUBLE、REAL。</p><ul><li>FLOAT 表示单精度浮点数；</li><li>DOUBLE 表示双精度浮点数；  </li></ul><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126111542104.png" alt="image-20220126111542104"></p><p>REAL默认就是 DOUBLE。如果你把 SQL 模式设定为启用“ <strong>REAL_AS_FLOAT</strong> ”，那 么，MySQL 就认为REAL 是 FLOAT。如果要启用“REAL_AS_FLOAT”，可以通过以下 SQL 语句实现：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> sql_mode <span class="operator">=</span> “REAL_AS_FLOAT”;  </span><br></pre></td></tr></table></figure><p><strong>问题1</strong>：FLOAT 和 DOUBLE 这两种数据类型的区别是啥呢？  </p><p>FLOAT 占用字节数少，取值范围小；DOUBLE 占用字节数多，取值范围也大。  </p><p><strong>问题2</strong>：为什么浮点数类型的无符号数取值范围，只相当于有符号数取值范围的一半，也就是<strong>只相当于有符号数取值范围大于等于零的部分</strong>呢？  有符号数取值范围大于等于零的部分呢？  </p><p>MySQL 存储浮点数的格式为： 符号(S) 、 尾数(M) 和 阶码(E) 。因此，无论有没有符号，MySQL 的浮点数都会存储表示符号的部分。因此， 所谓的无符号数取值范围，其实就是有符号数取值范围大于等于零的部分。  </p><h3 id="3-2-浮点数缺陷"><a href="#3-2-浮点数缺陷" class="headerlink" title="3.2 浮点数缺陷"></a>3.2 浮点数缺陷</h3><p>浮点数类型有个缺陷，就是不精准。下面我来重点解释一下为什么 MySQL 的浮点数不够精准。比如，我们设计一个表，有f1这个字段，插入值分别为0.47,0.44,0.19，我们期待的运行结果是：0.47 + 0.44 + 0.19 =1.1。而使用sum之后查询：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test_double2(f1 <span class="keyword">DOUBLE</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_double2</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="number">0.47</span>),(<span class="number">0.44</span>),(<span class="number">0.19</span>);  </span><br></pre></td></tr></table></figure><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126112530621.png" alt="image-20220126112530621"  /><p>查询结果是 1.0999999999999999。看到了吗？虽然误差很小，但确实有误差。 你也可以尝试把数据类型改成 FLOAT，然后运行求和查询，得到的是， 1.0999999940395355。显然，误差更大了。</p><p>那么，为什么会存在这样的误差呢？问题还是<strong>出在 MySQL 对浮点类型数据的存储方式上</strong>。</p><p>MySQL 用 4 个字节存储 FLOAT 类型数据，用 8 个字节来存储 DOUBLE 类型数据。无论哪个，都是采用二进制的方式来进行存储的。比如 9.625，用二进制来表达，就是 1001.101，或者表达成 1.001101×2^3。如果尾数不是 0 或 5（比如 9.624），你就无法用一个二进制数来精确表达。进而，就只好在取值允许的范围内进行四舍五入。</p><p>在编程中，如果用到浮点数，要特别注意误差问题，因为浮点数是不准确的，所以我们要<strong>避免使用“=”来判断两个数是否相等</strong>。同时，在一些对精确度要求较高的项目中，千万不要使用浮点数，不然会导致结果错误，甚至是造成不可挽回的损失。</p><p>那么，MySQL 有没有精准的数据类型呢？当然有，这就是<strong>定点数类型</strong>： <strong>DECIMAL</strong> 。  </p><h2 id="4-定点数类型"><a href="#4-定点数类型" class="headerlink" title="4. 定点数类型"></a>4. 定点数类型</h2><h3 id="4-1-类型介绍"><a href="#4-1-类型介绍" class="headerlink" title="4.1 类型介绍"></a>4.1 类型介绍</h3><p>MySQL中的定点数类型只有 DECIMAL 一种类型。  </p><table><thead><tr><th>数据类型</th><th>字节数</th><th>含义</th></tr></thead><tbody><tr><td>DECIMAL(M,D),DEC,NUMERIC</td><td>M+2字节</td><td>有效范围由M和D决定</td></tr></tbody></table><p>使用 DECIMAL(M,D) 的方式表示高精度小数。其中，M被称为精度，D被称为标度。<strong>0&lt;=M&lt;=65，0&lt;=D&lt;=30，D&lt;M</strong>。例如，定义DECIMAL（5,2）的类型，表示该列取值范围是-999.99~999.99。</p><p>DECIMAL(M,D)的<strong>最大取值范围与DOUBLE类型一样</strong>，但是有效的数据范围是由M和D决定的。DECIMAL 的存储空间并不是固定的，由精度值M决定，总共占用的存储空间为M+2个字节。也就是说，在一些对精度要求不高的场景下，比起占用同样字节长度的定点数，浮点数表达的数值范围可以更大一些。</p><p>定点数在MySQL内部是以 <strong>字符串</strong> 的形式进行存储，这就<strong>决定了它一定是精准的</strong>。当DECIMAL类型不指定精度和标度时，其默认为DECIMAL(10,0)。当数据的精度超出了定点数类型的精度范围时，则MySQL同样会进行四舍五入处理。  </p><p><strong>浮点数 vs 定点数</strong></p><p>浮点数相对于定点数的优点是在长度一定的情况下，浮点类型取值范围大，但是不精准，适用于需要取值范围大，又可以容忍微小误差的科学计算场景（比如计算化学、分子建模、流体动力学等）</p><p>定点数类型取值范围相对小，但是精准，没有误差，适合于对精度要求极高的场景 （比如涉及金额计算的场景）  </p><h3 id="4-2-开发中经验"><a href="#4-2-开发中经验" class="headerlink" title="4.2 开发中经验"></a>4.2 开发中经验</h3><p>“由于 DECIMAL 数据类型的精准性，在我们的项目中，除了极少数（比如商品编号）用到整数类型外，其他的数值都用的是 <strong>DECIMAL</strong>，原因就是这个项目所处的零售行业，要求精准，一分钱也不能差。 ” ——来自某项目经理  </p><h2 id="5-位类型：BIT"><a href="#5-位类型：BIT" class="headerlink" title="5.位类型：BIT"></a>5.位类型：BIT</h2><table><thead><tr><th>二进制字符串类型</th><th>长度</th><th>长度范围</th><th>占用空间</th></tr></thead><tbody><tr><td>BIT(M)</td><td>M</td><td>1 &lt;= M &lt;= 64</td><td>约为(M + 7)/8个字节</td></tr></tbody></table><p>BIT类型中存储的是二进制值，类似010110。</p><p>BIT类型，如果没有指定(M)，默认是1位。这个1位，表示只能存1位的二进制值。这里(M)是表示二进制的<br>位数，位数最小值为1，最大值为64。  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test_bit1(</span><br><span class="line">f1 BIT,</span><br><span class="line">f2 BIT(<span class="number">5</span>),</span><br><span class="line">f3 BIT(<span class="number">64</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_bit1(f1)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="number">1</span>);</span><br><span class="line">#Data too long <span class="keyword">for</span> <span class="keyword">column</span> <span class="string">&#x27;f1&#x27;</span> <span class="keyword">at</span> <span class="type">row</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_bit1(f1)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_bit1(f2)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="number">23</span>);  </span><br></pre></td></tr></table></figure><p>注意：在向BIT类型的字段中插入数据时，一定要确保插入的数据在BIT类型支持的范围内 。</p><h2 id="6-日期与时间类型"><a href="#6-日期与时间类型" class="headerlink" title="6.日期与时间类型"></a>6.日期与时间类型</h2><p>日期与时间是重要的信息，在我们的系统中，几乎所有的数据表都用得到。原因是客户需要知道数据的时间标签，从而进行数据查询、统计和处理。</p><p>MySQL有多种表示日期和时间的数据类型，不同的版本可能有所差异，MySQL8.0版本支持的日期和时间类型主要有：YEAR类型、TIME类型、DATE类型、DATETIME类型和TIMESTAMP类型。  </p><ul><li><strong>YEAR</strong> 类型通常用来表示年</li><li><strong>DATE</strong> 类型通常用来表示年、月、日</li><li><strong>TIME</strong> 类型通常用来表示时、分、秒</li><li><strong>DATETIME</strong> 类型通常用来表示年、月、日、时、分、秒</li><li><strong>TIMESTAMP</strong> 类型通常用来表示<strong>带时区</strong>的年、月、日、时、分、秒  </li></ul><table><thead><tr><th>类型</th><th>名称</th><th>字节</th><th>日期格式</th><th>最小值</th><th>最大值</th></tr></thead><tbody><tr><td>YEAR</td><td>年</td><td>1</td><td>YYYY或YY</td><td>1901</td><td>2155</td></tr><tr><td>TIME</td><td>时间</td><td>3</td><td>HH:MM:SS</td><td>-838:59:59</td><td>838:59:59</td></tr><tr><td>DATE</td><td>日期</td><td>3</td><td>YYYY-MM-DD</td><td>1000-01-01</td><td>9999-12-03</td></tr><tr><td>DATETIME</td><td>日期 时间</td><td>8</td><td>YYYY-MM-DD HH:MM:SS</td><td>1000-01-01 00:00:00</td><td>9999-12-31 23:59:59</td></tr><tr><td>TIMESTAMP</td><td>日期 时间</td><td>4</td><td>YYYY-MM-DD HH:MM:SS</td><td>1970-01-01 00:00:00 UTC</td><td>2038-01-19 03:14:07UTC</td></tr></tbody></table><p>为什么时间类型 TIME 的取值范围不是 -23:59:59～23:59:59 呢？原因是 MySQL 设计的 TIME 类型，不光表示一天之内的时间，而且可以用来<strong>表示一个时间间隔</strong>，这个时间间隔可以超过 24 小时。  </p><h3 id="6-1-YEAR类型"><a href="#6-1-YEAR类型" class="headerlink" title="6.1 YEAR类型"></a>6.1 YEAR类型</h3><p>YEAR类型用来表示年份，在所有的日期时间类型中所占用的存储空间最小，只需要 <strong>1个字节</strong> 的存储空间。</p><p>在MySQL中，YEAR有以下几种存储格式：</p><ul><li><p>以4位字符串或数字格式表示YEAR类型，其格式为YYYY，<strong>最小值为1901，最大值为2155</strong>。</p></li><li><p>以2位字符串格式表示YEAR类型，最小值为00，最大值为99。</p><ul><li><p>当取值为01到69时，表示2001到2069；</p></li><li><p>当取值为70到99时，表示1970到1999；</p></li><li><p>当取值整数的0或00添加的话，那么是0000年；</p></li><li><p>当取值是日期/字符串的’0’添加的话，是2000年。</p></li></ul></li></ul><p>从MySQL5.5.27开始，<strong>2位格式的YEAR已经不推荐使用。</strong>YEAR默认格式就是“YYYY”，没必要写成YEAR(4)，</p><p>从MySQL 8.0.19开始，<strong>不推荐使用指定显示宽度的YEAR(4)数据类型。</strong>  </p><h3 id="6-2-DATE类型"><a href="#6-2-DATE类型" class="headerlink" title="6.2 DATE类型"></a>6.2 DATE类型</h3><p>DATE类型<strong>表示日期，没有时间部分</strong>，格式为 <strong>YYYY-MM-DD</strong> ，其中，YYYY表示年份，MM表示月份，DD表示日期。需要 <strong>3个字节</strong> 的存储空间。在向DATE类型的字段插入数据时，同样需要满足一定的格式条件。</p><ul><li>以 <strong>YYYY-MM-DD</strong> 格式或者 <strong>YYYYMMDD</strong> 格式表示的字符串日期，其<strong>最小取值为1000-01-01，最大取值为9999-12-03</strong>。YYYYMMDD格式会被转化为YYYY-MM-DD格式。</li><li>以 <strong>YY-MM-DD</strong> 格式或者 <strong>YYMMDD</strong> 格式表示的字符串日期，此格式中，年份为两位数值或字符串满足YEAR类型的格式条件为：当年份取值为00到69时，会被转化为2000到2069；当年份取值为70到99时，会被转化为1970到1999。</li><li>使用 <strong>CURRENT_DATE()</strong> 或者 <strong>NOW()</strong> 函数，会插入当前系统的日期。</li></ul><p><strong>举例</strong> ： </p><p>创建数据表，表中只包含一个DATE类型的字段f1。  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test_date1(</span><br><span class="line">f1 <span class="type">DATE</span></span><br><span class="line">);</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.13</span> sec)  </span><br></pre></td></tr></table></figure><p><strong>插入数据：</strong>  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_date1</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;2020-10-01&#x27;</span>), (<span class="string">&#x27;20201001&#x27;</span>),(<span class="number">20201001</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_date1</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;00-01-01&#x27;</span>), (<span class="string">&#x27;000101&#x27;</span>), (<span class="string">&#x27;69-10-01&#x27;</span>), (<span class="string">&#x27;691001&#x27;</span>), (<span class="string">&#x27;70-01-01&#x27;</span>), (<span class="string">&#x27;700101&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;99-01-01&#x27;</span>), (<span class="string">&#x27;990101&#x27;</span>);  </span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_date1</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">000301</span>), (<span class="number">690301</span>), (<span class="number">700301</span>), (<span class="number">990301</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_date1</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="built_in">CURRENT_DATE</span>()), (NOW());</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> test_date1;  </span><br></pre></td></tr></table></figure><h3 id="6-3-TIME类型"><a href="#6-3-TIME类型" class="headerlink" title="6.3 TIME类型"></a>6.3 TIME类型</h3><p>TIME类型用来表示时间，不包含日期部分。在MySQL中，需要 3个字节 的存储空间来存储TIME类型的数据，可以使用“HH:MM:SS”格式来表示TIME类型，其中，HH表示小时，MM表示分钟，SS表示秒。</p><p>在MySQL中，向TIME类型的字段插入数据时，也可以使用几种不同的格式。 （1）可以使用带有冒号的字符串，比如’ D HH:MM:SS’ 、’ HH:MM:SS ‘、’ HH:MM ‘、’ D HH:MM ‘、’ D HH ‘或’ SS ‘格式，都能被正确地插入TIME类型的字段中。其中D表示天，其最小值为0，最大值为34。如果使用带有D格式的字符串插入TIME类型的字段时，D会被转化为小时，计算格式为D*24+HH。当使用带有冒号并且不带D的字符串表示时间时，表示当天的时间，比如12:10表示12:10:00，而不是00:12:10。 （2）可以使用不带有冒号的字符串或者数字，格式为’ HHMMSS ‘或者 HHMMSS 。如果插入一个不合法的字符串或者数字，MySQL在存储数据时，会将其自动转化为00:00:00进行存储。比如1210，MySQL会将最右边的两位解析成秒，表示00:12:10，而不是12:10:00。 （3）使用 CURRENT_TIME() 或者 NOW() ，会插入当前系统的时间。  </p><h3 id="6-4-DATETIME类型"><a href="#6-4-DATETIME类型" class="headerlink" title="6.4 DATETIME类型"></a>6.4 DATETIME类型</h3><p>DATETIME类型在所有的日期时间类型中占用的存储空间最大，总共需要 <strong>8</strong> 个字节的存储空间。在格式上为DATE类型和TIME类型的组合，可以表示为 <strong>YYYY-MM-DD HH:MM:SS</strong> ，其中YYYY表示年份，MM表示月份，DD表示日期，HH表示小时，MM表示分钟，SS表示秒。</p><p>在向DATETIME类型的字段插入数据时，同样需要满足一定的格式条件。</p><ul><li><p>以 <strong>YYYY-MM-DD HH:MM:SS</strong> 格式或者 <strong>YYYYMMDDHHMMSS</strong> 格式的字符串插入DATETIME类型的字段时，<strong>最小值为1000-01-01 00:00:00，最大值为9999-12-03 23:59:59</strong>。</p><ul><li><p>以YYYYMMDDHHMMSS格式的<strong>数字</strong>插入DATETIME类型的字段时，会被转化为YYYY-MM-DDHH:MM:SS格式。  </p></li><li><p>以 YY-MM-DD HH:MM:SS 格式或者 YYMMDDHHMMSS 格式的<strong>字符串</strong>插入DATETIME类型的字段时，两位数的年份规则符合YEAR类型的规则，00到69表示2000到2069；70到99表示1970到1999。  </p></li></ul></li><li><p>使用函数 <strong>CURRENT_TIMESTAMP()</strong> 和 <strong>NOW()</strong> ，可以向DATETIME类型的字段插入系统的当前日期和时间。  </p></li></ul><p><strong>举例：</strong></p><p>创建数据表，表中包含一个DATETIME类型的字段dt。  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test_datetime1(</span><br><span class="line">dt DATETIME</span><br><span class="line">);</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.02</span> sec)  </span><br></pre></td></tr></table></figure><p>插入数据：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_datetime1</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;2021-01-01 06:50:30&#x27;</span>), (<span class="string">&#x27;20210101065030&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_datetime1</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;99-01-01 00:00:00&#x27;</span>), (<span class="string">&#x27;990101000000&#x27;</span>), (<span class="string">&#x27;20-01-01 00:00:00&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;200101000000&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_datetime1</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">20200101000000</span>), (<span class="number">200101000000</span>), (<span class="number">19990101000000</span>), (<span class="number">990101000000</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_datetime1</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="built_in">CURRENT_TIMESTAMP</span>()), (NOW());  </span><br></pre></td></tr></table></figure><h3 id="6-5-TIMESTAMP类型"><a href="#6-5-TIMESTAMP类型" class="headerlink" title="6.5 TIMESTAMP类型"></a>6.5 TIMESTAMP类型</h3><p>TIMESTAMP类型也可以表示日期时间，其显示格式与DATETIME类型相同，都是 <strong>YYYY-MM-DD HH:MM:SS</strong> ，需要<strong>4个字节</strong>的存储空间。但是TIMESTAMP存储的<strong>时间范围比DATETIME要小很多</strong>，只能存储“<strong>1970-01-01 00:00:01 UTC”到“2038-01-19 03:14:07 UTC</strong>”之间的时间。其中，UTC表示世界统一时间，也叫作世界标准时间。</p><ul><li>存储数据的时候需要对当前时间所在的时区进行转换，查询数据的时候再将时间转换回当前的时区。因此，<strong>使用TIMESTAMP存储的同一个时间值，在不同的时区查询时会显示不同的时间</strong>。</li></ul><p>向TIMESTAMP类型的字段插入数据时，当插入的数据格式满足YY-MM-DD HH:MM:SS和YYMMDDHHMMSS时，两位数值的年份同样符合YEAR类型的规则条件，只不过表示的时间范围要小很多。</p><p>如果向TIMESTAMP类型的字段插入的时间超出了TIMESTAMP类型的范围，则MySQL会抛出错误信息。  </p><p><strong>举例：</strong></p><p>创建数据表，表中包含一个TIMESTAMP类型的字段ts。  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test_timestamp1(</span><br><span class="line">ts <span class="type">TIMESTAMP</span></span><br><span class="line">);  </span><br></pre></td></tr></table></figure><p>插入数据：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_timestamp1</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;1999-01-01 03:04:50&#x27;</span>), (<span class="string">&#x27;19990101030405&#x27;</span>), (<span class="string">&#x27;99-01-01 03:04:05&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;990101030405&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_timestamp1</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;2020@01@01@00@00@00&#x27;</span>), (<span class="string">&#x27;20@01@01@00@00@00&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_timestamp1</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="built_in">CURRENT_TIMESTAMP</span>()), (NOW());</span><br><span class="line">#Incorrect datetime <span class="keyword">value</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_timestamp1</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;2038-01-20 03:14:07&#x27;</span>);  </span><br></pre></td></tr></table></figure><p><strong>TIMESTAMP和DATETIME的区别：</strong></p><ul><li>TIMESTAMP存储空间比较小，表示的日期时间范围也比较小</li><li>底层存储方式不同，TIMESTAMP底层存储的是毫秒值，距离1970-1-1 0:0:0 0毫秒的毫秒值。</li><li>两个日期比较大小或日期计算时，TIMESTAMP更方便、更快。</li><li>TIMESTAMP和时区有关。TIMESTAMP会根据用户的时区不同，显示不同的结果。而DATETIME则只能反映出插入时当地的时区，其他时区的人查看数据必然会有误差的  </li></ul><h3 id="6-6-开发中经验"><a href="#6-6-开发中经验" class="headerlink" title="6.6 开发中经验"></a>6.6 开发中经验</h3><p>用得最多的日期时间类型，就是 <strong>DATETIME</strong> 。虽然 MySQL 也支持 YEAR（年）、 TIME（时间）、DATE（日期），以及 TIMESTAMP 类型，但是在实际项目中，尽量用 DATETIME 类型。因为这个数据类型包括了完整的日期和时间信息，取值范围也最大，使用起来比较方便。毕竟，如果日期时间信息分散在好几个字段，很不容易记，而且查询的时候，SQL 语句也会更加复杂。</p><p>此外，一般存注册时间、商品发布时间等，不建议使用DATETIME存储，而是使用 <strong>时间戳</strong> ，因为DATETIME虽然直观，但不便于计算。</p><h2 id="7-文本字符串类型"><a href="#7-文本字符串类型" class="headerlink" title="7.文本字符串类型"></a>7.文本字符串类型</h2><p>在实际的项目中，我们还经常遇到一种数据，就是字符串数据。<br>MySQL中，文本字符串总体上分为 CHAR 、 VARCHAR 、 TINYTEXT 、 TEXT 、 MEDIUMTEXT 、LONGTEXT 、 ENUM 、 SET 等类型。  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126125947693.png" alt="image-20220126125947693"></p><h3 id="7-1-CHAR与VARCHAR类型"><a href="#7-1-CHAR与VARCHAR类型" class="headerlink" title="7.1 CHAR与VARCHAR类型"></a>7.1 CHAR与VARCHAR类型</h3><p>CHAR和VARCHAR类型都可以存储比较短的字符串。  </p><table><thead><tr><th>字符串(文本)类型</th><th>特点</th><th>长度</th><th>长度范围</th><th>占用的存储空间</th></tr></thead><tbody><tr><td>CHAR(M)</td><td>固定长度</td><td>M</td><td>0 &lt;= M &lt;= 255</td><td>M个字节</td></tr><tr><td>VARCHAR(M)</td><td>可变长度</td><td>M</td><td>0 &lt;= M &lt;= 65535</td><td>(实际长度 + 1) 个字节</td></tr></tbody></table><p><strong>CHAR类型：</strong></p><ul><li>CHAR(M) 类型<strong>一般需要预先定义字符串长度</strong>。如果不指定(M)，则表示长度默认是1个字符。</li><li>如果保存时，数据的实际长度比CHAR类型声明的长度小，则会在 <strong>右侧填充</strong> 空格以达到指定的长度。当MySQL检索CHAR类型的数据时，CHAR类型的字段会去除尾部的空格。</li><li>定义CHAR类型字段时，<strong>声明的字段长度即为CHAR类型字段所占的存储空间的字节数</strong>。  </li></ul><p><strong>VARCHAR类型：</strong></p><ul><li>VARCHAR(M) 定义时， <strong>必须指定长度M，否则报错</strong>。</li><li>MySQL4.0版本以下，varchar(20)：指的是20字节，如果存放UTF8汉字时，只能存6个（每个汉字3字节） ；MySQL5.0版本以上，varchar(20)：指的是20字符。</li><li>检索VARCHAR类型的字段数据时，会保留数据尾部的空格。VARCHAR类型的字段所占用的存储空间为字符串实际长度加1个字节。  </li></ul><p><strong>哪些情况使用 CHAR 或 VARCHAR 更好</strong>  </p><table><thead><tr><th>类型</th><th>特点</th><th>空间上</th><th>时间上</th><th>适用场景</th></tr></thead><tbody><tr><td>CHAR(M)</td><td>固定长度</td><td>浪费存储空间</td><td>效率高</td><td>存储不大，速度要求高</td></tr><tr><td>VARCHAR(M)</td><td>可变长度</td><td>节省存储空间</td><td>效率低</td><td>非CHAR的情况</td></tr></tbody></table><p>情况1：存储很短的信息用char。比如门牌号码101，201……这样很短的信息应该用char，因为varchar还要占个byte用于存储信息长度，本来打算节约存储的，结果得不偿失。  </p><p>情况2：固定长度的用char。比如<strong>使用<code>UUID</code>作为主键，那用char应该更合适</strong>。因为他<strong>固定长度</strong>，varchar动态根据长度的特性就消失了，而且还要占个长度信息。  </p><p>情况3：十分频繁改变的column用char。因为varchar每次存储都要有额外的计算，得到长度等工作，如果一个非常频繁改变的，那就要有很多的精力用于计算，而这些对于char来说是不需要的。</p><p>情况4：具体存储引擎中的情况：</p><ul><li>MyISAM 数据存储引擎和数据列：MyISAM数据表，最好使用固定长度(CHAR)的数据列代替可变长度(VARCHAR)的数据列。这样使得整个表静态化，从而使 数据检索更快 ，用空间换时间。</li><li>MEMORY 存储引擎和数据列：MEMORY数据表目前都使用固定长度的数据行存储，因此无论使用CHAR或VARCHAR列都没有关系，两者都是作为CHAR类型处理的。</li><li><strong>InnoDB 存储引擎，建议使用VARCHAR类型</strong>。因为对于InnoDB数据表，内部的行存储格式并没有区分固定长度和可变长度列（所有数据行都使用指向数据列值的头指针），而且主要影响性能的因素是数据行使用的存储总量，由于char平均占用的空间多于varchar，所以<strong>除了简短并且固定长度的，其他考虑varchar</strong>。这样节省空间，对磁盘I/O和数据存储总量比较好。  </li></ul><h3 id="7-2-TEXT类型"><a href="#7-2-TEXT类型" class="headerlink" title="7.2 TEXT类型"></a>7.2 TEXT类型</h3><p>在MySQL中，TEXT用来保存文本类型的字符串，总共包含4种类型，分别为TINYTEXT、TEXT、MEDIUMTEXT 和 LONGTEXT 类型。</p><p>在向TEXT类型的字段保存和查询数据时，系统自动按照实际长度存储，不需要预先定义长度。这一点和VARCHAR类型相同。</p><p>每种TEXT类型保存的数据长度和所占用的存储空间不同，如下：  </p><table><thead><tr><th>文本字符串类 型</th><th>特点</th><th>长 度</th><th>长度范围</th><th>占用的存储空 间</th></tr></thead><tbody><tr><td>TINYTEXT</td><td>小文本、可变长 度</td><td>L</td><td>0 &lt;= L &lt;= 255</td><td>L + 2 个字节</td></tr><tr><td>TEXT</td><td>文本、可变长度</td><td>L</td><td>0 &lt;= L &lt;= 65535</td><td>L + 2 个字节</td></tr><tr><td>MEDIUMTEXT</td><td>中等文本、可变 长度</td><td>L</td><td>0 &lt;= L &lt;= 16777215</td><td>L + 3 个字节</td></tr><tr><td>LONGTEXT</td><td>大文本、可变长 度</td><td>L</td><td>0 &lt;= L&lt;= 4294967295（相当于 4GB）</td><td>L + 4 个字节</td></tr></tbody></table><p>由于实际存储的长度不确定，<strong>MySQL 不允许 TEXT 类型的字段做主键</strong>。遇到这种情况，你只能采用CHAR(M)，或者 VARCHAR(M)。  </p><p><strong>举例：</strong></p><p>创建数据表：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test_text(</span><br><span class="line">tx TEXT</span><br><span class="line">);  </span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_text</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;atguigu &#x27;</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CHAR_LENGTH</span>(tx)</span><br><span class="line"><span class="keyword">FROM</span> test_text; #<span class="number">10</span>  </span><br></pre></td></tr></table></figure><p>说明在保存和查询数据时，并没有删除TEXT类型的数据尾部的空格。</p><h3 id="开发中经验："><a href="#开发中经验：" class="headerlink" title="开发中经验："></a>开发中经验：</h3><p>TEXT文本类型，可以存比较大的文本段，搜索速度稍慢，因此如果不是特别大的内容，建议使用CHAR，VARCHAR来代替。还有<strong>TEXT类型不用加默认值</strong>，加了也没用。而且text和blob类型的数据删除后容易导致“<strong>空洞”，使得文件碎片比较多</strong>，所以频繁使用的表不建议包含TEXT类型字段，建议单独分出去，单独用一个表。  </p><h2 id="8-ENUM类型"><a href="#8-ENUM类型" class="headerlink" title="8.ENUM类型"></a>8.ENUM类型</h2><p>ENUM类型也叫作枚举类型，ENUM类型的取值范围需要在定义字段时进行指定。设置字段值时，ENUM类型只允许从成员中选取单个值，不能一次选取多个值。</p><p>其所需要的存储空间由定义ENUM类型时指定的成员个数决定。  </p><table><thead><tr><th>文本字符串类型</th><th>长度</th><th>长度范围</th><th>占用的存储空间</th></tr></thead><tbody><tr><td>ENUM</td><td>L</td><td>1 &lt;= L &lt;= 65535</td><td>1或2个字节</td></tr></tbody></table><ul><li>当ENUM类型包含1～255个成员时，需要<strong>1</strong>个字节的存储空间；</li><li>当ENUM类型包含256～65535个成员时，需要<strong>2</strong>个字节的存储空间。</li><li>ENUM类型的成员个数的上限为<strong>65535</strong>个。  </li></ul><p>举例：</p><p>创建表如下：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test_enum(</span><br><span class="line">season ENUM(<span class="string">&#x27;春&#x27;</span>,<span class="string">&#x27;夏&#x27;</span>,<span class="string">&#x27;秋&#x27;</span>,<span class="string">&#x27;冬&#x27;</span>,<span class="string">&#x27;unknow&#x27;</span>)</span><br><span class="line">);  </span><br></pre></td></tr></table></figure><p>添加数据：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_enum</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;春&#x27;</span>),(<span class="string">&#x27;秋&#x27;</span>);</span><br><span class="line"># 忽略大小写</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_enum</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;UNKNOW&#x27;</span>);</span><br><span class="line"># 允许按照角标的方式获取指定索引位置的枚举值</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_enum</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;1&#x27;</span>),(<span class="number">3</span>);</span><br><span class="line"># Data truncated <span class="keyword">for</span> <span class="keyword">column</span> <span class="string">&#x27;season&#x27;</span> <span class="keyword">at</span> <span class="type">row</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_enum</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;ab&#x27;</span>);</span><br><span class="line"># 当ENUM类型的字段没有声明为<span class="keyword">NOT</span> <span class="keyword">NULL</span>时，插入<span class="keyword">NULL</span>也是有效的</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_enum</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="keyword">NULL</span>);  </span><br></pre></td></tr></table></figure><h2 id="9-SET类型"><a href="#9-SET类型" class="headerlink" title="9. SET类型"></a>9. SET类型</h2><p>SET表示一个字符串对象，可以包含0个或多个成员，但成员个数的上限为 64 。设置字段值时，可以取取值范围内的 0 个或多个值。  </p><p>当SET类型包含的成员个数不同时，其所占用的存储空间也是不同的，具体如下 :</p><table><thead><tr><th>成员个数范围（L表示实际成员个数）</th><th>占用的存储空间</th></tr></thead><tbody><tr><td>1 &lt;= L &lt;= 8</td><td>1个字节</td></tr><tr><td>9 &lt;= L &lt;= 16</td><td>2个字节</td></tr><tr><td>17 &lt;= L &lt;= 24</td><td>3个字节</td></tr><tr><td>25 &lt;= L &lt;= 32</td><td>4个字节</td></tr><tr><td>33 &lt;= L &lt;= 64</td><td>8个字节</td></tr></tbody></table><p>SET类型在存储数据时成员个数越多，其占用的存储空间越大。注意：SET类型在选取成员时，可以一次选择多个成员，这一点与ENUM类型不同。</p><p>举例：</p><p>创建表：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test_set(</span><br><span class="line">s <span class="keyword">SET</span> (<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">);  </span><br></pre></td></tr></table></figure><p>向表中插入数据：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_set (s) <span class="keyword">VALUES</span> (<span class="string">&#x27;A&#x27;</span>), (<span class="string">&#x27;A,B&#x27;</span>);</span><br><span class="line">#插入重复的<span class="keyword">SET</span>类型成员时，MySQL会自动删除重复的成员</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_set (s) <span class="keyword">VALUES</span> (<span class="string">&#x27;A,B,C,A&#x27;</span>);</span><br><span class="line">#向<span class="keyword">SET</span>类型的字段插入<span class="keyword">SET</span>成员中不存在的值时，MySQL会抛出错误。</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_set (s) <span class="keyword">VALUES</span> (<span class="string">&#x27;A,B,C,D&#x27;</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> test_set;  </span><br></pre></td></tr></table></figure><p>举例：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> temp_mul(</span><br><span class="line">gender ENUM(<span class="string">&#x27;男&#x27;</span>,<span class="string">&#x27;女&#x27;</span>),</span><br><span class="line">hobby <span class="keyword">SET</span>(<span class="string">&#x27;吃饭&#x27;</span>,<span class="string">&#x27;睡觉&#x27;</span>,<span class="string">&#x27;打豆豆&#x27;</span>,<span class="string">&#x27;写代码&#x27;</span>)</span><br><span class="line">);  </span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> temp_mul <span class="keyword">VALUES</span>(<span class="string">&#x27;男&#x27;</span>,<span class="string">&#x27;睡觉,打豆豆&#x27;</span>); #成功</span><br><span class="line"># Data truncated <span class="keyword">for</span> <span class="keyword">column</span> <span class="string">&#x27;gender&#x27;</span> <span class="keyword">at</span> <span class="type">row</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> temp_mul <span class="keyword">VALUES</span>(<span class="string">&#x27;男,女&#x27;</span>,<span class="string">&#x27;睡觉,写代码&#x27;</span>); #失败</span><br><span class="line"># Data truncated <span class="keyword">for</span> <span class="keyword">column</span> <span class="string">&#x27;gender&#x27;</span> <span class="keyword">at</span> <span class="type">row</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> temp_mul <span class="keyword">VALUES</span>(<span class="string">&#x27;妖&#x27;</span>,<span class="string">&#x27;睡觉,写代码&#x27;</span>);#失败</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> temp_mul <span class="keyword">VALUES</span>(<span class="string">&#x27;男&#x27;</span>,<span class="string">&#x27;睡觉,写代码,吃饭&#x27;</span>); #成功  </span><br></pre></td></tr></table></figure><ol start="10"><li>二进制字符串类型  </li></ol><p>MySQL中的二进制字符串类型主要存储一些二进制数据，比如<strong>可以存储图片、音频和视频等二进制数据</strong>。</p><p>MySQL中支持的二进制字符串类型主要包括BINARY、VARBINARY、TINYBLOB、BLOB、MEDIUMBLOB 和LONGBLOB类型。</p><h3 id="BINARY与VARBINARY类型"><a href="#BINARY与VARBINARY类型" class="headerlink" title="BINARY与VARBINARY类型"></a><strong>BINARY与VARBINARY类型</strong></h3><p>BINARY和VARBINARY类似于CHAR和VARCHAR，只是它们存储的是二进制字符串。</p><p>BINARY (M)为固定长度的二进制字符串，M表示最多能存储的字节数，取值范围是0~255个字符。如果未指定(M)，表示只能存储 <strong>1个字节</strong> 。例如BINARY (8)，表示最多能存储8个字节，如果字段值不足(M)个字节，将在右边填充’\0’以补齐指定长度。</p><p>VARBINARY (M)为可变长度的二进制字符串，M表示最多能存储的字节数，总字节数不能超过行的字节长度限制65535，另外还要考虑额外字节开销，VARBINARY类型的数据除了存储数据本身外，还需要1或2个字节来存储数据的字节数。<strong>VARBINARY类型 必须指定(M) ，否则报错。</strong>  </p><table><thead><tr><th>二进制字符串类型</th><th>特点</th><th>值的长度</th><th>占用空间</th></tr></thead><tbody><tr><td>BINARY(M)</td><td>固定长度</td><td>M （0 &lt;= M &lt;= 255）</td><td>M个字节</td></tr><tr><td>VARBINARY(M)</td><td>可变长度</td><td>M（0 &lt;= M &lt;= 65535）</td><td>M+1个字节</td></tr></tbody></table><h3 id="BLOB类型"><a href="#BLOB类型" class="headerlink" title="BLOB类型"></a>BLOB类型</h3><p>BLOB是一个 <strong>二进制大对象</strong> ，可以容纳可变数量的数据。  </p><p>MySQL中的BLOB类型包括TINYBLOB、BLOB、MEDIUMBLOB和LONGBLOB 4种类型，它们可容纳值的最大长度不同。可以存储一个二进制的大对象，比如 图片 、 音频 和 视频 等。</p><p>需要注意的是，在实际工作中，往往不会在MySQL数据库中使用BLOB类型存储大对象数据，通常会将图片、音频和视频文件存储到 <strong>服务器的磁盘上</strong> ，并将图片、音频和视频的<strong>访问路径存储到MySQL中</strong>。  </p><table><thead><tr><th>二进制字符串类型</th><th>值的长度</th><th>长度范围</th><th>占用空间</th></tr></thead><tbody><tr><td>TINYBLOB</td><td>L</td><td>0 &lt;= L &lt;= 255</td><td>L + 1 个字节</td></tr><tr><td>BLOB</td><td>L</td><td>0 &lt;= L &lt;= 65535（相当于64KB）</td><td>L + 2 个字节</td></tr><tr><td>MEDIUMBLOB</td><td>L</td><td>0 &lt;= L &lt;= 16777215 （相当于16MB）</td><td>L + 3 个字节</td></tr><tr><td>LONGBLOB</td><td>L</td><td>0 &lt;= L &lt;= 4294967295（相当于4GB）</td><td>L + 4 个字节</td></tr></tbody></table><p>举例：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test_blob1(</span><br><span class="line">id <span class="type">INT</span>,</span><br><span class="line">img MEDIUMBLOB</span><br><span class="line">);  </span><br></pre></td></tr></table></figure><p>TEXT和BLOB的使用注意事项：</p><p>在使用text和blob字段类型时要注意以下几点，以便更好的发挥数据库的性能。</p><ul><li>① BLOB和TEXT值也会引起自己的一些问题，特别是执行了大量的删除或更新操作的时候。删除这种值会在数据表中留下很大的” <strong>空洞</strong> “，以后填入这些”空洞”的记录可能长度不同。为了提高性能，建议定期使用 OPTIMIZE TABLE 功能对这类表进行 <strong>碎片整理</strong> 。</li><li>② 如果需要对大文本字段进行模糊查询，MySQL 提供了 <strong>前缀索引</strong> 。但是仍然要在不必要的时候避免检索大型的BLOB或TEXT值。例如，SELECT * 查询就不是很好的想法，除非你能够确定作为约束条件的WHERE子句只会找到所需要的数据行。否则，你可能毫无目的地在网络上传输大量的值。</li><li>③ 把BLOB或TEXT列 <strong>分离到单独的表</strong> 中。在某些环境中，如果把这些数据列移动到第二张数据表中，可以让你把原数据表中的数据列转换为固定长度的数据行格式，那么它就是有意义的。这会 <strong>减少主表中的碎片</strong> ，使你得到固定长度数据行的性能优势。它还使你在主数据表上运行 SELECT * 查询的时候不会通过网络传输大量的BLOB或TEXT值。  </li></ul><h2 id="11-JSON-类型"><a href="#11-JSON-类型" class="headerlink" title="11. JSON 类型"></a>11. JSON 类型</h2><p>JSON（JavaScript Object Notation）是一种轻量级的 <strong>数据交换格式</strong> 。简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。它易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。JSON 可以将 JavaScript 对象中表示的一组数据转换为字符串，然后就可以在网络或者程序之间轻松地传递这个字符串，并在需要的时候将它还原为各编程语言所支持的数据格式。</p><p>在MySQL 5.7中，就已经支持JSON数据类型。在MySQL 8.x版本中，JSON类型提供了可以进行自动验证的JSON文档和优化的存储结构，使得在MySQL中存储和读取JSON类型的数据更加方便和高效。 创建数据表，表中包含一个JSON类型的字段 js 。  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test_json(</span><br><span class="line">js json</span><br><span class="line">);  </span><br></pre></td></tr></table></figure><p>向表中插入JSON数据。  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_json (js)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;&#123;&quot;name&quot;:&quot;songhk&quot;, &quot;age&quot;:18, &quot;address&quot;:&#123;&quot;province&quot;:&quot;beijing&quot;,</span></span><br><span class="line"><span class="string">&quot;city&quot;:&quot;beijing&quot;&#125;&#125;&#x27;</span>);  </span><br></pre></td></tr></table></figure><p>查询t19表中的数据  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">FROM</span> test_json;  </span><br></pre></td></tr></table></figure><p>当需要检索JSON类型的字段中数据的某个具体值时，可以使用“-&gt;”和“-&gt;&gt;”符号。  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126132424633.png" alt="image-20220126132424633"></p><p>通过“-&gt;”和“-&gt;&gt;”符号，从JSON字段中正确查询出了指定的JSON数据的值。  </p><h2 id="12-小结及选择建议"><a href="#12-小结及选择建议" class="headerlink" title="12. 小结及选择建议"></a>12. 小结及选择建议</h2><p>在定义数据类型时，如果确定是 <strong>整数</strong> ，就用 INT ； 如果是 小数 ，一定用定点数类型DECIMAL(M,D) ； 如果是日期与时间，就用 DATETIME 。<br>这样做的好处是，首先确保你的系统不会因为数据类型定义出错。不过，凡事都是有两面的，可靠性好，并不意味着高效。比如，TEXT 虽然使用方便，但是效率不如 CHAR(M) 和 VARCHAR(M)。</p><p>关于字符串的选择，建议参考如下阿里巴巴的《Java开发手册》规范：  </p><p><strong>阿里巴巴《Java开发手册》之MySQL数据库：</strong></p><ul><li>任何字段如果为<strong>非负数</strong>，必须是 <code>UNSIGNED</code></li><li><strong>【 强制 】</strong>小数类型为 <strong>DECIMAL</strong>，禁止使用 FLOAT 和 DOUBLE。<br>说明：在存储的时候，FLOAT 和 DOUBLE 都存在精度损失的问题，很可能在比较值的时候，得到不正确的结果。如果存储的数据范围超过 DECIMAL 的范围，建议将数据拆成整数和小数并分开存储。</li><li><strong>【 强制 】</strong>如果存储的字符串长度几乎相等，使用 <strong>CHAR</strong> 定长字符串类型。</li><li><strong>【 强制 】</strong>VARCHAR 是可变长字符串，不预先分配存储空间，长度不要超过 <strong>5000</strong>。如果存储长度大于此值，定义字段类型为 TEXT，独立出来一张表，用主键来对应，避免影响其它字段索引效率。  </li></ul>]]></content>
      
      
      <categories>
          
          <category> database </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>多表查询</title>
      <link href="/2022/01/25/%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2/"/>
      <url>/2022/01/25/%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h1><p>多表查询，也称为关联查询，指两个或更多个表一起完成查询操作。</p><p>前提条件：这些一起查询的表之间是有关系的（一对一、一对多），它们之间一定是有关联字段，这个关联字段可能建立了外键，也可能没有建立外键。比如：员工表和部门表，这两个表依靠“部门编号”进行关联。  </p><h2 id="1-一个案例引发的多表连接"><a href="#1-一个案例引发的多表连接" class="headerlink" title="1.一个案例引发的多表连接"></a>1.一个案例引发的多表连接</h2><h3 id="1-1-案例说明"><a href="#1-1-案例说明" class="headerlink" title="1.1 案例说明"></a>1.1 案例说明</h3><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220125162712644.png" alt="image-20220125162712644"></p><p>从多个表中获取数据：  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220125162742939.png" alt="image-20220125162742939"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#案例：查询员工的姓名及其部门名称</span><br><span class="line"><span class="keyword">SELECT</span> last_name, department_name <span class="keyword">FROM</span> employees, departments;  </span><br></pre></td></tr></table></figure><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220125162802341.png" alt="image-20220125162802341"></p><p>查询结果：  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220125162830410.png" alt="image-20220125162830410"></p><p><strong>2889 rows in set (0.01 sec)</strong>  </p><p><strong>分析错误情况 ：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(employee_id) <span class="keyword">FROM</span> employees;</span><br><span class="line">#输出<span class="number">107</span>行</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(department_id)<span class="keyword">FROM</span> departments;</span><br><span class="line">#输出<span class="number">27</span>行</span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">107</span><span class="operator">*</span><span class="number">27</span> <span class="keyword">FROM</span> dual;  </span><br></pre></td></tr></table></figure><p>我们把上述多表查询中出现的问题称为：笛卡尔积的错误。  </p><h3 id="1-2-笛卡尔积（或交叉连接）的理解"><a href="#1-2-笛卡尔积（或交叉连接）的理解" class="headerlink" title="1.2 笛卡尔积（或交叉连接）的理解"></a>1.2 笛卡尔积（或交叉连接）的理解</h3><p>笛卡尔乘积是一个数学运算。假设我有两个集合 X 和 Y，那么 X 和 Y 的笛卡尔积就是 X 和 Y 的所有可能组合，也就是第一个对象来自于 X，第二个对象来自于 Y 的所有可能。组合的个数即为两个集合中元素个数的乘积数。  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220125162944790.png" alt="image-20220125162944790"></p><p>SQL92中，笛卡尔积也称为 <strong>交叉连接</strong> ，英文是 <strong>CROSS JOIN</strong> 。在 SQL99 中也是使用 CROSS JOIN表示交叉连接。它的作用就是可以把任意表进行连接，即使这两张表不相关。在MySQL中如下情况会出现笛卡尔积：</p><ul><li><p><strong>笛卡尔积的错误会在下面条件下产生：</strong></p><ul><li><p>省略多个表的连接条件（或关联条件）</p></li><li><p>连接条件（或关联条件）无效</p></li><li><p>所有表中的所有行互相连接</p></li></ul></li></ul><p>为了避免笛卡尔积， <strong>可以在 WHERE 加入有效的连接条件</strong>。</p><p>加入连接条件后，查询语法：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> table1.column, table2.column</span><br><span class="line"><span class="keyword">FROM</span> table1, table2</span><br><span class="line"><span class="keyword">WHERE</span> table1.column1 <span class="operator">=</span> table2.column2; #连接条件  </span><br></pre></td></tr></table></figure><p>正确写法：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#案例：查询员工的姓名及其部门名称</span><br><span class="line"><span class="keyword">SELECT</span> last_name, department_name</span><br><span class="line"><span class="keyword">FROM</span> employees, departments</span><br><span class="line"><span class="keyword">WHERE</span> employees.department_id <span class="operator">=</span> departments.department_id;  </span><br></pre></td></tr></table></figure><p><strong>在表中有相同列时，在列名之前加上表名前缀。</strong>  <code>从SQL优化的角度，建议多表查询时，每个字段都指明其所在的表。</code></p><h2 id="2-多表查询分类讲解"><a href="#2-多表查询分类讲解" class="headerlink" title="2.多表查询分类讲解"></a>2.多表查询分类讲解</h2><h3 id="分类1：等值连接-vs-非等值连接"><a href="#分类1：等值连接-vs-非等值连接" class="headerlink" title="分类1：等值连接 vs 非等值连接"></a>分类1：等值连接 vs 非等值连接</h3><h4 id="等值连接"><a href="#等值连接" class="headerlink" title="等值连接"></a>等值连接</h4><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220125163431595.png" alt="image-20220125163431595"></p><p>例如上图中，从表<code> EMPLOYEES</code>中的 <code>DEPARTMENT_ID</code>对应表 <code>DEPARTMENTS</code>中的<code>DEPARTMENT_ID</code>， 我们要查询通过两张表中查询某员工的部门名称，那么就是通过两张表的<code>DEPARTMENT_ID</code>来进行连接的。通过两张表中字段确定的值来查询，这样的就叫做<strong>等值连接</strong>。</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220125163915473.png" alt="image-20220125163915473"></p><p><strong>拓展1：区分重复的列名</strong>  </p><ul><li>多个表中有相同列时，必须在列名之前加上表名前缀。</li><li>在不同表中具有相同列名的列可以用 <strong>表名</strong> 加以区分。  </li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employees.last_name, departments.department_name,employees.department_id</span><br><span class="line"><span class="keyword">FROM</span> employees, departments</span><br><span class="line"><span class="keyword">WHERE</span> employees.department_id <span class="operator">=</span> departments.department_id;  </span><br></pre></td></tr></table></figure><p><strong>拓展2：表的别名</strong>  </p><ul><li>使用别名可以简化查询。</li><li>列名前使用表名前缀可以提高查询效率。  </li><li><strong>需要注意的是</strong>，如果我们使用了表的别名，在查询字段中、过滤条件中就只能使用别名进行代替，不能使用原有的表名，否则就会报错  </li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> e.employee_id, e.last_name, e.department_id,</span><br><span class="line">d.department_id, d.location_id</span><br><span class="line"><span class="keyword">FROM</span> employees e , departments d</span><br><span class="line"><span class="keyword">WHERE</span> e.department_id <span class="operator">=</span> d.department_id;  </span><br></pre></td></tr></table></figure><p><strong>【强制】</strong>对于数据库中表记录的查询和变更，只要涉及多个表，都需要在列名前加表的别名（或表名）进行限定。</p><p><strong>说明</strong> ：对多表进行查询记录、更新记录、删除记录时，如果对操作列没有限定表的别名（或表名），并且操作列在多个表中存在时，就会抛异常。</p><p><strong>正例</strong> ：select t1.name from table_first as t1 , table_second as t2 where t1.id=t2.id;</p><p><strong>反例</strong> ：在某业务中，由于多表关联查询语句没有加表的别名（或表名）的限制，正常运行两年后，最近在 某个表中增加一个同名字段，在预发布环境做数据库变更后，线上查询语句出现出1052 异常：Column ‘name’ in field list is ambiguous。  </p><p><strong>拓展3：连接多个表</strong>  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220125164547569.png" alt="image-20220125164547569"></p><p><strong>总结：连接 n个表,至少需要n-1个连接条件</strong>。比如，连接三个表，至少需要两个连接条件。  </p><h4 id="非等值连接"><a href="#非等值连接" class="headerlink" title="非等值连接"></a>非等值连接</h4><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220125164609522.png" alt="image-20220125164609522"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> e.last_name, e.salary, j.grade_level</span><br><span class="line"><span class="keyword">FROM</span> employees e, job_grades j</span><br><span class="line"><span class="keyword">WHERE</span> e.salary <span class="keyword">BETWEEN</span> j.lowest_sal <span class="keyword">AND</span> j.highest_sal;  </span><br></pre></td></tr></table></figure><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220125164952009.png" alt="image-20220125164952009"></p><p>例如通过表<code>EMPLOYEES</code>查询该员工所在的工资等级GRA，是利用表<code>EMPLOYEES</code>的<code>SALARY</code>字段的值，看其处于表<code>JOB_GRADES</code>的那个范围，这就是<strong>非等值查询连接</strong>。</p><h3 id="分类2：自连接-vs-非自连接"><a href="#分类2：自连接-vs-非自连接" class="headerlink" title="分类2：自连接 vs 非自连接"></a>分类2：自连接 vs 非自连接</h3><p>之前查询并且连接不同的表，都是<strong>非自连接</strong>。</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220125165056389.png" alt="image-20220125165056389"></p><p>利用一张表<code>EMPLOYEES</code>，使得一行中显示员工的管理者，也就是表自己和自己连接。</p><p>当table1和table2本质上是同一张表，只是<strong>用取别名的方式虚拟成两张表</strong>以代表不同的意义。然后两个表再进行内连接，外连接等查询。  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employee_id, department_nameFROMemployees e,departments d</span><br><span class="line"><span class="keyword">WHERE</span> e. <span class="string">&#x27;department_id` = d.department_id; #只有106条记录，表EMPLOYEES中共107条记录</span></span><br></pre></td></tr></table></figure><p>因为这是<strong>内连接查询</strong>，只会将符合查询条件的查询出来。（剩余一个员工是最上级，再没有管理者）</p><h3 id="分类3：内连接-vs-外连接"><a href="#分类3：内连接-vs-外连接" class="headerlink" title="分类3：内连接 vs 外连接"></a>分类3：内连接 vs 外连接</h3><p>除了查询满足条件的记录以外，外连接还可以查询某一方<strong>不满足条件的记录</strong> 。</p><ul><li><p><strong>内连接:</strong> 合并具有同一列的两个以上的表的行, 结果集中不包含一个表与另一个表不匹配的行 （<strong>满足匹配条件的查出来，不满足条件的不会查出来</strong>）</p></li><li><p><strong>外连接:</strong> 两个表在连接过程中除了返回满足连接条件的行以外还返回左（或右）表中不满足条件的行 ，这种连接称为左（或右） 外连接。没有匹配的行时, 结果表中相应的列为空(NULL)。(<strong>把不满足条件的也查询出来</strong>)</p><ul><li>如果是<strong>左外连接</strong><code>LEFT JOIN</code>，则连接条件中左边的表也称为 <strong>主表</strong> ，右边的表称为 <strong>从表</strong> 。（左边不满足的查出来）</li></ul><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/img_leftjoin.gif" alt="SQL LEFT JOIN"></p><ul><li>如果是<strong>右外连接</strong><code>RIGHT JOIN</code> ，则连接条件中右边的表也称为 <strong>主表</strong> ，左边的表称为 <strong>从表</strong> 。 （右边不满足的查出来）</li></ul></li></ul><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/img_rightjoin.gif" alt="SQL RIGHT JOIN"></p><ul><li><strong>满外连接</strong> <code>FULL OUTER JOIN </code>关键字<strong>只要左表（table1）和右表（table2）其中一个表中存在匹配</strong>，则返回行。<code>FULL OUTER JOIN </code>关键字结合了<code> LEFT JOIN</code> 和 <code>RIGHT JOIN </code>的结果。</li></ul><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/img_fulljoin.gif" alt="SQL FULL OUTER JOIN"></p><p>SQL92语法实现内连接：见上</p><h3 id="SQL92：使用-创建连接"><a href="#SQL92：使用-创建连接" class="headerlink" title="SQL92：使用(+)创建连接"></a>SQL92：使用(+)创建连接</h3><p>在 SQL92 中采用（+）代表从表所在的位置。即左或右外连接中，(+) 表示哪个是从表。</p><p>Oracle 对 SQL92 支持较好，而 <strong>MySQL 则不支持 SQL92 的外连接</strong>  （！！！！！说了个卵）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#左外连接</span><br><span class="line"><span class="keyword">SELECT</span> last_name,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees ,departments</span><br><span class="line"><span class="keyword">WHERE</span> employees.department_id <span class="operator">=</span> departments.department_id(<span class="operator">+</span>);</span><br><span class="line">#右外连接</span><br><span class="line"><span class="keyword">SELECT</span> last_name,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees ,departments</span><br><span class="line"><span class="keyword">WHERE</span> employees.department_id(<span class="operator">+</span>) <span class="operator">=</span> departments.department_id;  </span><br></pre></td></tr></table></figure><p>而且在 SQL92 中，只有左外连接和右外连接，没有满（或全）外连接。  </p><p>因此我们要学习SQL99语法实现多表查询 。</p><h2 id="3-SQL99语法实现多表查询"><a href="#3-SQL99语法实现多表查询" class="headerlink" title="3. SQL99语法实现多表查询"></a>3. SQL99语法实现多表查询</h2><p>SQL99语法使用<code>JOIN ... ON</code>的方式实现多表查询，可解决外连接的问题。<strong>MySQL支持SQL99的外连接</strong>。</p><h4 id="3-1-基本语法"><a href="#3-1-基本语法" class="headerlink" title="3.1 基本语法"></a>3.1 基本语法</h4><p><strong>使用<code>JOIN...ON子</code>句创建连接的语法结构：</strong>  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> table1.column, table2.column,table3.column</span><br><span class="line"><span class="keyword">FROM</span> table1</span><br><span class="line"><span class="keyword">JOIN</span> table2 <span class="keyword">ON</span> table1 和 table2 的连接条件</span><br><span class="line"><span class="keyword">JOIN</span> table3 <span class="keyword">ON</span> table2 和 table3 的连接条件  </span><br></pre></td></tr></table></figure><p>它的嵌套逻辑类似我们使用的 FOR 循环：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> t1 in table1:</span><br><span class="line"><span class="keyword">for</span> t2 in table2:</span><br><span class="line"><span class="keyword">if</span> condition1:</span><br><span class="line"><span class="keyword">for</span> t3 in table3:</span><br><span class="line"><span class="keyword">if</span> condition2:</span><br><span class="line">output t1 + t2 + t3  </span><br></pre></td></tr></table></figure><p>SQL99 采用的这种嵌套结构非常清爽、层次性更强、可读性更强，即使再多的表进行连接也都清晰可见。如果你采用 SQL92，可读性就会大打折扣。  </p><p><strong>语法说明：</strong></p><ul><li>可以使用 ON 子句指定额外的连接条件。</li><li>这个连接条件是与其它条件分开的。</li><li>ON 子句使语句具有更高的易读性。</li><li>关键字 JOIN、INNER JOIN、CROSS JOIN 的含义是一样的，都表示内连接  </li></ul><h4 id="3-2-内连接-INNER-JOIN-的实现"><a href="#3-2-内连接-INNER-JOIN-的实现" class="headerlink" title="3.2 内连接(INNER JOIN)的实现"></a>3.2 内连接(INNER JOIN)的实现</h4><p><strong>语法：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表</span><br><span class="line"><span class="keyword">FROM</span> A表 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> B表</span><br><span class="line"><span class="keyword">ON</span> 关联条件</span><br><span class="line"><span class="keyword">WHERE</span> 等其他子句;  </span><br></pre></td></tr></table></figure><p>例：</p><p>三张表<code>employees</code>,<code>locations</code>,<code>departments</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> last_name, department_name </span><br><span class="line"><span class="keyword">FROM</span> employees e <span class="keyword">JOIN</span> departments d</span><br><span class="line"><span class="keyword">ON</span> e.department_id <span class="operator">=</span> d.department_id</span><br><span class="line"><span class="keyword">JOIN</span> locations l <span class="keyword">ON</span> d.location_id <span class="operator">=</span> l.location_id;</span><br></pre></td></tr></table></figure><h4 id="3-3-外连接-OUTER-JOIN-的实现"><a href="#3-3-外连接-OUTER-JOIN-的实现" class="headerlink" title="3.3 外连接(OUTER JOIN)的实现"></a>3.3 外连接(OUTER JOIN)的实现</h4><h5 id="3-3-1-左外连接-LEFT-OUTER-JOIN"><a href="#3-3-1-左外连接-LEFT-OUTER-JOIN" class="headerlink" title="3.3.1 左外连接(LEFT OUTER JOIN)"></a>3.3.1 左外连接(LEFT OUTER JOIN)</h5><ul><li>语法：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#实现查询结果是A</span><br><span class="line"><span class="keyword">SELECT</span> 字段列表</span><br><span class="line"><span class="keyword">FROM</span> A表 <span class="keyword">LEFT</span> <span class="keyword">JOIN</span>(或 <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span>) B表</span><br><span class="line"><span class="keyword">ON</span> 关联条件</span><br><span class="line"><span class="keyword">WHERE</span> 等其他子句;  </span><br></pre></td></tr></table></figure><ul><li>举例：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> e.last_name, e.department_id, d.department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e </span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> departments d</span><br><span class="line"><span class="keyword">ON</span> e.department_id <span class="operator">=</span> d.department_id;</span><br></pre></td></tr></table></figure><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220125191635213.png" alt="image-20220125191635213"></p><p>3.3.2 右外连接(RIGHT OUTER JOIN)  </p><ul><li>语法</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表</span><br><span class="line"><span class="keyword">FROM</span> A表 <span class="keyword">RIGHT</span> JOI</span><br><span class="line"><span class="keyword">ON</span> 关联条件</span><br><span class="line"><span class="keyword">WHERE</span> 等其他子句;  </span><br></pre></td></tr></table></figure><ul><li>举例：  </li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> e.last_name, e.department_id, d.department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">RIGHT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> departments  d</span><br><span class="line"><span class="keyword">ON</span> e.department_id <span class="operator">=</span> d.department_id;</span><br></pre></td></tr></table></figure><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220125192045048.png" alt="image-20220125192045048"></p><p><strong>需要注意的是</strong>，LEFT JOIN 和 RIGHT JOIN 只存在于 SQL99 及以后的标准中，在 SQL92 中不存在，<br>只能用 (+) 表示。  </p><h5 id="3-3-3-满外连接-FULL-OUTER-JOIN"><a href="#3-3-3-满外连接-FULL-OUTER-JOIN" class="headerlink" title="3.3.3 满外连接(FULL OUTER JOIN)"></a>3.3.3 满外连接(FULL OUTER JOIN)</h5><ul><li>满外连接的结果 = 左右表匹配的数据 + 左表没有匹配到的数据 + 右表没有匹配到的数据。</li><li>SQL99是支持满外连接的。使用<code>FULL JOIN</code> 或 <code>FULL OUTER JOIN</code>来实现。</li><li>需要注意的是，<strong>MySQL不支持</strong><code>FULL JOIN</code>，但是可以用 <code>LEFT JOIN UNION RIGHT JOIN</code>代替  </li></ul><h2 id="4-UNION的使用"><a href="#4-UNION的使用" class="headerlink" title="4.UNION的使用"></a>4.UNION的使用</h2><p><strong>合并查询结果</strong> 利用UNION关键字，可以给出多条SELECT语句，并将它们的结果组合成单个结果集。合并时，两个表对应的列数和数据类型必须相同，并且相互对应。各个SELECT语句之间使用UNION或UNIONALL关键字分隔。</p><p>语法格式：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">column</span>,... <span class="keyword">FROM</span> table1</span><br><span class="line"><span class="keyword">UNION</span> [<span class="keyword">ALL</span>]</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">column</span>,... <span class="keyword">FROM</span> table2  </span><br></pre></td></tr></table></figure><p><strong>UNION操作符</strong>  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220125193620957.png" alt="image-20220125193620957"></p><p><code>UNION </code>操作符返回两个查询的结果集的并集，<strong>去除重复记录</strong></p><p><strong>UNION ALL操作符</strong>  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220125193701666.png" alt="image-20220125193701666"></p><p><code>UNION ALL</code>操作符返回两个查询的结果集的并集。对于两个结果集的重复部分，<strong>不去重</strong>。  </p><p><strong>注意：</strong>执行<code>UNION ALL</code>语句时所需要的资源比<code>UNION</code>语句少。如果明确知道合并数据后的结果数据<br>不存在重复数据，或者不需要去除重复的数据，则<strong>尽量使用</strong><code>UNION ALL</code>语句，以提高数据查询的效<br>率。  </p><h2 id="5-7种SQL-JOINS的实现"><a href="#5-7种SQL-JOINS的实现" class="headerlink" title="5.   7种SQL JOINS的实现"></a>5.   7种SQL JOINS的实现</h2><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220125193922411.png" alt="image-20220125193922411" style="zoom:60%;" /><p>5.7.1 代码实现</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#中图：内连接 A∩B</span><br><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e <span class="keyword">JOIN</span> departments d</span><br><span class="line"><span class="keyword">ON</span> e.`department_id` <span class="operator">=</span> d.`department_id`;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#左上图：左外连接</span><br><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> departments d</span><br><span class="line"><span class="keyword">ON</span> e.`department_id` <span class="operator">=</span> d.`department_id`;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#右上图：右外连接</span><br><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> departments d</span><br><span class="line"><span class="keyword">ON</span> e.`department_id` <span class="operator">=</span> d.`department_id`;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#左中图：A <span class="operator">-</span> A∩B</span><br><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> departments d</span><br><span class="line"><span class="keyword">ON</span> e.`department_id` <span class="operator">=</span> d.`department_id`</span><br><span class="line"><span class="keyword">WHERE</span> d.`department_id` <span class="keyword">IS</span> <span class="keyword">NULL</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#右中图：B<span class="operator">-</span>A∩B</span><br><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> departments d</span><br><span class="line"><span class="keyword">ON</span> e.`department_id` <span class="operator">=</span> d.`department_id`</span><br><span class="line"><span class="keyword">WHERE</span> e.`department_id` <span class="keyword">IS</span> <span class="keyword">NULL</span>  </span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#左下图：满外连接</span><br><span class="line"></span><br><span class="line">#利用左中图 <span class="operator">+</span> 右上图 A∪B</span><br><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> departments d</span><br><span class="line"><span class="keyword">ON</span> e.`department_id` <span class="operator">=</span> d.`department_id`</span><br><span class="line"><span class="keyword">WHERE</span> d.`department_id` <span class="keyword">IS</span> <span class="keyword">NULL</span></span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span> #没有去重操作，效率高</span><br><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> departments d</span><br><span class="line"><span class="keyword">ON</span> e.`department_id` <span class="operator">=</span> d.`department_id`;  </span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#右下图</span><br><span class="line">#左中图 <span class="operator">+</span> 右中图 A ∪B<span class="operator">-</span> A∩B 或者 (A <span class="operator">-</span> A∩B) ∪ （B <span class="operator">-</span> A∩B）</span><br><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> departments d</span><br><span class="line"><span class="keyword">ON</span> e.`department_id` <span class="operator">=</span> d.`department_id`</span><br><span class="line"><span class="keyword">WHERE</span> d.`department_id` <span class="keyword">IS</span> <span class="keyword">NULL</span></span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> departments d</span><br><span class="line"><span class="keyword">ON</span> e.`department_id` <span class="operator">=</span> d.`department_id`</span><br><span class="line"><span class="keyword">WHERE</span> e.`department_id` <span class="keyword">IS</span> <span class="keyword">NULL</span>  </span><br></pre></td></tr></table></figure><h2 id="6-SQL99语法新特性"><a href="#6-SQL99语法新特性" class="headerlink" title="6. SQL99语法新特性"></a>6. SQL99语法新特性</h2><h3 id="6-1-自然连接"><a href="#6-1-自然连接" class="headerlink" title="6.1 自然连接"></a>6.1 自然连接</h3><p>SQL99 在 SQL92 的基础上提供了一些特殊语法，比如 <strong>NATURAL JOIN</strong> 用来表示自然连接。我们可以把自然连接理解为 SQL92 中的等值连接。它会帮你自动查询两张连接表中 <strong>所有相同的字段</strong> ，然后进行 <strong>等值连接</strong> 。  </p><p>在SQL92标准中：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e <span class="keyword">JOIN</span> departments d</span><br><span class="line"><span class="keyword">ON</span> e.`department_id` <span class="operator">=</span> d.`department_id`</span><br><span class="line"><span class="keyword">AND</span> e.`manager_id` <span class="operator">=</span> d.`manager_id`;  </span><br></pre></td></tr></table></figure><p>在 SQL99 中你可以写成：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e <span class="keyword">NATURAL</span> <span class="keyword">JOIN</span> departments d;  </span><br></pre></td></tr></table></figure><h3 id="6-2-USING连接"><a href="#6-2-USING连接" class="headerlink" title="6.2 USING连接"></a>6.2 USING连接</h3><p>当我们进行连接的时候，SQL99还支持使用 <strong>USING</strong> 指定数据表里的 <strong>同名字段</strong> 进行等值连接。但是只能配合JOIN一起使用。比如：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e <span class="keyword">JOIN</span> departments d</span><br><span class="line"><span class="keyword">USING</span> (department_id);  </span><br></pre></td></tr></table></figure><p>你能看出与自然连接 <code>NATURAL JOIN </code>不同的是，<code>USING </code>指定了具体的相同的字段名称，你需要在<code> USING</code>的括号 () 中填入要指定的同名字段。同时使用 <code>JOIN...USING</code> 可以简化 JOIN ON 的等值连接。它与下面的 SQL 查询结果是相同的：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e ,departments d</span><br><span class="line"><span class="keyword">WHERE</span> e.department_id <span class="operator">=</span> d.department_id;  </span><br></pre></td></tr></table></figure><h2 id="7-章节小结"><a href="#7-章节小结" class="headerlink" title="7. 章节小结"></a>7. 章节小结</h2><p>表连接的约束条件可以有三种方式：<code>WHERE, ON, USING  </code></p><ul><li>WHERE：适用于所有关联查询</li><li>ON ：只能和JOIN一起使用，只能写关联条件。虽然关联条件可以并到WHERE中和其他条件一起写，但分开写可读性更好。</li><li>USING：只能和JOIN一起使用，而且要求两个关联字段在关联表中名称一致，而且只能表示关联字段值相等  </li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#关联条件</span><br><span class="line">#把关联条件写在<span class="keyword">where</span>后面</span><br><span class="line"><span class="keyword">SELECT</span> last_name,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees,departments</span><br><span class="line"><span class="keyword">WHERE</span> employees.department_id <span class="operator">=</span> departments.department_id;</span><br><span class="line">#把关联条件写在<span class="keyword">on</span>后面，只能和<span class="keyword">JOIN</span>一起使用</span><br><span class="line"><span class="keyword">SELECT</span> last_name,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees <span class="keyword">INNER</span> <span class="keyword">JOIN</span> departments</span><br><span class="line"><span class="keyword">ON</span> employees.department_id <span class="operator">=</span> departments.department_id;</span><br><span class="line"><span class="keyword">SELECT</span> last_name,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees <span class="keyword">CROSS</span> <span class="keyword">JOIN</span> departments</span><br><span class="line"><span class="keyword">ON</span> employees.department_id <span class="operator">=</span> departments.department_id;</span><br><span class="line"><span class="keyword">SELECT</span> last_name,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees <span class="keyword">JOIN</span> departments</span><br><span class="line"><span class="keyword">ON</span> employees.department_id <span class="operator">=</span> departments.department_id;</span><br><span class="line">#把关联字段写在<span class="keyword">using</span>()中，只能和<span class="keyword">JOIN</span>一起使用</span><br><span class="line">#而且两个表中的关联字段必须名称相同，而且只能表示<span class="operator">=</span></span><br><span class="line">#查询员工姓名与基本工资</span><br><span class="line"><span class="keyword">SELECT</span> last_name,job_title</span><br><span class="line"><span class="keyword">FROM</span> employees <span class="keyword">INNER</span> <span class="keyword">JOIN</span> jobs <span class="keyword">USING</span>(job_id);</span><br><span class="line">#n张表关联，需要n<span class="number">-1</span>个关联条件</span><br><span class="line">#查询员工姓名，基本工资，部门名称</span><br><span class="line"><span class="keyword">SELECT</span> last_name,job_title,department_name <span class="keyword">FROM</span> employees,departments,jobs</span><br><span class="line"><span class="keyword">WHERE</span> employees.department_id <span class="operator">=</span> departments.department_id</span><br><span class="line"><span class="keyword">AND</span> employees.job_id <span class="operator">=</span> jobs.job_id;</span><br><span class="line"><span class="keyword">SELECT</span> last_name,job_title,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees <span class="keyword">INNER</span> <span class="keyword">JOIN</span> departments <span class="keyword">INNER</span> <span class="keyword">JOIN</span> jobs</span><br><span class="line"><span class="keyword">ON</span> employees.department_id <span class="operator">=</span> departments.department_id</span><br><span class="line"><span class="keyword">AND</span> employees.job_id <span class="operator">=</span> jobs.job_id;  </span><br></pre></td></tr></table></figure><p><strong>注意：</strong><br>我们要 <strong>控制连接表的数量</strong> 。多表连接就<strong>相当于嵌套 for 循环一样，非常消耗资源</strong>，会让 SQL 查询性能下降得很严重，因此不要连接不必要的表。在许多 DBMS 中，也都会有最大连接表的限制。  </p><p><strong>【强制】****超过三个表禁止 join</strong>。需要 join 的字段，数据类型保持绝对一致；多表关联查询时， 保证被关联的字段需要有索引。<br>说明：即使双表 join 也要注意表索引、SQL 性能。来源：阿里巴巴《Java开发手册》  </p><h2 id="附录：常用的-SQL-标准有哪些"><a href="#附录：常用的-SQL-标准有哪些" class="headerlink" title="附录：常用的 SQL 标准有哪些"></a>附录：常用的 SQL 标准有哪些</h2><p>在正式开始讲连接表的种类时，我们首先需要知道 SQL 存在不同版本的标准规范，因为不同规范下的表连接操作是有区别的。</p><p>SQL 有两个主要的标准，分别是 SQL92 和 SQL99 。92 和 99 代表了标准提出的时间，SQL92 就是 92 年提出的标准规范。当然除了 SQL92 和 SQL99 以外，还存在 SQL-86、SQL-89、SQL:2003、SQL:2008、SQL:2011 和 SQL:2016 等其他的标准。</p><p>这么多标准，到底该学习哪个呢？<strong>实际上最重要的 SQL 标准就是 SQL92 和 SQL99</strong>。一般来说 SQL92 的形式更简单，但是写的 SQL 语句会比较长，可读性较差。而 <strong>SQL99 相比于 SQL92 来说，语法更加复杂，但可读性更强</strong>。我们从这两个标准发布的页数也能看出，SQL92 的标准有 500 页，而 SQL99 标准超过了1000 页。实际上从 SQL99 之后，很少有人能掌握所有内容，因为确实太多了。就好比我们使用Windows、Linux 和 Office 的时候，很少有人能掌握全部内容一样。我们只需要掌握一些核心的功能，满<br>足日常工作的需求即可。</p><p><strong>SQL92 和 SQL99 是经典的 SQL 标准，也分别叫做 SQL-2 和 SQL-3 标准。</strong>也正是在这两个标准发布之<br>后，SQL 影响力越来越大，甚至超越了数据库领域。现如今 SQL 已经不仅仅是数据库领域的主流语言，<br>还是信息领域中信息处理的主流语言。在图形检索、图像检索以及语音检索中都能看到 SQL 语言的使<br>用。  </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>锁</title>
      <link href="/2022/01/19/%E9%94%81/"/>
      <url>/2022/01/19/%E9%94%81/</url>
      
        <content type="html"><![CDATA[<p>事务的 <strong>隔离性</strong> 由这章讲述的 <strong>锁</strong> 来实现。  </p><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p><strong>锁</strong>是计算机协调多个进程或线程<strong>并发访问某一资源</strong>的机制。在程序开发中会存在多线程同步的问题，当多个线程并发访问某个数据的时候，尤其是针对一些敏感的数据(比如订单、金额等)，我们就需要保证这个数据在任何时刻<strong>最多只有一个线程在访问</strong>，保证数据的<strong>完整性</strong>和一致性。在开发过程中加锁是为了保证数据的一致性，这个思想在数据库领域中同样很重要。</p><p>在数据库中，除传统的计算资源（如CPU、RAM、/O等）的争用以外，数据也是一种供计多用厂共寻的负源。乃保证数据的一致性，需要对<strong>并发操作进行控制</strong>，因此产生了<strong>锁</strong>。同时<strong>锁机制</strong>也为实现MysQL的各个隔离级别提供了保证。<strong>锁冲突</strong>也是影响数据库<strong>并发访问性能</strong>的一个重要因素。所以锁对数据库而言显得尤其重要，也更加复杂。</p><h2 id="2-MySQL并发事务访问相同记录"><a href="#2-MySQL并发事务访问相同记录" class="headerlink" title="2. MySQL并发事务访问相同记录"></a>2. MySQL并发事务访问相同记录</h2><p>并发事务访问相同记录的情况大致可以分为3种：</p><h3 id="2-1-读-读情况"><a href="#2-1-读-读情况" class="headerlink" title="2.1 读-读情况"></a>2.1 读-读情况</h3><p>读-读 情况，即并发事务相继 读取相同的记录 。读取操作本身不会对记录有任何影响，并不会引起什么<br>问题，所以允许这种情况的发生。  </p><p>怎么解决 <strong>脏读 、 不可重复读 、 幻读</strong> 这些问题呢？其实有两种可选的解决方案：  </p><h3 id="2-2-写-写情况"><a href="#2-2-写-写情况" class="headerlink" title="2.2 写-写情况"></a>2.2 写-写情况</h3><p>写-写 情况，即并发事务相继对相同的记录做出改动。</p><p>在这种情况下会发生 <strong>脏写</strong> 的问题，任何一种隔离级别都不允许这种问题的发生。所以在多个未提交事务相继对一条记录做改动时，需要让它们 排队执行 ，这个排队的过程其实是通过 <strong>锁</strong> 来实现的。这个所谓的锁其实是一个 <strong>内存中的结构</strong> ，在事务执行前本来是没有锁的，也就是说一开始是没有 锁结构 和记录进行关联的，如图所示：  </p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220119173930092.png" alt="image-20220119173930092" style="zoom: 50%;" /><p>当一个事务想对这条记录做改动时，首先会看看内存中有没有与这条记录关联的 锁结构 ，当没有的时候就会在内存中生成一个 锁结构 与之关联。比如，事务 T1 要对这条记录做改动，就需要生成一个 锁结构与之关联 ：</p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220119173952962.png" alt="image-20220119173952962" style="zoom:50%;" /><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220119174002208.png" alt="image-20220119174002208" style="zoom:50%;" /><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220119174010815.png" alt="image-20220119174010815" style="zoom:50%;" /><p>小结几种说法：</p><ul><li>不加锁</li></ul><p>意思就是不需要在内存中生成对应的 锁结构 ，可以直接执行操作。</p><ul><li>获取锁成功，或者加锁成功</li></ul><p>意思就是在内存中生成了对应的 锁结构 ，而且锁结构的 <code>is_waiting </code>属性为 <code>false</code> ，也就是事务可以继续执行操作。</p><ul><li>获取锁失败，或者加锁失败，或者没有获取到锁</li></ul><p>意思就是在内存中生成了对应的 <strong>锁结构</strong> ，不过锁结构的<code>is_waiting</code>属性为 <strong>true</strong> ，也就是事务需要等待，不可以继续执行操作。  </p><h3 id="2-3-读-写或写-读情况"><a href="#2-3-读-写或写-读情况" class="headerlink" title="2.3 读-写或写-读情况"></a>2.3 读-写或写-读情况</h3><p>读-写 或 写-读 ，即一个事务进行读取操作，另一个进行改动操作。这种情况下可能发生 <strong>脏读 、 不可重复读 、 幻读</strong> 的问题。</p><p>各个数据库厂商对 SQL标准 的支持都可能不一样。比如MySQL在 <strong>REPEATABLE READ</strong> 隔离级别上就已经解决了 <strong>幻读</strong> 问题。  </p><h3 id="2-4-并发问题的解决方案"><a href="#2-4-并发问题的解决方案" class="headerlink" title="2.4 并发问题的解决方案"></a>2.4 并发问题的解决方案</h3><p>怎么解决 脏读 、 不可重复读 、 幻读 这些问题呢？其实有<strong>两种可选的解决方案</strong>：  </p><p><strong>方案一</strong>：读操作利用多版本并发控制（ MVCC ，下章讲解），<strong>写</strong>操作进行 <code>加锁</code> 。  </p><p>所谓的<strong>MVCC</strong>，就是生成一个<strong>ReadView</strong>，通过ReadView找到符合条件的记录版本（历史版本由<strong>undo日志</strong>构建)。查询语句只能<strong>读</strong>到在生成ReadView之前<strong>已提交事务所做的更改</strong>，在生成ReadView之前未提交的事务或者之后才开启的事务所做的更改是看不到的。而<strong>写操作</strong>肯定的是<strong>最新版本的记录</strong>，读记录的历史版本和改动记录的最新版本本身并不冲突，也就是采用MVCC时，<strong>读-写操作并不冲突</strong>。</p><p>普通的SELECT语句在READ COMMITTED和REPEATABLE READ隔离级别下会使用到MVCC读取记录。</p><ul><li>在 <strong>READ COMMITTED</strong> 隔离级别下，一个事务在执行过程中每次执行SELECT操作时都会生成一个ReadView，ReadView的存在本身就保证了 <strong>事务不可以读取到未提交的事务所做的更改</strong> ，也就是避免了脏读现象；</li><li>在 <strong>REPEATABLE READ</strong> 隔离级别下，一个事务在执行过程中只有 <strong>第一次执行SELECT操作</strong> 才会生成一个ReadView，之后的SELECT操作都 <strong>复用</strong> 这个ReadView，这样也就避免了不可重复读和幻读的问题。  </li></ul><p><strong>方案二</strong>：读、写操作都采用 加锁 的方式。  </p><p>如果我们的一些业务场景不允许读取记录的旧版本，而是每次都必须去<strong>读取记录的最新版本</strong>。比如，在银行存款的事务中，你需要先把账户的余额读出来，然后将其加上本次存款的数额，最后再写到数据库中。在将账户余额读取出来后，就不想让别的事务再访问该余额，直到本次存款事务执行完成，其他事务才可以访问账户的余额。这样在读取记录的时候就需要对其进行<strong>加锁</strong>操作，这样也就意味着读操作和写操作也像<strong>写-写操作那样排队执行</strong>。</p><p><strong>脏读</strong>的产生是因为当前事务读取了另一个未提交事务写的一条记录，如果另一个事务在写记录的时候就给这条记录加锁，那么当前事务就无法继续读取该记录了，所以也就不会有脏读问题的产生了。</p><p><strong>不可重复读</strong>的产生是因为当前事务先读取一条记录，另外一个事务对该记录做了改动之后并提交之后，当前事务再次读取时会获得不同的值，如果在当前事务读取记录时就给该记录加锁，那么另一个事务就无法修改该记录，自然也不会发生不可重复读了。</p><p><strong>幻读</strong>问题的产生是因为当前事务读取了一个范围的记录，然后另外的事务向该范围内插入了新记录，当前事务再次读取该范围的记录时发现了新插入的新记录。采用加锁的方式解决幻读问题就有一些麻烦，因为当前事务在第一次读取记录时幻影记录并不存在，所以读取的时候加锁就有点尴尬（因为你并不知道给谁加锁，通过间隙锁和临键锁来解决，详见后面的InnoDB的行锁)。  </p><p><strong>小结对比发现：</strong></p><ul><li>采用 MVCC 方式的话， 读-写 操作彼此并不冲突， 性能更高 。</li><li>采用 加锁 方式的话， 读-写 操作彼此需要 排队执行 ，影响性能。</li></ul><p>一般情况下我们当然愿意采用 <strong>MVCC</strong> 来解决 <strong>读-写</strong> 操作并发执行的问题，但是业务在某些特殊情况下，要求必须采用 <strong>加锁</strong> 的方式执行。下面就讲解下MySQL中不同类别的锁。  </p><h2 id="3-锁的不同角度分类"><a href="#3-锁的不同角度分类" class="headerlink" title="3. 锁的不同角度分类"></a>3. 锁的不同角度分类</h2><p>锁的分类图，如下：  </p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220119173448654.png" alt="image-20220119173448654" style="zoom:40%;" /><h3 id="3-1-从数据操作的类型划分：读锁、写锁"><a href="#3-1-从数据操作的类型划分：读锁、写锁" class="headerlink" title="3.1 从数据操作的类型划分：读锁、写锁"></a>3.1 从数据操作的类型划分：读锁、写锁</h3><p>对于数据库中并发事务的读-读情况并不会引起什么问题。对于<strong>写-写、读-写</strong>或<strong>写-读</strong>这些情况可能会引起一些问题，需要使用<strong>MVCC</strong>或者<strong>加锁</strong>的方式来解决它们。在使用加锁的方式解决问题时，由于既要<strong>允许读-读</strong>情况不受影响，又要使<strong>写-写、读-写</strong>或<strong>写-读</strong>情况中的操作<strong>相互阻塞</strong>，所以MySQL实现一个由两种类型的锁组成的锁系统来解决。这两种类型的锁通常被称为<strong>共享锁(Shared Lock，SLock)<strong>和</strong>排他锁(Exclusive Lock，XLock)<strong>，也叫读</strong>锁(readlock)<strong>和</strong>写锁(write lock)</strong> 。</p><ul><li><strong>读锁</strong> ：也称为 <strong>共享锁</strong> 、英文用 <strong>S</strong> 表示。针对同一份数据，多个事务的读操作可以同时进行而<strong>不会互相影响，相互不阻塞</strong>的。</li><li><strong>写锁</strong> ：也称为 <strong>排他锁</strong> 、英文用 <strong>X</strong> 表示。当前写操作没有完成前，它<strong>会阻断其他写锁和读锁</strong>。这样就能确保在给定的时间里，只有一个事务能执行写入，并防止其他用户读取正在写入的同一资源。  </li></ul><p><strong>需要注意的是对于 InnoDB 引擎来说，读锁和写锁可以加在表上，也可以加在行上。</strong>  </p><p>**举例（行级读写锁)**︰如果一个事务T1已经获得了某个行r的读锁，那么此时另外的一个事务T2是可以去获得这个行r的读锁的，因为读取操作并没有改变行r的数据;但是，如果某个事务T3想获得行r的写锁，则它必须等待事务T1、T2释放掉行r上的读锁才行。</p><p>总结:这里的兼容是指对同一张表或记录的锁的兼容性情况。</p><table><thead><tr><th align="center"></th><th align="center">X锁</th><th align="center">S锁</th></tr></thead><tbody><tr><td align="center">X锁</td><td align="center">不兼容</td><td align="center">不兼容</td></tr><tr><td align="center">S锁</td><td align="center">不兼容</td><td align="center"><strong>兼容</strong></td></tr></tbody></table><h4 id="1-锁定读"><a href="#1-锁定读" class="headerlink" title="1.锁定读"></a>1.锁定读</h4><p>在采用<strong>加锁</strong>方式解决<strong>脏读、不可重复读、幻读</strong>这些问题时，读取一条记录时需要获取该记录的S锁，其实是<strong>不严谨的</strong>，有时候需要在读取记录时就获取记录的<strong>X锁</strong>，<strong>来禁止别的事务读写该记录</strong>，为此MysQL提出了两种比较特殊的SELECT语句格式:</p><ul><li>对读取的记录加S锁∶</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... LOCK <span class="keyword">IN</span> SHARE MODE;</span><br><span class="line">#或</span><br><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FOR</span> SHARE;#(<span class="number">8.0</span>新增语法)</span><br></pre></td></tr></table></figure><p>在普通的SELECT语句后边加<code>LOCK IN SHARE MODE</code>，如果当前事务执行了该语句，那么它会为读取到的记录加s锁，这样<strong>允许别的事务继续获取这些记录的S锁(<strong>比方说别的事务也使用<code>SELECT ... LOCK IN SHAREMODE</code>语句来读取这些记录)，但是不能获取这些记录的</strong>X锁</strong>(比如使用<code>SELECT ... FOR UPDATE</code>语句来读取这些记录，或者直接修改这些记录)。如果别的事务想要获取这些记录的<strong>X锁</strong>，那么它们会<strong>阻塞</strong>，<strong>直到当前事务提交之后将这些记录上的S锁释放掉</strong>。</p><ul><li>对读取的记录加X锁︰</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>; </span><br></pre></td></tr></table></figure><p>在普通的SELECT语句后边加<code>FOR UPDATE</code>，如果当前事务执行了该语句，那么它会为读取到的记录加X锁，这样<strong>既不允许别的事务获取这些记录的S锁(<strong>比方说别的事务使用<code>SELECT ... LOCK IN SHARE MODE</code>语句来读取这些记录)，也不允许获取这些记录的X锁(比如使用<code>SELECT ... FOR UPDATE</code>语句来读取这些记录，或者直接修改这些记录)。如果别的事务想要获取这些记录的S锁或者X锁，那么它们会</strong>阻塞</strong>，<strong>直到当前事务提交之后将这些记录上的X锁释放掉</strong>。</p><p><strong>MySQL 8.0 新特性</strong></p><p>在5.7及之前的版本，<code>SELECT ... FOR UPDATE</code>，如果获取不到锁，会一直等待，直到<code>innodb_lock_wait_timeout</code>超时。在8.0版本中，<code>SELECT ... FOR UPDATE，SELECT...FOR SHARE </code>添加<code>NOWAIT、SKIP LOCKED</code>语法，跳过锁等待，或者跳过锁定。</p><ul><li>通过添加<code>NOWAIT、SKIP LOCKED</code>语法，能够立即返回。如果查询的行已经加锁:</li><li>那么<code>NOWAIT</code>会立即报错返回</li><li>而<code>SKIP LOCKED</code>也会立即返回，只是返回的结果中不包含被锁定的行。</li></ul><h4 id="2-写操作"><a href="#2-写操作" class="headerlink" title="2.写操作"></a>2.写操作</h4><p>平常所用到的写操作无非是 DELETE、UPDATE、INSERT这三种:</p><p><strong>DELETE:</strong></p><p>对一条记录做DELETE操作的过程其实是先在B+树中定位到这条记录的位置，然后获取这条记录的X锁，再执行delete mark操作。我们也可以把这个定位待删除记录在B+树中位置的过程看成是一个获取X锁的锁定读。</p><p><strong>UPDATE</strong>:     在对一条记录做UPDATE操作时分为三种情况:</p><ul><li>情况1:未修改该记录的键值，并且被更新的列占用的存储空间在修改前后未发生变化。则先在B+树中定位到这条记录的位置，然后再获取一下记录的X锁，最后在原记录的位置进行修改操作。我们也可以把这个定位待修改记录在B+树中位置的过程看成是一个获取X锁的锁定读。</li><li>情况2∶未修改该记录的键值，并且至少有一个被更新的列占用的存储空间在修改前后发生变化。则先在B+树中定位到这条记录的位置，然后获取一下记录的X锁，将该记录彻底删除掉(就是把记录彻底移入垃圾链表)，最后再插入一条新记录。这个定位待修改记录在B+树中位置的过程看成是一个获取×锁的锁定读，新插入的记录由INSERT 操作提供的隐式锁进行保护。|</li><li>情况3:修改了该记录的键值，则相当于在原记录上做DELETE操作之后再来一次INSERT操作，加锁操作就需要按照DELETE 和INSERT的规则进行了。</li></ul><p><strong>INSERT :</strong></p><p>一般情况下，新插入一条记录的操作并不加锁，通过一种称之为隐式锁的结构来保护这条新插入的记录在本事务提交前不被别的事务访问。</p><h3 id="3-2-从数据操作的粒度划分：表级锁、页级锁、行锁"><a href="#3-2-从数据操作的粒度划分：表级锁、页级锁、行锁" class="headerlink" title="3.2 从数据操作的粒度划分：表级锁、页级锁、行锁"></a>3.2 从数据操作的粒度划分：表级锁、页级锁、行锁</h3><p>为了尽可能提高数据库的并发度，每次锁定的数据范围越小越好，理论上每次只锁定当前操作的数据的方案会得到最大的并发度，但是管理锁是很耗资源的事情（涉及获取、检查、释放锁等动作)。因此数据库系统需要在<strong>高并发响应</strong>和<strong>系统性能</strong>两方面进行平衡，这样就产生了“**锁粒度（Lock granularity)**”的概念。</p><p>对一条记录加锁影响的也只是这条记录而已，我们就说这个锁的粒度比较细;其实一个事务也可以在<strong>表级别</strong>进行加锁，自然就被称之为<strong>表级锁</strong>或者<strong>表锁</strong>，对一个表加锁影响整个表中的记录，我们就说这个锁的粒度比较粗。锁的粒度主要分为<strong>表级锁、页级锁</strong>和<strong>行锁</strong>。</p><h4 id="1-表锁（Table-Lock）"><a href="#1-表锁（Table-Lock）" class="headerlink" title="1. 表锁（Table Lock）"></a>1. 表锁（Table Lock）</h4><p>该锁会<strong>锁定整张表</strong>，它是MySQL中最基本的锁策略，并<strong>不依赖于存储引擎</strong>(不管你是MySQL的什么存储引擎，对于表锁的策略都是一样的)，并且<strong>表锁是开销最小的策略</strong>（因为粒度比较大)。由于表级锁一次会将整个表锁定，所以可以很好的<strong>避免死锁问题</strong>。当然，锁的粒度大所带来最大的负面影响就是出现锁资源争用的概率也会最高，导致并发率大打折扣。</p><h5 id="①-表级别的S锁、X锁"><a href="#①-表级别的S锁、X锁" class="headerlink" title="① 表级别的S锁、X锁"></a>① 表级别的S锁、X锁</h5><p>在对某个表执行<code>SELECT、INSERT、DELETE、UPDATE</code>语句时，InnoDB存储引擎是不会为这个表添加表级别的 S锁 或者 X锁 的。在对某个表执行一些诸如<code>ALTER TABLE 、 DROP TABLE</code>这类的 <strong>DDL 语句时</strong>，<strong>其他事务对这个表并发执行诸如<code>SELECT、INSERT、DELETE、UPDATE</code>的语句会发生阻塞</strong>。同理，某个事务中对某个表执行<code>SELECT、INSERT、DELETE、UPDATE</code>语句时，在其他会话中对这个表执行 DDL 语句也会发生阻塞。这个过程其实是通过在 <strong>server层</strong> 使用一种称之为 <strong>元数据锁</strong> （英文名： Metadata Locks ，简称 <strong>MDL</strong> ）结构来实现的。</p><p>一般情况下，不会使用InnoDB存储引擎提供的表级别的 S锁 和 X锁 。只会在一些特殊情况下，比方说 崩溃恢复 过程中用到。比如，在系统变量<code> autocommit=0，innodb_table_locks = 1</code> 时， 手动 获取InnoDB存储引擎提供的表t 的 S锁 或者 X锁 可以这么写：</p><ul><li><strong>LOCK TABLES t READ</strong> ：InnoDB存储引擎会对表 t 加表级别的 S锁 。</li><li><strong>LOCK TABLES t WRITE</strong> ：InnoDB存储引擎会对表 t 加表级别的 X锁 。</li></ul><p>不过尽量避免在使用InnoDB存储引擎的表上使用 LOCK TABLES  这样的手动锁表语句，它们并不会提供什么额外的保护，只是会降低并发能力而已。<strong>InnoDB的厉害之处还是实现了更细粒度的行锁</strong> ，关于InnoDB表级别的 S锁 和 X锁 大家了解一下就可以了。</p><p>MySQL的表级锁有两种模式：（以MyISAM表进行操作的演示）  </p><ul><li>表共享读锁（Table Read Lock）</li><li>表独占写锁（Table Write Lock）  </li></ul><table><thead><tr><th>锁类型</th><th>自己可读</th><th>自己可写</th><th>自己可操作其他表</th><th>他人可读</th><th>他人可写</th></tr></thead><tbody><tr><td>读锁</td><td>是</td><td>否</td><td>否</td><td>是</td><td>否，等</td></tr><tr><td>写锁</td><td>是</td><td>是</td><td>否</td><td>否，等</td><td>否，等</td></tr></tbody></table><h5 id="②-意向锁-（intention-lock）"><a href="#②-意向锁-（intention-lock）" class="headerlink" title="② 意向锁 （intention lock）"></a>② 意向锁 （intention lock）</h5><p>InnoDB 支持 <strong>多粒度锁（multiple granularity locking）</strong> ，它允许 <strong>行级锁</strong> 与 <strong>表级锁</strong> 共存，而<strong>意向锁</strong>就是其中的一种 <strong>表锁</strong> 。  </p><p>意向锁分为两种：  </p><p>1、意向锁的存在是<strong>为了协调行锁和表锁的关系</strong>，支持多粒度（表锁与行锁)的锁并存。</p><p>2、意向锁是一种<strong>不与行级锁冲突表级锁</strong>，这一点非常重要。</p><p>3、表明“某个事务正在某些行持有了锁或该事务准备去持有锁”</p><p><strong>意向共享锁（intention shared lock, IS）</strong>：事务有意向对表中的某些行加共享锁（S锁）  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 事务要获取某些行的 S 锁，必须先获得表的 IS 锁。</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">column</span> <span class="keyword">FROM</span> <span class="keyword">table</span> ... LOCK <span class="keyword">IN</span> SHARE MODE;  </span><br></pre></td></tr></table></figure><p><strong>意向排他锁（intention exclusive lock, IX）</strong>：事务有意向对表中的某些行加排他锁（X锁）  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 事务要获取某些行的 X 锁，必须先获得表的 IX 锁。</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">column</span> <span class="keyword">FROM</span> <span class="keyword">table</span> ... <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;  </span><br></pre></td></tr></table></figure><p>即：意向锁是由存储引擎 <strong>自己维护的</strong> ，用户无法手动操作意向锁，在为数据行加共享 / 排他锁之前，InooDB 会先获取该数据行 <strong>所在数据表的对应意向锁</strong> 。  </p><p><strong>1.意向锁要解决的问题</strong></p><p>现在有两个事务，分别是T1和T2，其中T2试图在该表级别上应用共享或排它锁，如果没有意向锁存在，那么T2就需要去检查各个页或行是否存在锁;如果存在意向锁，那么此时就会受到由T1控制的<strong>表级别意向锁的阻塞</strong>。T2在锁定该表前不必检查各个页或行锁，而只需检查表上的意向锁。简单来说就是<strong>给更大一级别的空间示意里面是否已经上过锁</strong>。</p><p>在数据表的场景中，<strong>如果我们给某一行数据加上了排它锁，数据库会自动给更大一级的空间，比如数据页或数据表加上意向锁，告诉其他人这个数据页或数据表已经有人上过排它锁了</strong>，这样当其他人想要获取数据表排它锁的时候，只需要了解是否有人已经获取了这个数据表的意向排他锁即可。</p><ul><li>如果事务想要获得数据表中某些记录的共享锁，就需要在数据表上<strong>添加意向共享锁。</strong></li><li>如果事务想要获得数据表中某些记录的排他锁，就需要在数据表上<strong>添加意向排他锁</strong>。</li></ul><p>这时，意向锁会告诉其他事务已经有人锁定了表中的某些记录。</p><p>举例:创建表teacher，插入6条数据，事务的隔离级别默认为Repeatable-Read，如下所示。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">&#x27;teacher`(&#x27;</span>id` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`name ` <span class="type">varchar</span> (<span class="number">255</span>)<span class="keyword">NOT</span> <span class="keyword">NULL</span>,<span class="keyword">PRIMARY</span> KEY ( `id `)</span><br><span class="line">）ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8mb4_0900_ai_ci;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">&#x27;teacher` VALUES</span></span><br><span class="line"><span class="string">( &#x27;</span><span class="number">1</span> <span class="string">&#x27;, &#x27;</span>zhangsan <span class="string">&#x27; ),</span></span><br><span class="line"><span class="string">( &#x27;</span><span class="number">2</span><span class="string">&#x27;, &#x27;</span>lisi <span class="string">&#x27;),( &#x27;</span><span class="number">3</span> <span class="string">&#x27; , &#x27;</span>wangwu <span class="string">&#x27; ) ，( &#x27;</span><span class="number">4</span><span class="string">&#x27;, &#x27;</span>zhaoliu <span class="string">&#x27;)，</span></span><br><span class="line"><span class="string">( &#x27;</span><span class="number">5</span><span class="string">&#x27;, &#x27;</span>songhongkang <span class="string">&#x27; ),( &#x27;</span><span class="number">6</span><span class="string">&#x27;, &#x27;</span>leifengyang<span class="string">&#x27;);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">mysql&gt; SELECT @@transaction_isolation;</span></span><br><span class="line"><span class="string">+----------------------------+</span></span><br><span class="line"><span class="string">|  @@transaction_isolationl  |</span></span><br><span class="line"><span class="string">+----------------------------+</span></span><br><span class="line"><span class="string">|  REAPEATABKE-READ          |</span></span><br><span class="line"><span class="string">+----------------------------+</span></span><br></pre></td></tr></table></figure><p>假设事务A获取了某一行的排他锁，并未提交，语句如下所示。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span> ;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> teacher <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">6</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure><p>事务B想要获取teacher 表的表读锁，语句如下。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line">LOCK TABLES teacher READ;</span><br></pre></td></tr></table></figure><p>因为共享锁与排他锁互斥，所以事务B在试图对teacher表加共享锁的时候，必须保证两个条件。</p><ul><li>当前没有其他事务持有teacher表的排他锁</li><li>当前没有其他事务持有teacher表中任意一行的排他锁。</li></ul><p>为了检测是否满足第二个条件，事务B必须在确保teacher表不存在任何排他锁的前提下，去检测表中的每一行是否存在排他锁。很明显这是一个效率很差的做法，但是有了意向锁之后，情况就不一样了。</p><p>意向锁是怎么解决这个问题的呢?首先，我们需要知道意向锁之间的兼容互斥性，如下所示。</p><table><thead><tr><th align="center"></th><th align="center">意向共享锁（IS）</th><th align="center">意向排他锁（IX）</th></tr></thead><tbody><tr><td align="center">意向共享锁（IS）</td><td align="center">兼容</td><td align="center">兼容</td></tr><tr><td align="center">意向排他锁（IX）</td><td align="center">兼容</td><td align="center">兼容</td></tr></tbody></table><p>即<strong>意向锁之间是互相兼容的</strong>，虽然意向锁和自家兄弟互相兼容，但是它<strong>会与普通的排他/共享锁互斥</strong>。</p><table><thead><tr><th align="center"></th><th align="center">意向共享锁（IS）</th><th align="center">意向排他锁（IX）</th></tr></thead><tbody><tr><td align="center">共享锁（S）</td><td align="center">兼容</td><td align="center">互斥</td></tr><tr><td align="center">排他锁（X）</td><td align="center">互斥</td><td align="center">互斥</td></tr></tbody></table><p>注意这里的排他/共享锁指的都是<strong>表锁</strong>，意向锁不会与行级的共享/排他锁互斥。回到刚才teacher表的例子。</p><p>事务A获取了某一行的排他锁，并未提交:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> teacher <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">6</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure><p>此时teacher表存在两把锁: teacher表上的<strong>意向排他锁</strong>与id为6的<strong>数据行上的排他锁</strong>。事务B想要获取 teacher表的共享锁。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line">LOCK TABLES teacher READ;</span><br></pre></td></tr></table></figure><p>此时事务B检测事务A持有teacher表的意向排他锁，就可以得知事务A必然持有该表中某些数据行的排他锁，那么事务B对teacher表的加锁请求就会被**排斥（阻塞)**，而无需去检测表中的每一行数据是否存在排他锁。</p><p><strong>意向锁的并发性</strong></p><p>意向锁不会与行级的共享 / 排他锁互斥！正因为如此，<strong>意向锁并不会影响到多个事务对不同数据行加排他锁时的并发性。</strong>（不然我们直接用普通的表锁就行了）</p><p>我们扩展一下上面 teacher表的例子来概括一下意向锁的作用（一条数据从被锁定到被释放的过程中，可能存在多种不同锁，但是这里我们只着重表现意向锁）。</p><p>事务A先获取了某一行的排他锁，并<strong>未提交:</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> teacher <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">6</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure><p>事务A获取了teacher表上的意向排他锁，事务A获取了id为6的数据行上的排他锁。之后事务B想要获取teacher表的共享锁。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line">LOCK TABLES teacher READ;</span><br></pre></td></tr></table></figure><p>事务B检测到事务A持有teacher表的意向排他锁。事务B对teacher表的加锁请求被阻塞(排斥)。最后事务C也想获取 teacher表中某一行的排他锁。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> teacher <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">5</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure><p>事务c申请teacher表的意向排他锁。事务c检测到事务A持有teacher表的意向排他锁。因为<strong>意向锁之间并不互斥</strong>，所以事务c获取到了teacher表的意向排他锁。因为id为<strong>5</strong>的数据行上不存在任何排他锁最终事务C成功获取到了该数据行上的排他锁。</p><p>从上面的案例可以得到如下结论：</p><ol><li>InnoDB 支持 <strong>多粒度锁</strong> ，特定场景下，<strong>行级锁可以与表级锁共存</strong>。</li><li>意向锁之间互不排斥，但除了 IS 与 S 兼容外， <strong>意向锁会与 共享锁 / 排他锁 互斥</strong> 。</li><li>IX，IS是表级锁，不会和行级的X，S锁发生冲突。只会和表级的X，S发生冲突。</li><li>意向锁在保证并发性的前提下，实现了 <strong>行锁和表锁共存</strong> 且 <strong>满足事务隔离性</strong> 的要求。  </li></ol><h5 id="③-自增锁（AUTO-INC锁）"><a href="#③-自增锁（AUTO-INC锁）" class="headerlink" title="③ 自增锁（AUTO-INC锁）"></a>③ 自增锁（AUTO-INC锁）</h5><p>在使用MySQL过程中，我们可以为表的某个列添加 AUTO_INCREMENT 属性。举例：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `teacher` (</span><br><span class="line">`id` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">`name` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8mb4_0900_ai_ci;  </span><br></pre></td></tr></table></figure><p>由于这个表的id字段声明了AUTO_INCREMENT，意味着在书写插入语句时不需要为其赋值，SQL语句修改<br>如下所示。  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `teacher` (name) <span class="keyword">VALUES</span> (<span class="string">&#x27;zhangsan&#x27;</span>), (<span class="string">&#x27;lisi&#x27;</span>);  </span><br></pre></td></tr></table></figure><p>上边的插入语句并没有为id列显式赋值，所以系统会自动为它赋上递增的值。</p><p>现在我们看到的上面插入数据只是一种简单的插入模式，所有插入数据的方式总共分为三类，分别是<code>“ Simple inserts ”，“ Bulk inserts ”和“ Mixed-mode inserts ”</code>。  </p><ol><li><strong>“Simple inserts” （简单插入）</strong></li></ol><p>可以 预先确定要插入的行数 （当语句被初始处理时）的语句。包括没有嵌套子查询的单行和多行<br>INSERT…VALUES() 和 REPLACE 语句。比如我们上面举的例子就属于该类插入，已经确定要插入的行<br>数。</p><ol start="2"><li><strong>“Bulk inserts” （批量插入）</strong></li></ol><p>事先不知道要插入的行数 （和所需自动递增值的数量）的语句。比如 INSERT … SELECT ， REPLACE<br>… SELECT 和 LOAD DATA 语句，但不包括纯INSERT。 InnoDB在每处理一行，为AUTO_INCREMENT列<br>分配一个新值。</p><ol start="3"><li><strong>“Mixed-mode inserts” （混合模式插入）</strong></li></ol><p>这些是“Simple inserts”语句但是指定部分新行的自动递增值。例如 <code>INSERT INTO teacher (id,name) VALUES (1,&#39;a&#39;), (NULL,&#39;b&#39;), (5,&#39;c&#39;), (NULL,&#39;d&#39;); </code>只是指定了部分id的值。另一种类型的“混合模式插入”是 <code>INSERT ... ON DUPLICATE KEY UPDATE </code>。  </p><p>innodb_autoinc_lock_mode有三种取值，分别对应与不同锁定模式：  </p><p>（1）innodb_autoinc_lock_mode = 0(“传统”锁定模式)  </p><p>在此锁定模式下，所有类型的insert语句都会获得一个特殊的表级AUTO-INC锁，用于插入具有AUTO_INCREMENT列的表。这种模式其实就如我们上面的例子，即每当执行insert的时候，都会得到一个表级锁(AUTO-INC锁)，使得语句中生成的auto_increment为顺序，且在binlog中重放的时候，可以保证master与slave中数据的auto_increment是相同的。因为是表级锁，当在同一时间多个事务中执行insert的<br>时候，对于AUTO-INC锁的争夺会 <strong>限制并发</strong> 能力 。</p><p>（2）innodb_autoinc_lock_mode = 1(“连续”锁定模式)  </p><p>在 <strong>MySQL 8.0 之前</strong>，<strong>连续锁定模式是 默认 的</strong>。</p><p>在这个模式下，“bulk inserts”仍然使用AUTO-INC表级锁，并保持到语句结束。这适用于所有<code>INSERT ...SELECT，REPLACE ... SELECT和LOAD DATA</code>语句。同一时刻只有一个语句可以持有AUTO-INC锁。</p><p>对于“Simple inserts”（要插入的行数事先已知），则通过在 mutex（轻量锁） 的控制下获得所需数量的自动递增值来避免表级AUTO-INC锁， 它只在分配过程的持续时间内保持，而不是直到语句完成。不使用表级AUTO-INC锁，除非AUTO-INC锁由另一个事务保持。如果另一个事务保持AUTO-INC锁，则“Simple inserts”等待AUTO-INC锁，如同它是一个“bulk inserts”。  </p><p>（3）innodb_autoinc_lock_mode = 2(“交错”锁定模式)  </p><p>从 <strong>MySQL 8.0</strong> 开始，<strong>交错锁模式</strong>是 <strong>默认</strong> 设置。</p><p>在此锁定模式下，自动递增值 保证 在所有并发执行的所有类型的insert语句中是 唯一 且 单调递增 的。但是，由于多个语句可以同时生成数字（即，跨语句交叉编号），<strong>为任何给定语句插入的行生成的值可能不是连续的</strong>。  </p><h5 id="④-元数据锁（MDL锁）"><a href="#④-元数据锁（MDL锁）" class="headerlink" title="④ 元数据锁（MDL锁）"></a>④ 元数据锁（MDL锁）</h5><p>MySQL5.5引入了meta data lock，简称MDL锁，属于表锁范畴。MDL 的作用是，保证读写的正确性。比如，如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个 <strong>表结构做变更</strong> ，增加了一列，那么查询线程拿到的结果跟表结构对不上，肯定是不行的。</p><p>因此，<strong>当对一个表做增删改查操作的时候，加 MDL读锁；当要对表做结构变更操作的时候，加 MDL 写锁</strong>。  </p><p>select name from world where GDP &gt;= ALL(select GDP from world where continent =’Europe’ and population &gt;0);</p>]]></content>
      
      
      <categories>
          
          <category> database </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>索引的创建与设计原则</title>
      <link href="/2022/01/18/%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
      <url>/2022/01/18/%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</url>
      
        <content type="html"><![CDATA[<h1 id="索引的创建与设计原则"><a href="#索引的创建与设计原则" class="headerlink" title="索引的创建与设计原则"></a>索引的创建与设计原则</h1><h2 id="1-索引的声明与使用"><a href="#1-索引的声明与使用" class="headerlink" title="1.索引的声明与使用"></a>1.索引的声明与使用</h2><h3 id="1-1-索引的分类"><a href="#1-1-索引的分类" class="headerlink" title="1.1 索引的分类"></a>1.1 索引的分类</h3><p>MySQL的索引包括普通索引、唯一性索引、全文索引、单列索引、多列索引和空间索引等。</p><ul><li>从 <strong>功能逻辑</strong> 上说，索引主要有 4 种，分别是普通索引、唯一索引、主键索引、全文索引。</li><li>按照 <strong>物理实现方式</strong> ，索引可以分为 2 种：聚簇索引和非聚簇索引。</li><li>按照 作用字段个数 进行划分，分成单列索引和联合索引。  </li></ul><p>1.普通索引</p><p>在创建普通索引时，不附加任何限制条件，只是用于提高查询效率。这类索引可以创建在<strong>任何数据类型</strong>中，其值是否唯一和非空，要由字段本身的完整性约束条件决定。建立索引以后，可以通过索引进行查询。例如，在表student的字段name上建立一个普通索引，查询记录时就可以根据该索引进行查询。</p><p>2.唯一性索引</p><p>使用<strong>UNIQUE参数</strong>可以设置索引为唯一性索引，在创建唯一性索引时，限制该索引的值必须是唯一的，但允许有空值。在一张数据表里<strong>可以有多个唯一索引</strong>。</p><p>例如，在表student的字段email中创建唯一性索引，那么字段email的值就必须是唯一的。通过唯一性索引，可以更快速地确定某条记录。</p><p>3.主键索引</p><p>主键索引就是一种<strong>特殊的唯一性索引</strong>，在唯一索引的基础上增加了不为空的约束，也就是NOT NULL+UNIQUE，<strong>一张表里最多只有一个主键索引</strong>。</p><p><strong>Why?</strong> 这是由主键索引的物理实现方式决定的，因为数据存储在文件中只能按照一种顺序进行存储。</p><p>4.单列索引</p><p>在表中的单个字段上创建索引。单列索引只根据该字段进行索引。单列索引可以是普通索引，也可以是唯一性索引，还可以是全文索引。只要保证该索引只对应一个字段即可。一个表可以有多个单列索引。</p><p>5.多列(组合、联合)索引</p><p>多列索引是在表的多个字段组合上创建一个索引。该索引指向创建时对应的多个字段，可以通过这几个子段进仃查询，但是只有查询条件中使用了这些字段中的第一个字段时才会被使用。例如，在表中的字段id、name和gender上建立一个多列索引idx_id_name_gender，只有在查询条件中使用了字段id时该索引才会被使用。使用组合索引时遵循最左前缀集合。</p><p>6.全文索引</p><p>全文索引(也称全文检索)是目前<strong>搜索引擎</strong>使用的一种关键技术。它能够利用【<strong>分词技术</strong>】等多种算法智能分析出文本文字中关键词的频率和重要性，然后按照一定的算法规则智能地筛选出我们想要的搜索结果。全文索引非常适合大型数据集，对于小的数据集，它的用处比较小。</p><p>使用参数<strong>FULLTEXT</strong>可以设置索引为全文索引。在定义索引的列上支持值的全文查找，允许在这些索引例中插入重复值和空值。全文索引只能创建在<strong>CHAR 、VARCHAR</strong>或TEXT类型及其系列类型的字段上，查<strong>询数据重较大的字符串类型的字段时，使用全文索引可以提高查询速度</strong>。例如，表student的字段information是I庆尖丝，该字段包含了很多文字信息。在字段information上建立全文索引后，可以提高查询字段information的速度。</p><p>全文索引典型的有两种类型:自然语言的全文索引和布尔全文索引。</p><ul><li>自然语言搜索引擎将计算每一个文档对象和查询的相关度。这里，相关度是基于匹配的关键词的个数，以及关键词在文档中出现的次数。<strong>在整个索引中出现次数越少的词语，匹配时的相关度就越高</strong>。相反，非常常见的单词将不会被搜索，如果一个词语的在超过50%的记录中都出现了，那么自然语言的搜索将不会搜索这类词语。</li></ul><p>MysQL数据库从3.23.23版开始支持全文索引，但MySQL5.6.4以前只有<strong>Myisam</strong>支持，5.6.4版本以后<strong>innodb</strong>才支持，但是官方版本不支持<strong>中文分词</strong>，需要第三方分词插件。在5.7.6版本，MySQL内置了ngram全文解析器，用来支持亚洲语种的分词。测试或使用全文索引时，要先看一下自己的MysQL版本、存储引擎和数据类型是否支持全文索引。</p><p>随着大数据时代的到来，关系型数据库应对全文索引的需求已力不从心，逐渐被solr、<strong>ElasticSearch</strong>等专门的搜索引擎所替代。</p><p>7.补充:空间索引</p><p>使用<strong>参数SPATIAL</strong>可以设置索引为<strong>空间索引</strong>。空间索引只能建立在空间数据类型上，这样可以提高系统获取空间数据的效率。MySQL中的空间数据类型包括<strong>GEOMETRY、POINT、LINESTRING和POLYGON</strong>等。目前只有MyISAM存储引擎支持空间检索，而且索引的字段不能为空值。对于初学者来说，这类索引很少会用到</p><p><strong>小结：</strong>不同的存储引擎支持的索引类型也不一样 InnoDB ：支持 B-tree、Full-text 等索引，不支持 Hash索引； MyISAM ： 支持 B-tree、Full-text 等索引，不支持 Hash 索引； Memory ：支持 B-tree、Hash 等索引，不支持 Full-text 索引； NDB ：支持 Hash 索引，不支持 B-tree、Full-text 等索引； Archive ：不支持 B-tree、Hash、Full-text 等索引；  </p><h3 id="1-2-创建索引"><a href="#1-2-创建索引" class="headerlink" title="1.2 创建索引"></a>1.2 创建索引</h3><p>MySQL支持多种方法在单个或多个列上创建索引:在创建表的定义语句<strong>CREATE TABLE</strong>中指定索引列，使用<strong>ALTER TABLE</strong>语句在存在的表上创建索引，或者使用<strong>CREATE INDEX</strong>语句在已存在的表上添加索引。</p><h4 id="1-创建表的时候创建索引"><a href="#1-创建表的时候创建索引" class="headerlink" title="1.创建表的时候创建索引"></a>1.创建表的时候创建索引</h4><p>使用CREATE TABLE创建表时，除了可以定义列的数据类型外，还可以定义主键约束、外键约束或者唯一性约束,而不论创建哪种约束，<strong>在定义约束的同时相当于在指定列上创建了一个索引</strong>。</p><p>举例：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#隐式的方式创建索引 在主键约束、外键约束或者唯一性约束的字段上，会自动的添加相关的索引</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> dept(</span><br><span class="line">dept_id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">dept_name <span class="type">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> emp(</span><br><span class="line">emp_id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">emp_name <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">UNIQUE</span>,</span><br><span class="line">dept_id <span class="type">INT</span>,</span><br><span class="line"><span class="keyword">CONSTRAINT</span> emp_dept_id_fk <span class="keyword">FOREIGN</span> KEY(dept_id) <span class="keyword">REFERENCES</span> dept(dept_id)</span><br><span class="line">);  </span><br></pre></td></tr></table></figure><p> 但是，如果显式创建表时创建索引的话，基本语法格式如下：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name [col_name data_type]</span><br><span class="line">[<span class="keyword">UNIQUE</span> <span class="operator">|</span> FULLTEXT <span class="operator">|</span> SPATIAL] [INDEX <span class="operator">|</span> KEY] [index_name] (col_name [length]) [<span class="keyword">ASC</span> <span class="operator">|</span></span><br><span class="line"><span class="keyword">DESC</span>]  </span><br></pre></td></tr></table></figure><ul><li><strong>UNIQUE 、 FULLTEXT</strong> 和 <strong>SPATIAL</strong> 为可选参数，分别表示唯一索引、全文索引和空间索引；</li><li><strong>INDEX</strong> 与 <strong>KEY</strong> 为同义词，两者的作用相同，用来指定创建索引；</li><li><strong>index_name</strong> 指定索引的名称，为可选参数，如果不指定，那么MySQL默认<strong>col_name为索引名</strong>；</li><li><strong>col_name</strong> 为需要创建索引的字段列，该列必须从数据表中定义的多个列中选择；</li><li><strong>length</strong> 为可选参数，表示索引的长度，只有字符串类型的字段才能指定索引长度；</li><li><strong>ASC 或 DESC</strong> 指定升序或者降序的索引值存储。  </li></ul><p><strong>通过命令查看索引：</strong></p><p>方式一：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> BOOK;</span><br></pre></td></tr></table></figure><p>方式二：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> BOOK;</span><br></pre></td></tr></table></figure><p><strong>1.创建普通索引</strong></p><p>在book表中的year_publication字段上建立普通索引，SQL语句如下：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> book(</span><br><span class="line">book_id <span class="type">INT</span> ,</span><br><span class="line">book_name <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">authors <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">info <span class="type">VARCHAR</span>(<span class="number">100</span>) ,</span><br><span class="line">comment <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">year_publication <span class="keyword">YEAR</span>,</span><br><span class="line">INDEX(year_publication)</span><br><span class="line">);  </span><br></pre></td></tr></table></figure><p>使用EXPLAIN语句查看索引是否正在使用:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> book <span class="keyword">WHERE</span> year_publication<span class="operator">=</span> <span class="string">&#x27;1990&#x27;</span> ;</span><br></pre></td></tr></table></figure><p>EXPLAIN语句输出结果的各个行我们在下一章讲解。这里主要关注两个字段:</p><ol><li> possible_keys行给出了MySQL在搜索数据记录时可选用的各个索引。</li><li> key行是MySQL实际选用的索引。</li></ol><p>可以看到possible_keys和key的值都为year_publication，查询时使用了索引。</p><p><strong>2.创建唯一索引</strong></p><p>举例：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test1(</span><br><span class="line">id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">name <span class="type">varchar</span>(<span class="number">30</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line"><span class="keyword">UNIQUE</span> INDEX uk_idx_id(id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>该语句执行完毕之后，使用SHOW CREATE TABLE查看表结构  :</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> test1;</span><br></pre></td></tr></table></figure><p><strong>3.主键索引</strong></p><p>设定为主键后数据库会自动建立索引，innodb为聚簇索引，语法：</p><ul><li><p>随表一起建索引：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#隐式的方式创建索引</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> student (</span><br><span class="line">id <span class="type">INT</span>(<span class="number">10</span>) UNSIGNED AUTO_INCREMENT ,</span><br><span class="line">student_no <span class="type">VARCHAR</span>(<span class="number">200</span>),</span><br><span class="line">student_name <span class="type">VARCHAR</span>(<span class="number">200</span>),</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY(id)</span><br><span class="line">);  </span><br></pre></td></tr></table></figure></li><li><p>删除主键索引：  </p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> student</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">PRIMARY</span> KEY;  </span><br></pre></td></tr></table></figure><p>修改主键索引：必须先删除掉(drop)原索引，再新建(add)索引  </p><p><strong>4.创建单列索引</strong>  </p><p>举例：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test2(</span><br><span class="line">id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">name <span class="type">CHAR</span>(<span class="number">50</span>) <span class="keyword">NULL</span>,</span><br><span class="line">INDEX single_idx_name(name(<span class="number">20</span>))</span><br><span class="line">);  </span><br></pre></td></tr></table></figure><p>该语句执行完毕之后，使用SHOW CREATE TABLE查看表结构：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> test2 ;</span><br></pre></td></tr></table></figure><p><strong>5.创建组合索引</strong>  </p><p>举例：创建表test3，在表中的id、name和age字段上建立组合索引，SQL语句如下：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test3(</span><br><span class="line">id <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">name <span class="type">CHAR</span>(<span class="number">30</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">age <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">info <span class="type">VARCHAR</span>(<span class="number">255</span>),</span><br><span class="line">INDEX multi_idx(id,name,age)</span><br><span class="line">);  </span><br></pre></td></tr></table></figure><p>该语句执行完毕之后，使用SHOW INDEX 查看：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> test3 ;</span><br></pre></td></tr></table></figure><p>由结果可以看到，id、name和age字段上已经成功建立了一个名为multi_idx的组合索引。</p><p>组合索引可起几个索引的作用，但是使用时并不是随便查询哪个字段都可以使用索引，而是遵从“最左前缀”。例如，索引可以搜索的字段组合为: (id, name, age) . (id, name)或者id。而(age)或者(name,age)组合不能使用索引查询。</p><p>在test3表中，查询id和name字段，使用EXPLAIN语句查看索引的使用情况:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> test3 <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span> <span class="keyword">AND</span> name<span class="operator">=</span> <span class="string">&#x27;songhongkang&#x27;</span>;</span><br></pre></td></tr></table></figure><p>可以看到，查询id和name字段时，使用了名称为Multildx的索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> test3 <span class="keyword">WHERE</span> name<span class="operator">=</span> <span class="string">&#x27;songhongkang&#x27;</span>;</span><br></pre></td></tr></table></figure><p>如果查询(name,age)组合或者单独查询name和age字段，会发现结果中possible_keys和key值为NULL（<strong>索引失效</strong>），并没有使用在t3表中创建的索引进行查询。(具体知识点详见 <strong>索引优化与查询优化笔记</strong>)</p><p><strong>6.创建全文索引</strong>  </p><p>FULLTEXT全文索引可以用于全文搜索，并且只为<strong>CHAR、VARCHAR和TEXT</strong>列创建索引。索引总是对整个列进行，不支持局部（前缀)索引。</p><p>举例1：创建表test4，在表中的info字段上建立全文索引，SQL语句如下：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test4(</span><br><span class="line">id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">name <span class="type">CHAR</span>(<span class="number">30</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">age <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">info <span class="type">VARCHAR</span>(<span class="number">255</span>),</span><br><span class="line">FULLTEXT INDEX futxt_idx_info(info)</span><br><span class="line">) ENGINE<span class="operator">=</span>MyISAM;  </span><br></pre></td></tr></table></figure><p>在MySQL5.7及之后版本中可以不指定最后的ENGINE了，因为在此版本中InnoDB支持全文索引。  </p><p>举例2：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> articles (</span><br><span class="line">id <span class="type">INT</span> UNSIGNED AUTO_INCREMENT <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">title <span class="type">VARCHAR</span> (<span class="number">200</span>),</span><br><span class="line">body TEXT,</span><br><span class="line">FULLTEXT index (title, body)</span><br><span class="line">) ENGINE <span class="operator">=</span> INNODB ;  </span><br></pre></td></tr></table></figure><p>创建了一个给title和body字段添加全文索引的表.</p><p>举例3：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `papers` (</span><br><span class="line">`id` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">`title` <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`content` text,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">FULLTEXT KEY `title` (`title`,`content`)</span><br><span class="line">) ENGINE<span class="operator">=</span>MyISAM <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;  </span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> papers <span class="keyword">WHERE</span> content <span class="keyword">LIKE</span> ‘<span class="operator">%</span>查询字符串<span class="operator">%</span>’;  </span><br></pre></td></tr></table></figure><p>全文索引用match+against方式查询：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> papers <span class="keyword">WHERE</span> <span class="keyword">MATCH</span>(title,content) AGAINST (‘查询字符串’);  </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">注意点:</span><br><span class="line">1. 使用全文索引前，搞清楚版本支持情况；</span><br><span class="line">2. 全文索引比 like + % 快 N 倍，但是可能存在精度问题；</span><br><span class="line">3. 如果需要全文索引的是大量数据，建议先添加数据，再创建索引。</span><br></pre></td></tr></table></figure><p><strong>7.创建空间索引</strong>  </p><p>空间索引创建中，要求空间类型的字段必须为 非空 。</p><p>举例：创建表test5，在空间类型为GEOMETRY的字段上创建空间索引，SQL语句如下：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test5(</span><br><span class="line">geo GEOMETRY <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">SPATIAL INDEX spa_idx_geo(geo)</span><br><span class="line">) ENGINE<span class="operator">=</span>MyISAM;  </span><br></pre></td></tr></table></figure><h4 id="2-在已经存在的表上创建索引"><a href="#2-在已经存在的表上创建索引" class="headerlink" title="2.在已经存在的表上创建索引"></a>2.在已经存在的表上创建索引</h4><p>在已经存在的表中创建索引可以使用<strong>ALTER TABLE</strong>语句或者<strong>CREATE INDEX</strong>语句  </p><p><strong>1.使用ALTER TABLE ADD语句创建索引</strong> </p><p>ALTER TABLE语句创建索引的基本语法如下：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ADD</span> [<span class="keyword">UNIQUE</span> <span class="operator">|</span> FULLTEXT <span class="operator">|</span> SPATIAL] [INDEX <span class="operator">|</span> KEY]</span><br><span class="line">[index_name] (col_name[length],...) [<span class="keyword">ASC</span> <span class="operator">|</span> <span class="keyword">DESC</span>]  </span><br></pre></td></tr></table></figure><p><strong>2.使用CREATE INDEX创建索引</strong> </p><p>CREATE INDEX语句可以在已经存在的表上添加索引，在MySQL中，<strong>CREATE INDEX</strong>被映射到一个<strong>ALTER TABLE</strong>语句上，基本语法结构为：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">UNIQUE</span> <span class="operator">|</span> FULLTEXT <span class="operator">|</span> SPATIAL] INDEX index_name</span><br><span class="line"><span class="keyword">ON</span> table_name (col_name[length],...) [<span class="keyword">ASC</span> <span class="operator">|</span> <span class="keyword">DESC</span>]  </span><br></pre></td></tr></table></figure><h3 id="1-3-删除索引"><a href="#1-3-删除索引" class="headerlink" title="1.3 删除索引"></a>1.3 删除索引</h3><ol><li><strong>使用ALTER TABLE删除索引</strong>  </li></ol><p>ALTER TABLE删除索引的基本语法格式如下：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">DROP</span> INDEX index_name;</span><br></pre></td></tr></table></figure><p><strong>提示</strong>        添加<strong>AUTO_INCERMENT</strong>约束字段的唯一索引<strong>不能被删除</strong>  </p><ol start="2"><li><strong>使用DROP INDEX语句删除索引</strong> </li></ol><p>DROP INDEX删除索引的基本语法格式如下：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> INDEX index_name <span class="keyword">ON</span> table_name;  </span><br></pre></td></tr></table></figure><p><strong>提示</strong>     </p><p>删除表中的列时，如果要删除的列为索引的组成部分，则该列也会从索引中删除。如果组成索引的所有列都被删除，则整个索引将被删除。</p><h2 id="2-MySQL8-0索引新特性"><a href="#2-MySQL8-0索引新特性" class="headerlink" title="2. MySQL8.0索引新特性"></a>2. MySQL8.0索引新特性</h2><h3 id="2-1-支持降序索引"><a href="#2-1-支持降序索引" class="headerlink" title="2.1 支持降序索引"></a>2.1 支持降序索引</h3><p>降序索引以降序存储键值。虽然在语法上，从MysQL 4版本开始就已经支持降序索引的语法了但实际上该DESC定义是被忽略的，直到MysQL 8.x版本才开始真正支持降序索引（仅限于InnoDB存储引擎)。</p><p>MySQL在<strong>8.0版本之前创建的仍然是升序索引，使用时进行反向扫描，这大大降低了数据库的效率</strong>。在某些场景下，降序索引意义重大。例如，如果一个查询，需要对多个列进行排序，且顺序要求不一致，那么使用降序索引将会避免数据库使用额外的文件排序操作，从而提高性能。</p><p>举例：分别在MySQL 5.7版本和MySQL 8.0版本中创建数据表ts1，结果如下：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> ts1(a <span class="type">int</span>,b <span class="type">int</span>,index idx_a_b(a,b <span class="keyword">desc</span>));  </span><br></pre></td></tr></table></figure><p>在MySQL 5.7版本中查看数据表ts1的结构，结果如下  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220119112409791.png" alt="image-20220119112409791"></p><p>从结果可以看出，索引仍然是默认的升序。在MySQL 8.0版本中查看数据表ts1的结构，结果如下：  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220119113035239.png" alt="image-20220119113035239"></p><p>从结果可以看出，索引已经是降序了。下面继续测试降序索引在执行计划中的表现。</p><p>分别在MySQL 5.7版本和MySQL 8.0版本的数据表ts1中插入800条随机数据，执行语句如下：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> ts_insert()</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">1</span>;</span><br><span class="line">WHILE i <span class="operator">&lt;</span> <span class="number">800</span></span><br><span class="line">DO</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> ts1 <span class="keyword">select</span> rand()<span class="operator">*</span><span class="number">80000</span>,rand()<span class="operator">*</span><span class="number">80000</span>;</span><br><span class="line"><span class="keyword">SET</span> i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">END</span> WHILE;</span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br><span class="line">\#调用  </span><br><span class="line"><span class="keyword">CALL</span> ts_insert();</span><br></pre></td></tr></table></figure><p>在MySQL 5.7版本中查看数据表ts1的执行计划，结果如下：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM ts1 ORDER BY a,b DESC LIMIT 5;  </span><br></pre></td></tr></table></figure><p>从结果可以看出，执行计划中扫描数为799，而且使用了Using filesort。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">提示 Using filesort是MySQL中一种速度比较慢的外部排序，能避免是最好的。多数情况下，管理员可以通过优化索引来尽量避免出现Using filesort，从而提高数据库执行速度。</span><br></pre></td></tr></table></figure><p>在MySQL 8.0版本中查看数据表ts1的执行计划。从结果可以看出，执行计划中扫描数为5，而且没有使用Using filesort。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意 降序索引只对查询中特定的排序顺序有效，如果使用不当，反而查询效率更低。例如，上述查询排序条件改为order by a desc, b desc，MySQL 5.7的执行计划要明显好于MySQL 8.0。将排序条件修改为order by a desc, b desc后，下面来对比不同版本中执行计划的效果。</span><br></pre></td></tr></table></figure><p> 在MySQL 5.7版本中查看数据表ts1的执行计划，结果如下：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> ts1 <span class="keyword">ORDER</span> <span class="keyword">BY</span> a <span class="keyword">DESC</span>,b <span class="keyword">DESC</span> LIMIT <span class="number">5</span>;  </span><br></pre></td></tr></table></figure><p>在MySQL 8.0版本中查看数据表ts1的执行计划。从结果可以看出，修改后MySQL 5.7的执行计划要明显好于MySQL 8.0。  </p><h3 id="2-2-隐藏索引"><a href="#2-2-隐藏索引" class="headerlink" title="2.2 隐藏索引"></a>2.2 隐藏索引</h3><p>在MySQL 5.7版本及之前，只能通过显式的方式删除索引。此时，如果发现删除索引后出现错误，又只能通过显式创建索引的方式将删除的索引创建回来。如果数据表中的数据量非常大，或者数据表本身比较大，这种操作就会消耗系统过多的资源，操作成本非常高。</p><p>从MySQL 8.x开始支持 <strong>隐藏索引</strong>（invisible indexes） ，只需要将待删除的索引设置为隐藏索引，使查询优化器不再使用这个索引（即使使用force index（强制使用索引），优化器也不会使用该索引），确认将索引设置为隐藏索引后系统不受任何响应，就可以彻底删除索引。 <strong>这种通过先将索引设置为隐藏索引，再删除索引的方式就是软删除</strong> 。  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220119113551533.png" alt="image-20220119113551533"></p><p>索引默认是可见的，在使用<strong>CREATE TABLE，CREATE INDEX</strong>或者ALTERTABLE等语句时可以通过VISIBLE或者INVISIBLE 关键词设置索引的可见性。</p><ol><li><strong>创建表时直接创建</strong> </li></ol><p>在MySQL中创建隐藏索引通过SQL语句INVISIBLE来实现，其语法形式如下：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tablename(</span><br><span class="line">propname1 type1[CONSTRAINT1],</span><br><span class="line">propname2 type2[CONSTRAINT2],</span><br><span class="line">……</span><br><span class="line">propnamen typen,</span><br><span class="line">INDEX [indexname](propname1 [(length)]) INVISIBLE</span><br><span class="line">);  </span><br></pre></td></tr></table></figure><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220119114052830.png" alt="image-20220119114052830"></p><p>上述语句比普通索引多了一个关键字INVISIBLE，用来标记索引为不可见索引。  </p><ol start="2"><li><strong>在已经存在的表上创建</strong>  </li></ol><p>可以为已经存在的表设置隐藏索引，其语法形式如下：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX indexname</span><br><span class="line"><span class="keyword">ON</span> tablename(propname[(length)]) INVISIBLE;  </span><br></pre></td></tr></table></figure><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220119114207883.png" alt="image-20220119114207883"></p><ol start="3"><li><strong>通过ALTER TABLE语句创建</strong>  </li></ol><p>语法形式如下：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tablename</span><br><span class="line"><span class="keyword">ADD</span> INDEX indexname (propname [(length)]) INVISIBLE;  </span><br></pre></td></tr></table></figure><ol start="4"><li><p><strong>切换索引可见状态</strong></p><p> 已存在的索引可通过如下语句切换可见状态：  </p></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tablename <span class="keyword">ALTER</span> INDEX index_name INVISIBLE; #切换成隐藏索引</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tablename <span class="keyword">ALTER</span> INDEX index_name VISIBLE; #切换成非隐藏索引  </span><br></pre></td></tr></table></figure><p>如果将index_cname索引切换成可见状态，通过explain查看执行计划，发现优化器选择了index_cname索引。  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意 当索引被隐藏时，它的内容仍然是和正常索引一样实时更新的。如果一个索引需要长期被隐藏，那么可以将其删除，因为索引的存在会影响插入、更新和删除的性能。  </span><br></pre></td></tr></table></figure><h2 id="3-索引的设计原则"><a href="#3-索引的设计原则" class="headerlink" title="3.索引的设计原则"></a>3.索引的设计原则</h2><h3 id="3-1-数据准备"><a href="#3-1-数据准备" class="headerlink" title="3.1 数据准备"></a>3.1 数据准备</h3><p>第1步：创建数据库、创建表  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE atguigudb1;</span><br><span class="line">USE atguigudb1;</span><br><span class="line">#<span class="number">1.</span>创建学生表和课程表</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `student_info` (</span><br><span class="line">`id` <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">`student_id` <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> ,</span><br><span class="line">`name` <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`course_id` <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> ,</span><br><span class="line">`class_id` <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`create_time` DATETIME <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `course` (</span><br><span class="line">`id` <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">`course_id` <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> ,</span><br><span class="line">`course_name` <span class="type">VARCHAR</span>(<span class="number">40</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;  </span><br></pre></td></tr></table></figure><p>第2步：创建模拟数据必需的存储函数  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#函数<span class="number">1</span>：创建随机产生字符串函数</span><br><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> rand_string(n <span class="type">INT</span>)</span><br><span class="line"><span class="keyword">RETURNS</span> <span class="type">VARCHAR</span>(<span class="number">255</span>) #该函数会返回一个字符串</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">DECLARE</span> chars_str <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span></span><br><span class="line"><span class="string">&#x27;abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ&#x27;</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> return_str <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">WHILE i <span class="operator">&lt;</span> n DO</span><br><span class="line"><span class="keyword">SET</span> return_str <span class="operator">=</span>CONCAT(return_str,<span class="built_in">SUBSTRING</span>(chars_str,<span class="built_in">FLOOR</span>(<span class="number">1</span><span class="operator">+</span>RAND()<span class="operator">*</span><span class="number">52</span>),<span class="number">1</span>));</span><br><span class="line"><span class="keyword">SET</span> i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">END</span> WHILE;</span><br><span class="line"><span class="keyword">RETURN</span> return_str;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;  </span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#函数<span class="number">2</span>：创建随机数函数</span><br><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> rand_num (from_num <span class="type">INT</span> ,to_num <span class="type">INT</span>) <span class="keyword">RETURNS</span> <span class="type">INT</span>(<span class="number">11</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">SET</span> i <span class="operator">=</span> <span class="built_in">FLOOR</span>(from_num <span class="operator">+</span>RAND()<span class="operator">*</span>(to_num <span class="operator">-</span> from_num<span class="operator">+</span><span class="number">1</span>)) ;</span><br><span class="line"><span class="keyword">RETURN</span> i;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;  </span><br></pre></td></tr></table></figure><p>创建函数，假如报错：</p><p>由于开启过慢查询日志bin-log, 我们就必须为我们的function指定一个参数。</p><p>主从复制，主机会将写操作记录在bin-log日志中。从机读取bin-log日志，执行语句来同步数据。如果使用函数来操作数据，会导致从机和主键操作时间不一致。所以，默认情况下，<strong>mysql不开启创建函数设置</strong>。</p><p>查看mysql是否允许创建函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#x27;log_bin_trust_function_creators&#x27;;  </span><br></pre></td></tr></table></figure><p>命令开启：允许创建函数设置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set global log_bin_trust_function_creators=1; # 不加global只是当前窗口有效。 </span><br></pre></td></tr></table></figure><p> mysqld重启，上述参数又会消失。永久方法：</p><p>windows下：my.ini[mysqld]加上：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log_bin_trust_function_creators=1  </span><br></pre></td></tr></table></figure><p>linux下：/etc/my.cnf下my.cnf[mysqld]加上：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log_bin_trust_function_creators=1  </span><br></pre></td></tr></table></figure><p>第3步：创建插入模拟数据的存储过程</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 存储过程<span class="number">1</span>：创建插入课程表存储过程</span><br><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> insert_course( max_num <span class="type">INT</span> )</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">SET</span> autocommit <span class="operator">=</span> <span class="number">0</span>; #设置手动提交事务</span><br><span class="line">    REPEAT #循环</span><br><span class="line">    <span class="keyword">SET</span> i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>; #赋值</span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> course (course_id, course_name ) <span class="keyword">VALUES</span></span><br><span class="line">    (rand_num(<span class="number">10000</span>,<span class="number">10100</span>),rand_string(<span class="number">6</span>));</span><br><span class="line">    UNTIL i <span class="operator">=</span> max_num</span><br><span class="line">    <span class="keyword">END</span> REPEAT;</span><br><span class="line">    <span class="keyword">COMMIT</span>; #提交事务</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 存储过程<span class="number">2</span>：创建插入学生信息表存储过程</span><br><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> insert_stu( max_num <span class="type">INT</span> )</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">SET</span> autocommit <span class="operator">=</span> <span class="number">0</span>;  #设置手动提交事务 </span><br><span class="line">    REPEAT #循环  </span><br><span class="line">    <span class="keyword">SET</span> i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>; #赋值</span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> student_info (course_id, class_id ,student_id ,NAME ) <span class="keyword">VALUES</span></span><br><span class="line">    (rand_num(<span class="number">10000</span>,<span class="number">10100</span>),rand_num(<span class="number">10000</span>,<span class="number">10200</span>),rand_num(<span class="number">1</span>,<span class="number">200000</span>),rand_string(<span class="number">6</span>));</span><br><span class="line">    UNTIL i <span class="operator">=</span> max_num</span><br><span class="line">    <span class="keyword">END</span> REPEAT;</span><br><span class="line">    <span class="keyword">COMMIT</span>; #提交事务</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><p>第4步：调用存储过程  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CALL</span> insert_course(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">CALL</span> insert_stu(<span class="number">1000000</span>);  </span><br></pre></td></tr></table></figure><h3 id="3-2-哪些情况适合创建索引"><a href="#3-2-哪些情况适合创建索引" class="headerlink" title="3.2 哪些情况适合创建索引"></a>3.2 哪些情况适合创建索引</h3><p>索引本身可以起到约束的作用，比如唯一索引、主键索引都是可以起到唯一性约束的，因此在我们的数据表中,如果某个字段是唯一性的，就可以直接创建唯一性索引，或者主键索引。这样可以更快速地通过该索引来确定某条记录。</p><p>例如，学生表中学号是具有唯一性的字段，为该字段建立唯一性索引可以很快确定某个学生的信息，如果使用姓名的话，可能存在同名现象，从而降低查询速度。</p><h4 id="1-字段的数值有唯一性的限制"><a href="#1-字段的数值有唯一性的限制" class="headerlink" title="1.字段的数值有唯一性的限制"></a>1.字段的数值有唯一性的限制</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">业务上具有唯一特性的字段，即使是组合字段，也必须建成唯一索引。（来源：Alibaba）</span><br><span class="line">说明：不要以为唯一索引影响了 insert 速度，这个速度损耗可以忽略，但提高查找速度是明显的。  </span><br></pre></td></tr></table></figure><h4 id="2-频繁作为-WHERE-查询条件的字段"><a href="#2-频繁作为-WHERE-查询条件的字段" class="headerlink" title="2. 频繁作为 WHERE 查询条件的字段"></a>2. 频繁作为 WHERE 查询条件的字段</h4><p>某个字段在SELECT语句的 WHERE 条件中经常被使用到，那么就需要给这个字段创建索引了。尤其是在数据量大的情况下，创建普通索引就可以大幅提升数据查询的效率。</p><p>比如student_info数据表（含100万条数据），假设我们想要查询 student_id=123110 的用户信息。  </p><h4 id="3-经常-GROUP-BY-和-ORDER-BY-的列"><a href="#3-经常-GROUP-BY-和-ORDER-BY-的列" class="headerlink" title="3.    经常 GROUP BY 和 ORDER BY 的列"></a>3.    经常 GROUP BY 和 ORDER BY 的列</h4><p>索引就是让数据按照某种顺序进行存储或检索，因此当我们使用 GROUP BY 对数据进行分组查询，或者使用 ORDER BY 对数据进行排序的时候，就需要 <strong>对分组或者排序的字段进行索引</strong> 。如果待排序的列有多个，那么可以在这些列上建立 组合索引 。  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220119121104654.png" alt="image-20220119121104654"></p><p>说明:多个单列索引在多条件查询时只会生效一个索引(MySQL会选择其中一个限制最严格的作为索引)，所以在多条件联合查询的时候最好创建联合索引。接着，我们创建联合索引(student_id, create_time)，查询时间为0.22s，效率提升了很多。</p><p>如果我们创建联合索引的顺序为(create_time, student_id)呢?运行时间为2.164s，因为在进行SELECT查询的时候，<strong>先进行GROUP BY，再对数据进行ORDER BY的操作</strong>，所以按照(student_id, create_time)这个联合索引的顺序效率是最高的。</p><h4 id="4-UPDATE、DELETE-的-WHERE-条件列"><a href="#4-UPDATE、DELETE-的-WHERE-条件列" class="headerlink" title="4. UPDATE、DELETE 的 WHERE 条件列"></a>4. UPDATE、DELETE 的 WHERE 条件列</h4><p>对数据按照某个条件进行查询后再进行 UPDATE 或 DELETE 的操作，如果对 WHERE 字段创建了索引，就能大幅提升效率。原理是因为我们需要先根据 WHERE 条件列检索出来这条记录，然后再对它进行更新或删除。<strong>如果进行更新的时候，更新的字段是非索引字段，提升的效率会更明显，这是因为非索引字段更新不需要对索引进行维护</strong>。  </p><h4 id="5-DISTINCT-字段需要创建索引"><a href="#5-DISTINCT-字段需要创建索引" class="headerlink" title="5. DISTINCT 字段需要创建索引"></a>5. DISTINCT 字段需要创建索引</h4><p>有时候我们需要对某个字段进行去重，使用 DISTINCT，那么对这个字段创建索引，也会提升查询效率。比如，我们想要查询课程表中不同的 student_id 都有哪些，如果我们没有对 student_id 创建索引，执行SQL 语句：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span>(student_id) <span class="keyword">FROM</span> `student_info`;  </span><br></pre></td></tr></table></figure><p>运行结果（600637 条记录，运行时间 0.683s ）</p><p>如果我们对 student_id 创建索引，再执行 SQL 语句：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span>(student_id) <span class="keyword">FROM</span> `student_info`;  </span><br></pre></td></tr></table></figure><p>运行结果（600637 条记录，运行时间 0.010s ）：</p><p>你能看到 SQL 查询效率有了提升，同时显示出来的 student_id 还是按照 <strong>递增的顺序</strong> 进行展示的。这是因为索引会对数据按照某种顺序进行排序，所以在去重的时候也会快很多。  </p><h4 id="6-多表-JOIN-连接操作时，创建索引注意事项"><a href="#6-多表-JOIN-连接操作时，创建索引注意事项" class="headerlink" title="6. 多表 JOIN 连接操作时，创建索引注意事项"></a>6. 多表 JOIN 连接操作时，创建索引注意事项</h4><p>首先， <strong>连接表的数量尽量不要超过 3 张</strong> ，因为每增加一张表就相当于增加了一次嵌套的循环，数量级增长会非常快，严重影响查询的效率。</p><p>其次， <strong>对 WHERE 条件创建索引</strong> ，因为 WHERE 才是对数据条件的过滤。如果在数据量非常大的情况下，没有 WHERE 条件过滤是非常可怕的。</p><p>最后， <strong>对用于连接的字段创建索引</strong> ，并且该字段在多张表中的 <strong>类型必须一致</strong> 。比如 course_id 在student_info 表和 course 表中都为 int(11) 类型，而不能一个为 int 另一个为 varchar 类型。  </p><p>举个例子，如果我们只对 student_id 创建索引，执行 SQL 语句：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> course_id, name, student_info.student_id, course_name</span><br><span class="line"><span class="keyword">FROM</span> student_info <span class="keyword">JOIN</span> course</span><br><span class="line"><span class="keyword">ON</span> student_info.course_id <span class="operator">=</span> course.course_id</span><br><span class="line"><span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;462eed7ac6e791292a79&#x27;</span>;  </span><br></pre></td></tr></table></figure><p>运行结果（1 条数据，运行时间 0.189s ）：</p><p>这里我们对 name 创建索引，再执行上面的 SQL 语句，运行时间为 0.002s 。  </p><h4 id="7-使用列的类型小的创建索引"><a href="#7-使用列的类型小的创建索引" class="headerlink" title="7. 使用列的类型小的创建索引"></a>7. 使用列的类型小的创建索引</h4><p>我们这里所说的<strong>类型大小</strong>指的就是该类型表示的<strong>数据范围的大小</strong>。</p><p>我们在定义表结构的时候要显式的指定列的类型，以整数类型为例，有<strong>TINYINT、MEDIUMINTINT 、BIGINT</strong>等，它们占用的存储空间依次递增，能表示的整数范围当然也是依次递增。如果我们想要对某个整数列建立索引的话，<strong>在表示的整数范围允许的情况下，尽量让索引列使用较小的类型</strong>，比如我们能使用<strong>INT</strong>就不要使用BIGINT，能使用<strong>MEDIUMINT</strong>就不要使用<strong>INT</strong>。这是因为:</p><p><strong>BINGINT:</strong>    从 <strong>-2^63</strong> (-9223372036854775808) 到 <strong>2^63-1</strong> (9223372036854775807) 的整型数据（所有数字），无符号的范围是0到</p><p>18446744073709551615。一位为 <strong>8</strong> 个字节。</p><p><strong>INT :</strong>     <strong>-2^31 (-2,147,483,648) 到 2^31 – 1 (2,147,483,647)</strong> 的整型数据（所有数字），存储大小为<strong>4</strong>个字节；</p><p><strong>MEDIUMINT:</strong>    一个中等大小整数，有符号的范围是**-8388608到8388607<strong>，无符号的范围是0到16777215。 一位大小为</strong>3**个字节。</p><p><strong>SMALLINT:</strong>    一个小整数。有符号的范围是**-2^15 (-32,768) 到 2^15 - 1 (32,767)** 的整型数据，无符号的范围是<strong>0到65535</strong>。一位大小为 <strong>2</strong> 个字节。</p><p><strong>TINYINT:</strong>     带符号的范围是**-128到127<strong>，无符号的范围是</strong>0到255**。</p><ul><li>数据类型越小，在查询时进行的比较操作越快。</li><li>数据类型越小，索引占用的存储空间就越少，<strong>在一个数据页内就可以放下更多的记录</strong>，从而<strong>减少磁盘I/0带来的性能损耗</strong>，也就意味着可以把更多的数据页缓存在内存中，从而加快读写效率。</li></ul><p>这个建议对于表的<strong>主键来说更加适用</strong>，因为不仅是聚簇索引中会存储主键值，其他所有的<strong>二级索引的节点处都会存储一份记录的主键值</strong>，如果主键使用更小的数据类型，也就意味着节省更多的存储空间和更高效的IO。</p><h4 id="8-使用字符串前缀创建索引"><a href="#8-使用字符串前缀创建索引" class="headerlink" title="8. 使用字符串前缀创建索引"></a>8. 使用字符串前缀创建索引</h4><p>假设我们的字符串很长，那存储一个字符串就需要占用很大的存储空间。在我们需要为这个字符串列建立索引时，那就意味着在对应的B+树中有这么两个问题:</p><ul><li>B+树索引中的记录需要把该列的完整字符串存储起来，更费时。而且<strong>字符串越长，在索引中占用的存储空间越大</strong>。</li><li>如果B+树索引中索引列存储的字符串很长，那在做字符串<strong>比较时会占用更多的时间</strong>。</li></ul><p>我们可以通过截取字段的前面一部分内容建立索引，这个就叫<strong>前缀索引</strong>。这样在查找记录时虽然不能精确的定位到记录的位置，但是能定位到相应前缀所在的位置，然后根据前缀相同的记录的主键值回表查询完整的字符串值。既<strong>节约空间</strong>，又<strong>减少了字符串的比较时间</strong>，还大体能解决排序的问题。</p><p>例如，TEXT和BLOG类型的字段，进行全文检索会很浪费时间，如果只检索字段前面的若干字符，这样可以提高检索速度。</p><p>创建一张商户表，因为地址字段比较长，在地址字段上建立前缀索引  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> shop(address <span class="type">varchar</span>(<span class="number">120</span>) <span class="keyword">not</span> <span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> shop <span class="keyword">add</span> index(address(<span class="number">12</span>));  </span><br></pre></td></tr></table></figure><p>问题是，截取多少呢？截取得多了，达不到节省索引存储空间的目的；截取得少了，重复内容太多，字段的散列度(选择性)会降低。怎么<strong>计算不同的长度的选择性呢</strong>？  </p><p>先看一下字段在全部数据中的选择度：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> address) <span class="operator">/</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> shop;  </span><br></pre></td></tr></table></figure><p>通过不同长度去计算，与全表的选择性对比：  </p><p>公式：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(列名, 索引长度))<span class="operator">/</span><span class="built_in">count</span>(<span class="operator">*</span>)  </span><br></pre></td></tr></table></figure><p>例如：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(address,<span class="number">10</span>)) <span class="operator">/</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> sub10, <span class="comment">-- 截取前10个字符的选择度</span></span><br><span class="line"><span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(address,<span class="number">15</span>)) <span class="operator">/</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> sub11, <span class="comment">-- 截取前15个字符的选择度</span></span><br><span class="line"><span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(address,<span class="number">20</span>)) <span class="operator">/</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> sub12, <span class="comment">-- 截取前20个字符的选择度</span></span><br><span class="line"><span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(address,<span class="number">25</span>)) <span class="operator">/</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> sub13 <span class="comment">-- 截取前25个字符的选择度</span></span><br><span class="line"><span class="keyword">from</span> shop;  </span><br></pre></td></tr></table></figure><p>越接近 1 越好！！</p><p><strong>引申另一个问题：索引列前缀对排序的影响</strong></p><p>如果使用了索引列前缀，比方说前边只把address列的前12个字符放到了二级索引中，下边这个查询可能就有点儿尴尬了:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> shop <span class="keyword">ORDER</span> <span class="keyword">BY</span> addressLIMIT <span class="number">12</span>;</span><br></pre></td></tr></table></figure><p>因为二级索引中不包含完整的address列信息，所以无法对前12个字符相同，后边的字符不同的记录进行排序，也就是使用索引列前缀的方式<strong>无法支持使用索引排序</strong>，只能使用<strong>文件排序</strong>。</p><p><strong>拓展：Alibaba《Java开发手册》</strong></p><p>【 强制 】在 varchar 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据实际文本<br>区分度决定索引长度。</p><p>说明：索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为 20 的索引，区分度会 <strong>高达</strong><br><strong>90% 以上</strong> ，可以使用<code> count(distinct left(列名, 索引长度)) / count(*)</code>的区分度来确定。  </p><h4 id="9-区分度高-散列性高-的列适合作为索引"><a href="#9-区分度高-散列性高-的列适合作为索引" class="headerlink" title="9. 区分度高(散列性高)的列适合作为索引"></a>9. 区分度高(散列性高)的列适合作为索引</h4><p><strong>列的基数</strong>指的是<strong>某一列中不重复数据的个数</strong>，比方说某个列包含值2，5，8，2，5，8，2，5，8，虽然有9条记录，但该列的基数却是3。也就是说，<strong>在记录行数一定的情况下，列的基数越大，该列中的值越分散;列的基数越小，该列中的值越集中</strong>。这个列的基数指标非常重要，直接影响我们是否能有效的利用索引。最好为列的基数大的列建立索引，为基数太小列的建立索引效果可能不好。</p><p>可以使用公式 <code>select count(distinct a)/count(*) from t1</code>计算区分度，越接近1越好。一般超过33%就算是比较高效的索引了。</p><p>拓展:联合索引把区分度高(散列性高)的列放在前面。</p><h4 id="10-使用最频繁的列放到联合索引的左侧"><a href="#10-使用最频繁的列放到联合索引的左侧" class="headerlink" title="10. 使用最频繁的列放到联合索引的左侧"></a>10. 使用最频繁的列放到联合索引的左侧</h4><p>这样也可以较少的建立一些索引。同时，由于”最左前缀原则”，可以增加联合索引的使用率。  </p><h4 id="11-在多个字段都要创建索引的情况下，联合索引优于单值索引"><a href="#11-在多个字段都要创建索引的情况下，联合索引优于单值索引" class="headerlink" title="11. 在多个字段都要创建索引的情况下，联合索引优于单值索引"></a>11. 在多个字段都要创建索引的情况下，联合索引优于单值索引</h4><h3 id="3-3限制索引的数目"><a href="#3-3限制索引的数目" class="headerlink" title="3.3限制索引的数目"></a>3.3限制索引的数目</h3><h3 id="3-4-哪些情况不适合创建索引"><a href="#3-4-哪些情况不适合创建索引" class="headerlink" title="3.4 哪些情况不适合创建索引"></a>3.4 哪些情况不适合创建索引</h3><h4 id="1-在where中使用不到的字段，不要设置索引"><a href="#1-在where中使用不到的字段，不要设置索引" class="headerlink" title="1. 在where中使用不到的字段，不要设置索引"></a>1. 在where中使用不到的字段，不要设置索引</h4><h4 id="2-数据量小的表最好不要使用索引"><a href="#2-数据量小的表最好不要使用索引" class="headerlink" title="2. 数据量小的表最好不要使用索引"></a>2. 数据量小的表最好不要使用索引</h4><p>结论：在数据表中的数据行数比较少的情况下，比如不到 <strong>1000</strong> 行，是不需要创建索引的。</p><h4 id="3-有大量重复数据的列上不要建立索引"><a href="#3-有大量重复数据的列上不要建立索引" class="headerlink" title="3. 有大量重复数据的列上不要建立索引"></a>3. 有大量重复数据的列上不要建立索引</h4><p> 举例1：要在 100 万行数据中查找其中的 50 万行（比如性别为男的数据），一旦创建了索引，你需要先访问 50 万次索引，然后再访问 50 万次数据表，这样加起来的开销比不使用索引可能还要大。</p><p>举例2：假设有一个学生表，学生总数为 100 万人，男性只有 10 个人，也就是占总人口的 10 万分之 1。学生表 student_gender 结构如下。其中数据表中的 student_gender 字段取值为 0 或 1，0 代表女性，1 代表男性。  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> student_gender(</span><br><span class="line">student_id <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">student_name <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">student_gender TINYINT(<span class="number">1</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY(student_id)</span><br><span class="line">)ENGINE <span class="operator">=</span> INNODB;  </span><br></pre></td></tr></table></figure><p>如果我们要筛选出这个学生表中的男性，可以使用：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student_gender <span class="keyword">WHERE</span> student_gender <span class="operator">=</span> <span class="number">1</span> ;</span><br></pre></td></tr></table></figure><p>结论：当数据重复度大，比如 高于 10% 的时候，也不需要对这个字段使用索引。  </p><h4 id="4-避免对经常更新的表创建过多的索引"><a href="#4-避免对经常更新的表创建过多的索引" class="headerlink" title="4. 避免对经常更新的表创建过多的索引"></a>4. 避免对经常更新的表创建过多的索引</h4><h4 id="5-不建议用无序的值作为索引"><a href="#5-不建议用无序的值作为索引" class="headerlink" title="5. 不建议用无序的值作为索引"></a>5. 不建议用无序的值作为索引</h4><p>例如身份证、UUID(在索引比较时需要转为ASCII，并且插入时可能造成页分裂)、MD5、HASH、无序长字符串等。  </p><h4 id="6-删除不再使用或者很少使用的索引"><a href="#6-删除不再使用或者很少使用的索引" class="headerlink" title="6. 删除不再使用或者很少使用的索引"></a>6. 删除不再使用或者很少使用的索引</h4><h4 id="7-不要定义冗余或重复的索引"><a href="#7-不要定义冗余或重复的索引" class="headerlink" title="7. 不要定义冗余或重复的索引"></a>7. 不要定义冗余或重复的索引</h4><p><strong>① 冗余索引</strong>  </p><p>举例：建表语句如下  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> person_info(</span><br><span class="line">id <span class="type">INT</span> UNSIGNED <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">name <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">birthday <span class="type">DATE</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">phone_number <span class="type">CHAR</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">country <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (id),</span><br><span class="line">KEY idx_name_birthday_phone_number (name(<span class="number">10</span>), birthday, phone_number),</span><br><span class="line">KEY idx_name (name(<span class="number">10</span>))</span><br><span class="line">);  </span><br></pre></td></tr></table></figure><p>我们知道，通过<code> idx_name_birthday_phone_number (联合索引)</code> 索引就可以对<code>name</code>列进行快速搜索，再创建一个专门针对<code>name</code>列的索引就算是一个 <strong>冗余索引</strong> ，维护这个索引只会增加维护的成本，并不会对搜索有什么好处。  </p><p><strong>② 重复索引</strong>  </p><p>另一种情况，我们可能会对某个列 <strong>重复建立索引</strong> ，比方说这样：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> repeat_index_demo (</span><br><span class="line">col1 <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">col2 <span class="type">INT</span>,</span><br><span class="line"><span class="keyword">UNIQUE</span> uk_idx_c1 (col1),</span><br><span class="line">INDEX idx_c1 (col1)</span><br><span class="line">);  </span><br></pre></td></tr></table></figure><p>我们看到，col1 既是主键、又给它定义为一个唯一索引，还给它定义了一个普通索引，可是主键本身就会生成聚簇索引，所以定义的唯一索引和普通索引是重复的，这种情况要避免。  </p>]]></content>
      
      
      <categories>
          
          <category> database </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>索引</title>
      <link href="/2022/01/15/%E7%B4%A2%E5%BC%95/"/>
      <url>/2022/01/15/%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<h1 id="1-为什么使用索引"><a href="#1-为什么使用索引" class="headerlink" title="1.为什么使用索引"></a>1.为什么使用索引</h1><p>索引是存储引擎用于快速找到数据记录的一种数据结构，就好比一本教课书的目录部分，通过目录中找到对应文章的页码，便可快速定位到需要的文章。MySQL中也是一样的道理，进行数据查找时，首先查查询条件是否命中某条索引，符合则<strong>通过索引查找</strong>相关数据，如果不符合则需要<strong>全表扫描</strong>，即需要一条一条地查找记录，直到找到与条件符合的记录。</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220115100536189.png" alt="image-20220115100536189"></p><p>如上图所示，数据库没有索引的情况下，数据 <strong>分布在硬盘不同的位置上面</strong>，读取数据时，摆臂需要前后摆动查找数据，这样操作非常消耗时间。如果数据 <strong>顺序摆放</strong>，那么也需要从1到6行按顺序读取，这样就相当于进行了6次I0操作，<strong>依旧非常耗时</strong>。如果我们不借助任何索引结构帮助我们快速定位数据的话，我们查找Col2=89这条记录，就要逐行去查找、去比较。从Col 2= 34开始，进行比较，发现不是，继续下一行。我们当前的表只有不到10行数据，但如果表很大的话，有<strong>上千万条数据</strong>，就意味着要做很多很多次磁盘I/0才能找到。现在要查找Col 2=89这条记录。CPu必须先去磁盘查找这条记录，找到之后加载到内存，再对数据进行处理。这个过程最耗时间的就是磁盘I/o(涉及到磁盘的旋转时间（速度较快)、磁头的寻道时间(速度慢、费时))</p><p>假如给数据使用 **二叉树 **这样的数据结构进行存储，如下图所示</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220115101032427.png" alt="image-20220115101032427"></p><p>对字段Col2添加了索引，就相当于在硬盘上为Col 2维护了一个索引的数据结构，即这个 <strong>二叉搜索树</strong>。二叉搜索树的每个结点存储的是<strong>（K，V)结构</strong>，key是Col2，value是该key 所在行的文件指针(地址)。比如:该二叉搜索树的根节点就是: <strong>(34,0x07）</strong>。现在对Col2添加了索引，这时再去查找Col 2=89这条记录的时候会先去查找该二叉搜索树（二叉树的遍历查找)。读34到内存，89&gt;34; 继续右侧数据，读89到内存，89 == 89; 找到数据返回。找到之后就根据当前结点的value快速定位到要查找的记录对应的地址。我们可以发现只需要<strong>查找两次</strong>就可以定位到记录的地址，查询速度就提高了。</p><p>这就是我们为什么要建索引，目的就是为了<strong>减少磁盘I/0的次数</strong>，加快查询速率。</p><h1 id="2-索引及其优缺点"><a href="#2-索引及其优缺点" class="headerlink" title="2.索引及其优缺点"></a>2.索引及其优缺点</h1><p>MySQL官方对索引的定义为：<strong>索引（Index）是帮助MySQL高效获取数据的数据结构</strong>。  </p><p><strong>索引的本质</strong>：<strong>索引是数据结构</strong>。你可以简单理解为“排好序的快速查找数据结构”，满足特定查找算法。这些数据结构以某种方式指向数据， 这样就可以在这些数据结构的基础上实现 <strong>高级查找算法</strong> 。  </p><p><strong>索引是在存储引擎中实现</strong>的，因此每种存储引擎的索引不一定完全相同，并且每种存储引擎不一定支持所有索引类型。同时，存储引擎可以定义每个表的<strong>最大索引数</strong>和<strong>最大索引长度</strong>。所有存储引擎支持每个表至少<strong>16</strong>个索引，总索引长度至少为256字节。有些存储引擎支持更多的索引数和更大的索引长度。|</p><h2 id="2-1-优点"><a href="#2-1-优点" class="headerlink" title="2.1 优点"></a>2.1 优点</h2><p>（1）类似大学图书馆建书目索引，提高数据检索的效率，降低 <strong>数据库的IO成本</strong> ，这也是创建索引最主要的原因。 </p><p>（2）通过创建唯一索引，可以保证数据库表中每一行 <strong>数据的唯一性</strong> 。 </p><p>（3）在实现数据的参考完整性方面，可以 <strong>加速表和表之间的连接</strong> 。换句话说，对于有依赖关系的子表和父表联合查询时，可以提高查询速度。 </p><p>（4）在使用分组和排序子句进行数据查询时，可以显著 <strong>减少查询中分组和排序的时间</strong> ，降低了CPU的消耗。  </p><h2 id="2-2-缺点"><a href="#2-2-缺点" class="headerlink" title="2.2 缺点"></a>2.2 缺点</h2><p>增加索引也有许多不利的方面，主要表现在如下几个方面： </p><p>（1）创建索引和维护索引要 <strong>耗费时间</strong> ，并且随着数据量的增加，所耗费的时间也会增加。 </p><p>（2）索引需要占 <strong>磁盘空间</strong> ，除了数据表占数据空间之外，每一个索引还要占一定的物理空间， <strong>存储在磁盘上</strong> ，如果有大量的索引，索引文件就可能比数据文件更快达到最大文件尺寸。 </p><p>（3）虽然索引大大提高了查询速度，同时却会 <strong>降低更新表的速度</strong> 。当对表<br>中的数据进行增加、删除和修改的时候，索引也要动态地维护，这样就降低了数据的维护速度。因此，选择使用索引时，需要综合考虑索引的优点和缺点。  </p><p>因此，选择使用索引时，需要综合考虑索引的优点和缺点。  </p><p>提示:<br>索引可以提高查询的速度，但是会影响插入记录的速度。这种情况下，最好的办法是先删除表中的索引，然后插入数据，插入完成后再创建索引。</p><h1 id="3-InnoDB中索引的推演"><a href="#3-InnoDB中索引的推演" class="headerlink" title="3.InnoDB中索引的推演"></a>3.InnoDB中索引的推演</h1><h2 id="3-1-索引之前的查找"><a href="#3-1-索引之前的查找" class="headerlink" title="3.1 索引之前的查找"></a>3.1 索引之前的查找</h2><p>先来看一个精确匹配的例子：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> [列名列表] <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 列名 <span class="operator">=</span> xxx;  </span><br></pre></td></tr></table></figure><p>1.<strong>在一个页中的查找</strong></p><p>假设目前表中的记录比较少，所有的记录都可以被存放到一个页中，在查找记录的时候可以根据搜索条件的不同分为两种情况:</p><ul><li><strong>以主键为搜索条件</strong></li></ul><p>​    可以在页目录中使用<strong>二分法</strong>快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录。</p><ul><li><strong>以其他列作为搜索条件</strong></li></ul><p>​    因为在数据页中并没有对非主键列建立所谓的页目录，所以我们无法通过<strong>二分法</strong>快速定位相应的槽。这种情况下只能从<strong>最小记录</strong>开始<strong>依次遍历</strong>单链表中的每条记录，然后对比每条记录是不是符合搜索条件。很显然，这种查找的效率是非常低的。</p><p>2.<strong>在很多页中查找</strong></p><p>大部分情况下我们表中存放的记录都是非常多的，需要好多的数据页来存储这些记录。在很多页中查找记录的话可以分为两个步骤:</p><p>​    1.定位到记录所在的页。</p><p>​    2.从所在的页内中查找相应的记录。</p><p>在没有索引的情况下，不论是根据主键列或者其他列的值进行查找，由于我们<strong>并不能快速的定位到记录所在的页</strong>，所以只能 <strong>从第一个页</strong> 沿着 <strong>双向链表</strong> 一直往下找，在每一个页中根据我们上面的查找方式去查找指定的记录。因为要遍历所有的数据页，所以这种方式显然是 <strong>超级耗时</strong> 的。如果一个表有一亿条记录呢？此时 <strong>索引</strong> 应运而生。  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220115102738099.png" alt="image-20220115102738099"></p><h2 id="3-2-设计索引"><a href="#3-2-设计索引" class="headerlink" title="3.2 设计索引"></a>3.2 设计索引</h2><p>建一个表：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> index_demo(</span><br><span class="line"></span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>c1 <span class="type">INT</span>, </span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>c2 <span class="type">INT</span>,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>c3 <span class="type">CHAR</span>(<span class="number">1</span>),</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span><span class="keyword">PRIMARY</span> KEY(c1) <span class="operator">|</span></span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> ) ROW_FORMAT <span class="operator">=</span> Compact;</span><br></pre></td></tr></table></figure><p>这个新建的 <strong>index_demo</strong> 表中有2个INT类型的列，1个CHAR(1)类型的列，而且我们规定了c1列为主键，这个表使用 <strong>Compact</strong> 行格式来实际存储记录的。这里我们简化了index_demo表的行格式示意图：  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220115103558132.png" alt="image-20220115103558132"></p><p>我们只在示意图里展示记录的这几个部分：</p><ul><li><strong>record_type</strong> ：记录头信息的一项属性，表示记录的类型， 0 表示普通记录、 2 表示最小记录、 3 表示最大记录、 1 暂时还没用过，下面讲。</li><li>next_record ：记录头信息的一项属性，表示下一条地址相对于本条记录的地址偏移量，我们用箭头来表明下一条记录是谁。</li><li><strong>各个列的值</strong> ：这里只记录在 index_demo 表中的三个列，分别是 c1 、 c2 和 c3 。</li><li><strong>其他信息</strong> ：除了上述3种信息以外的所有信息，包括其他隐藏列的值以及记录的额外信息。将记录格式示意图的其他信息项暂时去掉并把它竖起来的效果就是这样：</li></ul><p>将记录格式示意图的其他信息项暂时去掉并把它竖起来的效果就是这样：  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220115103713866.png" alt="image-20220115103713866"></p><p>把一些记录放到页里的示意图就是：  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220115103726133.png" alt="image-20220115103726133"></p><h3 id="1-一个简单的索引设计方案"><a href="#1-一个简单的索引设计方案" class="headerlink" title="1. 一个简单的索引设计方案"></a>1. 一个简单的索引设计方案</h3><p>我们在根据某个搜索条件查找一些记录时为什么要遍历所有的数据页呢？因为各个页中的记录并没有规律，我们并不知道我们的搜索条件匹配哪些页中的记录，所以不得不依次遍历所有的数据页。所以如果我们 <strong>想快速的定位到需要查找的记录在哪些数据页</strong> 中该咋办？我们可以为快速定位记录所在的数据页而 <strong>建立一个目录</strong> ，建这个目录必须完成下边这些事  </p><ul><li>下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值。  </li></ul><p>假设:每个数据页最多能存放3条记录(实际上一个数据页非常大，可以存放下好多记录)。有了这个假设之后我们向index_demo表插入3条记录:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> index_demo <span class="keyword">VALUES</span>(<span class="number">1</span>，<span class="number">4</span>，<span class="string">&#x27;u&#x27;</span>)，(<span class="number">3</span>， <span class="number">9</span>，<span class="string">&#x27;d&#x27;</span>)，(<span class="number">5</span> <span class="number">3</span>， <span class="string">&#x27;y&#x27;</span>);</span><br><span class="line">Query oK,<span class="number">3</span> <span class="keyword">rows</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line">Records : <span class="number">3</span> Duplicates: <span class="number">0</span> warnings : <span class="number">0</span></span><br></pre></td></tr></table></figure><p>那么这些记录已经按照主键值的大小串联成一个单向链表了，如图所示：</p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220115104243828.png" alt="image-20220115104243828" style="zoom:67%;" /><p>从图中可以看出来, <strong>index_demo</strong>表中的3条记录都被插入到了编号为10的数据页中了。此时我们再来插入一条记录:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> index_demo <span class="keyword">VALUES</span>(<span class="number">4</span>,<span class="number">4</span>,<span class="string">&#x27;a&#x27;</span>);</span><br></pre></td></tr></table></figure><p> <img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220115104413616.png" alt="image-20220115104413616"></p><p>注意，新分配的<strong>数据页编号</strong>可能并不是连续的。它们只是通过维护着上一个页和下一个页的编号而建立了<strong>链表</strong>关系。另外，<strong>页10</strong>中用户记录最大的主键值是5，而<strong>页28</strong>中有一条记录的主键值是4，因为<strong>5 &gt;4</strong>，所以这就不符合下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值的要求，所以在插入主键值为4的记录的时候需要伴随着一次<strong>记录移动</strong>，也就是把主键值为5的记录移动到页28中，然后再把主键值为4的记录插入到页10中，这个过程的示意图如下:</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220115104730152.png" alt="image-20220115104730152"></p><p>这个过程表明了在对页中的记录进行增删改操作的过程中，我们必须通过一些诸如记录移动的操作来始终保证这个状态一直成立:下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值。这个过程我们称为<strong>页分裂</strong>。</p><ul><li>给所有的页建立一个目录项  </li></ul><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220115105020632.png" alt="image-20220115105020632"></p><p>所以我们为上边几个页做好的目录就像这样子：  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220115104858560.png" alt="image-20220115104858560"></p><p>以 页28 为例，它对应 目录项2 ，这个目录项中包含着该页的页号 28 以及该页中用户记录的最小主键值 5 。我们只需要把几个目录项在物理存储器上连续存储（比如：数组），就可以实现根据主键值快速查找某条记录的功能了。比如：查找主键值为 20 的记录，具体查找过程分两步：</p><ol><li><p>先从<strong>目录项</strong>中根据 二分法 快速确定出主键值为 20 的记录在 目录项3 中（因为 12 &lt; 20 &lt;209 ），它对应的页是 页9 。</p></li><li><p>再根据前边说的在页中查找记录的方式去 页9 中定位具体的记录。</p></li></ol><p>至此，针对数据页做的简易目录就搞定了。这个目录有一个别名，称为 <strong>索引</strong> 。  </p><h3 id="2-InnoDB中的索引方案"><a href="#2-InnoDB中的索引方案" class="headerlink" title="2.InnoDB中的索引方案"></a>2.InnoDB中的索引方案</h3><p><strong>① 迭代1次：目录项纪录的页</strong>  </p><p>我们把前边使用到的目录项放到数据页中的样子就是这样：  </p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220117111135749.png" alt="image-20220117111135749" style="zoom: 67%;" /><p>从图中可以看出来，我们新分配了一个编号为30的页来专门存储目录项记录。这里再次强调 目录项记录和普通的 用户记录 的不同点：  </p><ul><li><strong>目录项记录</strong> 的<code> record_type</code> 值是 <strong>1</strong>，而 普通用户记录 的<code> record_type</code> 值是 <strong>0</strong>。</li><li>目录项记录只有 <strong>主键值和页的编号</strong> 两个列，而普通的用户记录的列是用户自己定义的，可能包含** <strong>很</strong><br>多列** ，另外还有<code>InnoDB</code>自己添加的隐藏列。</li><li>了解：记录头信息里还有一个叫 min_rec_mask 的属性，只有在存储 目录项记录 的页中的主键值<br>最小的 目录项记录 的 min_rec_mask 值为 1 ，其他别的记录的 min_rec_mask 值都是 0 。  </li></ul><p>相同点：两者用的是一样的数据页，都会为主键值生成 Page Directory （页目录），从而在按照主键值进行查找时可以使用 <strong>二分法</strong> 来加快查询速度。  </p><p>现在以查找主键为 20 的记录为例，根据某个主键值去查找记录的步骤就可以大致拆分成下边两步：  </p><ol><li>先到存储 <strong>目录项记录</strong> 的页，也就是页30中通过 <strong>二分法</strong> 快速定位到对应目录项，因为 12 &lt; 20 &lt; 209 ，所以定位到对应的记录所在的页就是页 <strong>9</strong>。</li><li>再到存储用户记录的页9中根据 <strong>二分法</strong> 快速定位到主键值为 20 的用户记录  </li></ol><p><strong>② 迭代2次：多个目录项纪录的页</strong>  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220117111536071.png" alt="image-20220117111536071"></p><p>从图中可以看出，我们插入了一条主键值为320的用户记录之后需要两个新的数据页：</p><ul><li>为存储该用户记录而新生成了 页31 。</li><li>因为原先存储目录项记录的 页30的容量已满 （我们前边假设只能存储4条目录项记录），所以不得<br>不需要一个新的 页32 来存放 页31 对应的目录项。  </li></ul><p>现在因为存储目录项记录的页不止一个，所以如果我们想根据主键值查找一条用户记录大致需要3个步<br>骤，以查找主键值为 20 的记录为例：  </p><ul><li><ol><li>确定 <strong>目录项记录页</strong><br>我们现在的存储目录项记录的页有两个，即 页30 和 页32 ，又因为页30表示的目录项的主键值的范围是 [1, 320) ，页32表示的目录项的主键值不小于 <strong>320</strong> ，所以主键值为 <strong>20</strong> 的记录对应的目录项记录在 页30 中。</li></ol></li><li><ol start="2"><li>通过目录项记录页 <strong>确定用户记录真实所在的页 。</strong><br>在一个存储 <strong>目录项记录</strong> 的页中通过主键值定位一条目录项记录的方式说过了。</li></ol></li><li><ol start="3"><li>在真实存储用户记录的页中定位到具体的记录。  </li></ol></li></ul><p><strong>③ 迭代3次：目录项记录页的目录页</strong>  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220117111848240.png" alt="image-20220117111848240"></p><p>如图，我们生成了一个存储更高级目录项的 <strong>页33</strong> ，这个页中的两条记录分别代表页30和页32，如果用户记录的主键值在 <strong>[1, 320)</strong> 之间，则到页30中查找更详细的目录项记录，如果主键值 不小于320 的话，就到页32中查找更详细的目录项记录。</p><p>我们可以用下边这个图来描述它：  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220117111947930.png" alt="image-20220117111947930"></p><p>这个数据结构，它的名称是 <strong>B+树</strong>  。</p><p><strong>④ B+Tree</strong>  </p><p>一个B+树的节点其实可以分成好多层，规定最下边的那层，也就是存放我们用户记录的那层为第 0 层，之后依次往上加。之前我们做了一个非常极端的假设：存放用户记录的页 最多存放3条记录 ，存放目录项记录的页 最多存放4条记录 。其实真实环境中一个页存放的记录数量是非常大的，假设所有存放用户记录的叶子节点代表的数据页可以存放 100条用户记录 ，所有存放目录项记录的内节点代表的数据页可以存放 1000条目录项记录 ，那么：  </p><ul><li>如果B+树只有1层，也就是只有1个用于存放用户记录的节点，最多能存放 100 条记录  </li><li>如果B+树有2层，最多能存放 1000×100=10,0000 条记录。</li><li>如果B+树有3层，最多能存放 1000×1000×100=1,0000,0000 条记录。</li><li>如果B+树有4层，最多能存放 1000×1000×1000×100=1000,0000,0000 条记录。相当多的记<br>录！！！  </li></ul><p>你的表里能存放 100000000000 条记录吗？所以一般情况下，我们 <strong>用到的B+树都不会超过4层</strong> ，那我们<br>通过主键值去查找某条记录<strong>最多只需要做4个页面内的查找</strong>（查找3个目录项页和一个用户记录页），又<br>因为在每个页面内有所谓的 Page Directory （页目录），所以在页面内也可以通过 <strong>二分法</strong> 实现快速<br>定位记录 。</p><h2 id="3-3-常见索引概念"><a href="#3-3-常见索引概念" class="headerlink" title="3.3 常见索引概念"></a>3.3 常见索引概念</h2><p>索引按照物理实现方式，索引可以分为 2 种：聚簇（聚集）和非聚簇（非聚集）索引。我们也把非聚集</p><p>索引称为二级索引或者辅助索引。  </p><h3 id="1-聚簇索引"><a href="#1-聚簇索引" class="headerlink" title="1.聚簇索引"></a>1.聚簇索引</h3><p><strong>索引即数据，数据即索引。</strong></p><p>特点：</p><ol><li>使用记录<strong>主键值</strong>的大小进行记录和页的排序，这包括三个方面的含义：</li></ol><ul><li>页内 的记录是按照主键的大小顺序排成一个 <strong>单向链表</strong> 。</li><li>各个存放 <strong>用户记录的页</strong> 也是根据页中用户记录的主键大小顺序排成一个 双向链表 。</li><li>存放 <strong>目录项记录的页</strong> 分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个 <strong>双向链表</strong> 。</li></ul><ol start="2"><li>B+树的 叶子节点 存储的是完整的用户记录。</li></ol><p>所谓完整的用户记录，就是指这个记录中存储了所有列的值（包括隐藏列）。  </p><p><strong>优点：</strong></p><ul><li>数据访问更快 ，因为<strong>聚簇索引将索引和数据保存在同一个B+树中</strong>，因此从聚簇索引中获取数据比非聚簇索引更快</li><li>聚簇索引对于<strong>主键的 排序查找 和 范围查找 速度非常快</strong></li><li>按照聚簇索引排列顺序，查询显示一定范围数据的时候，由于数据都是紧密相连，数据库不用从多个数据块中提取数据，所以 <strong>节省了大量的io操作</strong> 。  </li></ul><p>缺点：</p><ul><li><strong>插入速度严重依赖于插入顺序</strong> ，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们<strong>一般都会定义一个自增的ID列为主键</strong></li><li><strong>更新主键的代价很高</strong> ，因为将会导致被更新的行移动。因此，对于InnoDB表，我们<strong>一般定义主键为不可更新</strong></li><li>二级索引访问需要两次索引查找 ，第一次找到主键值，第二次根据主键值找到行数据  </li></ul><h3 id="2-二级索引（辅助索引、非聚簇索引）"><a href="#2-二级索引（辅助索引、非聚簇索引）" class="headerlink" title="2. 二级索引（辅助索引、非聚簇索引）"></a>2. 二级索引（辅助索引、非聚簇索引）</h3><p>上边介绍的<strong>聚簇索引</strong>只能在<strong>搜索条件是主键值时</strong>才能发挥作用，因为B+树中的数据都是按照主键进行排序的。那如果我们想以别的列作为搜索条件该怎么办呢? 肯定不能是从头到尾沿着链表依次遍历记录一遍</p><p>答案:我们可以<strong>多建几棵B+树</strong>，不同的B+树中的数据采用不同的排序规则。比方说我们用 <strong>c2</strong> 列的大小作为数据页、页中记录的排序规则，再建一棵B+树，效果如下图所示:</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220117112703079.png" alt="image-20220117112703079"></p><p>这个B+树与上边介绍的聚簇索引有几处不同：  </p><ul><li><p>使用记录c2列的大小进行记录和页的排序，这包括三个方面的含义:</p><ul><li><p>页内的记录是按照c2列的大小顺序排成一个<strong>单向链表</strong>。</p></li><li><p>各个存放用户记录的页也是根据页中记录的c2列大小顺序排成一个<strong>双向链表</strong>。</p></li><li><p>存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的c2列大小顺序排成一个<strong>双向链表</strong>。</p></li></ul></li><li><p>B+树的叶子节点存储的并不是完整的用户记录，而只是<strong>c2列+主键</strong>这两个列的值。</p></li><li><p>目录项记录中不再是<strong>主键+页号</strong>的搭配，而变成了<strong>c2列+页号</strong>的搭配。</p></li></ul><p>所以如果我们现在想通过c2列的值查找某些记录的话就可以使用我们刚刚建好的这个B+树了。以查找c2列的值为 <strong>4</strong> 的记录为例，查找过程如下:</p><p>1.确定<strong>目录项记录页</strong></p><p>根据<strong>根页面</strong>，也就是页44，可以快速定位到<strong>目录项记录</strong>所在的页为页42(因为2&lt;4&lt;9 )。</p><p>2．通过<strong>目录项记录</strong>页确定用户记录真实所在的页。</p><p>在页42中可以快速定位到实际存储用户记录的页，但是由于c2列并没有唯一性约束，所以c2列值为4的记录可能分布在多个数据页中，又因为2&lt; 4≤4，所以确定实际存储用户记录的页在页34和页35中。</p><p>3．在真实存储用户记录的页中定位到具体的记录。</p><p>到页34和页35中定位到具体的记录。</p><p>4、但是这个B+树的叶子节点中的记录只存储了<strong>c2</strong>和c1(也就是<strong>主键</strong>）两个列，所以我们<strong>必须再根据主键值去聚簇索引中再查找</strong>一遍完整的用户记录。</p><p><strong>概念</strong>：<strong>回表</strong> 我们根据这个以c2列大小排序的B+树只能确定我们要查找记录的主键值，所以如果我们想根据c2列的值查找到完整的用户记录的话，仍然需要到 <strong>聚簇索引</strong> 中再查一遍，这个过程称为 <strong>回表</strong> 。也就是根据c2列的值查询一条完整的用户记录需要使用到<code> 2 棵 B+树</code>！   </p><p><strong>问题</strong>：为什么我们还需要一次 <strong>回表</strong> 操作呢？直接把完整的用户记录放到二级索引的叶子节点不OK吗？  </p><p><strong>答</strong>：如果把完整的用户记录放到叶子节点是可以不用回表。但是<strong>太占地方了</strong>，相当于每建立一棵B+树都需要把所有的用户记录再都拷贝一遍，这就有点太浪费存储空间了。</p><p>因为这种按照非主键列建立的B+树需要一次回表操作才可以定位到完整的用户记录，所以这种B+树也被称为<strong>二级索引</strong>(英文名secondary index)，或者辅助索引。由于我们使用的是c2列的大小作为B+树的排序规则，所以我们也称这个B+树是为c2列建立的索引。</p><p>非聚簇索引的存在不影响数据在聚簇索引中的组织，所以<strong>一张表可以有多个非聚簇索引</strong>。</p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220118102446241.png" alt="image-20220118102446241" style="zoom:40%;" /><h3 id="3-联合索引"><a href="#3-联合索引" class="headerlink" title="3. 联合索引"></a>3. 联合索引</h3><p>我们也可以同时以多个列的大小作为排序规则，也就是同时为多个列建立索引，比方说我们想让B+树按照 c2和c3列 的大小进行排序，这个包含两层含义：</p><ul><li>先把各个记录和页按照c2列进行排序。</li><li>在记录的c2列相同的情况下，采用c3列进行排序</li></ul><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220118102859128.png" alt="image-20220118102859128"></p><p>注意一点，以<strong>c2和c3列的大小为排序规则</strong>建立的B+树称为 <strong>联合索引</strong> ，本质上也是一个<strong>二级索引</strong>。它的意思与分别为c2和c3列分别建立索引的表述是不同的，不同点如下：</p><p>建立 <strong>联合索引</strong> 只会建立如上图一样的1棵B+树。</p><p>为c2和c3列分别建立索引会分别以c2和c3列的大小为排序规则建立2棵B+树。  </p><h2 id="3-4-InnoDB-的B-树索引的注意事项"><a href="#3-4-InnoDB-的B-树索引的注意事项" class="headerlink" title="3.4 InnoDB 的B+树索引的注意事项"></a>3.4 InnoDB 的B+树索引的注意事项</h2><h3 id="1-根页面位置万年不动"><a href="#1-根页面位置万年不动" class="headerlink" title="1. 根页面位置万年不动"></a>1. 根页面位置万年不动</h3><p>我们前边介绍B+树索引的时候，为了大家理解上的方便，先把存储用户记录的叶子节点都画出来，然后接着画存储目录项记录的内节点，实际上B+树的形成过程是这样的:</p><ul><li>每当为某个表创建一个B+树索引(聚簇索引不是人为创建的，默认就有）的时候，都会为这个索引创建一个<br><strong>根节点</strong>页面。最开始表中没有数据的时候，每个B+树索引对应的根节点中既没有用户记录，也没有目录项记录。</li><li>随后向表中插入用户记录时，先把用户记录存储到这个根节点中。</li><li>当根节点中的可用空间用完时继续插入记录，此时会将根节点中的所有记录<strong>复制到一个新分配的页</strong>，比如页a中，然后对这个新页进行页分裂的操作，得到另一个新页，比如页b。这时新插入的记录根据键值（也就是聚簇索引中的主键值，二级索引中对应的索引列的值)的大小就会被分配到页a或者页b中，而<strong>根节点便升级为存储目录项记录的页</strong>。</li></ul><p>这个过程特别注意的是:一个B+树索引的根节点自诞生之日起，便不会再移动。这样只要我们对某个表建立一个索引，那么它的根节点的页号便会被记录到某个地方，然后凡是InnoDB存储引擎需要用到这个索引的时候，都会从那个固定的地方取出根节点的页号，从而来访问这个索引。</p><h3 id="2-内节点中目录项记录的唯一性"><a href="#2-内节点中目录项记录的唯一性" class="headerlink" title="2. 内节点中目录项记录的唯一性"></a>2. 内节点中目录项记录的唯一性</h3><p>我们知道B+树索引的内节点中目录项记录的内容是索引列＋页号的搭配，但是这个搭配对于二级索引来说有点儿不严谨。还拿<code>index_demo</code>表为例，假设这个表中的数据是这样的:</p><table><thead><tr><th align="center">c1</th><th align="center">c2</th><th align="center">c3</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">1</td><td align="center">‘u’</td></tr><tr><td align="center">3</td><td align="center">1</td><td align="center">‘d’</td></tr><tr><td align="center">5</td><td align="center">1</td><td align="center">‘y’</td></tr><tr><td align="center">7</td><td align="center">1</td><td align="center">‘a’</td></tr></tbody></table><p>如果二级索引中目录项记录的内容只是索引列＋页号的搭配的话，那么为c2列建立索引后的B+树应该长这样:</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220118104232145.png" alt="image-20220118104232145"></p><p>如果我们想新插入一行记录，其中c1、c2、c3的值分别是:9、1、 ‘c’，那么在修改这个为c2列建立的二级索引对应的B+树时便碰到驽个大问题:由于贝3.中仔储的日以的C的值也是1，那我们这条新插入的记录两条目录项记录对应的c2列的值都是1，而我们新插入的这条记录的c2列的值也是1，那我们这条新插入的记录到底应该放到页4中，还是应该放到页5中啊?答案是:对不起，懵了。</p><p>为了让新插入记录能找到自己在那个页里，我们<strong>需要保证在B+树的同一层内节点的目录项记录除页号这个字段以外是唯一的</strong>。所以对于二级索引的内节点的目录项记录的内容实际上是由三个部分构成的:</p><ul><li>索引列的值</li><li>主键值</li><li>页号</li></ul><p>也就是我们把主键值也添加到二级索引内节点中的目录项记录了，这样就能保证B+树每一层节点中各条目录项记录除页号这个字段外是唯一的，所以我们为c2列建立二级索引后的示意图实际上应该是这样子的:</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220118104430530.png" alt="image-20220118104430530"></p><p>这样我们再插入记录<code>(9，1，&#39;c&#39;)</code>时，由于页3中存储的目录项记录是由<code>c2列＋主键＋页号</code>的值构成的，可以先把新记录的c2列的值和页3中各目录项记录的c2列的值作比较，如果c2列的值相同的话，可以接着比较主键值，因为B+树同一层中不同目录项记录的<strong>c2列＋主键</strong>的值肯定是不一样的，所以最后肯定能定位<strong>唯一的一条目录项记录</strong>，在本例中最后确定新记录应该被插入到页<strong>5</strong>中。</p><h3 id="3-一个页面最少存储2条记录"><a href="#3-一个页面最少存储2条记录" class="headerlink" title="3. 一个页面最少存储2条记录"></a>3. 一个页面最少存储2条记录</h3><p>一个B+树只需要很少的层级就可以轻松存储数亿条记录，查询速度相当不错!这是因为B+树本质上就是一个大的多层级目录，每经过一个目录时都会过滤掉许多无效的子目录，直到最后访问到存储真实数据的目录。那如果一个大的目录中只存放一个子目录是个啥效果呢?那就是目录层级非常非常非常多，而且最后的那个存放真实数据的目录中只能存放一条记录。费了半天劲只能存放一条真实的用户记录?<strong>所以InnoDB的一个数据页至少可以存放两条记录</strong>。</p><h1 id="4-MyISAM中的索引方案"><a href="#4-MyISAM中的索引方案" class="headerlink" title="4. MyISAM中的索引方案"></a>4. MyISAM中的索引方案</h1><p>B树索引适用存储引擎如表所示：  </p><table><thead><tr><th align="center">索引 / 存储引擎</th><th align="center">MyISAM</th><th align="center">InnoDB</th><th align="center">Memory</th></tr></thead><tbody><tr><td align="center">B-Tree索引</td><td align="center">支持</td><td align="center">支持</td><td align="center">支持</td></tr></tbody></table><p>即使多个存储引擎支持同一种类型的索引，但是他们的实现原理也是不同的。Innodb和MyISAM默认的索引是Btree索引；而Memory默认的索引是<strong>Hash索引</strong>。</p><p>MyISAM引擎使用 B+Tree 作为索引结构，叶子节点的data域存放的是 <strong>数据记录的地址</strong> 。</p><h3 id="4-2-MyISAM索引的原理"><a href="#4-2-MyISAM索引的原理" class="headerlink" title="4.2 MyISAM索引的原理"></a>4.2 MyISAM索引的原理</h3><p>下图是MyISAM索引的原理图。  </p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220118111201081.png" alt="image-20220118111201081" style="zoom:45%;" /><p>如果我们在Col2上建立一个二级索引，则此索引的结构如下图所示：  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220118111212222.png" alt="image-20220118111212222"></p><h3 id="4-3-MyISAM-与-InnoDB对比"><a href="#4-3-MyISAM-与-InnoDB对比" class="headerlink" title="4.3 MyISAM 与 InnoDB对比"></a>4.3 MyISAM 与 InnoDB对比</h3><p>MyISAM的索引方式都是“非聚簇”的，与InnoDB包含1个聚簇索引是不同的。小结两种引擎中索引的区别：</p><p>① 在InnoDB存储引擎中，我们只需要根据主键值对 <strong>聚簇索引</strong> 进行一次查找就能找到对应的记录，而在MyISAM 中却需要进行一次 <strong>回表</strong> 操作，意味着MyISAM中建立的索引相当于全部都是 <strong>二级索引</strong> 。</p><p>② <code>InnoDB</code>的数据文件<strong>本身就是索引文件</strong>，<strong>而MyISAM索引文件和数据文件是 分离的</strong> ，索引文件仅保存<strong>数据记录的地址</strong>。</p><p>③ InnoDB的非聚簇索引data域存储相应记录 <strong>主键的值</strong> ，而MyISAM索引记录的是 地址 。换句话说，InnoDB的所有非聚簇索引都引用主键作为data域。</p><p>④ MyISAM的回表操作是十分 快速 的，因为是拿着地址偏移量直接到文件中取数据的，反观InnoDB是通过<strong>获取主键之后</strong>再去聚簇索引里找记录，虽然说也不慢，但还是比不上直接用地址去访问。</p><p>⑤ InnoDB要求表 <strong>必须有主键</strong> （ MyISAM可以没有 ）。如果没有显式指定，则MySQL系统会自动选择一个可以非空且唯一标识数据记录的列作为主键。如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整型。  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220118111349480.png" alt="image-20220118111349480"></p><h1 id="5-索引的代价"><a href="#5-索引的代价" class="headerlink" title="5. 索引的代价"></a>5. 索引的代价</h1><p>索引是个好东西，可不能乱建，它在空间和时间上都会有消耗：  </p><ul><li><strong>空间上的代价</strong></li></ul><p>每建立一个索引都要为它建立一棵B+树，每一棵B+树的每一个节点都是一个数据页，一个页默认会占用 16KB 的存储空间，一棵很大的B+树由许多数据页组成，那就是很大的一片存储空间。</p><ul><li><strong>时间上的代价</strong></li></ul><p>每次对表中的数据进行 <strong>增、删、改</strong> 操作时，都需要去修改各个B+树索引。而且我们讲过，B+树每层节点都是按照索引列的值 <strong>从小到大的顺序排序</strong> 而组成了 <strong>双向链表</strong> 。不论是叶子节点中的记录，还是内节点中的记录（也就是不论是用户记录还是目录项记录）都是按照索引列的值从小到大的顺序而形成了一个单向链表。而增、删、改操作可能会对节点和记录的排序造成破坏，所以存储引擎需要额外的时间进行一些 <strong>记录移位 ， 页面分裂 、 页面回收</strong> 等操作来维护好节点和记录的排序。如果我们建了许多索引，每个索引对应的B+树都要进行相关的维护操作，会给性能拖后腿。  </p><h1 id="6-MySQL数据结构选择的合理性"><a href="#6-MySQL数据结构选择的合理性" class="headerlink" title="6.MySQL数据结构选择的合理性"></a>6.MySQL数据结构选择的合理性</h1><h2 id="6-1-全表遍历"><a href="#6-1-全表遍历" class="headerlink" title="6.1 全表遍历"></a>6.1 全表遍历</h2><h2 id="6-2-Hash结构"><a href="#6-2-Hash结构" class="headerlink" title="6.2 Hash结构"></a>6.2 Hash结构</h2><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220118111726111.png" alt="image-20220118111726111"></p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220118111731791.png" alt="image-20220118111731791"></p><p>上图中哈希函数h有可能将两个不同的关键字映射到相同的位置，这叫做 碰撞 ，在数据库中一般采用 <strong>链接法</strong> 来解决。在链接法中，将散列到同一槽位的元素放在一个链表中，如下图所示：  </p><h3 id="Hash结构效率高，那为什么索引结构要设计成树型呢"><a href="#Hash结构效率高，那为什么索引结构要设计成树型呢" class="headerlink" title="Hash结构效率高，那为什么索引结构要设计成树型呢?"></a>Hash结构效率高，那为什么索引结构要设计成树型呢?</h3><p>原因1: Hash索引仅能满足(=) (&lt;&gt;) 和 IN查询(<strong>等值判断</strong>)。如果进行<strong>范围查询</strong>，哈希型的索引，时间复杂度会退化为<strong>o(n)</strong>; 而树型的 “有序” 特性，依然能够保持O(log2N)的高效率。</p><p>原因2: Hash索引还有一个缺陷，数据的存储是<strong>没有顺序</strong>的，在ORDER BY的情况下，使用Hash索引还需要对数据重新排序。</p><p>原因3:对于联合索引的情况，Hash值是将联合索引键合并后一起来计算的，无法对单独的一个键或者几个索引键进行查询。</p><p>原因4:∶对于等值查询来说，通常Hash索引的效率更高，不过也存在一种情况，就是<strong>索引列的重复值如果很多，效率就会降低</strong>。这是因为遇到<strong>Hash冲突</strong>时，需要遍历桶中的<strong>行指针</strong>来进行比较，找到查询的关键字，非常耗时。所以，Hash索引通常不会用到重复值多的列上，比如列为性别、年龄的情况等。</p><p>Hash索引适用存储引擎如表所示：  </p><table><thead><tr><th>索引 / 存储引擎</th><th>MyISAM</th><th>InnoDB</th><th>Memory</th></tr></thead><tbody><tr><td>HASH索引</td><td>不支持</td><td>不支持</td><td>支持</td></tr></tbody></table><p>Hash索引的适用性：<br>Hash 索引存在着很多限制，相比之下在数据库中B+树索引的使用面会更广，不过也有一些场景采用Hash索引效率更高，比如在键值型(Key-Value)数据库中，<strong>Redis存储的核心就是Hash表</strong>。</p><p>MySQL中的Memory存储引|擎支持Hash存储，如果我们需要用到查询的临时表时，就可以选择Memory存储引擎，把某个字段设置为Hash索引，比如字符串类型的字段，进行Hash计算之后长度可以缩短到几个字节。当字段的重复度低，而且经常需要进行<strong>等值查询</strong>的时候，采用Hash索引是个不错的选择。</p><p>另外，InnoDB本身不支持 Hash索引，但是提供<strong>自适应Hash索引</strong>(Adaptive Hash Index)。什么情况下才会使用自适应Hash索引呢? 如果某个数据经常被访问，当满足一定条件的时候，就会将这个数据页的地址存放到Hash表中。这样下次查询的时候，就可以直接找到这个页面的所在位置。这样让B+树也具备了Hash 索引的优点。</p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220118111831329.png" alt="image-20220118111831329" style="zoom:30%;" /><p>采用自适应 Hash 索引目的是<strong>方便根据 SQL 的查询条件加速定位到叶子节点</strong>，特别是当 B+ 树比较深的时候，通过自适应 Hash 索引可以明显提高数据的检索效率。</p><p>我们可以通过<code> innodb_adaptive_hash_index</code> 变量来查看是否开启了自适应 Hash，比如：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%adaptive_hash_index&#x27;</span>;  </span><br></pre></td></tr></table></figure><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220118112043877.png" alt="image-20220118112043877"></p><h2 id="6-3-二叉搜索树"><a href="#6-3-二叉搜索树" class="headerlink" title="6.3 二叉搜索树"></a>6.3 二叉搜索树</h2><p>如果我们利用二叉树作为索引结构，那么磁盘的IO次数和索引树的高度是相关的 。</p><p>1.二叉搜索树的特点</p><ul><li>一个节点只能有两个子节点，也就是一个节点度不能超过2</li><li>左子节点 <code>&lt;</code> 本节点;右子节点 <code>&gt;=</code> 本节点，比我大的向右，比我小的向左</li></ul><p>2.查找规则我们先来看下最基础的二叉搜索树(Binary Search Tree)，搜索某个节点和插入节点的规则一样，我们假设搜索插入的数值为key:</p><ul><li>1.如果key大于根节点，则在右子树中进行查找;</li><li>2如果key 小于根节点，则在左子树中进行查找;</li><li>3.如果 key等于根节点，也就是找到了这个节点，返回根节点即可。</li></ul><p>举个例子，我们对数列(34，22，89，5，23，77，91）创造出来的二分查找树如下图所示:</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220118113202984.png" alt="image-20220118113202984"></p><p>但是存在特殊的情况，就是有时候二叉树的深度非常大。比如我们给出的数据顺序是<code>(5,22,23,34,77,89,91)</code>，创造出来的二分搜索树如下图所示:│</p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220118113325362.png" alt="image-20220118113325362" style="zoom:80%;" /><p>上面第二棵树也属于二分查找树，但是性能上已经退化成了一条链表，查找数据的时间复杂度变成了0(n)。你能看出来第一个树的深度是3，也就是说最多只需3次比较，就可以找到节点，而第二个树的深度是7，最多需要7次比较才能找到节点。</p><p>为了提高查询效率，就需要<strong>减少磁盘IO数</strong>。为了减少磁盘lo的次数，就需要尽量<strong>降低树的高度</strong>。需要把原来“瘦高”的树结构变的“矮胖”，树的每层的分叉越多越好。</p><h2 id="6-4-AVL树"><a href="#6-4-AVL树" class="headerlink" title="6.4 AVL树"></a>6.4 AVL树</h2><p>为了解决上面二叉查找树退化成链表的问题，人们提出了<strong>平衡二叉搜索树</strong>(Balanced Binary Tree)，又称为AVL树(有别于AVL算法)，它在二叉搜索树的基础上增加了约束，具有以下性质:</p><p><strong>它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</strong></p><p>这里说一下，常见的平衡二叉树有很多种，包括了<strong>平衡二叉搜索树、红黑树、数堆、伸展树</strong>。平衡二叉搜索树是最早提出来的自平衡二叉搜索树，当我们提到平衡二叉树时一般指的就是平衡二叉搜索树。事实上，第一棵树就属于平衡二叉搜索树，搜索时间复杂度就是**0(log2n)**。</p><p>数据查询的时间主要依赖于磁盘I/O的次数，如果我们采用二叉树的形式，即使通过平衡二叉搜索树进行了改进，树的深度也是 o(log2n)，当n 比较大时，深度也是比较高的，比如下图的情况:</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220118113703965.png" alt="image-20220118113703965"></p><p>每访问一次节点就需要进行一次磁盘 I/0操作，对于上面的树来说，我们需要进行5次I/0操作虽然平衡二叉树的效率高，但是树的深度也同样高，这就意味着磁盘I/o操作次数多，会影响整体数据查询的效率。，对于上面的树来说，我们需要进行5次I/0操作虽然平衡二叉树的效率高，但是树的深度也同样高，这就意味着磁盘I/o操作次数多，会影响整体数据查询的效率。</p><p>针对同样的数据，如果我们把二叉树改成 <strong>M 叉树</strong> （M&gt;2）呢？当 M=3 时，同样的 31 个节点可以由下面的三叉树来进行存储：  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220118113631329.png" alt="image-20220118113631329"></p><p>你能看到此时树的高度降低了，当数据量N大的时候，以及树的分叉数M大的时候，M叉树的高度会远小于二叉树的高度(M&gt;2)。所以，我们需要把<strong>树从“瘦高”变“矮胖”</strong>。</p><h2 id="6-5-B-Tree"><a href="#6-5-B-Tree" class="headerlink" title="6.5 B-Tree"></a>6.5 B-Tree</h2><p>B 树的结构如下图所示：  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220118114836279.png" alt="image-20220118114836279"></p><p>B树作为多路平衡查找树，它的每一个节点最多可以包括M个子节点，<strong>M称为 B树的阶</strong>。每个磁盘块中包括了<strong>关键字</strong>和<strong>子节点的指针</strong>。如果一个磁盘块中包括了×个关键字，那么指针数就是x+1。对于一个10o阶的B树来说，如果有3层的话最多可以存储约100万的索引数据。对于大量的索引数据来说，采用B树的结构是非常适合的，因为树的高度要远小于二叉树的高度。一个 M 阶的 B 树（M&gt;2）有以下的特性：</p><ol><li><p>根节点的儿子数的范围是 [2,M]。</p></li><li><p>每个中间节点包含 k-1 个关键字和 k 个孩子，孩子的数量 = 关键字的数量 +1，k 的取值范围为[ceil(M/2), M]。</p></li><li><p>叶子节点包括 k-1 个关键字（叶子节点没有孩子），k 的取值范围为 [ceil(M/2), M]。</p></li><li><p>假设中间节点节点的关键字为：Key[1], Key[2], …, Key[k-1]，且关键字按照升序排序，即 Key[i]&lt;Key[i+1]。此时 k-1 个关键字相当于划分了 k 个范围，也就是对应着 k 个指针，即为：P[1], P[2], …,P[k]，其中 P[1] 指向关键字小于 Key[1] 的子树，P[i] 指向关键字属于 (Key[i-1], Key[i]) 的子树，P[k]指向关键字大于 Key[k-1] 的子树。</p></li><li><p>所有叶子节点位于同一层。</p></li></ol><p>上面那张图所表示的 B 树就是一棵 3 阶的 B 树。我们可以看下磁盘块 2，里面的关键字为（8，12），它有 3 个孩子 (3，5)，(9，10) 和 (13，15)，你能看到 (3，5) 小于 8，(9，10) 在 8 和 12 之间，而 (13，15)大于 12，刚好符合刚才我们给出的特征。  </p><p>然后我们来看下如何用 B 树进行查找。假设我们想要 <strong>查找的关键字是 9</strong> ，那么步骤可以分为以下几步：</p><ol><li>我们与根节点的关键字 (17，35）进行比较，9 小于 17 那么得到指针 P1；</li><li>按照指针 P1 找到磁盘块 2，关键字为（8，12），因为 9 在 8 和 12 之间，所以我们得到指针 P2；</li><li>按照指针 P2 找到磁盘块 6，关键字为（9，10），然后我们找到了关键字 9。</li></ol><p>你能看出来在 B 树的搜索过程中，我们比较的次数并不少，但如果把数据读取出来然后在内存中进行比较，这个时间就是可以忽略不计的。而读取磁盘块本身需要进行 I/O 操作，消耗的时间比在内存中进行比较所需要的时间要多，是数据查找用时的重要因素。 <strong>B 树相比于平衡二叉树来说磁盘 I/O 操作要少</strong> ，在数据查询中比平衡二叉树效率要高。所以 <strong>只要树的高度足够低，IO次数足够少，就可以提高查询性能</strong> 。  </p><p><strong>小结:</strong></p><ol><li>B树在插入和删除节点的时候如果导致树不平衡，就通过自动调整节点的位置来保持树的自平衡。</li><li>关键字集合分布在整棵树中,即**叶子节点和非叶子节点都存放数据 **(如8这个非叶子节点就会存放数据)。搜索有可能在非叶子节点结束.</li><li>其搜索性能等价于在关键字全集内做一次二分查找。</li></ol><p><strong>再举例1：</strong>  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220118115030993.png" alt="image-20220118115030993"></p><h2 id="6-6-B-Tree"><a href="#6-6-B-Tree" class="headerlink" title="6.6 B+Tree"></a>6.6 B+Tree</h2><p>B+树也是一种多路搜索树，<strong>基于B树做出了改进</strong>，主流的DBMS都支持B+树的索引方式，比如MySQL。相比于B-Tree，B+Tree适合文件索引系统。</p><p>MySQL官网说明：  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220118115713457.png" alt="image-20220118115713457"></p><p><strong>B+ 树和 B 树的差异：</strong></p><ol><li>有 k 个孩子的节点就有 k 个关键字。也就是孩子数量 = 关键字数，而 B 树中，孩子数量 = 关键字数+1。</li><li>非叶子节点的关键字也会同时存在在子节点中，并且是在子节点中所有关键字的最大（或最小）。</li><li>非叶子节点仅用于索引，不保存数据记录，跟记录有关的信息都放在叶子节点中。而 B 树中， <strong>非叶子节点既保存索引，也保存数据记录</strong> 。</li><li>所有关键字都在叶子节点出现，叶子节点构成一个有序链表，而且叶子节点本身按照关键字的大小从小到大顺序链接。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">B 树和 B+ 树都可以作为索引的数据结构，在 MySQL 中采用的是 B+ 树。</span><br><span class="line"></span><br><span class="line">但B树和B+树各有自己的应用场景，不能说B+树完全比B树好，反之亦然  </span><br></pre></td></tr></table></figure><p>整个过程一共进行了3次I/O操作，看起来B+树和B树的查询过程差不多，但是B+树和B树有个根本的差异在于，<strong>B+树的中间节点并不直接存储数据</strong>。这样的好处都有什么呢?</p><p>首先，B+树查询效率更稳定。因为B+树每次只有访问到叶子节点才能找到对应的数据，而在B树中，非叶子节点也会存储数据，这样就会造成查询效率不稳定的情况，有时候访问到了非叶子节点就可以找到关键字，而有时需要访问到叶子节点才能找到关键字。</p><p>其次，B+树的查询效率更高。这是因为通常B+树比B树更矮胖(阶数更大，深度更低)，查询所需要的磁盘I/o也会更少。同样的磁盘页大小，B+树可以存储更多的节点关键字。</p><p>不仅是对单个关键字的查询上，<strong>在查询范围上，B+树的效率也比B树高。</strong>这是因为所有关键字都出现在B+树的叶子节点中，叶子节点之间会有指针，数据又是递增的，这使得我们范围查找可以通过指针连接查找。而在B树中则需要通过中序遍历才能完成查询范围的查找，效率要低很多。</p><h1 id="面试造火箭计划！！！"><a href="#面试造火箭计划！！！" class="headerlink" title="面试造火箭计划！！！"></a>面试造火箭计划！！！</h1><p><strong>思考题：为了减少IO，索引树会一次性加载吗？</strong></p><p>1、数据库索引是存储在磁盘上的，如果数据量很大，必然导致索引的大小也会很大，超过几个G。<br>2、当我们利用索引查询时候，是不可能将全部几个G的索引都加载进内存的，我们能做的只能是:逐一加载每一个磁盘页，因为磁盘页对应着索引树的节点。</p><p><strong>思考题：B+树的存储能力如何？为何说一般查找行记录，最多只需1~3次磁盘IO</strong></p><p>InnoDB存储引擎中页的大小为1<strong>6KB</strong>，一般表的主键类型为INT(占用4个字节)或BIGINT(占用8个字节)，指针类型也一般为4或8个字节，也就是说一个页(B+Tree中的一个节点)中大概存储16KB/(8B+8B)=<strong>1K个键值</strong>(因为是估值，为方便计算，这里的K取值为10^3。也就是说一个深度为3的B+Tree索引可以维护10^3<em>10^3</em>10^3= <strong>10亿条记录</strong>。(这里假定一个数据页也存储10^3条行记录数据了)</p><p>实际情况中每个节点可能不能填充满，因此在数据库中，<strong>B+Tree 的高度一般都在2~4层</strong>。MySQL的InnoDB存储引擎在设计时是将根<strong>节点常驻内存的</strong>，也就是说查找某一键值的行记录时最多只需要<strong>1~3次</strong>磁盘1/o操作。</p><p><strong>思考题：为什么说B+树比B-树更适合实际应用中操作系统的文件索引和数据库索引？</strong></p><p>1、B+树的磁盘读写代价更低</p><p>B+树的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。</p><p>2、B+树的查询效率更加稳定</p><p>由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</p><p><strong>思考题：Hash 索引与 B+ 树索引的区别</strong></p><p>我们之前讲到过B+树索引的结构，Hash索引结构和B+树的不同，因此在索引使用上也会有差别</p><p>1、Hash索引<strong>不能进行范围查询，而B+树可以</strong>。这是因为Hash索引指向的数据是无序的，而B+树的叶子节点是个有序的链表。</p><p>2、Hash索引<strong>不支持联合索引的最左侧原则</strong>(即联合索引的部分索引无法使用)，而B+树可以。对于联合索引来说，Hash索引在计算Hash值的时候是将索引键合并后再一起计算Hash值，所以不会针对每个索引单独计算 Hash值。因此如果用到联合索引的一个或者几个索引时，联合索引无法被利用。</p><p>3、Hash索引<strong>不支持ORDER BY排序</strong>，因为Hash索引指向的数据是无序的，因此无法起到排序优化的作用，而<strong>B+树索引数据是有序的</strong>，可以起到对该字段ORDER BY排序优化的作用。同理，我们也<strong>无法用Hash索引进行模糊查询</strong>，而B+树使用LIKE进行模糊查询的时候，LIKE后面后模糊查询（比如%结尾）的话就可以起到优化的作用。</p><p>4.InnoDB不支持哈希索引。</p><p><strong>思考题：Hash 索引与 B+ 树索引是在建索引的时候手动指定的吗？</strong>  </p><p>如果使用的是MysQL的话，我们需要了解MySQL的存储引擎都支持哪些索引结构，如下图所示（参考来源https:/dev.mysql.com/doc/refman/8.0/en/create-index.html)。如果是其他的DBMS，可以参考相关的DBMS文档。</p><p><img src="C:\Users\Li\AppData\Roaming\Typora\typora-user-images\image-20220118120907649.png" alt="image-20220118120907649"></p><p>你能看到，针对 <strong>InnoDB和MyISAM</strong>存储引擎，都会<strong>默认采用B+树索引，无法使用 Hash索引</strong>。InnoDB提供的<strong>自适应Hash是不需要手动指定的</strong>。如果是Memory/Heap和NDB存储引擎，是可以进行选择Hash索引的。</p>]]></content>
      
      
      <categories>
          
          <category> database </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>02 | 日志系统：一条SQL更新语句是如何执行的？（数据库使用InnoDB恢复原理）</title>
      <link href="/2022/01/13/%E4%B8%A4%E4%B8%AA%E9%87%8D%E8%A6%81%E6%97%A5%E5%BF%97%E5%8F%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D/"/>
      <url>/2022/01/13/%E4%B8%A4%E4%B8%AA%E9%87%8D%E8%A6%81%E6%97%A5%E5%BF%97%E5%8F%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="两个重要日志及数据库恢复"><a href="#两个重要日志及数据库恢复" class="headerlink" title="两个重要日志及数据库恢复"></a>两个重要日志及数据库恢复</h1><p>一条更新语句的执行流程又是怎样的呢？</p><p>之前你可能经常听 DBA 同事说，MySQL 可以恢复到半个月内任意一秒的状态，惊叹的同时，你是不是心中也会不免会好奇，这是怎样做到的呢？</p><p>我们还是从一个表的一条更新语句说起，下面是这个表的创建语句，这个表有一个主键 ID 和一个整型字段 age：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">create</span> <span class="keyword">table</span> T(ID <span class="type">int</span> <span class="keyword">primary</span> key, age <span class="type">int</span>);</span><br></pre></td></tr></table></figure><p>如果要将 ID=2 这一行的值加 1，SQL 语句就会这么写：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">update</span> T <span class="keyword">set</span> age<span class="operator">=</span>age<span class="operator">+</span><span class="number">1</span> <span class="keyword">where</span> ID<span class="operator">=</span><span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>前面我有跟你介绍过 SQL 语句基本的执行链路，这里我再把那张图拿过来，你也可以先简单看看这个图回顾下。首先，可以确定的说，查询语句的那一套流程，更新语句也是同样会走一遍。</p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/0d2070e8f84c4801adbfa03bda1f98d9.png" alt="MySQL 的逻辑架构图" style="zoom:33%;" /><p>执行语句前要先连接数据库，这是连接器的工作。</p><p>前面我们说过，在一个表上有更新的时候，跟这个表有关的查询缓存会失效，所以这条语句就会把表 T 上所有缓存结果都清空。这也就是我们一般不建议使用查询缓存的原因。</p><p>接下来，分析器会通过词法和语法解析知道这是一条更新语句。优化器决定要使用 ID 这个索引。然后，执行器负责具体执行，找到这一行，然后更新。</p><p>与查询流程不一样的是，更新流程还涉及两个重要的日志模块，它们正是我们今天要讨论的主角：<code>redo log（重做日志）</code>和<code> binlog（归档日志）</code>。</p><h2 id="重要的日志模块：redo-log"><a href="#重要的日志模块：redo-log" class="headerlink" title="重要的日志模块：redo log"></a>重要的日志模块：redo log</h2><p>不知道你还记不记得《孔乙己》这篇文章，酒店掌柜有一个粉板，专门用来记录客人的赊账记录。如果赊账的人不多，那么他可以把顾客名和账目写在板上。但如果赊账的人多了，粉板总会有记不下的时候，这个时候掌柜一定还有一个专门记录赊账的账本。</p><p>如果有人要赊账或者还账的话，掌柜一般有两种做法：</p><ul><li>一种做法是直接把账本翻出来，把这次赊的账加上去或者扣除掉；</li><li>另一种做法是先在粉板上记下这次的账，等打烊以后再把账本翻出来核算。</li></ul><p>在生意红火柜台很忙时，掌柜一定会选择后者，因为前者操作实在是太麻烦了。首先，你得找到这个人的赊账总额那条记录。你想想，密密麻麻几十页，掌柜要找到那个名字，可能还得带上老花镜慢慢找，找到之后再拿出算盘计算，最后再将结果写回到账本上。</p><p>这整个过程想想都麻烦。相比之下，还是先在粉板上记一下方便。你想想，如果掌柜没有粉板的帮助，每次记账都得翻账本，效率是不是低得让人难以忍受？</p><p>同样，在 MySQL 里也有这个问题，如果每一次的更新操作都需要写进磁盘，然后磁盘也要找到对应的那条记录，然后再更新，整个过程 IO 成本、查找成本都很高。为了解决这个问题，MySQL 的设计者就用了类似酒店掌柜粉板的思路来提升更新效率。</p><p>而粉板和账本配合的整个过程，其实就是 MySQL 里经常说到的 <code>WAL 技术</code>，WAL 的全称是 <code>Write-Ahead Logging</code>，它的关键点就是<strong>先写日志，再写磁盘</strong>，也就是先写粉板，等不忙的时候再写账本。</p><p>具体来说，当有一条记录需要更新的时候，<code>InnoDB </code>引擎就会<strong>先把记录写到 redo log</strong>（粉板）里面，<strong>并更新内存</strong>，这个时候更新就算完成了。同时，<code>InnoDB </code>引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做，这就像打烊以后掌柜做的事。</p><p>如果今天赊账的不多，掌柜可以等打烊后再整理。但如果某天赊账的特别多，粉板写满了，又怎么办呢？这个时候掌柜只好放下手中的活儿，把粉板中的一部分赊账记录更新到账本中，然后把这些记录从粉板上擦掉，为记新账腾出空间。</p><p>与此类似，<strong>InnoDB 的 redo log 是固定大小的</strong>，比如可以配置为一组 4 个文件，每个文件的大小是 1GB，那么这块“粉板”总共就可以记录 4GB 的操作。从头开始写，写到末尾就又回到开头<strong>循环写</strong>，如下面这个图所示。</p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/16a7950217b3f0f4ed02db5db59562a7.png" alt="" style="zoom: 67%;" /><p><strong>write pos</strong> 是当前记录的位置，一边写一边后移，写到第 3 号文件末尾后就回到 0 号文件开头。<strong>checkpoint</strong> 是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。</p><p>write pos 和 checkpoint 之间的是“粉板”上还空着的部分，可以用来记录新的操作。如果 write pos 追上 checkpoint，表示“粉板”满了，这时候不能再执行新的更新，得停下来先擦掉一些记录，把 checkpoint 推进一下。</p><p>有了 redo log，<code>InnoDB</code> 就<strong>可以保证即使数据库发生异常重启，之前提交的记录都不会丢失</strong>，这个能力称为 <strong>crash-safe</strong>。</p><p>要理解 crash-safe 这个概念，可以想想我们前面赊账记录的例子。只要赊账记录记在了粉板上或写在了账本上，之后即使掌柜忘记了，比如突然停业几天，恢复生意后依然可以通过账本和粉板上的数据明确赊账账目。</p><h2 id="重要的日志模块：binlog"><a href="#重要的日志模块：binlog" class="headerlink" title="重要的日志模块：binlog"></a>重要的日志模块：binlog</h2><p>前面我们讲过，MySQL 整体来看，其实就有两块：一块是 Server 层，它主要做的是 MySQL 功能层面的事情；还有一块是引擎层，负责存储相关的具体事宜。上面我们聊到的粉板 <strong>redo log 是 <code>InnoDB </code>引擎特有的日志</strong>，而 Server 层也有自己的日志，称为 <code>binlog</code>（归档日志）。</p><p>为什么会有两份日志呢？</p><p>因为最开始 MySQL 里并没有<code>InnoDB</code>引擎。MySQL 自带的引擎是 <code>MyISAM</code>，但是<code>MyISAM</code>没有 crash-safe 的能力，<code>binlog </code>日志只能用于归档。而<code>InnoDB</code>是另一个公司以插件形式引入 MySQL 的，既然只依靠 <code>binlog </code>是没有 crash-safe 能力的，所以 <code>InnoDB</code> 使用另外一套日志系统——也就是 <strong>redo log 来实现 crash-safe 能力</strong>。</p><h2 id="redo-log-和-binlog的区别"><a href="#redo-log-和-binlog的区别" class="headerlink" title="redo log 和 binlog的区别"></a>redo log 和 binlog的区别</h2><p>两种日志有以下三点不同。</p><ol><li>redo log 是 InnoDB 引擎特有的；<strong>binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用</strong>。redo log 是<strong>物理日志</strong>，记录的是“在某个数据页上做了什么修改”；</li><li>binlog 是<strong>逻辑日志</strong>，记录的是这个语句的原始逻辑，比如“给 ID=2 这一行的 age字段加 1 ”。<strong>redo log 是循环写的，空间固定会用完</strong>；</li><li>binlog 是可以<strong>追加写</strong>入的。“追加写”是指 binlog 文件写到一定大小后会切换到下一个，<strong>并不会覆盖以前的日志</strong>。</li></ol><h2 id="update-语句的执行流程"><a href="#update-语句的执行流程" class="headerlink" title="update 语句的执行流程"></a><strong>update 语句的执行流程</strong></h2><h3 id="update-语句执行流程图"><a href="#update-语句执行流程图" class="headerlink" title="update 语句执行流程图"></a><strong>update 语句执行流程图</strong></h3><p>图中浅色框表示是在 InnoDB 内部执行的，深色框表示是在执行器中执行的。</p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/2e5bff4910ec189fe1ee6e2ecc7b4bbe.png" alt="update 语句的执行流程图" style="zoom:67%;" /><h3 id="update-语句执行步骤"><a href="#update-语句执行步骤" class="headerlink" title="update 语句执行步骤"></a>update 语句执行步骤</h3><ol><li><p>执行器：找存储引擎取到 id = 2 这一行记录</p></li><li><p>存储引擎：根据主键索引树找到这一行，如果 id = 2 这一行所在的数据页本来就在内存池（Buffer Pool）中，就直接返回给执行器；否则，需要先从磁盘读入内存池，然后再返回</p></li><li><p><a href="https://www.zhihu.com/search?q=%E6%89%A7%E8%A1%8C%E5%99%A8&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2280710259%7D">执行器</a>：拿到存储引擎返回的行记录，把 age 字段加上 1，得到一行新的记录，然后再调用存储引擎的接口写入这行新记录</p></li><li><p>存储引擎：将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 <code>prepare</code> 状态。然后告知执行器执行完成了，随时可以提交事务</p><p>注意:不要把这里的提交事务和我们 sql 语句中的提交事务 commit 命令搞混了哈，我们这里说的提交事务，指的是事务提交过程中的一个小步骤，也是最后一步。当这个步骤执行完成后，commit 命令就执行成功了。</p></li><li><p>执行器：生成这个操作的 bin log，并把 bin log 写入磁盘</p></li><li><p>执行器：调用存储引擎的提交事务接口</p></li><li><p>存储引擎：把刚刚写入的 redo log 状态改成提交（<code>commit</code>）状态，更新完成</p></li></ol><p>请格外注意和理解为什么将<code>redo log</code>的写入拆成了<strong>两个步骤</strong>：<code>prepare </code>和 <code>commit</code>，这就是**”两阶段提交”**。</p><p>为什么这样设计就能<strong>实现数据库崩溃后还能恢复数据</strong>呢？</p><h2 id="为什么说-redo-log-具有崩溃恢复的能力"><a href="#为什么说-redo-log-具有崩溃恢复的能力" class="headerlink" title="为什么说 redo log 具有崩溃恢复的能力"></a>为什么说 redo log 具有崩溃恢复的能力</h2><p>redo log 和 bin log 的一个很大的区别就是，一个是<strong>循环写</strong>，一个是追加写。也就是说 <strong>redo log 只会记录未刷入磁盘的日志</strong>，已经刷入磁盘的数据都会从 redo log 这个有限大小的日志文件里删除。</p><p>而 bin log 是追加日志，<strong>保存的是全量的日志</strong>。这就会导致一个问题，那就是没有标志能让 InnoDB 从 bin log 中判断哪些数据已经刷入磁盘了，哪些数据还没有。</p><p>举个例子，bin log 记录了两条日志：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">记录 1：给 id = 1 这一行的 age 字段加 1</span><br><span class="line">记录 2：给 id = 1 这一行的 age 字段加 1</span><br></pre></td></tr></table></figure><p>假设在记录 1 刷盘后，记录 2 未刷盘时，数据库崩溃。重启后，只通过 bin log 数据库是无法判断这两条记录哪条已经写入磁盘，哪条没有写入磁盘，不管是两条都恢复至内存，还是都不恢复，对 id = 1 这行数据来说，都是不对的。</p><p>但 redo log 不一样，只要刷入磁盘的数据，都会从 redo log 中被抹掉，数据库重启后，直接把 redo log 中的数据都恢复至内存就可以了。</p><p>这就是为什么说 <strong>redo log 具有崩溃恢复的能力，而 bin log 不具备</strong>。</p><h2 id="崩溃恢复时的判断规则"><a href="#崩溃恢复时的判断规则" class="headerlink" title="崩溃恢复时的判断规则"></a>崩溃恢复时的判断规则</h2><p>根据两阶段提交，<strong>崩溃恢复时的判断规则</strong>是这样的：</p><ol><li>如果 redo log 里面的事务是完整的，也就是已经有了 commit 标识，则直接提交</li><li>如果 redo log 里面的事务处于 prepare 状态，则判断对应的事务 binlog 是否存在并完整</li></ol><ul><li>a. 如果 binlog 存在并完整，则提交事务；</li><li>b. 否则，回滚事务。</li></ul><h3 id="数据库崩溃例一"><a href="#数据库崩溃例一" class="headerlink" title="数据库崩溃例一"></a>数据库崩溃例一</h3><p>如下图所示，假设数据库在<strong>写入 redo log(prepare) 阶段之后、写入 binlog 之前</strong>，发生了崩溃，此时 redo log 里面的事务处于 prepare 状态，binlog 还没写（对应 2b），所以崩溃的时候，这个事务会回滚。</p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/v2-a26e4c7c6d2e1c89ed9c2296798e7899_720w.jpg" alt="img" style="zoom: 67%;" /><p>原因：</p><p>此时 redo log 里面的事务处于 prepare 状态，binlog 还没写，之后从库进行同步的时候，无法执行这个操作，但是实际上主库已经完成了这个操作，所以为了主备一致，MySQL 崩溃时会在主库上回滚这个事务。并且，由于 binlog 还没写，所以也就不会传到备库，从而避免主备不一致的情况。</p><h3 id="数据库崩溃例二"><a href="#数据库崩溃例二" class="headerlink" title="数据库崩溃例二"></a>数据库崩溃例二</h3><p>如果数据库在写入 binlog 之后，redo log 状态修改为 commit 前发生崩溃，此时 redo log 里面的事务仍然是 prepare 状态，binlog 存在并完整（对应 2a），所以即使在这个时刻数据库崩溃了，事务仍然会被正常提交。</p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/v2-94ec46b4b750cdf6bd913b5d9eedcb53_720w.jpg" alt="img" style="zoom:67%;" /><p>原因：</p><p>因为 binlog 已经写入成功了，这样之后就会被从库同步过去，但是实际上主库并没有完成这个操作，所以为了主备一致，在<a href="https://www.zhihu.com/search?q=%E4%B8%BB%E5%BA%93&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2280710259%7D">主库</a>上需要提交这个事务。</p><h2 id="redo-log-两阶段提交的必要性"><a href="#redo-log-两阶段提交的必要性" class="headerlink" title="redo log 两阶段提交的必要性"></a>redo log <strong>两阶段提交的必要性</strong></h2><p>可不可以先 redo log 写完，再写 bin log 或者反过来？</p><h3 id="1）对于先写完-redo-log-后写-bin-log-的情况："><a href="#1）对于先写完-redo-log-后写-bin-log-的情况：" class="headerlink" title="1）对于先写完 redo log 后写 bin log 的情况："></a>1）对于先写完 redo log 后写 bin log 的情况：</h3><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/v2-b690e860bdb751e57e14af362ba16647_720w.jpg" alt="img" style="zoom:67%;" /><p>假设在 <strong>redo log 写完，binlog 还没有写完</strong>的时候，MySQL 进程异常重启。由于我们前面说过的，redo log 写完之后，系统即使崩溃，仍然能够把数据恢复回来，所以恢复后这一行 age 的值是 1。但是由于 binlog 没写完就 crash 了，这时候 binlog 里面就没有记录这个语句。</p><p>因此，之后备份日志的时候，存起来的 binlog 里面就没有这条语句。然后你会发现，如果需要用这个 binlog 来恢复临时库的话，由于这个语句的 binlog 丢失，这个临时库就会少了这一次更新，恢复出来的这一行 c 的值就是 0，与原库的值不同。</p><h3 id="2）对于先写完-binlog-后写-redo-log-的情况："><a href="#2）对于先写完-binlog-后写-redo-log-的情况：" class="headerlink" title="2）对于先写完 binlog 后写 redo log 的情况："></a>2）对于先写完 binlog 后写 redo log 的情况：</h3><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/v2-df3f63c6451613af1dcc4324677f1e4f_720w.jpg" alt="img" style="zoom:67%;" /><p>如果在 binlog 写完之后 crash，由于 redo log 还没写，崩溃恢复以后这个事务无效，所以这一行 c 的值是 0。但是 binlog 里面已经记录了“把 c 从 0 改成 1”这个日志。所以，在之后用 binlog 来恢复的时候就多了一个事务出来，恢复出来的这一行 c 的值就是 1，与原库的值不同。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Bin log 用于记录了完整的逻辑记录，所有的逻辑记录在 bin log 里都能找到，所以在备份恢复时，是以 bin log 为基础，通过其记录的完整逻辑操作，备份出一个和原库完整的数据。</p><h2 id="面试造火箭计划！！！"><a href="#面试造火箭计划！！！" class="headerlink" title="面试造火箭计划！！！"></a>面试造火箭计划！！！</h2><ol><li><p>redo log的概念是什么? 为什么会存在.</p><p>答： redo log是重做日志。主要用于MySQL异常重启后的一种数据恢复手段，确保了数据的一致性。归根到底是MySQL为了实现WAL机制的一种手段。因为MySQL进行更新操作，为了能够快速响应，所以采用了异步写回磁盘的技术，写入内存后就返回。但是会存在crash后内存数据丢失的隐患，而redo log具备crash safe能力。</p></li><li><p>什么是<code>WAL(write-ahead log)</code>机制, 好处是什么.</p><p>答： WAL机制是<strong>先写日志，再写磁盘</strong>。也就是MySQL更新操作后在真正把数据写入到磁盘前先记录日志。好处是不用每一次操作都实时把数据写盘，就算crash后也可以通过redo log重放恢复，所以能够实现快速响应SQL语句。</p></li><li><p>redo log 为什么可以保证crash safe机制.</p><p>答： 因为redo log是每次更新操作完成后，就一定会写入的，如果写入失败，这说明此次操作失败，事务也不可能提交。redo log内部结构是基于页的，记录了这个页的字段值变化，只要crash后读取redo log进行重放就可以恢复数据。（因为redo log是循环写的，如果满了InnoDB就会执行真正写盘）</p></li><li><p>binlog的概念是什么, 起到什么作用, 可以做crash safe吗?</p><p>答：  bin log是归档日志，属于MySQL Server层的日志。可以起到全量备份的作用。当需要恢复数据时，可以取出某个时间范围内的bin log进行重放恢复。但是bin log不可以做crash safe，因为crash之前，bin log可能没有写入完全MySQL就挂了。所以需要配合redo log才可以进行crash safe。</p></li><li><p>binlog 和 redolog的不同点有哪些?</p><p>答案：参考上面笔记。</p></li><li><p>物理一致性和逻辑一直性各应该怎么理解?</p><p>答: binlog 是逻辑日志，可以给别的数据库，别的引擎使用，已经大家都讲得通这个“逻辑”；redolog是物理日志，就只有“我”自己能用，别人没有共享我的“物理格式”</p></li><li><p>执行器和innoDB在执行update语句时候的流程是什么样的?</p><p>答案：参考上面笔记。</p></li><li><p>如果数据库误操作, 如何执行数据恢复?</p><p>答：数据库在某一天误操作，就可以找到距离误操作最近的时间节点前的bin log，重放到临时数据库里，然后选择当天误删的数据恢复到线上数据库。</p></li><li><p>什么是两阶段提交, 为什么需要两阶段提交, 两阶段提交怎么保证数据库中两份日志间的逻辑一致性(什么叫逻辑一致性)?</p><p>答案：参考上面笔记。</p></li><li><p>如果不是两阶段提交, 先写redo log和先写bin log两种情况各会遇到什么问题?</p><p>答案：参考上面笔记。</p></li></ol><h2 id="一些名词"><a href="#一些名词" class="headerlink" title="一些名词"></a>一些名词</h2><p>数据页 ：MySQL的记录是以“页”为单位存取的，默认大小16K。也就是说，你要访问磁盘中一个记录，不会只读这个记录，而会把它所在的16K数据一起读入内存</p>]]></content>
      
      
      <categories>
          
          <category> database </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>01 | 基础架构：一条SQL查询语句是如何执行的？</title>
      <link href="/2022/01/12/%E4%B8%80%E6%9D%A1SQL%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/"/>
      <url>/2022/01/12/%E4%B8%80%E6%9D%A1SQL%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/</url>
      
        <content type="html"><![CDATA[<h1 id="基础架构：一条SQL查询语句是如何执行的？"><a href="#基础架构：一条SQL查询语句是如何执行的？" class="headerlink" title="基础架构：一条SQL查询语句是如何执行的？"></a>基础架构：一条SQL查询语句是如何执行的？</h1><p>下面我给出的是 <strong>MySQL 的基本架构示意图</strong>，从中你可以清楚地看到 SQL 语句在 MySQL 的各个功能模块中的执行过程。</p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/0d2070e8f84c4801adbfa03bda1f98d9.png" alt="img" style="zoom: 33%;" /><p>大体来说，MySQL 可以分为 <code>Server 层</code>和<code>存储引擎层</code>两部分。</p><p><strong>Server 层</strong>包括连接器、查询缓存、分析器、优化器、执行器等，涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），<strong>所有跨存储引擎的功能都在这一层实现</strong>，比如存储过程、触发器、视图等。</p><p><strong>存储引擎层</strong>负责<code>数据的存储和提取</code>。其架构模式是<strong>插件式</strong>的，支持 InnoDB、MyISAM、Memory 等多个存储引擎。现在最常用的存储引擎是 InnoDB（支持事务），它从 MySQL 5.5.5 版本开始成为了默认存储引擎。</p><p>从图中不难看出，<strong>不同的存储引擎共用一个 Server 层</strong>，也就是从连接器到执行器的部分。</p><h2 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h2><p>第一步，你会先连接到这个数据库上，这时候接待你的就是连接器。连接器负责跟客户端建立连接、获取权限、维持和管理连接。连接命令一般是这么写的：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql <span class="operator">-</span>h$ip <span class="operator">-</span>P$port <span class="operator">-</span>u$<span class="keyword">user</span> <span class="operator">-</span>p</span><br></pre></td></tr></table></figure><p>输完命令之后，你就需要在交互对话里面输入密码。</p><p>连接完成后，如果你没有后续的动作，这个连接就处于空闲状态，你可以在<code>show processlist</code>命令中看到它。文本中这个图是 <code>show processlist </code>的结果，其中的 Command 列显示为“Sleep”的这一行，就表示现在系统里面有一个空闲连接。</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/f2da4aa3a672d48ec05df97b9f992fed.png" alt="img"></p><p>客户端如果太长时间没动静，连接器就会自动将它断开。这个时间是由参数 <code>wait_timeout </code>控制的，默认值是 8 小时。</p><p>数据库里面，长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。</p><p>建立连接的过程通常是比较复杂的，<strong>尽量减少建立连接的动作，也就是尽量使用长连接。</strong></p><p>但是全部使用长连接后，你可能会发现，有些时候 MySQL 占用内存涨得特别快，这是因为 MySQL 在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候才释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉（OOM），从现象看就是 MySQL 异常重启了。</p><p>怎么解决这个问题呢？你可以考虑以下两种方案。</p><ol><li>定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。</li><li>如果你用的是 <code>MySQL 5.7 </code>或更新版本，可以在每次执行一个比较大的操作后，通过执行<code>mysql_reset_connection</code>来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。</li></ol><h2 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h2><p>连接建立完成后，你就可以执行 <code>select</code> 语句了。执行逻辑就会来到第二步：查询缓存。</p><p>MySQL 拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。之前执行过的语句及其结果可能会以 key-value 对的形式，被直接缓存在内存中。key 是查询的语句，value 是查询的结果。如果你的查询能够直接在这个缓存中找到 key，那么这个 value 就会被直接返回给客户端。如果语句不在查询缓存中，就会继续后面的执行阶段。执行完成后，执行结果会被存入查询缓存中。你可以看到，如果查询命中缓存，MySQL 不需要执行后面的复杂操作，就可以直接返回结果，这个效率会很高。</p><p>缺点：</p><p>查询缓存的失效非常频繁，<strong>只要有对一个表的更新，这个表上所有的查询缓存都会被清空</strong>。因此很可能你费劲地把结果存起来，还没使用呢，就被一个更新全清空了。对于更新压力大的数据库来说，查询缓存的命中率会非常低。除非你的业务就是有一张静态表，很长时间才会更新一次。比如，一个系统配置表，那这张表上的查询才适合使用查询缓存。</p><p><strong>MySQL 8.0 版本直接将查询缓存的整块功能删掉了，也就是说 8.0 开始彻底没有这个功能了。</strong></p><h2 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h2><p>如果没有命中查询缓存，就要开始真正执行语句了。首先，MySQL 需要知道你要做什么，因此需要对 SQL 语句做解析。</p><p>分析器先会做“词法分析”。你输入的是由多个字符串和空格组成的一条 SQL 语句，MySQL 需要识别出里面的字符串分别是什么，代表什么。</p><p>MySQL 从你输入的”select”这个关键字识别出来，这是一个查询语句。它也要把字符串“T”识别成“表名 T”，把字符串“ID”识别成“列 ID”。</p><p>做完了这些识别以后，就要做“语法分析”。根据词法分析的结果，语法分析器会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法。</p><p>如果你的语句不对，就会收到<code>“You have an error in your SQL syntax”</code>的错误提醒，比如下面这个语句 select 少打了开头的字母“s”。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> elect <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> ID<span class="operator">=</span><span class="number">1</span>;ERROR <span class="number">1064</span> (<span class="number">42000</span>): You have an error <span class="keyword">in</span> your <span class="keyword">SQL</span> syntax; <span class="keyword">check</span> the manual that corresponds <span class="keyword">to</span> your MySQL server version <span class="keyword">for</span> the <span class="keyword">right</span> syntax <span class="keyword">to</span> use near <span class="string">&#x27;elect * from t where ID=1&#x27;</span> <span class="keyword">at</span> line <span class="number">1</span></span><br></pre></td></tr></table></figure><p>一般语法错误会<strong>提示第一个出现错误的位置</strong>，所以你要关注的是紧接<code>“use near”</code>的内容。</p><h2 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h2><p>经过了分析器，MySQL 就知道你要做什么了。在开始执行之前，还要先经过优化器的处理。</p><p>优化器是在表里面有多个索引的时候，<strong>决定使用哪个索引</strong>；或者在一个语句有多表关联（join）的时候，<strong>决定各个表的连接顺序</strong>。比如你执行下面这样的语句，这个语句是执行两个表的 join：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">join</span> t2 <span class="keyword">using</span>(ID) <span class="keyword">where</span> t1.c<span class="operator">=</span><span class="number">10</span> <span class="keyword">and</span> t2.d<span class="operator">=</span><span class="number">20</span>;</span><br></pre></td></tr></table></figure><p>既可以先从表 t1 里面取出 c=10 的记录的 ID 值，再根据 ID 值关联到表 t2，再判断 t2 里面 d 的值是否等于 20。</p><p>也可以先从表 t2 里面取出 d=20 的记录的 ID 值，再根据 ID 值关联到 t1，再判断 t1 里面 c 的值是否等于 10。</p><p>这两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪一个方案。优化器阶段完成后，这个语句的执行方案就确定下来了，然后进入执行器阶段。</p><h2 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h2><p>MySQL 通过分析器知道了你要做什么，通过优化器知道了该怎么做，于是就进入了执行器阶段，开始执行语句。</p><p>开始执行的时候，要先判断一下你对这个表 T 有没有执行查询的权限，如果没有，就会返回没有权限的错误，如下所示 (在工程实现上，如果命中查询缓存，会在查询缓存返回结果的时候，做权限验证。查询也会在优化器之前调用 precheck 验证权限)。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> T <span class="keyword">where</span> ID<span class="operator">=</span><span class="number">10</span>;ERROR <span class="number">1142</span> (<span class="number">42000</span>): <span class="keyword">SELECT</span> command denied <span class="keyword">to</span> <span class="keyword">user</span> <span class="string">&#x27;b&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> <span class="keyword">for</span> <span class="keyword">table</span> <span class="string">&#x27;T&#x27;</span></span><br></pre></td></tr></table></figure><p>如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口。</p><p>比如我们这个例子中的表 T 中，ID 字段没有索引，那么执行器的执行流程是这样的：</p><p>调用 InnoDB 引擎接口取这个表的第一行，判断 ID 值是不是 10，如果不是则跳过，如果是则将这行存在结果集中；</p><p>调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。</p><p>执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。</p><p>至此，这个语句就执行完成了。</p><p>对于有索引的表，执行的逻辑也差不多。第一次调用的是“取满足条件的第一行”这个接口，之后循环取“满足条件的下一行”这个接口，这些接口都是引擎中已经定义好的。</p><p>你会在数据库的慢查询日志中看到一个<code>rows_examined</code>的字段，表示这个语句执行过程中扫描了多少行。这个值就是在执行器每次调用引擎获取数据行的时候累加的。</p><p>在有些场景下，执行器调用一次，在引擎内部则扫描了多行，因此<strong>引擎扫描行数跟 rows_examined 并不是完全相同的</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> database </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Spiral Matrix</title>
      <link href="/2022/01/11/Spiral-Matrix/"/>
      <url>/2022/01/11/Spiral-Matrix/</url>
      
        <content type="html"><![CDATA[<h2 id="54-螺旋矩阵"><a href="#54-螺旋矩阵" class="headerlink" title="54. 螺旋矩阵"></a><a href="https://leetcode-cn.com/problems/spiral-matrix/">54. 螺旋矩阵</a></h2><p>给你一个 <code>m</code> 行 <code>n</code> 列的矩阵 <code>matrix</code> ，请按照 <strong>顺时针螺旋顺序</strong> ，返回矩阵中的所有元素。</p><p><strong>Example 1:</strong></p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220111194853048.png" alt="image-20220111194853048"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">Output: [1,2,3,6,9,8,7,4,5]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220111195003770.png" alt="image-20220111195003770"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]</span><br><span class="line">Output: [1,2,3,4,8,12,11,10,9,5,6,7]</span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>m == matrix.length</code></li><li><code>n == matrix[i].length</code></li><li><code>1 &lt;= m, n &lt;= 10</code></li><li><code>-100 &lt;= matrix[i][j] &lt;= 100</code></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>参考<code>[59. 螺旋矩阵 II]</code>，模拟顺时针顺序，依次将数字填入结果链表<code>result</code>中</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">spiralOrder</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">top</span> <span class="operator">=</span> <span class="number">0</span>, bottom = m - <span class="number">1</span>, left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(result.size() &lt;= m * n) &#123;</span><br><span class="line">            <span class="comment">//从左到右</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left; i &lt;= right; i++) &#123;</span><br><span class="line">                result.add(matrix[top][i]);</span><br><span class="line">                <span class="keyword">if</span>(result.size() == m * n) &#123;</span><br><span class="line">                    <span class="keyword">return</span> result;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            top++;</span><br><span class="line">            <span class="comment">//从上往下</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> top; i &lt;= bottom; i++) &#123;</span><br><span class="line">                result.add(matrix[i][right]);</span><br><span class="line">                <span class="keyword">if</span>(result.size() == m * n) &#123;</span><br><span class="line">                    <span class="keyword">return</span> result;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            right--;</span><br><span class="line">            <span class="comment">//从右往左</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> right; i &gt;= left; i--) &#123;</span><br><span class="line">                result.add(matrix[bottom][i]);</span><br><span class="line">                <span class="keyword">if</span>(result.size() == m * n) &#123;</span><br><span class="line">                    <span class="keyword">return</span> result;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            bottom--;</span><br><span class="line">            <span class="comment">//从下往后上</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> bottom; i &gt;= top; i--) &#123;</span><br><span class="line">                result.add(matrix[i][left]);</span><br><span class="line">                <span class="keyword">if</span>(result.size() == m * n) &#123;</span><br><span class="line">                    <span class="keyword">return</span> result;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="59-螺旋矩阵-II"><a href="#59-螺旋矩阵-II" class="headerlink" title="59. 螺旋矩阵 II"></a><a href="https://leetcode-cn.com/problems/spiral-matrix-ii/">59. 螺旋矩阵 II</a></h2><p>给你一个正整数 <code>n</code> ，生成一个包含 <code>1</code> 到 <code>n2</code> 所有元素，且元素按顺时针顺序螺旋排列的 <code>n x n</code> 正方形矩阵 <code>matrix</code> 。</p><p><strong>示例 1：</strong></p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220111194853048.png" alt="image-20220111194853048"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：[[1,2,3],[8,9,4],[7,6,5]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 1</span><br><span class="line">输出：[[1]]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 20</code></li></ul><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ul><li><p>生成一个 <code>n × n </code>空矩阵 mat，随后模拟整个向内环绕的填入过程：</p><ol><li>定义当前左右上下边界<code> l,r,t,b</code>，初始值 num = 1，迭代终止值 <code>tar = n * n</code>；</li><li>当 <code>num &lt;= tar</code> 时，始终按照 从左到右 从上到下 从右到左 从下到上 填入顺序循环，每次填入后：<ul><li>执行 num += 1：得到下一个需要填入的数字；</li><li>更新边界：例如从左到右填完后，上边界 t += 1，相当于上边界向内缩 1。</li></ul></li><li>使用<code>num &lt;= tar</code>而不是<code>l &lt; r || t &lt; b</code>作为迭代条件，是为了解决当n为奇数时，矩阵中心数字无法在迭代过程中被填充的问题。</li></ol></li><li><p>最终返回 mat 即可。</p></li></ul><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/ccff416fa39887c938d36fec8e490e1861813d3bba7836eda941426f13420759-Picture1.png" alt="Picture1.png" style="zoom:67%;" /><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] generateMatrix(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">top</span> <span class="operator">=</span> <span class="number">0</span>, bottom = n - <span class="number">1</span>, left = <span class="number">0</span>, right = n - <span class="number">1</span>; </span><br><span class="line">        <span class="type">int</span>[][] result = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> n * n;</span><br><span class="line">        <span class="keyword">while</span>(num &lt;= target) &#123;</span><br><span class="line">            <span class="comment">//从左到右</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left; i &lt;= right; i++) &#123;</span><br><span class="line">                result[top][i] = num++;</span><br><span class="line">            &#125;</span><br><span class="line">            top++;</span><br><span class="line">            <span class="comment">//从上往下</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> top; i &lt;= bottom; i++) &#123;</span><br><span class="line">                result[i][right] = num++;</span><br><span class="line">            &#125;</span><br><span class="line">            right--;</span><br><span class="line">            <span class="comment">//从右往左</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> right; i &gt;= left; i--) &#123;</span><br><span class="line">                result[bottom][i] = num++;</span><br><span class="line">            &#125;</span><br><span class="line">            bottom--;</span><br><span class="line">            <span class="comment">//从下往后上</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> bottom; i &gt;= top; i--) &#123;</span><br><span class="line">                result[i][left] = num++;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="剑指-Offer-29-顺时针打印矩阵"><a href="#剑指-Offer-29-顺时针打印矩阵" class="headerlink" title="剑指 Offer 29. 顺时针打印矩阵"></a><a href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/">剑指 Offer 29. 顺时针打印矩阵</a></h2><p>难度简单335</p><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：[1,2,3,6,9,8,7,4,5]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]</span><br><span class="line">输出：[1,2,3,4,8,12,11,10,9,5,6,7]</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><ul><li><code>0 &lt;= matrix.length &lt;= 100</code></li><li><code>0 &lt;= matrix[i].length &lt;= 100</code></li></ul><p>注意：本题与主站 54 题相同：<a href="https://leetcode-cn.com/problems/spiral-matrix/">https://leetcode-cn.com/problems/spiral-matrix/</a></p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数组中的双指针相关题目</title>
      <link href="/2022/01/10/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E5%8F%8C%E6%8C%87%E9%92%88%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/"/>
      <url>/2022/01/10/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E5%8F%8C%E6%8C%87%E9%92%88%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="数组中的双指针"><a href="#数组中的双指针" class="headerlink" title="数组中的双指针"></a>数组中的双指针</h1><h2 id="leetcode-26-删除有序数组中的重复项"><a href="#leetcode-26-删除有序数组中的重复项" class="headerlink" title="leetcode 26. 删除有序数组中的重复项"></a><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/">leetcode 26. 删除有序数组中的重复项</a></h2><p>给你一个有序数组 <code>nums</code> ，请你**<a href="http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95"> 原地</a>** 删除重复出现的元素，使每个元素 <strong>只出现一次</strong> ，返回删除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在 <strong><a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地 </a>修改输入数组</strong> 并在使用 O(1) 额外空间的条件下完成。</p><p><strong>说明:</strong></p><p>为什么返回数值是整数，但输出的答案是数组呢?</p><p>请注意，输入数组是以<strong>「引用」</strong>方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝</span><br><span class="line">int len = removeDuplicates(nums);</span><br><span class="line"></span><br><span class="line">// 在函数里修改输入数组对于调用者是可见的。</span><br><span class="line">// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。</span><br><span class="line">for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,1,2]</span><br><span class="line">输出：2, nums = [1,2]</span><br><span class="line">解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,0,1,1,1,2,2,3,3,4]</span><br><span class="line">输出：5, nums = [0,1,2,3,4]</span><br><span class="line">解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= nums.length &lt;= 3 * 104</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li><li><code>nums</code> 已按升序排列</li></ul><h3 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h3><p>数组一旦创建，就不能改变其长度，因此题目的“删除”其实是把不重复的放在前面。</p><p>题目要求不使用额外的数组，那么就在原数组上修改。</p><p>使用双指针 <code>slow</code> 和 <code>fast</code>  ，<code>slow</code>指针用来标记下一个不重复元素应该存储的位置，<code>fast</code>指针用来遍历数组。</p><h3 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h3><ol><li><p>当数组为空时，则返回 0 ；</p></li><li><p>当数组长度 &gt; 0时， 不管有没有重复元素，至少有一个不重复的元素，nums[0]一定是最后结果数组中的。因此我们从nums[1]开始遍历。设置 slow = 1, fast = 1</p></li><li><p><code>fast</code> 指针遍历数组</p><ul><li><p>当 nums[fast] == nums[fast - 1]时，说明当前fast元素已经重复，那么 fast指针继续后移（slow不动）；</p><p>当 nums[fast]  != nums[fast - 1]时，说明当前fast元素与之前不重复，将其放入<code>slow</code>的位置，<code>slow</code>和<code>fast</code>均后移。</p><p>牢记<code>slow</code>表示下一个不重复元素要放置的位置！！！！</p></li></ul></li><li><p>不重复数组长度为 <code>slow</code></p></li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">fast</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(fast &lt; nums.length) &#123;</span><br><span class="line">            <span class="comment">// nums[fast] == nums[fast - 1]时，说明当前fast元素已经重复，那么 fast指针继续后移（slow不动）</span></span><br><span class="line">            <span class="keyword">if</span>(nums[fast] == nums[fast - <span class="number">1</span>]) &#123;</span><br><span class="line">                fast++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">                <span class="comment">// 当 nums[fast]  != nums[fast - 1]时，说明当前fast元素与之前不重复，</span></span><br><span class="line">                <span class="comment">// 将其放入`slow`的位置，`slow`和`fast`均后移</span></span><br><span class="line">                nums[slow] = nums[fast];</span><br><span class="line">                slow++;</span><br><span class="line">                fast++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><p>时间复杂度： 由于利用双指针只遍历一次数组，所以时间复杂度为<code>O(N)</code></p><p>空间复杂度：为创建新数组，只是创建slow，fast指针，所以空间复杂度为<code>O(1)</code></p><h2 id="leetcode-27-移除元素"><a href="#leetcode-27-移除元素" class="headerlink" title="leetcode 27. 移除元素"></a><a href="https://leetcode-cn.com/problems/remove-element/">leetcode 27. 移除元素</a></h2><p>给你一个数组 <code>nums</code> 和一个值 <code>val</code>，你需要 <strong><a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a></strong> 移除所有数值等于 <code>val</code> 的元素，并返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须仅使用 <code>O(1)</code> 额外空间并 <strong><a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地 </a>修改输入数组</strong>。</p><p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p><p><strong>说明:</strong></p><p>为什么返回数值是整数，但输出的答案是数组呢?</p><p>请注意，输入数组是以<strong>「引用」</strong>方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝</span><br><span class="line">int len = removeElement(nums, val);</span><br><span class="line"></span><br><span class="line">// 在函数里修改输入数组对于调用者是可见的。</span><br><span class="line">// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。</span><br><span class="line">for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,2,2,3], val = 3</span><br><span class="line">输出：2, nums = [2,2]</span><br><span class="line">解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,1,2,2,3,0,4,2], val = 2</span><br><span class="line">输出：5, nums = [0,1,4,0,3]</span><br><span class="line">解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= nums.length &lt;= 100</code></li><li><code>0 &lt;= nums[i] &lt;= 50</code></li><li><code>0 &lt;= val &lt;= 100</code></li></ul><h3 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h3><p>这道题和第 27 题很像。这道题和第 283 题，第 27 题基本一致，283 题是删除 0，27 题是删除指定元素，这一题是删除重复元素，实质是一样的。</p><p>这里数组的删除并不是真的删除，只是将不需移除的元素放在数组前面。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">fast</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(fast &lt; nums.length) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[fast] == val) &#123;</span><br><span class="line">                fast++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nums[slow] = nums[fast];</span><br><span class="line">                slow++;</span><br><span class="line">                fast++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="leetcode-283-移动零"><a href="#leetcode-283-移动零" class="headerlink" title="leetcode 283. 移动零"></a><a href="https://leetcode-cn.com/problems/move-zeroes/">leetcode 283. 移动零</a></h2><p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p><p><strong>示例:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [0,1,0,3,12]</span><br><span class="line">输出: [1,3,12,0,0]</span><br></pre></td></tr></table></figure><p><strong>说明</strong>:</p><ol><li>必须在原数组上操作，不能拷贝额外的数组。</li><li>尽量减少操作次数。</li></ol><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>利用 26，27的双指针解法，将非0元素移到数组前面，记录<code>fast</code>遍历时<code>0</code>的个数 <code>count</code>，最后在数组的最后 count 个数设置为0。</p><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">moveZeroes</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">fast</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(fast &lt; nums.length) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[fast] == <span class="number">0</span>) &#123;</span><br><span class="line">                fast++;</span><br><span class="line">                count++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nums[slow] = nums[fast];</span><br><span class="line">                fast++;</span><br><span class="line">                slow++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(; count &gt; <span class="number">0</span>; count--) &#123;</span><br><span class="line">            nums[nums.length - count] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="leetcode-977-有序数组的平方"><a href="#leetcode-977-有序数组的平方" class="headerlink" title="leetcode 977. 有序数组的平方"></a><a href="https://leetcode-cn.com/problems/squares-of-a-sorted-array/">leetcode 977. 有序数组的平方</a></h2><p>给你一个按 <strong>非递减顺序</strong> 排序的整数数组 <code>nums</code>，返回 <strong>每个数字的平方</strong> 组成的新数组，要求也按 <strong>非递减顺序</strong> 排序。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-4,-1,0,3,10]</span><br><span class="line">输出：[0,1,9,16,100]</span><br><span class="line">解释：平方后，数组变为 [16,1,0,9,100]</span><br><span class="line">排序后，数组变为 [0,1,9,16,100]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-7,-3,2,3,11]</span><br><span class="line">输出：[4,9,9,49,121]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 104</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li><li><code>nums</code> 已按 <strong>非递减顺序</strong> 排序</li></ul><p><strong>进阶：</strong></p><ul><li>请你设计时间复杂度为 <code>O(n)</code> 的算法解决本问题</li></ul><h3 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h3><p>最先想到的肯定就是直接遍历数组的每个值平方，然后排序美滋滋</p><h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortedSquares(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            nums[i] = nums[i] * nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Arrays.sort(nums)</code>底层对基本数据类型排序使用的是快速排序，我们回顾一下快速排序，平均时间复杂度是<code>O(NlogN)</code>，最坏情况下是<code>O(N^2)</code></p><p>因此我们需要对<strong>解法一</strong>进行优化</p><h3 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h3><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>题目是<code>非递减数组</code>，所以可知数组的最外边是最大的，越在中心越小。</p><p>此时可以考虑双指针法了，i指向起始位置，j指向终止位置。</p><p>定义一个新数组result，和A数组一样的大小，让k指向result数组终止位置。</p><p>如果<code>A[i] * A[i] &lt; A[j] * A[j]</code> 那么<code>result[k--] = A[j] * A[j];</code> 。</p><p>如果<code>A[i] * A[i] &gt;= A[j] * A[j]</code> 那么<code>result[k--] = A[i] * A[i];</code> 。</p><p>具体步骤如下动图所示（参考<a href="https://www.programmercarl.com/0977.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9.html#%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95">代码随想录</a>）：</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/977.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9.gif" alt="977.有序数组的平方"></p><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortedSquares(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//新数组从后往前，从大到小的放置元素</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] * nums[i] &gt; nums[j] * nums[j]) &#123;</span><br><span class="line">                res[k] = nums[i] * nums[i];</span><br><span class="line">                i++;</span><br><span class="line">                k--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res[k] = nums[j] * nums[j];</span><br><span class="line">                j--;</span><br><span class="line">                k--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Binary Search Algorithm and Related Topics</title>
      <link href="/2022/01/08/Binary%20Search%20Algorithm%20and%20Related%20Topics/"/>
      <url>/2022/01/08/Binary%20Search%20Algorithm%20and%20Related%20Topics/</url>
      
        <content type="html"><![CDATA[<h3 id="二分查找算法的要求"><a href="#二分查找算法的要求" class="headerlink" title="二分查找算法的要求"></a>二分查找算法的要求</h3><ul><li>1.必须采用<strong>顺序存储</strong>结构</li><li>2.必须按关键字大小有序排列</li></ul><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>首先，将表中间位置记录的关键字与查找关键字比较，如果两者相等，则查找成功；否则利用中间位置记录将表分成前、后两个子表，如果中间位置记录的关键字大于查找关键字，则进一步查找前一子表，否则进一步查找后一子表。<br>重复以上过程，直到找到满足条件的记录，使查找成功，或直到子表不存在为止，此时查找不成功。</p><p>第一种写法，我们定义 target 是在一个在左闭右闭的区间里，<strong>也就是[left, right] （这个很重要非常重要）</strong>。</p><p>区间的定义这就决定了二分法的代码应该如何写，<strong>因为定义target在[left, right]区间，所以有如下两点：</strong></p><ul><li>while (left &lt;= right) 要使用 <strong>&lt;=</strong> ，因为left == right是有意义的 （当数组个数为<strong>偶数</strong>时，就会出现这种情况），所以使用 &lt;=</li><li>if (nums[middle] &gt; target) right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1</li></ul><p>例如在数组：1,2,3,4,7,9,10中查找元素2，如图所示：</p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/20210311153055723.jpg" alt="704.二分查找" style="zoom:80%;" /><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(target &lt; nums[<span class="number">0</span>] || target &gt; nums[nums.length - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &lt;= high) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (low + high) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//找到直接返回</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target) &#123;<span class="comment">//在右子表</span></span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//在左子表</span></span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>二分查找最重要的就是边界问题</strong>     </p><p>while（low &lt;= high）{} </p><h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220108134734989.png" alt="image-20220108134734989"></p><h2 id="leetcode-35-搜索插入位置"><a href="#leetcode-35-搜索插入位置" class="headerlink" title="leetcode 35. 搜索插入位置"></a><a href="https://leetcode-cn.com/problems/search-insert-position/">leetcode 35. 搜索插入位置</a></h2><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>请必须使用时间复杂度为 <strong>O(log n)</strong> 的算法。</p><p>示例 1:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,3,5,6], target = 5</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,3,5,6], target = 2</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure><p>示例 3:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,3,5,6], target = 7</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure><p>示例 4:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,3,5,6], target = 0</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure><p>示例 5:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1], target = 0</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">searchInsert</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="comment">//先二分查找，利用pos记录 mid 最后的位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &lt;= high) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (low + high) / <span class="number">2</span>;</span><br><span class="line">            pos = mid;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target) &#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target) &#123;</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//根据最后pos的位置来确定不存在元素的插入位置</span></span><br><span class="line">        <span class="keyword">if</span>(nums[pos] &lt; target) &#123;</span><br><span class="line">            <span class="keyword">return</span> pos + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pos == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> pos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="leetcode-34-在排序数组中查找元素的第一个和最后一个位置"><a href="#leetcode-34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="leetcode 34. 在排序数组中查找元素的第一个和最后一个位置"></a><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/">leetcode 34. 在排序数组中查找元素的第一个和最后一个位置</a></h2><p>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。</p><p>如果数组中不存在目标值 target，返回 [-1, -1]。</p><p>进阶：</p><p>你可以设计并实现时间复杂度为 O(log n) 的算法解决此问题吗？</p><p>示例 1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [5,7,7,8,8,10], target = 8</span><br><span class="line">输出：[3,4]</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [5,7,7,8,8,10], target = 6</span><br><span class="line">输出：[-1,-1]</span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [], target = 0</span><br><span class="line">输出：[-1,-1]</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li><p>0 &lt;= nums.length &lt;= 105</p></li><li><p>-109 &lt;= nums[i] &lt;= 109</p></li><li><p>nums 是一个非递减数组</p></li><li><p>-109 &lt;= target &lt;= 109</p></li></ul><h3 id="最先想到的解法思路"><a href="#最先想到的解法思路" class="headerlink" title="最先想到的解法思路"></a>最先想到的解法思路</h3><p>利用二分法找到第一个符合的位置，然后向两边扩展，但如果整个数组都是目标值的活，时间复杂度应该是<strong>O（N）</strong></p><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] searchRange(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &lt;= high) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (low + high) / <span class="number">2</span>;</span><br><span class="line">            pos = mid;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target) &#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target) &#123;</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[pos] != target) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = pos;</span><br><span class="line">            right = pos;</span><br><span class="line">            <span class="comment">//找左边界</span></span><br><span class="line">            <span class="keyword">while</span>(left - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; nums[left - <span class="number">1</span>] == target) &#123;</span><br><span class="line">                left--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//找右边界</span></span><br><span class="line">            <span class="keyword">while</span>(right + <span class="number">1</span> &lt;= nums.length - <span class="number">1</span> &amp;&amp; nums[right + <span class="number">1</span>] == target) &#123;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;left, right&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优化解法"><a href="#优化解法" class="headerlink" title="优化解法"></a>优化解法</h3><p>这一题是经典的二分搜索变种题。二分搜索有 4 大基础变种题：</p><ol><li>查找第一个值等于给定值的元素</li><li>查找最后一个值等于给定值的元素</li><li>查找第一个大于等于给定值的元素</li><li>查找最后一个小于等于给定值的元素</li></ol><p>这一题的解题思路可以分别利用变种 1 和变种 2 的解法就可以做出此题。或者用一次变种 1 的方法，然后循环往后找到最后一个与给定值相等的元素。不过后者这种方法可能会使时间复杂度下降到 O(n)，因为有可能数组中 n 个元素都和给定元素相同。(4 大基础变种的实现见代码)</p><h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] searchRange(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;firstElement(nums, target), lastElement(nums, target)&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">firstElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &lt;= high) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (low + high) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target) &#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target) &#123;</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(mid == <span class="number">0</span> || nums[mid - <span class="number">1</span>] != target) &#123;</span><br><span class="line">                    <span class="keyword">return</span> mid;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//说明在当前mid 的左边还有符合的元素，那么就去左边继续利用二分查找</span></span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lastElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &lt;= high) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (low + high) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target) &#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target) &#123;</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(mid == nums.length - <span class="number">1</span> || nums[mid + <span class="number">1</span>] != target) &#123;</span><br><span class="line">                    <span class="keyword">return</span> mid;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//说明在当前mid 的左边还有符合的元素，那么就去左边继续利用二分查找</span></span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="算法分析-1"><a href="#算法分析-1" class="headerlink" title="算法分析"></a>算法分析</h4><p>左右边界均是利用二分查找找到的，所以时间复杂度为 O（logN）</p><h2 id="leetcode-69-Sqrt-x"><a href="#leetcode-69-Sqrt-x" class="headerlink" title="leetcode 69. Sqrt(x)"></a><a href="https://leetcode-cn.com/problems/sqrtx/">leetcode 69. Sqrt(x)</a></h2><p>给你一个非负整数 x ，计算并返回 x 的 算术平方根 。</p><p>由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。</p><p>注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。</p><p>示例 1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：x = 4</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：x = 8</span><br><span class="line">输出：2</span><br><span class="line">解释：8 的算术平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li>0 &lt;= x &lt;= 231 - 1</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>利用二分查找，设结果为 <code>res</code>， 可以看作在区间【0，x】上找出最后一个res，使得 <code>res * res &lt;= x</code></p><p>利用二分查找最后一个小于等于 target 的元素的模板，稍加改动</p><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">mySqrt</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="comment">//特殊值</span></span><br><span class="line">        <span class="keyword">if</span>(x == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> x;</span><br><span class="line">        <span class="keyword">while</span>(low &lt;= high) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> low + (high - low) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//使用(long)强转 以及 不使用mid * mid而是用 mid &gt; x / mid为了防止超过 int 最大值</span></span><br><span class="line">            <span class="keyword">if</span>((<span class="type">long</span>)mid * mid &lt;= x) &#123;</span><br><span class="line">                <span class="keyword">if</span>(mid + <span class="number">1</span> &gt; x / (mid + <span class="number">1</span>)) &#123;</span><br><span class="line">                    pos = mid;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="leetcode-367-有效的完全平方数"><a href="#leetcode-367-有效的完全平方数" class="headerlink" title="leetcode 367. 有效的完全平方数"></a><a href="https://leetcode-cn.com/problems/valid-perfect-square/">leetcode 367. 有效的完全平方数</a></h2><p>给定一个 正整数 num ，编写一个函数，如果 num 是一个完全平方数，则返回 true ，否则返回 false 。</p><p>进阶：不要 使用任何内置的库函数，如  sqrt 。</p><p>示例 1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：num = 16</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：num = 14</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li>1 &lt;= num &lt;= 2^31 - 1</li></ul><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>二分查找相关题目，同69题</p><h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPerfectSquare</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> num;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &lt;= high) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> low + (high - low) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>((<span class="type">long</span>)mid * mid == num) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="type">long</span>)mid * mid &lt; num) &#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-大基础变种的代码实现"><a href="#4-大基础变种的代码实现" class="headerlink" title="4 大基础变种的代码实现"></a>4 大基础变种的代码实现</h3><p> <a href="https://books.halfrost.com/leetcode/ChapterFour/0001~0099/0034.Find-First-and-Last-Position-of-Element-in-Sorted-Array/">Go实现，转载自 <strong>halfrost</strong>《LeetCode Cookbook》</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">searchRange</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> []<span class="type">int</span>&#123;searchFirstEqualElement(nums, target), searchLastEqualElement(nums, target)&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二分查找第一个与 target 相等的元素，时间复杂度 O(logn)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">searchFirstEqualElement</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">low, high := <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line"><span class="keyword">for</span> low &lt;= high &#123;</span><br><span class="line">mid := low + ((high - low) &gt;&gt; <span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> nums[mid] &gt; target &#123;</span><br><span class="line">high = mid - <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[mid] &lt; target &#123;</span><br><span class="line">low = mid + <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (mid == <span class="number">0</span>) || (nums[mid<span class="number">-1</span>] != target) &#123; <span class="comment">// 找到第一个与 target 相等的元素</span></span><br><span class="line"><span class="keyword">return</span> mid</span><br><span class="line">&#125;</span><br><span class="line">high = mid - <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二分查找最后一个与 target 相等的元素，时间复杂度 O(logn)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">searchLastEqualElement</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">low, high := <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line"><span class="keyword">for</span> low &lt;= high &#123;</span><br><span class="line">mid := low + ((high - low) &gt;&gt; <span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> nums[mid] &gt; target &#123;</span><br><span class="line">high = mid - <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[mid] &lt; target &#123;</span><br><span class="line">low = mid + <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (mid == <span class="built_in">len</span>(nums)<span class="number">-1</span>) || (nums[mid+<span class="number">1</span>] != target) &#123; <span class="comment">// 找到最后一个与 target 相等的元素</span></span><br><span class="line"><span class="keyword">return</span> mid</span><br><span class="line">&#125;</span><br><span class="line">low = mid + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二分查找第一个大于等于 target 的元素，时间复杂度 O(logn)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">searchFirstGreaterElement</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">low, high := <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line"><span class="keyword">for</span> low &lt;= high &#123;</span><br><span class="line">mid := low + ((high - low) &gt;&gt; <span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> nums[mid] &gt;= target &#123;</span><br><span class="line"><span class="keyword">if</span> (mid == <span class="number">0</span>) || (nums[mid<span class="number">-1</span>] &lt; target) &#123; <span class="comment">// 找到第一个大于等于 target 的元素</span></span><br><span class="line"><span class="keyword">return</span> mid</span><br><span class="line">&#125;</span><br><span class="line">high = mid - <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">low = mid + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二分查找最后一个小于等于 target 的元素，时间复杂度 O(logn)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">searchLastLessElement</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">low, high := <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line"><span class="keyword">for</span> low &lt;= high &#123;</span><br><span class="line">mid := low + ((high - low) &gt;&gt; <span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> nums[mid] &lt;= target &#123;</span><br><span class="line"><span class="keyword">if</span> (mid == <span class="built_in">len</span>(nums)<span class="number">-1</span>) || (nums[mid+<span class="number">1</span>] &gt; target) &#123; <span class="comment">// 找到最后一个小于等于 target 的元素</span></span><br><span class="line"><span class="keyword">return</span> mid</span><br><span class="line">&#125;</span><br><span class="line">low = mid + <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">high = mid - <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Sorting algorithrm I</title>
      <link href="/2021/12/29/Sorting-algorithrm/"/>
      <url>/2021/12/29/Sorting-algorithrm/</url>
      
        <content type="html"><![CDATA[<p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/sort.png" alt="sort"></p><h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>​    冒泡排序是一种简单的交换类排序方法，它是通过对相邻数据元素进行交换，逐步将待排序序列变成有序序列的过程。</p><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a><strong>算法思想</strong></h3><p>反复扫描待排序序列，再扫描的过程中顺次比较相邻两个元素的大小，逆序就交换位置。</p><p>以升序为例，在第一趟冒泡排序中，从第一个记录开始，扫描整个待排序序列，若相邻的两个元素逆序，则交换位置。</p><p>在扫描在过程中，不断地将两个相邻记录中关键字大的记录向后移动，最后<strong>必然将待排序列中最大的换到序列的末尾。</strong></p><p>然后进行第二趟冒泡排序，对前n -1个元素进行同样的操作，其结果是使次大的元素被放在第 n - 1个位置上。</p><p>然后进行第三趟冒泡排序，对前n - 2个元素进行同样的操作，其结果是使第三大的元素被放在第 n - 2个位置上。</p><p>如此反复，知道剩下一个最小的元素。</p><p>如果<strong>在某一趟冒泡排序过程中，没有发现一个逆序，说明已经有序，则可以直接结束整个排序</strong>。所以<strong>冒泡排序最多进行 n -1 趟</strong>。（只剩最后一个不用再进行排序，因为已经比它大的已经全在它的右边排好了，所以最多 n - 1趟）</p><h3 id="动图演示："><a href="#动图演示：" class="headerlink" title="动图演示："></a>动图演示：</h3><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/bubbleSort.gif" alt="bubbleSort"></p><h3 id="最好情况"><a href="#最好情况" class="headerlink" title="最好情况"></a>最好情况</h3><p>当输入的数据已经是<strong>正序</strong>时（都已经是正序了，我还要你冒泡排序有何用啊）。</p><h3 id="最坏情况"><a href="#最坏情况" class="headerlink" title="最坏情况"></a>最坏情况</h3><p>当输入的数据是<strong>逆序</strong>时（写一个 for 循环反序输出数据不就行了，干嘛要用你冒泡排序呢，我是闲的吗）。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> JZoffer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Array;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ykangli</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/12/29 12:55</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BubbleSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] a = &#123;<span class="number">2</span>, <span class="number">45</span>, <span class="number">34</span>, <span class="number">23</span>, <span class="number">5</span>, <span class="number">11</span>, <span class="number">32</span>, <span class="number">98</span>, <span class="number">61</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[] ints = <span class="keyword">new</span> <span class="title class_">BubbleSort</span>().bubbleSort(a);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> anInt : ints) &#123;</span><br><span class="line">            System.out.println(anInt);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] bubbleSort(<span class="type">int</span>[] sourceArray) &#123;</span><br><span class="line">        <span class="comment">//对 arr 进行拷贝，不改变原数组</span></span><br><span class="line">        <span class="type">int</span>[] arr = Arrays.copyOf(sourceArray, sourceArray.length);</span><br><span class="line">        <span class="comment">//最多排 n - 1趟</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="comment">//设置一个flag，当在一趟序列遍历中元素没有发生交换，则证明该序列已经有序，结束整个冒泡排序</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length - i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[j];</span><br><span class="line">                    arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                    arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><ul><li><p>时间复杂度：O(N^2)</p></li><li><p>空间复杂度：O(1)</p></li><li><p>冒泡排序是<strong>稳定</strong>的排序</p></li></ul><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h3 id="算法改进要点"><a href="#算法改进要点" class="headerlink" title="算法改进要点"></a>算法改进要点</h3><p>冒泡排序在扫描过程中只对相邻两个元素进行比较，因此互换相邻元素只能消除一个逆序。如果能通过两个（不相邻）元素的交换，相处待排序序列中的多个逆序，则会大大加快排序的速度。</p><p>快速排序中的一次交换可能消除多个逆序。</p><h3 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h3><p>从待排序记录序列中选取一个元素（通常选取第一个元素）为<strong>枢轴</strong>，其关键字设为 pivot，然后将其余关键字小于 pivot的记录移到前面，而将关键字大于或等于 pivot的记录移到后面，结果将待排序记录序列分成两个子表，最后将关键字为 pivot的记录插到其分界线的位置处。将这个过程称为一趟快速排序。通过一次划分后，就以关键字为 pivot的记录来为界，将待排序序列分成了两个子表，且前面子表中所有记录的关键字均小于 pivot ，而后面子表中的所有记录的关键字均大于或等于pivot。对分割后的子表继续按上述原则进行分割，直到所有子表的表长不超过1为止，此时待排序记录序列就变成了一个有序表。</p><h3 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h3><p>假设待划分序列为 r[ low ], r[ low +1 ], … r[ high ] 。首先将基准记录 r[ low ]移至<strong>变量 pivot</strong> 中．使 r [ low ］相当于空单元，然后反复进行如下两个扫描过程，<strong>直到 low 和 high 相遇</strong>。</p><p>high 从右向左扫描，直到r [high] &lt; pivot时，将 r [ high］移至空单元元 r [ Iow ]处，此时 r[ high ]相当于空单元。<br>low 从左向右扫描，直到 r [low]  ≥ pivot时，将 r [ low ］移至空单元 r [ high ]，此时 r [l ow ］相当于空单元.<br>当 low 和 high 相遇时，r[ low ]或 r [ high ] 相当于空单元，且 r[ low ］<strong>左边所有记录的关键字均小于基准记录的关键字</strong>，而 r [ low ]<strong>右边所有记录的关键字均大于或等于基准记录的关键字</strong>。最后将基准记录移至r[ low ］中就完成一次划分过程。对于 r [ low ］左边的子表和   r [ low］右边的子表可采用同样的方法进行进一步划分。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">QuickSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] a = &#123;<span class="number">2</span>, <span class="number">45</span>, <span class="number">34</span>, <span class="number">23</span>, <span class="number">5</span>, <span class="number">11</span>, <span class="number">32</span>, <span class="number">98</span>, <span class="number">61</span>&#125;;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">QuickSort</span>().quickSort(a, <span class="number">0</span>, <span class="number">8</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : a) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] r, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="comment">//调用一趟快速排序算法，以枢纽pivot为界划分为两个子表</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> quickPass(r, low, high);</span><br><span class="line">            <span class="comment">//递归对左子表进行快速排序</span></span><br><span class="line">            quickSort(r, low, pivot - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//递归对右子表进行快速排序</span></span><br><span class="line">            quickSort(r, pivot + <span class="number">1</span>, high);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 一趟快速排序算法，返回调整后基准数的位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">quickPass</span><span class="params">(<span class="type">int</span>[] r, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">        <span class="comment">//选择第一个元素为基准数</span></span><br><span class="line">        <span class="comment">//有的书上是以中间的数作为基准数的，要实现这个方便非常方便，直接将中间的数和第一个数进行交换就可以了。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> r[low];</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="keyword">while</span> (low &lt; high &amp;&amp; r[high] &gt;= pivot) &#123;</span><br><span class="line">                high--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">                r[low] = r[high];</span><br><span class="line">                low++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (low &lt; high &amp;&amp; r[low] &lt; pivot) &#123;</span><br><span class="line">                low++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">                r[high] = r[low];</span><br><span class="line">                high--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        r[low] = pivot;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最好情况-1"><a href="#最好情况-1" class="headerlink" title="最好情况"></a>最好情况</h3><p>每趟将序列一分两半，正好在表中间，将表分成两个大小相等的子表，为<code>O(NlogN)</code></p><h3 id="最坏情况-1"><a href="#最坏情况-1" class="headerlink" title="最坏情况"></a>最坏情况</h3><p>已经排好序。</p><p>第一趟经过n - 1 次比较，第一次记录定在原位置，左部子表为空表，右部子表为 n - 1 个记录，第二趟对第一趟排序后的右子表经过 n - 2 次比较，第二个记录定在原位置，左部子表为空表，右部子表为 n - 2个记录 …… 共需经过 n(n - 1) / 2次比较，所以时间复杂度<code>O(N^2)</code></p><h3 id="算法分析-1"><a href="#算法分析-1" class="headerlink" title="算法分析"></a>算法分析</h3><ul><li>时间复杂度：*快速排序的最坏运行情况是 **O(n²)*<em>，比如说已排好序的数列。但它的平摊期望时间是 O(nlogn)，且 O(nlogn) 记号中隐含的常数因子很小，比复杂度稳定等于 O(nlogn) 的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。</em></li><li>空间复杂度：快速排序递归算法的执行过程对应一颗二叉树，理想情况下是一颗完全二叉树。平均情况下空间复杂度<strong>O(logN)</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Sliding Window</title>
      <link href="/2021/12/28/Sliding-Window/"/>
      <url>/2021/12/28/Sliding-Window/</url>
      
        <content type="html"><![CDATA[<h1 id="滑动窗口的相关题型"><a href="#滑动窗口的相关题型" class="headerlink" title="滑动窗口的相关题型"></a>滑动窗口的相关题型</h1><h2 id="leetcode-1-两数之和"><a href="#leetcode-1-两数之和" class="headerlink" title="leetcode 1. 两数之和"></a><a href="https://leetcode-cn.com/problems/two-sum/">leetcode 1. 两数之和</a></h2><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p><p>示例 1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,7,11,15], target = 9</span><br><span class="line">输出：[0,1]</span><br><span class="line">解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,2,4], target = 6</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,3], target = 6</span><br><span class="line">输出：[0,1]</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li><p>2 &lt;= nums.length &lt;= 104</p></li><li><p>-109 &lt;= nums[i] &lt;= 109</p></li><li><p>-109 &lt;= target &lt;= 109</p></li><li><p>只会存在一个有效答案</p></li></ul><p>进阶：你可以想出一个时间复杂度小于 O(n2) 的算法吗？</p><h3 id="暴力解法："><a href="#暴力解法：" class="headerlink" title="暴力解法："></a>暴力解法：</h3><h4 id="思路分析："><a href="#思路分析：" class="headerlink" title="思路分析："></a>思路分析：</h4><p>枚举数组中的每一个数 <code>x</code>，寻找数组中是否存在 <code>target - x</code>。</p><p>当我们使用遍历整个数组的方式寻找 <code>target - x</code> 时，需要注意到每一个位于 <code>x</code> 之前的元素都已经和 <code>x</code> 匹配过，因此不需要再进行匹配，所以我们只需要在 <code>x</code> 后面的元素中寻找 <code>target - x</code>。</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">difference</span> <span class="operator">=</span> target - nums[i];</span><br><span class="line">            right = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(right &lt; nums.length) &#123;</span><br><span class="line">                <span class="keyword">if</span>(difference == nums[right]) &#123;</span><br><span class="line">                    result[<span class="number">0</span>] = i;</span><br><span class="line">                    result[<span class="number">1</span>] = right;</span><br><span class="line">                    <span class="keyword">return</span> result;</span><br><span class="line">                &#125;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li><p>时间复杂度：O(N^2)，其中 N 是数组中的元素数量。最坏情况下数组中任意两个数都要被匹配一次。</p></li><li><p>空间复杂度：O(1)。</p></li></ul><h3 id="哈希表解法："><a href="#哈希表解法：" class="headerlink" title="哈希表解法："></a>哈希表解法：</h3><h4 id="思路分析：-1"><a href="#思路分析：-1" class="headerlink" title="思路分析："></a>思路分析：</h4><p>暴力解法时间复杂度较高的原因是寻找 target - x 的时间复杂度过高。因此，我们需要一种更优秀的方法，能够快速寻找数组中是否存在目标元素。如果存在，我们需要找出它的索引。</p><p>我们可以利用HashMap，如果哈希表中无该元素，就将每遍历到的元素加入哈希表。比如：当 nums = [2, 3, 4, 5, 6, 7]， target = 9。</p><p>最多当遍历到 7 ，哈希表中已经存入 2，可以 O(1)地寻找 <code>target - x</code>。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">difference</span> <span class="operator">=</span> target - nums[i];</span><br><span class="line">            <span class="keyword">if</span>(map.get(difference) != <span class="literal">null</span>) &#123;</span><br><span class="line">                result[<span class="number">0</span>] = i;</span><br><span class="line">                result[<span class="number">1</span>] = map.get(difference);</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li><p>时间复杂度：O(N)，其中 N 是数组中的元素数量。对于每一个元素 x，我们可以 O(1) 地寻找 target - x。</p></li><li><p>空间复杂度：O(N)，其中 N 是数组中的元素数量。主要为哈希表的开销。</p></li></ul><h2 id="leetcode-15-三数之和"><a href="#leetcode-15-三数之和" class="headerlink" title="leetcode 15. 三数之和"></a><a href="https://leetcode-cn.com/problems/3sum/">leetcode 15. 三数之和</a></h2><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。</p><p>注意：答案中不可以包含重复的三元组。</p><p>示例 1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-1,0,1,2,-1,-4]</span><br><span class="line">输出：[[-1,-1,2],[-1,0,1]]</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0]</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li><code>0 &lt;= nums.length &lt;= 3000</code></li><li><code>-105 &lt;= nums[i] &lt;= 105</code></li></ul><h3 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析:"></a>思路分析:</h3><p>如果我们直接使用三重循环枚举三元组，会得到 O(N^3)个满足题目要求的三元组（其中 N是数组的长度）**时间复杂度至少为 O(N^3)**。在这之后，我们还需要使用哈希表进行去重操作，得到不包含重复三元组的最终答案，又消耗了大量的空间。这个做法的时间复杂度和空间复杂度都很高，因此我们要换一种思路来考虑这个问题。</p><p>拿这个 nums 数组来举例，首先将数组排序，然后有一层for循环，k 从下标0的地方开始，同时定一个下标 i = k+1 的位置上，定义下标 j 在数组结尾的位置上(j = nums.length - 1)。</p><p>依然还是在数组中找到 abc 使得a + b +c =0，我们这里相当于 a = nums[k] ,b = nums[i] ,c = nums[j]。</p><p>接下来如何移动left 和right呢， 如果nums[i] + nums[left] + nums[right] &gt; 0 就说明 此时三数之和大了，因为数组是排序后了，所以right下标就应该向左移动，这样才能让三数之和小一些。</p><p>如果 nums[i] + nums[left] + nums[right] &lt; 0 说明 此时 三数之和小了，i 就向右移动，才能让三数之和大一些，直到 i 与 j 相遇为止。</p><h3 id="双指针法思路"><a href="#双指针法思路" class="headerlink" title="双指针法思路"></a>双指针法思路</h3><p> 固定 3个指针中最左（最小）数字的指针 k，双指针 i，j 分设在数组索引 (k, len(nums)) 两端，通过双指针交替向中间移动，记录对于每个固定指针 k 的所有满足 nums[k] + nums[i] + nums[j] == 0 的 i,j 组合：</p><ol><li><p>当 nums[k] &gt; 0 时直接break跳出：因为 nums[j]  &gt;=  nums[i]  &gt;=  nums[k]  &gt; 0，即 3个数字都大于 0，则三数之和必然无法等于 0，结束循环。</p></li><li><p>当 k &gt; 0且nums[k] == nums[k - 1]时即跳过此元素nums[k]：因为<strong>已经将 nums[k - 1] 的所有组合加入到结果中</strong>，本次双指针搜索只会得到重复组合。</p></li><li><p>i，j 分设在数组索引  (k, len(nums)) 两端，当i &lt; j时循环计算s = nums[k] + nums[i] + nums[j]，并按照以下规则执行双指针移动：</p><ul><li><p>当s &lt; 0时，说明nums[i] 太小，i 右移；</p></li><li><p>当s &gt; 0时，说明nums[j] 太大，j 左移；</p></li><li><p>当s == 0时，记录组合[k, i, j]至 res，<strong>执行i += 1和j -= 1</strong>，并跳过所有重复的nums[i] 和 nums[j]，防止记录到重复组合。</p></li></ul></li></ol><p>其实第二个和第三个数就是<strong>滑动窗口</strong>。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="literal">null</span> || nums.length &lt; <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; nums.length; k++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[k] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//k进行去重  注意去重条件    nums[k] == nums[k + 1]是错误的！！！！</span></span><br><span class="line">            <span class="keyword">if</span>(k &gt; <span class="number">0</span> &amp;&amp; nums[k] == nums[k - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; j) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums[k] + nums[i] + nums[j];</span><br><span class="line">                <span class="keyword">if</span>(sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(sum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    j--;           </span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    res.add(Arrays.asList(nums[k], nums[i], nums[j]));</span><br><span class="line">                    <span class="comment">//i,j同时减小，过程中去除重复的i,j   </span></span><br><span class="line">                   <span class="comment">//注意++i效率更高，++i是直接对于原对象进行自增，不用生成临时变量</span></span><br><span class="line">                    <span class="comment">//而且不需要最后再进行一次 i++ 到不重复的位置去</span></span><br><span class="line">                    <span class="keyword">while</span>(i &lt; j &amp;&amp; nums[i] == nums[++i]) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">while</span>(i &lt; j &amp;&amp; nums[j] == nums[--j]) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>++i 和 i++<strong>两者参与运算时的区别就是：</strong></p><ol><li>a=i++ , a 返回原来的值a=i,i=i+1;<br>a=++i , a 返回加1后的值,a=i+1,i=i+1。<br>也就是<strong>i++是先赋值，然后再自增；++i是先自增，后赋值。</strong></li><li>第二个区别就是： i++ 不能作为左值，而++i可以。</li></ol><p><strong>两者效率在某些情况下仍有不同！</strong></p><p>当我们考虑自定义类的时候，就不一样了。</p><p>i++是先用临时对象保存原来的对象，然后对原对象自增，再返回临时对象，不能作为左值；**++i是直接对于原对象进行自增**，然后返回原对象的引用，可以作为左值。</p><p>由于要生成临时对象，i++需要调用两次拷贝构造函数与析构函数（将原对象赋给临时对象一次，临时对象以值传递方式返回一次）；</p><p><strong>++i由于不用生成临时变量</strong>，且以引用方式返回，故没有构造与析构的开销，<strong>效率更高</strong>。</p><p>所以在使用类等自定义类型的时候，应尽量使用++i。</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20211230163506590.png" alt="image-20211230163506590"></p><h2 id="leetcode-18-四数之和"><a href="#leetcode-18-四数之和" class="headerlink" title="leetcode 18. 四数之和"></a><a href="https://leetcode-cn.com/problems/4sum/">leetcode 18. 四数之和</a></h2><p>给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）：</p><ul><li><p>0 &lt;= a, b, c, d &lt; n</p></li><li><p>a、b、c 和 d <strong>互不相同</strong></p></li><li><p>nums[a] + nums[b] + nums[c] + nums[d] == target</p></li></ul><p>你可以按 <strong>任意顺序</strong> 返回答案 。</p><p>示例 1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,0,-1,0,-2,2], target = 0</span><br><span class="line">输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,2,2,2,2], target = 8</span><br><span class="line">输出：[[2,2,2,2]]</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li>1 &lt;= nums.length &lt;= 200</li><li>-109 &lt;= nums[i] &lt;= 109</li><li>-109 &lt;= target &lt;= 109</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>暴力解法为O（N^4），数组排序后，最里面两层利用滑动窗口，可将时间复杂度将为0(N ^ 3)</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">fourSum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="literal">null</span> || nums.length &lt; <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">0</span>; m &lt; nums.length; m++) &#123;</span><br><span class="line">            <span class="comment">//不能用这里的去重，因为target是任意值</span></span><br><span class="line">            <span class="comment">//if(nums[m] &gt; target) &#123;</span></span><br><span class="line">            <span class="comment">//    break;</span></span><br><span class="line">            <span class="comment">//&#125;</span></span><br><span class="line">            <span class="keyword">if</span>(m &gt; <span class="number">0</span> &amp;&amp; nums[m] == nums[m - <span class="number">1</span>] ) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> m + <span class="number">1</span>; n &lt; nums.length; n++) &#123;</span><br><span class="line">                <span class="comment">//不能用这里的去重，因为target是任意值</span></span><br><span class="line">                <span class="comment">//例： nums[m] == -3, nums[n] == -2 ,target = -6</span></span><br><span class="line">                <span class="comment">// if(nums[m] + nums[n] &gt; target) &#123;</span></span><br><span class="line">                <span class="comment">//     break;</span></span><br><span class="line">                <span class="comment">// &#125;</span></span><br><span class="line">                <span class="keyword">if</span>(n &gt; m + <span class="number">1</span> &amp;&amp; nums[n] == nums[n - <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n + <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(i &lt; j) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums[m] + nums[n] + nums[i] + nums[j];</span><br><span class="line">                    <span class="keyword">if</span>(sum &lt; target) &#123;</span><br><span class="line">                        i++;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(sum &gt; target) &#123;</span><br><span class="line">                        j--;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        res.add(Arrays.asList(nums[m] , nums[n] , nums[i] , nums[j]));</span><br><span class="line">                        <span class="comment">//去重</span></span><br><span class="line">                        <span class="keyword">while</span>(i &lt; j &amp;&amp; nums[i] == nums[++i]) &#123;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//去重</span></span><br><span class="line">                        <span class="keyword">while</span>(i &lt; j &amp;&amp; nums[j] == nums[--j]) &#123;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="leetcode-3-无重复字符的最长子串"><a href="#leetcode-3-无重复字符的最长子串" class="headerlink" title="leetcode 3. 无重复字符的最长子串"></a><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">leetcode 3. 无重复字符的最长子串</a></h2><p>给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。</p><p>示例 1:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></pre></td></tr></table></figure><p>示例 3:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure><p>示例 4:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;&quot;</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= s.length &lt;= 5 * 104</code></li><li><code>s</code> 由英文字母、数字、符号和空格组成</li></ul><h3 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length() == <span class="number">0</span> || s == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>;</span><br><span class="line">            HashMap&lt;Character, Character&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">            map.put(s.charAt(i), s.charAt(i));</span><br><span class="line">            <span class="keyword">while</span>(j &lt; s.length() &amp;&amp; map.get(s.charAt(j)) == <span class="literal">null</span>) &#123;</span><br><span class="line">                map.put(s.charAt(j), s.charAt(j));</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            res = Math.max(res, j - i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="滑动窗口解法"><a href="#滑动窗口解法" class="headerlink" title="滑动窗口解法"></a>滑动窗口解法</h3><p>思想：</p><p>暴力解法时间复杂度是O(N^2)，使用滑动窗口可遍历一次数组完成，使得时间复杂度将为O（N）</p><p>滑动窗口的右边界不断的右移，只要没有重复的字符，就持续向右扩大窗口边界。一旦出现了重复字符，就需要缩小左边界，直到重复的字符移出了左边界，然后继续移动滑动窗口的右边界。以此类推，每次移动需要计算当前长度，并判断是否需要更新最大长度，最终最大的值就是题目中的所求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length() == <span class="number">0</span> || s == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> -<span class="number">1</span>;  </span><br><span class="line">        <span class="comment">//set用来存储当前无重复字串都有哪些唯一的字符</span></span><br><span class="line">        HashSet&lt;Character&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>; left &lt; len; left++) &#123;</span><br><span class="line">            <span class="comment">//每次left移动位置，都要去除set中原left位置对应的元素，因为set中始终存储的是当前不重复字串</span></span><br><span class="line">            <span class="keyword">if</span>(left != <span class="number">0</span>) &#123;</span><br><span class="line">                set.remove(s.charAt(left - <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//只要没有重复的字符，就持续向右扩大窗口边界</span></span><br><span class="line">            <span class="keyword">while</span>(right + <span class="number">1</span> &lt; len &amp;&amp; !set.contains(s.charAt(right + <span class="number">1</span>))) &#123;</span><br><span class="line">                right++;</span><br><span class="line">                <span class="comment">//向set中添加</span></span><br><span class="line">                set.add(s.charAt(right));</span><br><span class="line">            &#125;</span><br><span class="line">            result = Math.max(result, right - left + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        HashSet&lt;Character&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="keyword">while</span>(right &lt; length) &#123;</span><br><span class="line">            <span class="comment">//只要没有重复的字符，就持续向右扩大窗口边界</span></span><br><span class="line">            <span class="keyword">if</span>(!set.contains(s.charAt(right))) &#123;</span><br><span class="line">                set.add(s.charAt(right));</span><br><span class="line">                result = Math.max(result, right - left + <span class="number">1</span>);</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//一旦出现了重复字符，就需要缩小左边界，直到重复的字符移出了左边界</span></span><br><span class="line">            <span class="keyword">while</span>(right &lt; length &amp;&amp; set.contains(s.charAt(right))) &#123;</span><br><span class="line">                set.remove(s.charAt(left));</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="leetcode-209-长度最小的子数组"><a href="#leetcode-209-长度最小的子数组" class="headerlink" title="leetcode 209. 长度最小的子数组"></a><a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/">leetcode 209. 长度最小的子数组</a></h2><p>给定一个含有 <code>n</code> 个正整数的数组和一个正整数 <code>target</code> <strong>。</strong></p><p>找出该数组中满足其和 <code>≥ target</code> 的长度最小的 <strong>连续子数组</strong> <code>[numsl, numsl+1, ..., numsr-1, numsr]</code> ，并返回其长度<strong>。</strong>如果不存在符合条件的子数组，返回 <code>0</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：target = 7, nums = [2,3,1,2,4,3]</span><br><span class="line">输出：2</span><br><span class="line">解释：子数组 [4,3] 是该条件下的长度最小的子数组。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：target = 4, nums = [1,4,4]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：target = 11, nums = [1,1,1,1,1,1,1,1]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= target &lt;= 109</code></li><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>1 &lt;= nums[i] &lt;= 105</code></li></ul><p><strong>进阶：</strong></p><ul><li>如果你已经实现 <code>O(n)</code> 时间复杂度的解法, 请尝试设计一个 <code>O(n log(n))</code> 时间复杂度的解法。</li></ul><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>子数组想到是否能利用<code>滑动窗口</code> ？？？</p><p>这一题的解题思路是用滑动窗口。在滑动窗口 [i,j]之间不断往后移动，如果总和小于 s，就扩大右边界 j，不断加入右边的值，直到 sum &gt; s，之后再缩小 i 的左边界，不断缩小直到 sum &lt; s，这时候右边界又可以往右移动。以此类推。</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="comment">//扩大窗口</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>; right &lt; nums.length; right++) &#123;</span><br><span class="line">            sum += nums[right];</span><br><span class="line">            <span class="comment">//缩小窗口</span></span><br><span class="line">            <span class="keyword">while</span>(sum &gt;= target) &#123;</span><br><span class="line">                result = Math.min(result, right - left + <span class="number">1</span>);</span><br><span class="line">                sum -= nums[left];</span><br><span class="line">                left++;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//有无找到</span></span><br><span class="line">        <span class="type">return</span> <span class="variable">result</span> <span class="operator">=</span>= Integer.MAX_VALUE ? <span class="number">0</span> : result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="代码框架"><a href="#代码框架" class="headerlink" title="代码框架"></a>代码框架</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">minWindow</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">         <span class="comment">// 记录t 以及 滑动窗口window中 字符与个数的映射关系</span></span><br><span class="line">        HashMap&lt;Character, Integer&gt; window_map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        HashMap&lt;Character, Integer&gt; t_map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; t.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c1</span> <span class="operator">=</span> t.charAt(i);</span><br><span class="line">            t_map.put(c1, t_map.getOrDefault(c1, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 双指针, </span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 用于更新满足的窗口window的长度,如果是len一直是MAX_VALUE，说明没有满足的串</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="comment">// 用于记录window串的起始位置，则返回 s[start, len]</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (right &lt; s.length()) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(right);</span><br><span class="line">            right++;</span><br><span class="line">            <span class="comment">// 只要c是t中出现的字符就更新</span></span><br><span class="line">            <span class="keyword">if</span> (t_map.containsKey(c)) &#123;</span><br><span class="line">                window_map.put(c, window_map.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">                <span class="comment">// 更新c字符出现的次数</span></span><br><span class="line">                <span class="keyword">if</span> (window_map.get(c).equals(t_map.get(c))) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// System.out.println(window_map); </span></span><br><span class="line">            <span class="comment">// ----------------------------------</span></span><br><span class="line">            <span class="comment">// 收缩window的长度</span></span><br><span class="line">            <span class="keyword">while</span> (count == t_map.size()) &#123;</span><br><span class="line">                <span class="comment">// 更新并记录window的长度,以及window的起始位置start</span></span><br><span class="line">                <span class="keyword">if</span> (right - left &lt; len) &#123;</span><br><span class="line">                    start = left;</span><br><span class="line">                    len = right - left;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="type">char</span> <span class="variable">d</span> <span class="operator">=</span> s.charAt(left);</span><br><span class="line">                left++;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (t_map.containsKey(d)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (window_map.get(d).equals(t_map.get(d))) &#123;</span><br><span class="line">                        count--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    window_map.put(d, window_map.get(d) - <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="type">return</span> <span class="variable">len</span> <span class="operator">=</span>= Integer.MAX_VALUE ? <span class="string">&quot;&quot;</span> : s.substring(start, start + len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Palindromic substring</title>
      <link href="/2021/12/26/palindromic-substring/"/>
      <url>/2021/12/26/palindromic-substring/</url>
      
        <content type="html"><![CDATA[<p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/980081ebc17e7bbd499001644140ba4.jpg" alt="2021年12月26日，毛主席诞辰128周年。西安疫情严重，西北大学学子真情流露，在操场雪地上写下众多标语，流露出对毛主席的怀念之情以及对战胜疫情回家过年的期盼。"></p><h1 id="回文串相关题目"><a href="#回文串相关题目" class="headerlink" title="回文串相关题目"></a>回文串相关题目</h1><h2 id="leecode-234-回文链表"><a href="#leecode-234-回文链表" class="headerlink" title="leecode 234. 回文链表"></a>leecode 234. 回文链表</h2><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/03/pal1linked-list.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,2,1]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/03/pal2linked-list.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>进阶：</strong>你能否用 <code>O(n)</code> 时间复杂度和 <code>O(1)</code> 空间复杂度解决此题？</p><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>找到链表<strong>后半部分开始的节点</strong>，反转后半部分链表。</p><h3 id="找链表中点："><a href="#找链表中点：" class="headerlink" title="找链表中点："></a>找链表中点：</h3><ul><li>链表节点数为奇数，快指针 fast 指向最后一个节点时，慢指针 slow的位置就是中点。</li><li>链表节点数为偶数，快指针 fast 指向倒数第二个节点，慢指针 slow的位置就是链表<strong>前半部分结束的节点</strong>。</li></ul><p>注意<strong>循环条件</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(fast.next != <span class="literal">null</span> &amp;&amp; fast.next.next != <span class="literal">null</span>) &#123;</span><br><span class="line">    slow = slow.next;</span><br><span class="line">    fast = fast.next.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>找链表中点的算法 ——&gt; <strong>快慢指针</strong></p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">middleNode</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;        </span><br></pre></td></tr></table></figure><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/1.png" alt="1" style="zoom: 50%;" /><p>由上图可知：</p><p>如果是奇数，链表中点就是 slow</p><p>如果是偶数，链表中点就是slow.next</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(fast.next != <span class="literal">null</span> &amp;&amp; fast.next.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">lastHalfReversed</span> <span class="operator">=</span>  reverseRecursion(slow.next);</span><br><span class="line">        <span class="keyword">while</span>(lastHalfReversed != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(head.val != lastHalfReversed.val) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head.next;</span><br><span class="line">            lastHalfReversed = lastHalfReversed.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseRecursion</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newNode</span> <span class="operator">=</span> reverseRecursion(head.next);</span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> newNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度：O(n)</strong>    其中 n 指的是链表的大小。</li><li><strong>空间复杂度：O(1)</strong>    我们只会修改原本链表中节点的指向，而在堆栈上的堆栈帧不超过 O(1)。</li></ul><h2 id="leetcode-647-回文子串"><a href="#leetcode-647-回文子串" class="headerlink" title="leetcode 647 . 回文子串"></a>leetcode 647 . 回文子串</h2><p>给你一个字符串 s ，请你统计并返回这个字符串中 回文子串 的数目。</p><p>回文字符串 是正着读和倒过来读一样的字符串。</p><p>子字符串 是字符串中的由连续字符组成的一个序列。</p><p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;abc&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：三个回文子串: &quot;a&quot;, &quot;b&quot;, &quot;c&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;aaa&quot;</span><br><span class="line">输出：6</span><br><span class="line">解释：6个回文子串: &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;aa&quot;, &quot;aa&quot;, &quot;aaa&quot;</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 1000</code></li><li><code>s</code> 由小写英文字母组成</li></ul><h3 id="暴力解法："><a href="#暴力解法：" class="headerlink" title="暴力解法："></a>暴力解法：</h3><p>判断所有字串是否为回文串，存储最长的回文子串</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//判断字符串是不是 回文串  对称位置的关系  i &lt;------&gt; len - i - 1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindromic</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len / <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) != s.charAt(len - i - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; s.length(); j++) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">subStr</span> <span class="operator">=</span> s.substring(i, j + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(isPalindromic(subStr) &amp;&amp; subStr.length() &gt; longest.length()) &#123;</span><br><span class="line">                    num++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度：</strong></p><p>用<br>$$<br>O(N^2)<br>$$<br>的时间枚举出所有的字串，然后判断字符串是否为回文串的算法 isPalindromic（）时间复杂度为 O(N)，所以暴力解法的时间复杂度为<br>$$<br>O(N^3)<br>$$</p><h3 id="中心扩展法："><a href="#中心扩展法：" class="headerlink" title="中心扩展法："></a><strong>中心扩展法：</strong></h3><h4 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a><strong>思路：</strong></h4><p>枚举出所有的子串（看所有的字串是不是回文串）又有另一种的思路：枚举每一个<strong>可能的回文中心</strong>，然后用两个指针分别向左右两边拓展，当两个指针指向的元素相同的时候就拓展，否则停止拓展。</p><p>偶数的子串(通过偶数的所有子串，找出偶数的回文子串)不能通过单个向两边扩展得到，比如 ababa中的字串 abab无法通过任何一个字符向两边扩展得到。</p><p>所以中心点不能只有单个字符构成，还要包括两个字符，比如上面这个子串 <code>abab</code>，就可以由中心点 <code>ba</code> 扩展一次得到。</p><h4 id="分析结论："><a href="#分析结论：" class="headerlink" title="分析结论："></a>分析结论：</h4><p>所以最终的中心点有 <code>2 * len - 1</code> 个，分别是 <code>len</code> 个单字符和 <code>len - 1</code> 个双字符。</p><p>如果上面看不太懂的话，还可以看看下面几个问题：</p><ul><li>为什么有 2 * len - 1 个中心点？<ul><li>aba 有5个中心点，分别是 a、b、c、ab、ba</li><li>abba 有7个中心点，分别是 a、b、b、a、ab、bb、ba</li></ul></li><li>什么是中心点？<ul><li>中心点即 left 指针和 right 指针初始化指向的地方，可能是一个也可能是两个</li></ul></li><li>为什么不可能是三个或者更多？<ul><li>因为 3 个可以由 1 个扩展一次得到，4 个可以由两个扩展一次得到</li></ul></li></ul><p>再次强调：如果回文长度是奇数，那么回文中心是一个字符；如果回文长度是偶数，那么中心是两个字符。</p><p>我们不妨写一组出来观察观察，假设 n = 4（abba），我们可以把可能的回文中心列出来：</p><table><thead><tr><th align="center">编号(0 ~ 2 n - 1)</th><th align="center">回文中心</th><th align="center">回文中心左起始位置</th><th align="center">回文中心右起始位置</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">a</td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center">1</td><td align="center">ab</td><td align="center">0</td><td align="center">1</td></tr><tr><td align="center">2</td><td align="center">b</td><td align="center">1</td><td align="center">1</td></tr><tr><td align="center">3</td><td align="center">bb</td><td align="center">1</td><td align="center">2</td></tr><tr><td align="center">4</td><td align="center">b</td><td align="center">2</td><td align="center">2</td></tr><tr><td align="center">5</td><td align="center">ba</td><td align="center">2</td><td align="center">3</td></tr><tr><td align="center">6</td><td align="center">a</td><td align="center">3</td><td align="center">3</td></tr></tbody></table><p>单字符中心：n 个</p><p>双字符中心： n - 1 个</p><h4 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countSubstrings</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">//回文字串最少是 s.length() -----&gt; 也就是单个字符的个数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">substrings</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//以单个字符为中心的情况（也就是回文子串长度是奇数的情况） n种情况</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="comment">//注意left和right的取值范围</span></span><br><span class="line">            <span class="keyword">while</span>(left &gt;= <span class="number">0</span> &amp;&amp; right &lt; s.length() &amp;&amp; s.charAt(left) == s.charAt(right)) &#123;</span><br><span class="line">                substrings++;</span><br><span class="line">                left--;</span><br><span class="line">                right++;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//以双字符为中心的情况（也就是回文字串长度是偶数的情况） n - 1种情况 </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left &gt;= <span class="number">0</span> &amp;&amp; right &lt; s.length() &amp;&amp; s.charAt(left) == s.charAt(right)) &#123;</span><br><span class="line">                substrings++;</span><br><span class="line">                left--;</span><br><span class="line">                right++;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> substrings;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a><strong>复杂度分析</strong></h4><ul><li>时间复杂度：O(n^2)</li><li>空间复杂度：O(1)</li></ul><h2 id="leetcode-5-最长回文子串"><a href="#leetcode-5-最长回文子串" class="headerlink" title="leetcode 5. 最长回文子串"></a>leetcode 5. 最长回文子串</h2><h3 id="暴力解法：-1"><a href="#暴力解法：-1" class="headerlink" title="暴力解法："></a>暴力解法：</h3><h4 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//判断字符串是不是 回文串  对称位置的关系  i &lt;------&gt; len - i - 1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindromic</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len / <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) != s.charAt(len - i - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">longest</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; s.length(); j++) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">subStr</span> <span class="operator">=</span> s.substring(i, j + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(isPalindromic(subStr) &amp;&amp; subStr.length() &gt; longest.length()) &#123;</span><br><span class="line">                    longest = subStr;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> longest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度:"></a>时间复杂度:</h4><p>用O(N^2)的时间枚举出所有的字串，然后判断字符串是否为回文串的算法 isPalindromic（）时间复杂度为 O(N)，所以暴力解法的时间复杂度为O(N^3)</p><h3 id="中心扩展法：-1"><a href="#中心扩展法：-1" class="headerlink" title="中心扩展法："></a>中心扩展法：</h3><p>同leetcode 645</p><h4 id="代码：-3"><a href="#代码：-3" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="literal">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">longest</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">longestStr</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="comment">//以单个字符为中心的情况（也就是回文子串长度是奇数的情况） n种情况</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="comment">// left = right 的时候，此时回文中心是一个字符，回文串的长度是奇数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> left;</span><br><span class="line">            <span class="comment">//注意left和right的取值范围</span></span><br><span class="line">            <span class="keyword">while</span>(left &gt;= <span class="number">0</span> &amp;&amp; right &lt; s.length() &amp;&amp; s.charAt(left) == s.charAt(right)) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">subStrLen</span> <span class="operator">=</span> right - left + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(subStrLen &gt; longest) &#123;</span><br><span class="line">                    longest = subStrLen;</span><br><span class="line">                    longestStr = s.substring(left, right + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                left--;</span><br><span class="line">                right++;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//以双字符为中心的情况（也就是回文字串长度是偶数的情况） n - 1种情况 </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// right = left + 1 的时候，此时回文中心是一个空隙，回文串的长度是偶数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> left + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left &gt;= <span class="number">0</span> &amp;&amp; right &lt; s.length() &amp;&amp; s.charAt(left) == s.charAt(right)) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">subStrLen</span> <span class="operator">=</span> right - left + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(subStrLen &gt; longest) &#123;</span><br><span class="line">                    longest = subStrLen;</span><br><span class="line">                    longestStr = s.substring(left, right + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                left--;</span><br><span class="line">                right++;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> longestStr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li><p>时间复杂度：O(n^2)，其中 n是字符串的长度。长度为 1和 2的回文中心分别有 n和 n−1 个，每个回文中心最多会向外扩展 O(n)次。</p></li><li><p>空间复杂度：O(1)</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Fighting COVID-19</title>
      <link href="/2021/12/25/Fighting-COVID-19/"/>
      <url>/2021/12/25/Fighting-COVID-19/</url>
      
        <content type="html"><![CDATA[<p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20211225194728.jpg" alt="微信图片_20211225194728"></p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20211225194749.jpg" alt="微信图片_20211225194749"></p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20211225194836.jpg" alt="微信图片_20211225194836"></p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20211225210532848.png" alt="image-20211225210532848"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>刷题 12/24</title>
      <link href="/2021/12/24/%E5%89%91%E6%8C%87offer-03/"/>
      <url>/2021/12/24/%E5%89%91%E6%8C%87offer-03/</url>
      
        <content type="html"><![CDATA[<h2 id="剑指offer-03-数组中重复的数字"><a href="#剑指offer-03-数组中重复的数字" class="headerlink" title="剑指offer 03. 数组中重复的数字"></a>剑指offer 03. 数组中重复的数字</h2><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20211224095946844.png"></p><h3 id="一-遍历暴力解法-利用HashSet"><a href="#一-遍历暴力解法-利用HashSet" class="headerlink" title="一.遍历暴力解法 ( 利用HashSet )"></a>一.遍历暴力解法 ( 利用HashSet )</h3><p>利用HashSet, 每遍历一个就去Set集合中查询，如果有就说明前面已经存在；若没有将其存入Set。 </p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findRepeatNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        HashSet&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(set.contains(nums[i])) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                set.add(nums[i]);</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>notes</strong>： 牢记<code>HashSet</code>的两个函数</p><ol><li><strong>add( )</strong>                  如果Set集合中存在该元素，则返回 false</li><li><strong>contains ( )</strong>         如果Set集合中存在该元素，则返回 false</li></ol><ul><li><p><strong>时间复杂度 O(N)：</strong> 遍历数组使用 O(N) ，HashSet 添加与查找元素皆为 O(1)。</p></li><li><p><strong>空间复杂度 O(N)：</strong> HashSet 占用 O(N)  大小的额外空间。</p></li></ul><h3 id="二-原地交换"><a href="#二-原地交换" class="headerlink" title="二. 原地交换"></a>二. 原地交换</h3><p>实际中，可能要求降低空间复杂度。那我们就不能新建 HashSet，利用Set集合的唯一性来实现。那我们就得想，有没有办法仅仅使用当前的数组 nums[ ]来模拟Set。</p><p>我们仔细观察该题目，发现 ——-&gt;  <code>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内</code></p><p>可遍历数组并通过交换操作，<strong>使元素与索引值 一 一对应</strong>（即 nums[i] = inums[i]=i ）。因而，就能通过索引映射对应的值，起到与Set等价的作用。</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20211224104020538.png" alt="image-20211224104020538"></p><p>遍历中，第一次遇到数字 xx 时，将其交换至索引 xx 处；而当第二次遇到数字 xx 时，一定有 nums[x] = xnums[x]=x ，此时即可得到一组重复数字。</p><p><strong>算法步骤：</strong></p><p>一、遍历数组 nums[ ]：</p><ul><li>若 nums[i] == i， 说明元素与索引值对应，继续下一个位置。</li><li>若 nums[nums[i]] == nums[i]， 说明 索引nums[i]处和索引 i 处的元素值都是 nums[i]，找到重复的值，那么返回 nusm[i].</li><li>否则，交换 索引 i 处和 索引 nums[i] 处的元素值，也就是把 元素nums[i], 放到索引 nums[i]处。使得元素值与索引对应。</li></ul><p>二、 遍历完成未找到，返回-1 （本题有重复元素，一定能找到）</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findRepeatNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; nums.length) &#123;</span><br><span class="line">            <span class="comment">//元素与索引值对应，继续下一个位置</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i] == i) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//找到重复的值 </span></span><br><span class="line">            <span class="keyword">if</span>(nums[nums[i]] == nums[i]) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//交换元素位置，使得元素值与索引对应</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span>  nums[i];</span><br><span class="line">            nums[i] = nums[temp];</span><br><span class="line">            nums[temp] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>时间复杂度 O(N):</strong>    遍历数组使用<em>O</em>(<em>N</em>) ，每轮遍历的判断和交换操作使用<em>O</em>(1) 。</p></li><li><p><strong>空间复杂度 O(1) ：</strong> 使用常数复杂度的额外空间。</p></li></ul><h3 id="要求时间复杂度O-1-的话，怎么实现？？？？？？？"><a href="#要求时间复杂度O-1-的话，怎么实现？？？？？？？" class="headerlink" title="要求时间复杂度O(1) 的话，怎么实现？？？？？？？"></a>要求时间复杂度O(1) 的话，怎么实现？？？？？？？</h3><h2 id="剑指-Offer-30-包含min函数的栈"><a href="#剑指-Offer-30-包含min函数的栈" class="headerlink" title="剑指 Offer 30. 包含min函数的栈"></a>剑指 Offer 30. 包含min函数的栈</h2><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20211224110825312.png" alt="image-20211224110825312"  /><h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p>普通栈的 <code>push()</code> 和 <code>pop()</code> 函数的复杂度为 <em>O</em>(1) ；而获取栈最小值 <code>min()</code> 函数需要遍历整个栈，复杂度为 <em>O</em>(<em>N</em>) 。</p><h3 id="难点："><a href="#难点：" class="headerlink" title="难点："></a>难点：</h3><p>那么本题要解决的就是 <strong>将 <code>min()</code> 函数复杂度降为 <em>O</em>(1) ，可通过建立辅助栈实现</strong>。</p><h3 id="具体操作："><a href="#具体操作：" class="headerlink" title="具体操作："></a>具体操作：</h3><ul><li><strong>数据栈 A</strong>：  栈 A用于存储所有元素，保证入栈 push() 函数、出栈 pop() 函数、获取栈顶 top() 函数的正常逻辑。</li><li><strong>辅助栈 B</strong> ： 栈 B中存储栈 A中所有 非严格降序（相等也行） 的元素，则栈 A 中的最小元素始终对应栈 B的栈顶元素，即 min() 函数只需返回栈 B 的栈顶元素即可，可达到min（）的时间复杂度为O(N)的目的。</li></ul><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line">    <span class="comment">//A保存所有元素，B保存非严格单调递减的元素（为了使得B栈顶就是最小值，时间复杂度为O（1））</span></span><br><span class="line">    Deque&lt;Integer&gt; A, B;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MinStack</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.A = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="built_in">this</span>.B = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        A.push(x);</span><br><span class="line">        <span class="keyword">if</span>(B.isEmpty() || B.peek() &gt;= x) &#123;</span><br><span class="line">            B.push(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(A.peek().equals(B.peek())) &#123;</span><br><span class="line">            B.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        A.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> A.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">min</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> B.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj.min();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h3 id="复杂度分析："><a href="#复杂度分析：" class="headerlink" title="复杂度分析："></a>复杂度分析：</h3><ul><li><strong>时间复杂度 O(1) ：</strong> push( ), pop( ), top( ), min( ) 四个函数的时间复杂度均为常数级别。</li><li><strong>空间复杂度 O(N) ：</strong> 当共有 N 个待入栈元素时，辅助栈 BB 最差情况下存储 N 个元素，使用 O(N） 额外空间。</li></ul><h2 id="剑指offer-10-II-青蛙跳台的问题"><a href="#剑指offer-10-II-青蛙跳台的问题" class="headerlink" title="剑指offer 10 - II. 青蛙跳台的问题"></a>剑指offer 10 - II. 青蛙跳台的问题</h2><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20211224170310559.png" alt="image-20211224170310559" style="zoom:80%;" /><h3 id="递归三部曲："><a href="#递归三部曲：" class="headerlink" title="递归三部曲："></a>递归三部曲：</h3><ol><li><p><strong>找base case</strong>，也就是<strong>找整个递归的终止条件：递归应该在什么时候结束？</strong></p></li><li><p><strong>找返回值</strong>：应该给上一级返回什么信息？</p></li><li><p><strong>本级递归应该做什么：</strong>在这一级递归中，应该完成什么任务？</p></li></ol><p>一般想清楚<strong>本级递归应该做什么</strong>就能解决递归！</p><p>在本题中，设跳上 n级台阶有 f(n)种跳法。在所有跳法中，青蛙的最后一步只有两种情况： <strong>跳上 1 级或 2 级台阶</strong>。</p><p>所以本级递归应该完成 f(n) = f(n -1) + f(n - 2) ，就是把两种情况的各自有多少种情况加起来。</p><h3 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//map用来记忆算过的f（n）,加快递归速度，不用去重复递归计算</span></span><br><span class="line">    HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numWays</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(map.get(n) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> map.get(n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//base case</span></span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span> || n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//本级递归种要做的事情</span></span><br><span class="line">        result = (numWays(n - <span class="number">2</span>)  + numWays(n -<span class="number">1</span>)) % <span class="number">1000000007</span>;</span><br><span class="line">        map.put(n, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="leetcode-24-两两交换链表中的结点"><a href="#leetcode-24-两两交换链表中的结点" class="headerlink" title="leetcode 24. 两两交换链表中的结点"></a>leetcode 24. 两两交换链表中的结点</h2><p><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/">https://leetcode-cn.com/problems/swap-nodes-in-pairs/</a></p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20211224201958367.png" alt="image-20211224201958367"></p><p>这种链表中的k个一组交换 —–&gt; 递归   相似的还有<code> leetcode 25. K个一组反转链表</code> <a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/">https://leetcode-cn.com/problems/reverse-nodes-in-k-group/</a></p><p><strong>base case</strong>: 只有一个节点或为空</p><p><strong>本级递归要做的事情</strong>：</p><p>head， head.next， swapPairs（head.next.next）这三个节点中，将head和head.next交换</p><h3 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">swapPairs</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">//base case</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//本级递归</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">second</span> <span class="operator">=</span> head.next;</span><br><span class="line">        head.next = swapPairs(head.next.next);</span><br><span class="line">        second.next = head;</span><br><span class="line">        <span class="keyword">return</span> second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hexo + Github + TecentCloud + PicGo + AliCloud OSS 搭建个人博客</title>
      <link href="/2021/12/21/Build_A_Blog/"/>
      <url>/2021/12/21/Build_A_Blog/</url>
      
        <content type="html"><![CDATA[<p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/blog.png" alt="blog"></p>]]></content>
      
      
      <categories>
          
          <category> tech </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World(Hexo Docs)</title>
      <link href="/2021/12/21/hello-world/"/>
      <url>/2021/12/21/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.Quick Start</p><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> tech </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>事务基础知识</title>
      <link href="/2021/01/14/%E4%BA%8B%E5%8A%A1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2021/01/14/%E4%BA%8B%E5%8A%A1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="事务基础知识"><a href="#事务基础知识" class="headerlink" title="事务基础知识"></a>事务基础知识</h1><h2 id="1-数据库事务概述"><a href="#1-数据库事务概述" class="headerlink" title="1.数据库事务概述"></a>1.数据库事务概述</h2><h3 id="1-1-存储引擎支持情况"><a href="#1-1-存储引擎支持情况" class="headerlink" title="1.1 存储引擎支持情况"></a>1.1 存储引擎支持情况</h3><p><code>SHOW ENGINES</code> 命令来查看当前 MySQL 支持的存储引擎都有哪些，以及这些存储引擎是否支持事务。  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220114114705699.png" alt="image-20220114114705699"></p><p>能看出在 MySQL 中，只有<code>InnoDB</code> 是支持事务的。  </p><h3 id="1-2-基本概念"><a href="#1-2-基本概念" class="headerlink" title="1.2 基本概念"></a>1.2 基本概念</h3><p><strong>事务</strong>：一组逻辑操作单元，使数据从一种状态变换到另一种状态。</p><p><strong>事务处理的原则</strong>：保证所有事务都作为 一个工作单元 来执行，即使出现了故障，都不能改变这种执行方式。当在一个事务中执行多个操作时，要么所有的事务都被提交( commit )，那么这些修改就 永久 地保存下来；要么数据库管理系统将 放弃 所作的所有 修改 ，整个事务回滚( rollback )到最初状态。  </p><h3 id="1-3-事务的ACID特性"><a href="#1-3-事务的ACID特性" class="headerlink" title="1.3 事务的ACID特性"></a>1.3 事务的ACID特性</h3><ul><li><strong>原子性（atomicity）：</strong></li></ul><p>原子性是指事务是一个不可分割的工作单位，要么全部提交，要么全部失败回滚。</p><ul><li><strong>一致性（consistency）：</strong></li></ul><p>（国内很多网站上对一致性的阐述有误，具体你可以参考 Wikipedia 对<code>Consistency</code>的阐述）根据定义，一致性是指事务执行前后，数据从一个 合法性状态 变换到另外一个 合法性状态 。这种状态是 语义上 的而不是语法上的，跟具体的业务有关。</p><p>那什么是合法的数据状态呢？满足 预定的约束 的状态就叫做合法的状态。通俗一点，这状态是由你自己来定义的（比如满足现实世界中的约束）。满足这个状态，数据就是一致的，不满足这个状态，数据就是不一致的！如果事务中的某个操作失败了，系统就会自动撤销当前正在执行的事务，返回到事务操作之前的状态。</p><ul><li><strong>隔离型（isolation）：</strong></li></ul><p>事务的隔离性是指一个事务的执行 <strong>不能被其他事务干扰</strong> ，即一个事务内部的操作及使用的数据对 <strong>并发</strong> 的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</p><p>如果无法保证隔离性会怎么样？假设A账户有200元，B账户0元。A账户往B账户转账两次，每次金额为50<br>元，分别在两个事务中执行。如果无法保证隔离性，会出现下面的情形：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> money <span class="operator">=</span> money <span class="operator">-</span> <span class="number">50</span> <span class="keyword">WHERE</span> NAME <span class="operator">=</span> <span class="string">&#x27;AA&#x27;</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> money <span class="operator">=</span> money <span class="operator">+</span> <span class="number">50</span> <span class="keyword">WHERE</span> NAME <span class="operator">=</span> <span class="string">&#x27;BB&#x27;</span>;  </span><br></pre></td></tr></table></figure><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220114115057584.png" alt="image-20220114115057584"></p><ul><li><strong>持久性（durability）：</strong></li></ul><p>持久性是指一个事务一旦被提交，它对数据库中数据的改变就是 <strong>永久性</strong>的 ，接下来的其他操作和数据库故障不应该对其有任何影响。</p><p>持久性是通过 <strong>事务日志</strong> 来保证的。日志包括了 <code>重做日志</code> 和 <code>回滚日志</code> 。当我们通过事务对数据进行修改的时候，首先会将数据库的变化信息记录到重做日志中，然后再对数据库中对应的行进行修改。这样做的好处是，即使数据库系统崩溃，数据库重启后也能找到没有更新到数据库系统中的重做日志，重新执行，从而使事务具有持久性。  </p><h3 id="1-4-事务的状态"><a href="#1-4-事务的状态" class="headerlink" title="1.4 事务的状态"></a>1.4 事务的状态</h3><p>我们现在知道 <strong>事务</strong> 是一个抽象的概念，它其实对应着一个或多个数据库操作，MySQL根据这些操作所执行的不同阶段把 <strong>事务</strong> 大致划分成几个状态：</p><ul><li><strong>活动的（active）</strong></li></ul><p>事务对应的数据库操作正在执行过程中时，我们就说该事务处在 <strong>活动的</strong> 状态。</p><ul><li><strong>部分提交的（partially committed）</strong></li></ul><p>当事务中的最后一个操作执行完成，但由于操作都在内存中执行，所造成的影响并 <strong>没有刷新到磁盘</strong>时，我们就说该事务处在 <strong>部分提交</strong>的 状态。</p><ul><li><strong>失败的（failed）</strong></li></ul><p>当事务处在 <strong>活动的</strong> 或者 部分提交的 状态时，可能遇到了某些错误（数据库自身的错误、操作系统错误或者直接断电等）而无法继续执行，或者人为的停止当前事务的执行，我们就说该事务处在 <strong>失败的</strong> 状态。  </p><ul><li><strong>中止的（aborted）</strong></li></ul><p>如果事务执行了一部分而变为 <strong>失败的</strong> 状态，那么就需要把已经修改的事务中的操作还原到事务执行前的状态。换句话说，就是要撤销失败事务对当前数据库造成的影响。我们把这个撤销的过程称之为 <strong>回滚</strong> 。当 回滚 操作执行完毕时，也就是数据库恢复到了执行事务之前的状态，我们就说该事务处在了 <strong>中止的</strong> 状态。<br>举例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> money <span class="operator">=</span> money <span class="operator">-</span> <span class="number">50</span> <span class="keyword">WHERE</span> NAME <span class="operator">=</span> <span class="string">&#x27;AA&#x27;</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> money <span class="operator">=</span> money <span class="operator">+</span> <span class="number">50</span> <span class="keyword">WHERE</span> NAME <span class="operator">=</span> <span class="string">&#x27;BB&#x27;</span>;  </span><br></pre></td></tr></table></figure><ul><li><strong>提交的（committed）</strong></li></ul><p>当一个处在 <strong>部分提交的</strong> 状态的事务将修改过的数据都 <strong>同步到磁盘</strong> 上之后，我们就可以说该事务处在了 <strong>提交的</strong> 状态。</p><p>一个基本的状态转换图如下所示：  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220114115758371.png" alt="image-20220114115758371"></p><h2 id="2-如何使用事务"><a href="#2-如何使用事务" class="headerlink" title="2. 如何使用事务"></a>2. 如何使用事务</h2><p>使用事务有两种方式，分别为 <strong>显式事务</strong> 和 <strong>隐式事务</strong> 。</p><h3 id="2-1-显式事务"><a href="#2-1-显式事务" class="headerlink" title="2.1 显式事务"></a>2.1 显式事务</h3><p><strong>步骤1</strong>： <code>START TRANSACTION </code>或者 <code>BEGIN</code> ，作用是显式开启一个事务。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">BEGIN</span>;</span><br><span class="line">#或者</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">START</span> TRANSACTION; </span><br></pre></td></tr></table></figure><p> <code>START TRANSACTION</code> 语句相较于 <code>BEGIN</code> 特别之处在于，后边能跟随几个 <strong>修饰符</strong> ：</p><p>① <code>READ ONLY</code> ：标识当前事务是一个 <strong>只读事务</strong> ，也就是属于该事务的数据库操作只能读取数据，而不能修改数据。</p><p>② <code>READ WRITE</code> ：标识当前事务是一个 <strong>读写事务</strong> ，也就是属于该事务的数据库操作既可以读取数据，也可以修改数据。</p><p>③ <code>WITH CONSISTENT SNAPSHOT</code> ：启动一致性读。</p><p><strong>步骤2</strong>：一系列事务中的操作（主要是DML，不含DDL）</p><p><strong>步骤3</strong>：提交事务 或 中止事务（即回滚事务）  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 提交事务。当提交事务后，对数据库的修改是永久性的。</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 回滚事务。即撤销正在进行的所有没有提交的修改</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">ROLLBACK</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 将事务回滚到某个保存点。</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">ROLLBACK</span> <span class="keyword">TO</span> [<span class="keyword">SAVEPOINT</span>]  </span><br></pre></td></tr></table></figure><h3 id="2-2-隐式事务"><a href="#2-2-隐式事务" class="headerlink" title="2.2 隐式事务"></a>2.2 隐式事务</h3><p>MySQL中有一个系统变量 <code>autocommit</code> ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW VARIABLES LIKE &#x27;autocommit&#x27;;</span><br><span class="line">+---------------+-------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+---------------+-------+</span><br><span class="line">| autocommit | ON |</span><br><span class="line">+---------------+-------+</span><br><span class="line">1 row in set (0.01 sec)  </span><br></pre></td></tr></table></figure><p>当然，如果我们想关闭这种 <strong>自动提交</strong> 的功能，可以使用下边两种方法之一：</p><ul><li><p>显式的的使用 <code>START TRANSACTION</code> 或者<code>BEGIN</code>语句开启一个事务。这样<strong>在本次事务提交或者回滚前会暂时关闭掉自动提交的功能</strong>。</p></li><li><p>把系统变量 <code>autocommit </code>的值设置为 <code>OFF</code> ，就像这样：</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> autocommit <span class="operator">=</span> OFF;</span><br><span class="line">#或</span><br><span class="line"><span class="keyword">SET</span> autocommit <span class="operator">=</span> <span class="number">0</span>;  </span><br></pre></td></tr></table></figure><h3 id="2-3-隐式提交数据的情况"><a href="#2-3-隐式提交数据的情况" class="headerlink" title="2.3 隐式提交数据的情况"></a>2.3 隐式提交数据的情况</h3><ul><li><p>数据定义语言（Data definition language，缩写为：DDL）</p></li><li><p>隐式使用或修改mysql数据库中的表</p></li><li><p>事务控制或关于锁定的语句</p></li></ul><p>​    ① 当我们在一个事务还没提交或者回滚时就又使用 START TRANSACTION 或者 BEGIN 语句开启了另一个事务时，会 隐式的提交 上一个事务。即：</p><p>​    ② 当前的 autocommit 系统变量的值为 OFF ，我们手动把它调为 ON 时，也会 隐式的提交 前边语句所属的事务。</p><p>​    ③ 使用 LOCK TABLES 、 UNLOCK TABLES 等关于锁定的语句也会 隐式的提交 前边语句所属的事务。</p><ul><li>加载数据的语句</li><li>关于MySQL复制的一些语句</li><li>其它的一些语句</li></ul><h3 id="2-4-使用举例1：提交与回滚"><a href="#2-4-使用举例1：提交与回滚" class="headerlink" title="2.4 使用举例1：提交与回滚"></a>2.4 使用举例1：提交与回滚</h3><p>我们看下在 MySQL 的默认状态下，下面这个事务最后的处理结果是什么。</p><p><strong>情况1</strong>：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">user</span>(name <span class="type">varchar</span>(<span class="number">20</span>), <span class="keyword">PRIMARY</span> KEY (name)) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span> <span class="keyword">SELECT</span> <span class="string">&#x27;张三&#x27;</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span> <span class="keyword">SELECT</span> <span class="string">&#x27;李四&#x27;</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span> <span class="keyword">SELECT</span> <span class="string">&#x27;李四&#x27;</span>;</span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">user</span>;  </span><br></pre></td></tr></table></figure><p>运行结果（1 行数据）：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">commit</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> 秒)</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">BEGIN</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> 秒)</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span> <span class="keyword">SELECT</span> <span class="string">&#x27;李四&#x27;</span>;</span><br><span class="line">Query OK, <span class="number">1</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> 秒)</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span> <span class="keyword">SELECT</span> <span class="string">&#x27;李四&#x27;</span>;</span><br><span class="line">Duplicate entry <span class="string">&#x27;李四&#x27;</span> <span class="keyword">for</span> key <span class="string">&#x27;user.PRIMARY&#x27;</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">ROLLBACK</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.01</span> 秒)</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------+</span></span><br><span class="line"><span class="operator">|</span> name   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+</span></span><br><span class="line"><span class="operator">|</span> 张三    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+</span></span><br><span class="line"><span class="number">1</span> 行于数据集 (<span class="number">0.01</span> 秒)</span><br></pre></td></tr></table></figure><p><strong>情况2</strong>：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">user</span> (name <span class="type">varchar</span>(<span class="number">20</span>), <span class="keyword">PRIMARY</span> KEY (name)) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span> <span class="keyword">SELECT</span> <span class="string">&#x27;张三&#x27;</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span> <span class="keyword">SELECT</span> <span class="string">&#x27;李四&#x27;</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span> <span class="keyword">SELECT</span> <span class="string">&#x27;李四&#x27;</span>;</span><br><span class="line"><span class="keyword">ROLLBACK</span>  </span><br></pre></td></tr></table></figure><p>运行结果（2 行数据）：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------+</span></span><br><span class="line"><span class="operator">|</span> name   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+</span></span><br><span class="line"><span class="operator">|</span>  张三   <span class="operator">|</span> </span><br><span class="line"><span class="operator">|</span>  李四   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+</span></span><br><span class="line"><span class="number">2</span> 行于数据集 (<span class="number">0.01</span> 秒)</span><br></pre></td></tr></table></figure><p><strong>情况3</strong>：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">user</span>(name <span class="type">varchar</span>(<span class="number">255</span>), <span class="keyword">PRIMARY</span> KEY (name)) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"><span class="keyword">SET</span> @<span class="variable">@completion</span>_type <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span> <span class="keyword">SELECT</span> <span class="string">&#x27;张三&#x27;</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span> <span class="keyword">SELECT</span> <span class="string">&#x27;李四&#x27;</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span> <span class="keyword">SELECT</span> <span class="string">&#x27;李四&#x27;</span>;</span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">user</span>;  </span><br></pre></td></tr></table></figure><p>运行结果（1 行数据）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------+</span></span><br><span class="line"><span class="operator">|</span> name   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+</span></span><br><span class="line"><span class="operator">|</span> 张三    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+</span></span><br><span class="line"><span class="number">1</span> 行于数据集 (<span class="number">0.01</span> 秒)</span><br></pre></td></tr></table></figure><p><strong>注</strong>：</p><p>当我们设置 <code> autocommit=0</code> 时，不论是否采用 START TRANSACTION 或者 BEGIN 的方式来开启事务，都需要用 <code>COMMIT </code>进行提交，让事务生效，使用 <code>ROLLBACK</code> 对事务进行回滚。</p><p>当我们设置 <code>autocommit=1</code> 时，每条 SQL 语句都会自动进行提交。 不过这时，如果你采用<code>START TRANSACTION</code>或者 <code>BEGIN</code> 的方式来显式地开启事务，那么这个事务只有在 COMMIT 时才会生效，在 <code>ROLLBACK </code>时才会回滚。  </p><h2 id="3-事务隔离级别"><a href="#3-事务隔离级别" class="headerlink" title="3. 事务隔离级别"></a>3. 事务隔离级别</h2><p>MySQL是一个<code>客户端／服务器</code> 架构的软件，对于同一个服务器来说，可以有若干个客户端与之连接，每个客户端与服务器连接上之后，就可以称为一个会话（ <strong>Session</strong> ）。每个客户端都可以在自己的会话中向服务器发出请求语句，一个请求语句可能是某个事务的一部分，也就是<strong>对于服务器来说可能同时处理多个事务</strong>。事务有 <code>隔离性</code>的特性，理论上在某个事务 对某个数据进行访问 时，其他事务应该进行 排<br>队 ，当该事务提交之后，其他事务才可以继续访问这个数据。但是这样对 <strong>性能影响</strong>太大 ，我们既想保持事务的隔离性，又想让服务器在处理访问同一数据的多个事务时 <code>性能尽量高些</code> ，那就看二者如何权衡取舍了。</p><h3 id="3-1-数据准备"><a href="#3-1-数据准备" class="headerlink" title="3.1 数据准备"></a>3.1 数据准备</h3><p>我们需要创建一个表：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> student (</span><br><span class="line">studentno <span class="type">INT</span>,</span><br><span class="line">name <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">class <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (studentno)</span><br><span class="line">) Engine<span class="operator">=</span>InnoDB CHARSET<span class="operator">=</span>utf8;  </span><br></pre></td></tr></table></figure><p>然后向这个表里插入一条数据：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> student <span class="keyword">VALUES</span>(<span class="number">1</span>, <span class="string">&#x27;小谷&#x27;</span>, <span class="string">&#x27;1班&#x27;</span>);  </span><br></pre></td></tr></table></figure><p>现在表里的数据就是这样的：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+--------+-------+</span></span><br><span class="line"><span class="operator">|</span> studentno <span class="operator">|</span> name   <span class="operator">|</span> class <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+--------+-------+ </span></span><br><span class="line"><span class="operator">|</span>         <span class="number">1</span> <span class="operator">|</span> 小谷    <span class="operator">|</span> <span class="number">1</span>班   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+--------+-------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h3 id="3-2-数据并发问题"><a href="#3-2-数据并发问题" class="headerlink" title="3.2 数据并发问题"></a>3.2 数据并发问题</h3><p>针对事务的隔离性和并发性，我们怎么做取舍呢？先看一下访问相同数据的事务在 <strong>不保证串行执行</strong> （也就是不保证执行完一个再执行另一个）的情况下可能会出现哪些问题：  </p><p><strong>1. 脏写（ Dirty Write ）</strong></p><p>对于两个事务 Session A、Session B，如果事务Session A <strong>修改了</strong> 另一个 <strong>未提交</strong> 事务Session B <strong>修改过</strong> 的数据，那就意味着发生了 <strong>脏写</strong></p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220114123217362.png" alt="image-20220114123217362"></p><p>Session A和Session B各开启了一个事务，Session B中的事务先将 studentno 列为1的记录的name列更新为’李四’，然后Session A中的事务接着又把这条 studentno 列为1的记录的name列更新为’张三’。如果之后Session B中的事务进行了回滚，那么Session A中的更新也将不复存在，这种现象就称之为脏写。这时Session A中的事务就没有效果了，明明把数据更新了，最后也提交事务了，最后看到的数据什么变化也没有。这里大家对事务的隔离级比较了解的话，会发现默认隔离级别下，上面 sessionA 中的更新语句会处于等待状态，这里只是跟大家说明一下会出现这样现象。</p><p><strong>2. 脏读（ Dirty Read ）</strong></p><p>对于两个事务 Session A、Session B，Session A <strong>读取</strong> 了已经被 Session B <strong>更新</strong> 但还 没有被提交 的字段。之后若 Session B <strong>回滚</strong>,Session A 读取 的内容就是 <strong>临时且无效</strong> 的。</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220114123457085.png" alt="image-20220114123457085"></p><p>Session A和Session B各开启了一个事务，Session B中的事务先将studentno列为1的记录的name列更新为’张三’，然后Session A中的事务再去查询这条studentno为1的记录，如果读到列name的值为’张三’，而Session B中的事务稍后进行了回滚，那么Session A中的事务相当于读到了一个不存在的数据，这种现象就称之为 <strong>脏读</strong> 。</p><p><strong>3. 不可重复读（ Non-Repeatable Read ）</strong></p><p>对于两个事务Session A、Session B，Session A <strong>读取</strong> 了一个字段，然后 Session B <strong>更新</strong> 了该字段。 之后Session A 再次读取 同一个字段， <strong>值就不同</strong> 了。那就意味着发生了不可重复读。</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220114123733312.png" alt="image-20220114123733312"></p><p>我们在Session B中提交了几个 <strong>隐式事务</strong> （注意是隐式事务，意味着语句结束事务就提交了），这些事务都修改了studentno列为1的记录的列name的值，每次事务提交之后，如果Session A中的事务都可以查看到最新的值，这种现象也被称之为 <strong>不可重复读</strong> 。</p><p><strong>4. 幻读（ Phantom ）</strong></p><p>对于两个事务Session A、Session B, Session A 从一个表中 <strong>读取</strong> 了一个字段, 然后 Session B 在该表中 <strong>插入</strong> 了一些新的行。 之后, 如果 Session A 再次读取 <strong>同一个表</strong>, 就会多出几行。那就意味着发生了幻读。</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220114123846351.png" alt="image-20220114123846351"></p><p>Session A中的事务先根据条件 studentno &gt; 0这个条件查询表student，得到了name列值为’张三’的记录；之后Session B中提交了一个 <strong>隐式事务</strong> ，该事务向表student中插入了一条新记录；之后Session A中的事务再根据相同的条件 studentno &gt; 0查询表student，得到的结果集中包含Session B中的事务新插入的那条记录，这种现象也被称之为 <strong>幻读</strong> 。我们把新插入的那些记录称之为 <strong>幻影记录</strong> 。</p><h3 id="3-3-SQL中的四种隔离级别"><a href="#3-3-SQL中的四种隔离级别" class="headerlink" title="3.3 SQL中的四种隔离级别"></a>3.3 SQL中的四种隔离级别</h3><p>上面介绍了几种并发事务执行过程中可能遇到的一些问题，这些问题有轻重缓急之分，我们给这些问题按照严重性来排一下序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">脏写 &gt; 脏读 &gt; 不可重复读 &gt; 幻读  </span><br></pre></td></tr></table></figure><p>我们愿意舍弃一部分隔离性来换取一部分性能在这里就体现在：设立一些隔离级别，隔离级别越低，并发问题发生的就越多。 SQL标准 中设立了<strong>4个 隔离级别</strong> ：</p><ul><li><strong>READ UNCOMMITTED</strong> ：<strong>读未提交</strong>，在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。不能避免脏读、不可重复读、幻读。</li><li><strong>READ COMMITTED</strong> ：<strong>读已提交</strong>，它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。<strong>可以避免脏读</strong>，但不可重复读、幻读问题仍然存在。</li><li><strong>REPEATABLE READ</strong> ：<strong>可重复读</strong>，事务A在读到一条数据之后，此时事务B对该数据进行了修改并提交，那么事务A再读该数据，读到的还是原来的内容。可以避免脏读、不可重复读，但幻读问题仍然存在。这是<strong>MySQL的默认隔离级别</strong>。</li></ul><p><strong>可重复读应用场景</strong>：假设你在管理一个个人银行账户表。一个表存了账户余额，一个表存了账单明细。到了月底你要做数据校对，也就是判断上个月的余额和当前余额的差额，是否与本月的账单明细一致。你一定希望在校对过程中，即使有用户发生了一笔新的交易，也不影响你的校对结果。</p><ul><li><strong>SERIALIZABLE</strong> ：<strong>可串行化</strong>，顾名思义是<strong>对于同一行记录，“写”会加“写锁”，“读”会加“读锁”</strong>。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。确保事务可以从一个表中读取相同的行。在这个事务持续期间，禁止其他事务对该表执行插入、更新和删除操作。所有的并发问题都可以避免，但性能十分低下。能避免脏读、不可重复读和幻读。</li></ul><p><strong>SQL标准</strong> 中规定，针对不同的隔离级别，并发事务可以发生不同严重程度的问题，具体情况如下：  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220114124428542.png" alt="image-20220114124428542"></p><p><strong>脏写</strong> 怎么没涉及到？因为脏写这个问题太严重了，<strong>不论是哪种隔离级别，都不允许脏写的情况发生</strong>。</p><p>不同的隔离级别有不同的现象，并有不同的锁和并发机制，隔离级别越高，数据库的并发性能就越差，4种事务隔离级别与并发性能的关系如下：  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220114124452423.png" alt="image-20220114124452423"></p><h3 id="3-4-MySQL支持的四种隔离级别"><a href="#3-4-MySQL支持的四种隔离级别" class="headerlink" title="3.4 MySQL支持的四种隔离级别"></a>3.4 MySQL支持的四种隔离级别</h3><p><strong>MySQL的默认隔离级别为REPEATABLE READ</strong>，我们可以手动修改一下事务的隔离级别。  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># 查看隔离级别，MySQL <span class="number">5.7</span><span class="number">.20</span>的版本之前：</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;tx_isolation&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-----------------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name <span class="operator">|</span> <span class="keyword">Value</span>           <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-----------------+ </span></span><br><span class="line"><span class="operator">|</span> tx_isolation  <span class="operator">|</span> REPEATABLE<span class="operator">-</span>READ <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-----------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line"># MySQL <span class="number">5.7</span><span class="number">.20</span>版本之后，引入transaction_isolation来替换tx_isolation</span><br><span class="line"># 查看隔离级别，MySQL <span class="number">5.7</span><span class="number">.20</span>的版本及之后：</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;transaction_isolation&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------+-----------------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span>                 <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------+-----------------+</span></span><br><span class="line"><span class="operator">|</span> transaction_isolation <span class="operator">|</span> REPEATABLE<span class="operator">-</span>READ <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------+-----------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.02</span> sec)</span><br><span class="line"></span><br><span class="line">#或者不同MySQL版本中都可以使用的：</span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@transaction</span>_isolation;  </span><br></pre></td></tr></table></figure><h3 id="3-5-如何设置事务的隔离级别"><a href="#3-5-如何设置事务的隔离级别" class="headerlink" title="3.5 如何设置事务的隔离级别"></a>3.5 如何设置事务的隔离级别</h3><p>通过下面的语句修改事务的隔离级别：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> [<span class="keyword">GLOBAL</span><span class="operator">|</span>SESSION] TRANSACTION ISOLATION LEVEL 隔离级别;</span><br><span class="line">#其中，隔离级别格式：</span><br><span class="line"><span class="operator">&gt;</span> READ UNCOMMITTED</span><br><span class="line"><span class="operator">&gt;</span> READ COMMITTED</span><br><span class="line"><span class="operator">&gt;</span> REPEATABLE READ</span><br><span class="line"><span class="operator">&gt;</span> SERIALIZABLE  </span><br></pre></td></tr></table></figure><p>或者：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> [<span class="keyword">GLOBAL</span><span class="operator">|</span>SESSION] TRANSACTION_ISOLATION <span class="operator">=</span> <span class="string">&#x27;隔离级别&#x27;</span></span><br><span class="line">#其中，隔离级别格式：</span><br><span class="line"><span class="operator">&gt;</span> READ<span class="operator">-</span>UNCOMMITTED</span><br><span class="line"><span class="operator">&gt;</span> READ<span class="operator">-</span>COMMITTED</span><br><span class="line"><span class="operator">&gt;</span> REPEATABLE<span class="operator">-</span>READ</span><br><span class="line"><span class="operator">&gt;</span> SERIALIZABLE  </span><br></pre></td></tr></table></figure><p><strong>关于设置时使用GLOBAL或SESSION的影响：</strong>  </p><ul><li>使用 <code>GLOBAL</code> 关键字（在全局范围影响）：  </li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> TRANSACTION ISOLATION LEVEL SERIALIZABLE;</span><br><span class="line">#或</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> TRANSACTION_ISOLATION <span class="operator">=</span> <span class="string">&#x27;SERIALIZABLE&#x27;</span>;  </span><br></pre></td></tr></table></figure><p>使用 <code>SESSION </code>关键字（在会话范围影响）:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE;</span><br><span class="line">#或</span><br><span class="line"><span class="keyword">SET</span> SESSION TRANSACTION_ISOLATION <span class="operator">=</span> <span class="string">&#x27;SERIALIZABLE&#x27;</span>;  </span><br></pre></td></tr></table></figure><p>则：</p><ul><li><strong>对当前会话的所有后续的事务有效</strong></li><li>如果在事务之间执行，则对后续的事务有效该语句可以在已经开启的事务中间</li><li>行，但不会影响当前正在执行的事务  </li></ul><h3 id="3-6-不同隔离级别举例"><a href="#3-6-不同隔离级别举例" class="headerlink" title="3.6 不同隔离级别举例"></a>3.6 不同隔离级别举例</h3><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220114140424937.png" alt="image-20220114140424937"></p><p><strong>演示1. 读未提交之脏读</strong><br>例一：</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220114135908854.png" alt="image-20220114135908854"></p><p>例二：</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220114135928302.png" alt="image-20220114135928302"></p><p><strong>演示2：读已提交</strong>  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220114135945107.png" alt="image-20220114135945107"></p><p>虽然已经解决脏读，但仍会发生不可重复读的情况。</p><p><strong>演示3. 可重复读</strong></p><p>设置隔离级别为可重复读，事务的执行流程如下：  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220114135954500.png" alt="image-20220114135954500"></p><p><strong>演示4：幻读</strong>  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220114140102345.png" alt="image-20220114140102345"></p><h2 id="面试造火箭计划！！！"><a href="#面试造火箭计划！！！" class="headerlink" title="面试造火箭计划！！！"></a>面试造火箭计划！！！</h2><p><strong>1.事务的概念是什么?</strong></p><p>事务是对数据库中数据操作的保证数据逻辑一致的最小操作单位。</p><p><strong>2.mysql的事务隔离级别读未提交, 读已提交, 可重复读, 串行各是什么意思?</strong></p><p>读未提交：一个事务读取到了其他事务未提交的操作。</p><p>读已提交：一个事务读取到了其他事务已经提交的操作。</p><p>可重复读：一个事务从它开始到结束整个生命周期中，所能读取到的数据内容和它启动的时候所能读到的数据内容是相同的。不会出现在事务运行的整个过程中，不同的时间点读取到的数据不一样的情况。</p><p>串行化：所有的事务都进行排队执行，事务之间不存才并发的情况。读有读锁，写有写锁。读、读之间不影响，读、写和写、写之间互相排斥，当遇到排斥的情况后，后发生的事务需要等待先发生的事务执行完成后才可以执行。</p><p><strong>3.读已提交, 可重复读是怎么通过视图构建实现的?</strong></p><p>读已提交：会在事务中的每一个SQL语句执行的时候都为对应的SQL创建一个一致性视图。此时这个SQL能读取到已经提交的事务对数据的操作。</p><p>可重复读：会在事务启动的时候，为整个事务创建一个一致性视图，这个视图会贯穿到这个事务执行结束。在整个事务执行过程中，都使用这个视图中的数据作为一致性读的依据。</p><p><strong>4.可重复读的使用场景举例?</strong></p><p>对账的时候：假设你在管理一个个人银行账户表。一个表存了账户余额，一个表存了账单明细。到了月底你要做数据校对，也就是判断上个月的余额和当前余额的差额，是否与本月的账单明细一致。你一定希望在校对过程中，即使有用户发生了一笔新的交易，也不影响你的校对结果。</p><p>库管盘货</p><p><strong>5.事务隔离是怎么通过read-view(读视图)实现的?</strong></p><p>每一行数有多个版本，当我们要去读取数据的时候，要判断这个数据的版本号，对当前事务而言，是否可见，如果不可见，则要根据undolog计算得到上一个版本。如果上一个版本也不符合要求，则要找到再上一个版本，<br>直到找到对应正确的数据版本。</p><p><strong>6.并发版本控制(MCVV)的概念是什么, 是怎么实现的?</strong></p><p><strong>7.使用长事务的弊病? 为什么使用常事务可能拖垮整个库?</strong></p><p>长事务导致表空间持续增长，即便是事务提交或者回滚后，回滚表空间被是否后，表空间大小仍然不会被缩小。</p><p>长事务的存在导致锁发生冲突或等待的几率大大增加。</p><p>如果某个应用有发生锁等待后尝试重新建立连接的机制，那么在发生锁等待或冲突的时候，应用就会不断地发起新的连接，导致MySQL的连接数被占用爆满。MySQL不能在提供连接服务，就挂掉了。</p><p><strong>8.事务的启动方式有哪几种?</strong></p><p>begin;–一致性读的视图不会马上创建，而是在执行begin后面的第一个操作innodb表的SQL语句时生成。这个SQL可以是</p><p>select,update,delete,insert。事务ID也是此时被分配的</p><p>start transaction;–和begin的功能效果一样。</p><p>start transaciton with consistent snapshot;–该语句执行后，会马上创建一致性读的视图。这个是它和begin的区别。事务ID也是此时被</p><p>分配的。</p><p><strong>9.commit work and chain的语法是做什么用的?</strong></p><p>提交上一个事务，并且再开启一个新的事务。它的功能等效于：commit + begin。</p><p><strong>10.怎么查询各个表中的长事务?</strong></p><p>select * from information_schema.innodb_trx;</p><p>这个表中记录了所有正在运行的事务信息，里面有事务的开始时间。可以从这里看出哪些事务运行的时间比较长。</p><p><strong>11.如何避免长事务的出现?</strong></p><p>从数据库方面：</p><ul><li>  a.设置autocommit=1，不要设置为0。</li><li>  b.写脚本监控information_schemal.innodb_trx表中数据内容，发现长事务，kill掉它。</li><li>  c.配置SQL语句所能执行的最大运行时间，如果查过最大运行时间后，中断这个运行事情长的SQL语句。</li><li>  d.设置回滚表空单独存放，便于回收表空间。</li></ul><p>从业务代码方面：</p><ul><li>  a.确认是否使用了autocommit=0的配置，如果有关闭它，然后再业务代码中手动的使用begin;commit来操作。</li><li>  b.检查业务逻辑代码，能拆分为小事务的不要用大事务。</li><li>  c.检查代码，把没有必要的select语句被事务包裹的情况去掉。</li></ul>]]></content>
      
      
      <categories>
          
          <category> database </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
