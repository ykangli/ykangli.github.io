<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Git学习笔记</title>
      <link href="/2022/02/03/Git/"/>
      <url>/2022/02/03/Git/</url>
      
        <content type="html"><![CDATA[<h1 id="Git学习笔记"><a href="#Git学习笔记" class="headerlink" title="Git学习笔记"></a>Git学习笔记</h1><h2 id="Git-Commit"><a href="#Git-Commit" class="headerlink" title="Git Commit"></a>Git Commit</h2><p>Git 仓库中的提交记录保存的是你的目录下所有文件的快照，就像是把整个目录复制，然后再粘贴一样，但比复制粘贴优雅许多！</p><p>Git 希望提交记录尽可能地轻量，因此在你每次进行提交时，它并不会盲目地复制整个目录。条件允许的情况下，它会将当前版本与仓库中的上一个版本进行对比，并把所有的差异打包到一起作为一个提交记录。</p><p>Git 还保存了提交的历史记录。这也是为什么大多数提交记录的上面都有父节点的原因 —— 我们会在图示中用箭头来表示这种关系。对于项目组的成员来说，维护提交历史对大家都有好处。</p><p>实际操作一下，看看提交记录是怎样的。右边展示了一个（小型）Git 代码库。当前有两个提交记录 —— 初始提交 <code>C0</code> 和其后可能包含某些有用修改的提交 <code>C1</code>。</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220203160058760.png" alt="image-20220203160058760"></p><p>此时执行 <code>git commit</code>后：</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220203160141577.png" alt="image-20220203160141577"></p><p>我们刚才修改了代码库，并把这些修改保存成了一个提交记录 <code>C2</code>。<code>C2</code> 的父节点是 <code>C1</code>，父节点是当前提交中变更的基础。</p><h2 id="Git-Branch"><a href="#Git-Branch" class="headerlink" title="Git Branch"></a>Git Branch</h2><p>Git 的分支也非常轻量。它们只是简单地指向某个提交纪录 —— 仅此而已。所以许多 Git 爱好者传颂：早建分支！多用分支！</p><p>这是因为即使创建再多的分支也不会造成储存或内存上的开销，并且按逻辑分解工作到不同的分支要比维护那些特别臃肿的分支简单多了。在将分支和提交记录结合起来后，我们会看到两者如何协作。现在只要记住使用分支其实就相当于在说：“我想基于这个提交以及它所有的父提交进行新的工作。”</p><p>目前状态如下：</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220203160301341.png" alt="image-20220203160301341"></p><p>接下来，我们将要创建一个到名为 <code>newImage</code> 的分支。 执行 <code>git branch newImage</code>:</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220203160348072.png" alt="image-20220203160348072"></p><p>新创建的分支 <code>newImage</code> 指向的是提交记录 <code>C1</code>。</p><p>现在执行<code>git commit</code>:</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220203160429885.png" alt="image-20220203160429885"></p><p>为什么 <code>main</code> 分支前进了，但 <code>newImage</code> 分支还待在原地呢？！这是因为我们没有“在”这个新分支上，看到 <code>main</code> 分支上的那个星号（*）了吗？这表示当前所在的分支是 <code>main</code>。</p><p>现在咱们告诉 Git 我们想要切换到新的分支上</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220203160532244.png" alt="image-20220203160532244"></p><pre class="line-numbers language-none"><code class="language-none">git checkout &lt;name&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>下面的命令会让我们在提交修改之前先切换到新的分支上</p><p><code>git checkout newImage</code></p><p><code>git commit</code></p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220203160619999.png" alt="image-20220203160619999"></p><p>这就对了！我们的修改已经保存到新的分支里了。</p><p><strong>注意</strong>：在 Git 2.23 版本中，引入了一个名为 <code>git switch</code> 的新命令，最终会取代 <code>git checkout</code>，因为 <code>checkout</code> 作为单个命令有点超载（它承载了很多独立的功能）。 </p><p>如果你想<strong>创建一个新的分支同时切换到新创建的分支</strong>的话，可以通过 <code>git checkout -b &lt;your-branch-name&gt;</code> 来实现。</p><h2 id="分支与合并"><a href="#分支与合并" class="headerlink" title="分支与合并"></a>分支与合并</h2><p>太好了! 我们已经知道如何提交以及如何使用分支了。接下来咱们看看如何将两个分支合并到一起。就是说我们新建一个分支，在其上开发某个新功能，开发完成后再合并回主线。</p><h3 id="Git-Merge"><a href="#Git-Merge" class="headerlink" title="Git Merge"></a>Git Merge</h3><p>咱们先来看一下第一种方法 —— <code>git merge</code>。在 Git 中合并两个分支时会产生一个特殊的提交记录，它有两个父节点。翻译成自然语言相当于：“我要把这两个父节点本身及它们所有的祖先都包含进来。”</p><p>我们准备了两个分支，每个分支上各有一个独有的提交。这意味着没有一个分支包含了我们修改的所有内容。咱们通过合并这两个分支来解决这个问题。</p><p>我们要把 <code>bugFix</code> 合并到 <code>main</code> 里</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220203160846947.png" alt="image-20220203160846947"></p><p>此时执行<code>git merge bugFix</code>：</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220203160942439.png" alt="image-20220203160942439"></p><p>首先，<code>main</code> 现在指向了一个拥有两个父节点的提交记录。假如从 <code>main</code> 开始沿着箭头向上看，在到达起点的路上会经过所有的提交记录。这意味着 <code>main</code> 包含了对代码库的所有修改。</p><p>还有，看见各个提交记录的颜色变化了吗？为了帮助学习理解，我引入了颜色搭配。每个分支都有不同的颜色，而每个提交记录的颜色是所有包含该提交记录的分支的颜色混合之后的颜色。</p><p>所以，<code>main</code> 分支的颜色被混入到所有的提交记录，但 <code>bugFix</code> 没有。下面咱们让它也改变一下颜色。</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220203161059572.png" alt="image-20220203161059572"></p><p>此时执行以下命令：</p><p><code>git checkout bugFix</code></p><p><code>git merge main</code></p><p>因为 <code>main</code> 继承自 <code>bugFix</code>，Git 什么都不用做，只是简单地把 <code>bugFix</code> 移动到 <code>main</code> 所指向的那个提交记录。</p><p>现在所有提交记录的颜色都一样了，这表明每一个分支都包含了代码库的所有修改！大功告成！</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220203161159155.png" alt="image-20220203161159155"></p><h3 id="Git-Rebase"><a href="#Git-Rebase" class="headerlink" title="Git Rebase"></a>Git Rebase</h3><p>第二种合并分支的方法是 <code>git rebase</code>。Rebase 实际上就是取出一系列的提交记录，“复制”它们，然后在另外一个地方逐个的放下去。</p><p>Rebase 的优势就是可以创造更线性的提交历史，这听上去有些难以理解。如果只允许使用 Rebase 的话，代码库的提交历史将会变得异常清晰。</p><p>还是准备了两个分支；注意当前所在的分支是 bugFix（星号标识的是当前分支）</p><p>我们想要把 bugFix 分支里的工作直接移到 main 分支上。移动以后会使得两个分支的功能看起来像是按顺序开发，但实际上它们是并行开发的。咱们这次用 <code>git rebase</code> 实现此目标</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220203161306271.png" alt="image-20220203161306271"></p><p>此时执行<code>git rebase main</code> :</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220203161517867.png" alt="image-20220203161517867"></p><p>现在 bugFix 分支上的工作在 main 的最顶端，同时我们也得到了一个更线性的提交序列。</p><p>注意，提交记录 C3 依然存在（树上那个半透明的节点），而 C3’ 是我们 Rebase 到 main 分支上的 C3 的副本。</p><p>现在唯一的问题就是 main 还没有更新，下面咱们就来更新它吧……</p><p>现在我们切换到了 <code>main</code> 上。</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220203161632301.png" alt="image-20220203161632301"></p><p>此时执行<code>git rebase bugFix</code>:</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220203161713269.png" alt="image-20220203161713269"></p><p>由于 <code>bugFix</code> 继承自 <code>main</code>，所以 Git 只是简单的把 <code>main</code> 分支的引用向前移动了一下而已。</p><h2 id="Git-Fetch"><a href="#Git-Fetch" class="headerlink" title="Git Fetch"></a>Git Fetch</h2><p>Git 远程仓库相当的操作实际可以归纳为两点：向远程仓库传输数据以及从远程仓库获取数据。既然我们能与远程仓库同步，那么就可以分享任何能被 Git 管理的更新（因此可以分享代码、文件、想法、情书等等）。</p><p>如何从远程仓库获取数据，它就是 <code>git fetch</code>。当我们从远程仓库获取数据时, 远程分支也会更新以反映最新的远程仓库。</p><p>在解释 <code>git fetch</code> 前，我们先看看实例。这里我们有一个远程仓库, 它有两个我们本地仓库中没有的提交。</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220203155737157.png" alt="image-20220203155737157"></p><p>此时执行 <code>git fetch</code>后，状态如下：</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220203155833869.png" alt="image-20220203155833869"></p><p>就是这样了! <code>C2</code>,<code>C3</code> 被下载到了本地仓库，同时远程分支 <code>o/main</code> 也被更新，反映到了这一变化</p><h3 id="git-fetch-做了些什么"><a href="#git-fetch-做了些什么" class="headerlink" title="git fetch 做了些什么"></a>git fetch 做了些什么</h3><p><code>git fetch</code> 完成了仅有的但是很重要的两步:</p><ul><li>从远程仓库下载本地仓库中缺失的提交记录</li><li>更新远程分支指针(如 <code>o/main</code>)</li></ul><p><code>git fetch</code> 实际上将本地仓库中的远程分支更新成了远程仓库相应分支最新的状态。</p><p>如果你还记得上一节课程中我们说过的，远程分支反映了远程仓库在你<strong>最后一次与它通信时</strong>的状态，<code>git fetch</code> 就是你与远程仓库通信的方式了！希望我说的够明白了，你已经了解 <code>git fetch</code> 与远程分支之间的关系了吧。</p><p><code>git fetch</code> 通常通过互联网（使用 <code>http://</code> 或 <code>git://</code> 协议) 与远程仓库通信。</p><h3 id="git-fetch-不会做的事"><a href="#git-fetch-不会做的事" class="headerlink" title="git fetch 不会做的事"></a>git fetch 不会做的事</h3><p><code>git fetch</code> <strong>并不会改变你本地仓库的状态</strong>。它不会更新你的 <code>main</code> 分支，也<strong>不会修改你磁盘上的文件</strong>。</p><p>理解这一点很重要，因为许多开发人员误以为执行了 <code>git fetch</code> 以后，他们本地仓库就与远程仓库同步了。它可能已经将进行这一操作所需的所有数据都下载了下来，但是<strong>并没有</strong>修改你本地的文件。我们在后面的课程中将会讲解能完成该操作的命令 :D</p><p>所以, 你可以将 <code>git fetch</code> 的理解为单纯的下载操作。</p><h2 id="偏离的工作"><a href="#偏离的工作" class="headerlink" title="偏离的工作"></a>偏离的工作</h2><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>假设你周一克隆了一个仓库，然后开始研发某个新功能。到周五时，你新功能开发测试完毕，可以发布了。但是 —— 天啊！你的同事这周写了一堆代码，还改了许多你的功能中使用的 API，这些变动会导致你新开发的功能变得不可用。但是他们已经将那些提交推送到远程仓库了，因此你的工作就变成了基于项目<strong>旧版</strong>的代码，与远程仓库最新的代码不匹配了。</p><p>这种情况下, <code>git push</code> 就不知道该如何操作了。如果你执行 <code>git push</code>，Git 应该让远程仓库回到星期一那天的状态吗？还是直接在新代码的基础上添加你的代码，亦或由于你的提交已经过时而直接忽略你的提交？</p><p>因为这情况（历史偏离）有许多的不确定性，Git 是不会允许你 <code>push</code> 变更的。实际上它会强制你先合并远程最新的代码，然后才能分享你的工作。</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220203164347886.png" alt="image-20220203164347886"></p><p>此时若执行 <code>git push</code>:</p><p>看见了吧？什么都没有变，因为命令失败了！<code>git push</code> 失败是因为你最新提交的 <code>C3</code> 基于远程分支中的 <code>C1</code>。而远程仓库中该分支已经更新到 <code>C2</code> 了，所以 Git 拒绝了你的推送请求。</p><p>那该如何解决这个问题呢？很简单，你需要做的就是<strong>使你的工作基于最新的远程分支</strong>。</p><p>有许多方法做到这一点呢，不过最直接的方法就是通过 rebase 调整你的工作。咱们继续，看看怎么 rebase！</p><p>此时执行:</p><p><code>git fetch </code></p><p><code>git rebase o/main</code></p><p><code>git push</code></p><p>上面三条命令相当于 <code>git pull --rebase; git push</code></p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220203164655199.png" alt="image-20220203164655199"></p><p>我们用 <code>git fetch</code> 更新了本地仓库中的远程分支，然后用 rebase 将我们的工作移动到最新的提交记录下，最后再用 <code>git push</code> 推送到远程仓库。</p><p>还可以用 merge 替换 rebase。</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220203164347886.png" alt="image-20220203164347886"></p><p>此时执行:</p><p><code>git fetch </code></p><p><code>git merge o/main</code></p><p><code>git push</code></p><p>上面三条命令相当于 <code>git pull; git push</code></p><p>我们用 <code>git fetch</code> 更新了本地仓库中的远程分支，然后<strong>合并</strong>了新变更到我们的本地分支（为了包含远程仓库的变更），最后我们用 <code>git push</code> 把工作推送到远程仓库</p><p><strong>命令：</strong></p><p><code>git pull</code> 就是 fetch 和 merge 的简写，类似的 <code>git pull --rebase</code> 就是 fetch 和 rebase 的简写！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java-NIO</title>
      <link href="/2022/02/02/Java-NIO/"/>
      <url>/2022/02/02/Java-NIO/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章-BIO、NIO、AIO课程介绍"><a href="#第一章-BIO、NIO、AIO课程介绍" class="headerlink" title="第一章 BIO、NIO、AIO课程介绍"></a>第一章 BIO、NIO、AIO课程介绍</h1><h2 id="1-1-课程说明"><a href="#1-1-课程说明" class="headerlink" title="1.1 课程说明"></a>1.1 课程说明</h2><p> 在Java的软件设计开发中，通信架构是不可避免的，我们在进行不同系统或者不同进程之间的数据交互，或者在高并发下的通信场景下都需要用到网络通信相关的技术，对于一些经验丰富的程序员来说，Java早期的网络通信架构存在一些缺陷，<strong>其中最令人恼火的是基于性能低下的同步阻塞式的I/O通信（BIO）</strong>，随着互联网开发下通信性能的高要求，Java在2002年开始支持了非阻塞式的I/O通信技术(NIO)。大多数读者在学习网络通信相关技术的时候，都只是接触到零碎的通信技术点，没有完整的技术体系架构，以至于对于Java的通信场景总是没有清晰的解决方案。本次课程将通过大量清晰直接的案例从最基础的BIO式通信开始介绍到NIO , AIO，读者可以清晰的了解到阻塞、同步、异步的现象、概念和特征以及优缺点。本课程结合了大量的案例让读者可以快速了解每种通信架构的使用。</p><h2 id="1-2-本课程学习要求"><a href="#1-2-本课程学习要求" class="headerlink" title="1.2 本课程学习要求"></a>1.2 本课程学习要求</h2><ul><li>本课程不太适合完全0基础学员。</li><li>至少需要掌握: Java SE基础编程，如Java多线程，Java IO流编程，Java网络基础知识（如：IP , 端口，协议），常用的Java设计模式要有一定的了解。</li><li>能熟练掌握Java OOP编程，有一定的编程思维。</li></ul><h2 id="1-3-通信技术整体解决的问题"><a href="#1-3-通信技术整体解决的问题" class="headerlink" title="1.3 通信技术整体解决的问题"></a>1.3 通信技术整体解决的问题</h2><ul><li>局域网内的通信要求。</li><li>多系统间的底层消息传递机制。</li><li>高并发下，大数据量的通信场景需要。</li><li>游戏行业。无论是手游服务端，还是大型的网络游戏，Java语言都得到越来越广泛的应用。</li></ul><h1 id="第二章-Java的I-O演进之路"><a href="#第二章-Java的I-O演进之路" class="headerlink" title="第二章 Java的I/O演进之路"></a>第二章 Java的I/O演进之路</h1><h2 id="2-1-I-O-模型基本说明"><a href="#2-1-I-O-模型基本说明" class="headerlink" title="2.1 I/O 模型基本说明"></a>2.1 I/O 模型基本说明</h2><p>I/O 模型：就是用什么样的通道或者说是通信模式和架构进行数据的传输和接收，很大程度上决定了程序通信的性能，Java 共支持 3 种网络编程的/IO 模型：<strong>BIO、NIO、AIO</strong> 实际通信需求下，要根据不同的业务场景和性能需求决定选择不同的I/O模型</p><h2 id="2-2-I-O模型"><a href="#2-2-I-O模型" class="headerlink" title="2.2 I/O模型"></a>2.2 I/O模型</h2><h4 id="Java-BIO"><a href="#Java-BIO" class="headerlink" title="Java BIO"></a>Java BIO</h4><p><strong>同步并阻塞</strong>(传统阻塞型)，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器 端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销 【简单示意图】</p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220202150239257.png" alt="image-20220202150239257" style="zoom:67%;"><h4 id="Java-NIO"><a href="#Java-NIO" class="headerlink" title="Java NIO"></a>Java NIO</h4><p>Java NIO ： <strong>同步非阻塞</strong>，服务器实现模式为一个线程处理多个请求(连接)，即客户端发送的连接请求都会注 册到多路复用器上，多路复用器轮询到连接有 I/O 请求就进行处理 【简单示意图】</p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220202150345643.png" alt="image-20220202150345643" style="zoom:67%;"><h4 id="Java-AIO"><a href="#Java-AIO" class="headerlink" title="Java AIO"></a>Java AIO</h4><p>Java AIO(NIO.2) ：<strong>异步非阻塞</strong>，服务器实现模式为一个有效请求一个线程，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理，一般适用于连接数较多且连接时间较长的应用</p><h2 id="2-3-BIO、NIO、AIO-适用场景分析"><a href="#2-3-BIO、NIO、AIO-适用场景分析" class="headerlink" title="2.3 BIO、NIO、AIO 适用场景分析"></a>2.3 BIO、NIO、AIO 适用场景分析</h2><p>1、<strong>BIO</strong> 方式适用于<strong>连接数目比较小且固定的架构</strong>，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序简单易理解。 </p><p>2、<strong>NIO</strong> 方式适用于<strong>连接数目多且连接比较短（轻操作）</strong>的架构，比如聊天服务器，弹幕系统，服务器间通讯等。 编程比较复杂，JDK1.4 开始支持。</p><p>3、<strong>AIO</strong> 方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用 OS 参与并发操作， 编程比较复杂，JDK7 开始支持。</p><h1 id="第三章-JAVA-BIO深入剖析"><a href="#第三章-JAVA-BIO深入剖析" class="headerlink" title="第三章 JAVA BIO深入剖析"></a>第三章 JAVA BIO深入剖析</h1><h2 id="3-1-Java-BIO-基本介绍"><a href="#3-1-Java-BIO-基本介绍" class="headerlink" title="3.1 Java BIO 基本介绍"></a>3.1 Java BIO 基本介绍</h2><ul><li>Java BIO 就是传统的 java io 编程，其相关的类和接口在 java.io</li><li>BIO(blocking I/O) ： 同步阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，可以通过<strong>线程池机制</strong>改善(实现多个客户连接服务器).</li></ul><h2 id="3-2-Java-BIO-工作机制"><a href="#3-2-Java-BIO-工作机制" class="headerlink" title="3.2 Java BIO 工作机制"></a>3.2 Java BIO 工作机制</h2><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220202151042311.png" alt="image-20220202151042311" style="zoom: 80%;"><h2 id="3-3-传统的BIO编程实例回顾"><a href="#3-3-传统的BIO编程实例回顾" class="headerlink" title="3.3 传统的BIO编程实例回顾"></a>3.3 传统的BIO编程实例回顾</h2><p> 网络编程的基本模型是Client/Server模型，也就是两个进程之间进行相互通信，其中服务端提供位置信（绑定IP地址和端口），客户端通过连接操作向服务端监听的端口地址发起连接请求，基于TCP协议下进行三次握手连接，连接成功后，双方通过网络套接字（Socket）进行通信。</p><p> 传统的同步阻塞模型开发中，服务端ServerSocket负责绑定IP地址，启动监听端口；客户端Socket负责发起连接操作。连接成功后，双方通过输入和输出流进行<strong>同步阻塞式通信</strong>。 基于BIO模式下的通信，客户端 - 服务端是完全同步，完全耦合的。</p><h3 id="客户端案例如下"><a href="#客户端案例如下" class="headerlink" title="客户端案例如下"></a>客户端案例如下</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>itheima<span class="token punctuation">.</span></span>_02bio01<span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">OutputStream</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">PrintStream</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>net<span class="token punctuation">.</span></span><span class="token class-name">Socket</span><span class="token punctuation">;</span><span class="token comment">/**    目标: Socket网络编程。    Java提供了一个包：java.net下的类都是用于网络通信。    Java提供了基于套接字（端口）Socket的网络通信模式，我们基于这种模式就可以直接实现TCP通信。    只要用Socket通信，那么就是基于TCP可靠传输通信。    功能1：客户端发送一个消息，服务端接口一个消息，通信结束！！    创建客户端对象：        （1）创建一个Socket的通信管道，请求与服务端的端口连接。        （2）从Socket管道中得到一个字节输出流。        （3）把字节流改装成自己需要的流进行数据的发送    创建服务端对象：        （1）注册端口        （2）开始等待接收客户端的连接,得到一个端到端的Socket管道        （3）从Socket管道中得到一个字节输入流。        （4）把字节输入流包装成自己需要的流进行数据的读取。    Socket的使用：        构造器：public Socket(String host, int port)        方法：  public OutputStream getOutputStream()：获取字节输出流               public InputStream getInputStream() :获取字节输入流    ServerSocket的使用：        构造器：public ServerSocket(int port)    小结：        通信是很严格的，对方怎么发你就怎么收，对方发多少你就只能收多少！！ */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ClientDemo</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"==客户端的启动=="</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// （1）创建一个Socket的通信管道，请求与服务端的端口连接。</span>        <span class="token class-name">Socket</span> socket <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Socket</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1"</span><span class="token punctuation">,</span><span class="token number">8888</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// （2）从Socket通信管道中得到一个字节输出流。</span>        <span class="token class-name">OutputStream</span> os <span class="token operator">=</span> socket<span class="token punctuation">.</span><span class="token function">getOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// （3）把字节流改装成自己需要的流进行数据的发送</span>        <span class="token class-name">PrintStream</span> ps <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PrintStream</span><span class="token punctuation">(</span>os<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// （4）开始发送消息</span>        ps<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"我是客户端，我想约你吃小龙虾！！！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ps<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="服务端案例如下"><a href="#服务端案例如下" class="headerlink" title="服务端案例如下"></a>服务端案例如下</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>itheima<span class="token punctuation">.</span></span>_02bio01<span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">BufferedReader</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">InputStream</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">InputStreamReader</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>net<span class="token punctuation">.</span></span><span class="token class-name">ServerSocket</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>net<span class="token punctuation">.</span></span><span class="token class-name">Socket</span><span class="token punctuation">;</span><span class="token comment">/** * 服务端 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ServerDemo</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"==服务器的启动=="</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// （1）注册端口</span>        <span class="token class-name">ServerSocket</span> serverSocket <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ServerSocket</span><span class="token punctuation">(</span><span class="token number">8888</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//（2）开始在这里暂停等待接收客户端的连接,得到一个端到端的Socket管道</span>        <span class="token class-name">Socket</span> socket <span class="token operator">=</span> serverSocket<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//（3）从Socket管道中得到一个字节输入流。</span>        <span class="token class-name">InputStream</span> is <span class="token operator">=</span> socket<span class="token punctuation">.</span><span class="token function">getInputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//（4）把字节输入流包装成自己需要的流进行数据的读取。</span>        <span class="token class-name">BufferedReader</span> br <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span>is<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//（5）读取数据</span>        <span class="token class-name">String</span> line <span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>line <span class="token operator">=</span> br<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"服务端收到："</span><span class="token operator">+</span>line<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li>在以上通信中，服务端会一直等待客户端的消息，如果客户端没有进行消息的发送，服务端将一直进入阻塞状态。</li><li>同时服务端是按照行获取消息的，这意味着客户端也必须按照行进行消息的发送，否则服务端将进入等待消息的阻塞状态！</li></ul><h2 id="3-4-BIO模式下多发和多收消息"><a href="#3-4-BIO模式下多发和多收消息" class="headerlink" title="3.4 BIO模式下多发和多收消息"></a>3.4 BIO模式下多发和多收消息</h2><p>在1.3的案例中，<strong>只能实现客户端发送消息，服务端接收消息</strong>，并不能实现反复的收消息和反复的发消息，我们只需要在客户端案例中，加上反复按照行发送消息的逻辑即可！案例代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>itheima<span class="token punctuation">.</span></span>_03bio02<span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">OutputStream</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">PrintStream</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>net<span class="token punctuation">.</span></span><span class="token class-name">Socket</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Scanner</span><span class="token punctuation">;</span><span class="token comment">/**    目标: Socket网络编程。    功能1：客户端可以反复发消息，服务端可以反复收消息    小结：        通信是很严格的，对方怎么发你就怎么收，对方发多少你就只能收多少！！ */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ClientDemo</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"==客户端的启动=="</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// （1）创建一个Socket的通信管道，请求与服务端的端口连接。</span>        <span class="token class-name">Socket</span> socket <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Socket</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1"</span><span class="token punctuation">,</span><span class="token number">8888</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// （2）从Socket通信管道中得到一个字节输出流。</span>        <span class="token class-name">OutputStream</span> os <span class="token operator">=</span> socket<span class="token punctuation">.</span><span class="token function">getOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// （3）把字节流改装成自己需要的流进行数据的发送</span>        <span class="token class-name">PrintStream</span> ps <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PrintStream</span><span class="token punctuation">(</span>os<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// （4）开始发送消息</span>        <span class="token class-name">Scanner</span> sc <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"请说:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">String</span> msg <span class="token operator">=</span> sc<span class="token punctuation">.</span><span class="token function">nextLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            ps<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>            ps<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="服务端代码如下"><a href="#服务端代码如下" class="headerlink" title="服务端代码如下"></a>服务端代码如下</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>itheima<span class="token punctuation">.</span></span>_03bio02<span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">BufferedReader</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">InputStream</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">InputStreamReader</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>net<span class="token punctuation">.</span></span><span class="token class-name">ServerSocket</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>net<span class="token punctuation">.</span></span><span class="token class-name">Socket</span><span class="token punctuation">;</span><span class="token comment">/** * 服务端 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ServerDemo</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">String</span> s <span class="token operator">=</span> <span class="token string">"886"</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"886"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"==服务器的启动=="</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//（1）注册端口</span>        <span class="token class-name">ServerSocket</span> serverSocket <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ServerSocket</span><span class="token punctuation">(</span><span class="token number">8888</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//（2）开始在这里暂停等待接收客户端的连接,得到一个端到端的Socket管道</span>        <span class="token class-name">Socket</span> socket <span class="token operator">=</span> serverSocket<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//（3）从Socket管道中得到一个字节输入流。</span>        <span class="token class-name">InputStream</span> is <span class="token operator">=</span> socket<span class="token punctuation">.</span><span class="token function">getInputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//（4）把字节输入流包装成  自己需要的流进行数据的读取。</span>        <span class="token class-name">BufferedReader</span> br <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span>is<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//（5）读取数据</span>        <span class="token class-name">String</span> line <span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>line <span class="token operator">=</span> br<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"服务端收到："</span><span class="token operator">+</span>line<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><ul><li>本案例中确实可以实现客户端多发多收</li><li>但是<strong>服务端只能处理一个客户端的请求</strong>，因为服务端是单线程的。<strong>一次只能与一个客户端进行消息通信</strong>。</li></ul><h2 id="3-5-BIO模式下接收多个客户端"><a href="#3-5-BIO模式下接收多个客户端" class="headerlink" title="3.5 BIO模式下接收多个客户端"></a>3.5 BIO模式下接收多个客户端</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>在上述的案例中，一个服务端只能接收一个客户端的通信请求，<strong>那么如果服务端需要处理很多个客户端的消息通信请求应该如何处理呢</strong>，此时我们就需要<strong>在服务端引入线程</strong>了，也就是说<strong>客户端每发起一个请求，服务端就创建一个新的线程</strong>来处理这个客户端的请求，这样就实现了一个客户端一个线程的模型，图解模式如下：</p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220202152550833.png" alt="image-20220202152550833" style="zoom: 80%;"><h3 id="客户端案例代码如下"><a href="#客户端案例代码如下" class="headerlink" title="客户端案例代码如下"></a>客户端案例代码如下</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**    目标: 实现服务端可以同时接受多个客户端的Socket通信需求    思路：是服务端每接受一个客户端socket请求对象之后都交给一个独立的线程来处理客户端的数据交互需求 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ClientDemo</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"==客户端的启动=="</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// （1）创建一个Socket的通信管道，请求与服务端的端口连接。</span>        <span class="token class-name">Socket</span> socket <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Socket</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1"</span><span class="token punctuation">,</span><span class="token number">7777</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// （2）从Socket通信管道中得到一个字节输出流。</span>        <span class="token class-name">OutputStream</span> os <span class="token operator">=</span> socket<span class="token punctuation">.</span><span class="token function">getOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// （3）把字节流改装成自己需要的流进行数据的发送</span>        <span class="token class-name">PrintStream</span> ps <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PrintStream</span><span class="token punctuation">(</span>os<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// （4）开始发送消息</span>        <span class="token class-name">Scanner</span> sc <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"请说:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">String</span> msg <span class="token operator">=</span> sc<span class="token punctuation">.</span><span class="token function">nextLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            ps<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>            ps<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="服务端案例代码如下"><a href="#服务端案例代码如下" class="headerlink" title="服务端案例代码如下"></a>服务端案例代码如下</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**    服务端 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ServerDemo</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"==服务器的启动=="</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// （1）注册端口</span>        <span class="token class-name">ServerSocket</span> serverSocket <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ServerSocket</span><span class="token punctuation">(</span><span class="token number">7777</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token comment">//（2）开始在这里暂停等待接收客户端的连接,得到一个端到端的Socket管道</span>            <span class="token class-name">Socket</span> socket <span class="token operator">=</span> serverSocket<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">new</span> <span class="token class-name">ServerReadThread</span><span class="token punctuation">(</span>socket<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>socket<span class="token punctuation">.</span><span class="token function">getRemoteSocketAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"上线了！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">ServerReadThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span><span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">Socket</span> socket<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">ServerReadThread</span><span class="token punctuation">(</span><span class="token class-name">Socket</span> socket<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>socket <span class="token operator">=</span> socket<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">try</span><span class="token punctuation">&#123;</span>            <span class="token comment">//（3）从Socket管道中得到一个字节输入流。</span>            <span class="token class-name">InputStream</span> is <span class="token operator">=</span> socket<span class="token punctuation">.</span><span class="token function">getInputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//（4）把字节输入流包装成自己需要的流进行数据的读取。</span>            <span class="token class-name">BufferedReader</span> br <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span>is<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//（5）读取数据</span>            <span class="token class-name">String</span> line <span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>line <span class="token operator">=</span> br<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"服务端收到："</span><span class="token operator">+</span>socket<span class="token punctuation">.</span><span class="token function">getRemoteSocketAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">":"</span><span class="token operator">+</span>line<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>socket<span class="token punctuation">.</span><span class="token function">getRemoteSocketAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"下线了！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><ul><li>1.每个Socket接收到，都会创建一个线程，线程的竞争、切换上下文影响性能；</li><li>2.每个线程都会占用栈空间和CPU资源；</li><li>3.并不是每个socket都进行IO操作，无意义的线程处理；</li><li>4.客户端的并发访问增加时。服务端将呈现1:1的线程开销，访问量越大，系统将发生线程栈溢出，线程创建失败，最终导致进程宕机或者僵死，从而不能对外提供服务。</li></ul><h2 id="3-6-伪异步I-O编程"><a href="#3-6-伪异步I-O编程" class="headerlink" title="3.6 伪异步I/O编程"></a>3.6 伪异步I/O编程</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>在上述案例中：客户端的并发访问增加时。服务端将呈现1:1的线程开销，访问量越大，系统将发生线程栈溢出，线程创建失败，最终导致进程宕机或者僵死，从而不能对外提供服务。</p><p>接下来我们采用一个伪异步I/O的通信框架，采用<strong>线程池</strong>和<strong>任务队列</strong>实现，当客户端接入时，将客户端的Socket封装成一个Task(该任务实现java.lang.Runnable线程任务接口)交给后端的线程池中进行处理。JDK的线程池维护一个消息队列和N个活跃的线程，对消息队列中Socket任务进行处理，由于线程池可以设置消息队列的大小和最大线程数，因此，它的资源占用是可控的，无论多少个客户端并发访问，都不会导致资源的耗尽和宕机。</p><p>图示如下:</p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220202153828332.png" alt="image-20220202153828332" style="zoom:80%;"><h3 id="客户端源码分析"><a href="#客户端源码分析" class="headerlink" title="客户端源码分析"></a>客户端源码分析</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">&#123;</span>   <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>         <span class="token comment">// 1.简历一个与服务端的Socket对象：套接字</span>         <span class="token class-name">Socket</span> socket <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Socket</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1"</span><span class="token punctuation">,</span> <span class="token number">9999</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// 2.从socket管道中获取一个输出流，写数据给服务端 </span>         <span class="token class-name">OutputStream</span> os <span class="token operator">=</span> socket<span class="token punctuation">.</span><span class="token function">getOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>         <span class="token comment">// 3.把输出流包装成一个打印流 </span>         <span class="token class-name">PrintWriter</span> pw <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PrintWriter</span><span class="token punctuation">(</span>os<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// 4.反复接收用户的输入 </span>         <span class="token class-name">BufferedReader</span> br <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token class-name">String</span> line <span class="token operator">=</span> <span class="token keyword">null</span> <span class="token punctuation">;</span>         <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>line <span class="token operator">=</span> br<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            pw<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span><span class="token punctuation">;</span>            pw<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">&#125;</span>      <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>         e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>   <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="线程池处理类"><a href="#线程池处理类" class="headerlink" title="线程池处理类"></a>线程池处理类</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 线程池处理类</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HandlerSocketThreadPool</span> <span class="token punctuation">&#123;</span>      <span class="token comment">// 线程池 </span>   <span class="token keyword">private</span> <span class="token class-name">ExecutorService</span> executor<span class="token punctuation">;</span>      <span class="token keyword">public</span> <span class="token class-name">HandlerSocketThreadPool</span><span class="token punctuation">(</span><span class="token keyword">int</span> maxPoolSize<span class="token punctuation">,</span> <span class="token keyword">int</span> queueSize<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>executor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span>            <span class="token number">3</span><span class="token punctuation">,</span> <span class="token comment">// 8</span>            maxPoolSize<span class="token punctuation">,</span>              <span class="token number">120L</span><span class="token punctuation">,</span>             <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">,</span>            <span class="token keyword">new</span> <span class="token class-name">ArrayBlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>queueSize<span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span>      <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> task<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>executor<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="服务端源码分析"><a href="#服务端源码分析" class="headerlink" title="服务端源码分析"></a>服务端源码分析</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**目标：开发实现伪异步通信架构/public class Server &#123;   public static void main(String[] args) &#123;      try &#123;         System.out.println("----------服务端启动成功------------");         ServerSocket ss = new ServerSocket(9999);         // 一个服务端只需要对应一个线程池         HandlerSocketThreadPool handlerSocketThreadPool =               new HandlerSocketThreadPool(3, 1000);         // 客户端可能有很多个         while(true)&#123;            Socket socket = ss.accept() ; // 阻塞式的！            System.out.println("有人上线了！！");            // 每次收到一个客户端的socket请求，都需要为这个客户端分配一个            // 独立的线程 专门负责对这个客户端的通信！！            handlerSocketThreadPool.execute(new ReaderClientRunnable(socket));         &#125;      &#125; catch (Exception e) &#123;         e.printStackTrace();      &#125;   &#125;&#125;class ReaderClientRunnable implements Runnable&#123;   private Socket socket ;   public ReaderClientRunnable(Socket socket) &#123;      this.socket = socket;   &#125;   @Override   public void run() &#123;      try &#123;         // 读取一行数据         InputStream is = socket.getInputStream() ;         // 转成一个缓冲字符流         Reader fr = new InputStreamReader(is);         BufferedReader br = new BufferedReader(fr);         // 一行一行的读取数据         String line = null ;         while((line = br.readLine())!=null)&#123; // 阻塞式的！！            System.out.println("服务端收到了数据："+line);         &#125;      &#125; catch (Exception e) &#123;         System.out.println("有人下线了");      &#125;   &#125;&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><ul><li>伪异步io采用了线程池实现，因此避免了为每个请求创建一个独立线程造成线程资源耗尽的问题，但由于底层依然是采用的同步阻塞模型，因此无法从根本上解决问题。</li><li>如果单个消息处理的缓慢，或者服务器线程池中的全部线程都被阻塞，那么后续socket的i/o消息都将在队列中排队。新的Socket请求将被拒绝，客户端会发生大量连接超时。</li></ul><h2 id="3-7-基于BIO形式下的文件上传"><a href="#3-7-基于BIO形式下的文件上传" class="headerlink" title="3.7 基于BIO形式下的文件上传"></a>3.7 基于BIO形式下的文件上传</h2><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>支持任意类型文件形式的上传。</p><h3 id="客户端开发"><a href="#客户端开发" class="headerlink" title="客户端开发"></a>客户端开发</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>itheima<span class="token punctuation">.</span>file</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">DataOutputStream</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">FileInputStream</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">InputStream</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>net<span class="token punctuation">.</span></span><span class="token class-name">Socket</span><span class="token punctuation">;</span><span class="token comment">/**    目标：实现客户端上传任意类型的文件数据给服务端保存起来。 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">try</span><span class="token punctuation">(</span>                <span class="token class-name">InputStream</span> is <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">"C:\\Users\\dlei\\Desktop\\BIO,NIO,AIO\\文件\\java.png"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token comment">//  1、请求与服务端的Socket链接</span>            <span class="token class-name">Socket</span> socket <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Socket</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1"</span> <span class="token punctuation">,</span> <span class="token number">8888</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//  2、把字节输出流包装成一个数据输出流</span>            <span class="token class-name">DataOutputStream</span> dos <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DataOutputStream</span><span class="token punctuation">(</span>socket<span class="token punctuation">.</span><span class="token function">getOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//  3、先发送上传文件的后缀给服务端</span>            dos<span class="token punctuation">.</span><span class="token function">writeUTF</span><span class="token punctuation">(</span><span class="token string">".png"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//  4、把文件数据发送给服务端进行接收</span>            <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> buffer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> len<span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>len <span class="token operator">=</span> is<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                dos<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>buffer <span class="token punctuation">,</span> <span class="token number">0</span> <span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            dos<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">10000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="服务端开发"><a href="#服务端开发" class="headerlink" title="服务端开发"></a>服务端开发</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>itheima<span class="token punctuation">.</span>file</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>net<span class="token punctuation">.</span></span><span class="token class-name">ServerSocket</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>net<span class="token punctuation">.</span></span><span class="token class-name">Socket</span><span class="token punctuation">;</span><span class="token comment">/**    目标：服务端开发，可以实现接收客户端的任意类型文件，并保存到服务端磁盘。 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Server</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">try</span><span class="token punctuation">&#123;</span>            <span class="token class-name">ServerSocket</span> ss <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ServerSocket</span><span class="token punctuation">(</span><span class="token number">8888</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token class-name">Socket</span> socket <span class="token operator">=</span> ss<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 交给一个独立的线程来处理与这个客户端的文件通信需求。</span>                <span class="token keyword">new</span> <span class="token class-name">ServerReaderThread</span><span class="token punctuation">(</span>socket<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>itheima<span class="token punctuation">.</span>file</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">DataInputStream</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">FileOutputStream</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">OutputStream</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>net<span class="token punctuation">.</span></span><span class="token class-name">Socket</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span>UUID<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ServerReaderThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">Socket</span> socket<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">ServerReaderThread</span><span class="token punctuation">(</span><span class="token class-name">Socket</span> socket<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>socket <span class="token operator">=</span> socket<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">try</span><span class="token punctuation">&#123;</span>            <span class="token comment">// 1、得到一个数据输入流读取客户端发送过来的数据</span>            <span class="token class-name">DataInputStream</span> dis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DataInputStream</span><span class="token punctuation">(</span>socket<span class="token punctuation">.</span><span class="token function">getInputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 2、读取客户端发送过来的文件类型</span>            <span class="token class-name">String</span> suffix <span class="token operator">=</span> dis<span class="token punctuation">.</span><span class="token function">readUTF</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"服务端已经成功接收到了文件类型："</span> <span class="token operator">+</span> suffix<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 3、定义一个字节输出管道负责把客户端发来的文件数据写出去</span>            <span class="token class-name">OutputStream</span> os <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span><span class="token string">"C:\\Users\\dlei\\Desktop\\BIO,NIO,AIO\\文件\\server\\"</span><span class="token operator">+</span>                    UUID<span class="token punctuation">.</span><span class="token function">randomUUID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span>suffix<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 4、从数据输入流中读取文件数据，写出到字节输出流中去</span>            <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> buffer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> len<span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>len <span class="token operator">=</span> dis<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                os<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            os<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"服务端接收文件保存成功！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h3><p>客户端怎么发，服务端就怎么接收</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaGuide</title>
      <link href="/2022/01/31/JavaGuide/"/>
      <url>/2022/01/31/JavaGuide/</url>
      
        <content type="html"><![CDATA[<h1 id="JavaGuide（Java学习-amp-amp-面试指南）"><a href="#JavaGuide（Java学习-amp-amp-面试指南）" class="headerlink" title="JavaGuide（Java学习&amp;&amp;面试指南）"></a>JavaGuide（Java学习&amp;&amp;面试指南）</h1><p>除夕之夜，却无烟花爆竹之声。春晚如约而至，却感索然无味。无聊至极，不如整理资料，不至过于空虚，也增些许充实之感。</p><p>Markdown格式更加方便，所以在学习的过程中，将已有Java相关资料整理为md格式，供日后秋招使用。</p><p>声明：此文绝大部分内容为转载 Guide 哥的原创项目  <a href="https://javaguide.cn/">JavaGuide</a>，另外自己 <a href="https://ykangli.top/">ykangli </a>会另外添加一部分相关内容加深理解和掌握，转载请注明出处。</p><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><h3 id="Java基础知识-amp-面试题总结"><a href="#Java基础知识-amp-面试题总结" class="headerlink" title="Java基础知识&amp;面试题总结"></a>Java基础知识&amp;面试题总结</h3><h4 id="Java-语言有哪些特点"><a href="#Java-语言有哪些特点" class="headerlink" title="Java 语言有哪些特点?"></a>Java 语言有哪些特点?</h4><ol><li>简单易学；</li><li><strong>面向对象（封装，继承，多态）</strong>；</li><li>平台无关性（ Java 虚拟机实现平台无关性）====&gt; <strong>跨平台</strong>；</li><li>支持<strong>多线程</strong>（ C++ 语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而 Java 语言却提供了多线程支持）；</li><li>可靠性；</li><li>安全性；</li><li><strong>支持网络编程</strong>并且很方便（ Java 语言诞生本身就是为简化网络编程设计的，因此 Java 语言不仅支持网络编程而且很方便）；</li><li>编译与解释并存；</li></ol><p><strong>修正（参见： <a href="https://github.com/Snailclimb/JavaGuide/issues/544">issue#544  (opens new window)</a>）</strong> ：C++11 开始（2011 年的时候）,C++就引入了多线程库，在 windows、linux、macos 都可以使用<code>std::thread</code>和<code>std::async</code>来创建线程。</p><h4 id="JVM-vs-JDK-vs-JRE"><a href="#JVM-vs-JDK-vs-JRE" class="headerlink" title="JVM vs JDK vs JRE"></a>JVM vs JDK vs JRE</h4><ul><li><strong>JVM</strong></li></ul><p>Java 虚拟机（JVM）是运行 <strong>Java 字节码</strong>的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），<strong>目的是使用相同的字节码，它们都会给出相同的结果</strong>。字节码和不同系统的 JVM 实现是 Java 语言“一次编译，随处可以运行”的关键所在 (也就是我们常说的<strong>Java的跨平台性</strong>)。</p><p><strong>JVM 并不是只有一种！只要满足 JVM 规范，每个公司、组织或者个人都可以开发自己的专属 JVM。</strong> 也就是说我们平时接触到的 HotSpot VM 仅仅是是 JVM 规范的一种实现而已。</p><p>除了我们平时最常用的 HotSpot VM 外，还有 J9 VM、Zing VM、JRockit VM 等 JVM 。维基百科上就有常见 JVM 的对比：<a href="https://en.wikipedia.org/wiki/Comparison_of_Java_virtual_machines">Comparison of Java virtual machines  (opens new window)</a> ，感兴趣的可以去看看。并且，你可以在 <a href="https://docs.oracle.com/javase/specs/index.html">Java SE Specifications  (opens new window)</a> 上找到各个版本的 JDK 对应的 JVM 规范。</p><ul><li><strong>JDK 和 JRE</strong></li></ul><p>JDK 是 Java Development Kit 缩写，它是功能齐全的 Java SDK。它拥有 JRE 所拥有的一切，还有编译器（javac）和工具（如 javadoc 和 jdb）。它<strong>能够创建和编译程序</strong>。</p><p><strong>JRE 是 Java 运行时环境</strong>。它是<strong>运行已编译 Java 程序所需的所有内容的集合</strong>，包括 Java 虚拟机（JVM），Java 类库，java 命令和其他的一些基础构件。但是，它<strong>不能用于创建新程序</strong>。</p><p>如果你只是为了运行一下 Java 程序的话，那么你只需要安装 JRE 就可以了。如果你需要进行一些 Java 编程方面的工作，那么你就需要安装 JDK 了。但是，这不是绝对的。有时，即使您不打算在计算机上进行任何 Java 开发，仍然需要安装 JDK。例如，如果要使用 JSP 部署 Web 应用程序，那么从技术上讲，您只是在应用程序服务器中运行 Java 程序。那你为什么需要 JDK 呢？因为应用程序服务器会将 JSP 转换为 Java servlet，并且需要使用 JDK 来编译 servlet。</p><h4 id="什么是字节码-采用字节码的好处是什么"><a href="#什么是字节码-采用字节码的好处是什么" class="headerlink" title="什么是字节码?采用字节码的好处是什么?"></a>什么是字节码?采用字节码的好处是什么?</h4><p>在 Java 中，<strong>JVM 可以理解的代码就叫做字节码</strong>（即扩展名为 <code>.class</code> 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以， Java 程序运行时相对来说还是高效的（不过，和 C++，Rust，Go 等语言还是有一定差距的），而且，由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。</p><p><strong>Java 程序从源代码到运行的过程如下图所示：</strong></p><p><img src="https://javaguide.cn/assets/img/java%E7%A8%8B%E5%BA%8F%E8%BD%AC%E5%8F%98%E4%B8%BA%E6%9C%BA%E5%99%A8%E4%BB%A3%E7%A0%81%E7%9A%84%E8%BF%87%E7%A8%8B.28d2ecb1.png" alt="Java程序转变为机器代码的过程"></p><h3 id="重要知识点"><a href="#重要知识点" class="headerlink" title="重要知识点"></a>重要知识点</h3><h4 id="IO模型详解"><a href="#IO模型详解" class="headerlink" title="IO模型详解"></a>IO模型详解</h4>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>1-手写数据库之Transaction Manager(事务管理器)</title>
      <link href="/2022/01/27/1-Transaction-Manager/"/>
      <url>/2022/01/27/1-Transaction-Manager/</url>
      
        <content type="html"><![CDATA[<h1 id="1-手写数据库之Transaction-Manager-事务管理器"><a href="#1-手写数据库之Transaction-Manager-事务管理器" class="headerlink" title="1-手写数据库之Transaction Manager(事务管理器)"></a>1-手写数据库之Transaction Manager(事务管理器)</h1><p>TM对事务进行管理, 能够让其他模块查询事务的状态。</p><p><strong>数据库模型如下图：</strong></p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220127112245276.png" alt="image-20220127112245276"></p><p>TM是怎么样标识各个事务的呢? TM会为每个事务, 分配一个特定的XID, 作为其标识. 且这个XID是递增的, 后开始的事务XID要大于先开始的事务。<strong>Transaction Manager（TM） 通过维护 XID 文件来维护事务的状态</strong>，并提供接口供其他模块来查询某个事务的状态。</p><h2 id="XID文件"><a href="#XID文件" class="headerlink" title="XID文件"></a>XID文件</h2><p>在KangDB 中，每一个事务都有一个 <strong>XID</strong>，这个 ID <strong>唯一标识</strong>了这个事务。事务的 XID 从 <strong>1</strong> 开始标号，并自增，不可重复。并特殊规定 <strong>XID 0 是一个超级事务（Super Transaction）</strong>。因此如果上级模块想在不申请事务的情况下, 对数据库做一些修改, 则它可以将XID设置为0。<strong>XID 为 0 的事务的状态永远是 committed</strong>。 </p><p><strong>Transaction Manager 维护了一个 XID 格式的文件，用来记录各个事务的状态</strong>。KangDB 中，每个事务都有下面的三种状态：</p><ul><li><p><strong>active</strong>    事务正在进行，尚未结束</p></li><li><p><strong>committed</strong>    事务已提交 </p></li><li><p><strong>aborted</strong>    事务回滚，进入中止状态</p><p><strong>关于事务状态的具体内容详见 《数据库系统概念-第六版》P634</strong></p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220114115758371.png" alt="事务的状态"></li></ul><p>XID 文件给每个事务分配了 <strong>1</strong> 个字节的空间，用来<strong>保存其状态</strong>。同时，在 XID 文件的头部，还保存了一个 <strong>8</strong> 字节的数字 (<strong>用 long 类型来记录，Java中 long 类型占8个字节</strong> )，记录了这个 XID 文件管理的事务的个数。于是，事务 xid 在文件中的状态就存储在 (xid-1)+8 字节处，xid-1 是因为 xid 0（Super XID） 的状态不需要记录。</p><h3 id="TransactionManager-接口"><a href="#TransactionManager-接口" class="headerlink" title="TransactionManager 接口"></a>TransactionManager 接口</h3><p>TransactionManager 提供了一些接口供其他模块调用，用来创建事务和查询事务状态。具体如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">kangdb<span class="token punctuation">.</span>backend<span class="token punctuation">.</span>tm</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">kangdb<span class="token punctuation">.</span>backend<span class="token punctuation">.</span>utils<span class="token punctuation">.</span></span><span class="token class-name">Panic</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">kangdb<span class="token punctuation">.</span>common<span class="token punctuation">.</span></span><span class="token class-name">Error</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">File</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">FileNotFoundException</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">IOException</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">RandomAccessFile</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>nio<span class="token punctuation">.</span></span><span class="token class-name">ByteBuffer</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>nio<span class="token punctuation">.</span>channels<span class="token punctuation">.</span></span><span class="token class-name">FileChannel</span><span class="token punctuation">;</span><span class="token comment">/** * @author ykangli * @version 1.0 * @date 2022/1/27 20:04 * TransactionManager 对事务进行管理, 能够让其他模块查询事务的状态。 */</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">TransactionManager</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/**     * 开始一个事务，并返回XID     * @return xid  (每一个事务都有一个 XID，这个 ID 唯一标识了这个事务)     */</span>    <span class="token keyword">long</span> <span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/**     * 提交xid事务     * @param xid 事务的xid     */</span>    <span class="token keyword">void</span> <span class="token function">commit</span><span class="token punctuation">(</span><span class="token keyword">long</span> xid<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/**     * 回滚xid事务     * @param xid 事务的xid     */</span>    <span class="token keyword">void</span> <span class="token function">abort</span><span class="token punctuation">(</span><span class="token keyword">long</span> xid<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/**     * 查询一个事务的状态是否是正在进行的状态     * @param xid 事务的xid     * @return java.lang.boolean     */</span>    <span class="token keyword">boolean</span> <span class="token function">isActive</span><span class="token punctuation">(</span><span class="token keyword">long</span> xid<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/**     *  查询一个事务的状态是否是已提交     * @param xid 事务的xid     * @return java.lang.boolean     */</span>    <span class="token keyword">boolean</span> <span class="token function">isCommitted</span><span class="token punctuation">(</span><span class="token keyword">long</span> xid<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/**     * 查询一个事务的状态是否是已取消     * @param xid 事务的xid     * @return java.lang.boolean     */</span>    <span class="token keyword">boolean</span> <span class="token function">isAborted</span><span class="token punctuation">(</span><span class="token keyword">long</span> xid<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/**     * 关闭TM     */</span>    <span class="token keyword">void</span> <span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/**     * 创建一个 xid 文件并创建 Transaction Manager(TM)     * @param path xid文件路径     * @return TransactionManagerImpl对象     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">TransactionManagerImpl</span> <span class="token function">create</span><span class="token punctuation">(</span><span class="token class-name">String</span> path<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">File</span> file <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span>path <span class="token operator">+</span> <span class="token class-name">TransactionManagerImpl</span><span class="token punctuation">.</span>XID_SUFFIX<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token comment">//创建文件失败</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>file<span class="token punctuation">.</span><span class="token function">createNewFile</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token class-name">Panic</span><span class="token punctuation">.</span><span class="token function">panic</span><span class="token punctuation">(</span><span class="token class-name">Error<span class="token punctuation">.</span>FileExistsException</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">Panic</span><span class="token punctuation">.</span><span class="token function">panic</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">//该函数确定程序是否可以读取或写入由抽象路径名表示的文件。</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>file<span class="token punctuation">.</span><span class="token function">canRead</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token operator">!</span>file<span class="token punctuation">.</span><span class="token function">canWrite</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">Panic</span><span class="token punctuation">.</span><span class="token function">panic</span><span class="token punctuation">(</span><span class="token class-name">Error<span class="token punctuation">.</span>FileCannotRWException</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token class-name">FileChannel</span> fc <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token class-name">RandomAccessFile</span> raf <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            raf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RandomAccessFile</span><span class="token punctuation">(</span>file<span class="token punctuation">,</span> <span class="token string">"rw"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            fc <span class="token operator">=</span> raf<span class="token punctuation">.</span><span class="token function">getChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">FileNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">Panic</span><span class="token punctuation">.</span><span class="token function">panic</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">//写只有前8字节Header的空文件，即设置 xidCounter 为 0</span>        <span class="token class-name">ByteBuffer</span> buffer <span class="token operator">=</span> <span class="token class-name">ByteBuffer</span><span class="token punctuation">.</span><span class="token function">wrap</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token class-name">TransactionManagerImpl</span><span class="token punctuation">.</span>LEN_XID_HEADER_LENGTH<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            fc<span class="token punctuation">.</span><span class="token function">position</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            fc<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">Panic</span><span class="token punctuation">.</span><span class="token function">panic</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">TransactionManagerImpl</span><span class="token punctuation">(</span>raf<span class="token punctuation">,</span> fc<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>public static TransactionManagerImpl create(String path)</strong></li></ul><p>创建<code>xxx.xid</code> 文件，并创建 TM，设置xidCounter 为0。</p><ul><li><strong>public static TransactionManagerImpl open(String path)</strong></li></ul><p>从一个已有的 xid 文件来创建 TM。</p><h3 id="TransactionManagerImpl实现类"><a href="#TransactionManagerImpl实现类" class="headerlink" title="TransactionManagerImpl实现类"></a>TransactionManagerImpl实现类</h3><ul><li><strong><a href="http://c.biancheng.net/view/1137.html">Java RandomAccessFile类</a>：动态读取文件内容</strong></li></ul><p>所谓动态读取是指从文件的<strong>任意位置开始访问文件</strong>，而不是必须从文件开始位置读取到文件末尾。动态读取需要用到 Java 中的 RandomAccessFile 类。</p><p>RandomAccessFile 是 Java 输入/输出流体系中功能最丰富的文件内容访问类，它提供了众多的方法来访问文件内容，它既可以读取文件内容，也可以向文件输出数据。由于 <strong>RandomAccessFile 可以从任意位置访问文件</strong>，所以在只需要访问文件部分内容的情况下，使用 RandonAccessFile 类是一个很好的选择。</p><p>RandomAccessFile 对象包含了一个记录指针，用以标识当前读写处的位置，当程序新创建一个 RandomAccessFile 对象时，该对象的文件记录指针位于文件头（也就是 0 处），<strong>当读/写了 n 个字节后，文件记录指针将会向后移动 n 个字节</strong>。除此之外，RandonAccessFile <strong>可以自由移动该记录指针</strong>，既可以向前移动，也可以向后移动。</p><pre class="line-numbers language-none"><code class="language-none">java.io.RandomAccessFile.length()方法 返回当前文件的长度，以字节为单位<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><strong>NIO</strong></li></ul><p>文件读写都采用了 NIO 方式的 FileChannel</p><ul><li><strong>private void checkXIDCounter()</strong></li></ul><p>在构造函数创建了一个 TransactionManager 之后，首先要对 XID 文件进行校验，以保证这是一个合法的 XID 文件。校验的方式也很简单，通过文件头的 8 字节数字**(long 类型) **反推文件的理论长度，与文件的实际长度做对比。如果不同则认为 XID 文件不合法。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**     * 检查XID文件是否合法     * 读取XID_FILE_HEADER中的xidcounter，根据它计算文件的理论长度，对比实际长度     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">checkXIDCounter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">long</span> fileLen <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token comment">//文件的实际长度</span>            fileLen <span class="token operator">=</span> file<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e1<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">Panic</span><span class="token punctuation">.</span><span class="token function">panic</span><span class="token punctuation">(</span><span class="token class-name">Error<span class="token punctuation">.</span>BadXIDFileException</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>fileLen <span class="token operator">&lt;</span> LEN_XID_HEADER_LENGTH<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">Panic</span><span class="token punctuation">.</span><span class="token function">panic</span><span class="token punctuation">(</span><span class="token class-name">Error<span class="token punctuation">.</span>BadXIDFileException</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">//从堆空间中分配一个容量大小为 LEN_XID_HEADER_LENGTH 的byte数组作为缓冲区的byte数据存储器</span>        <span class="token class-name">ByteBuffer</span> buf <span class="token operator">=</span> <span class="token class-name">ByteBuffer</span><span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span>LEN_XID_HEADER_LENGTH<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            fc<span class="token punctuation">.</span><span class="token function">position</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            fc<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">Panic</span><span class="token punctuation">.</span><span class="token function">panic</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">//初始时 xidCounter应该为0，刚开始没有事务开启</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>xidCounter <span class="token operator">=</span> <span class="token class-name">Parser</span><span class="token punctuation">.</span><span class="token function">parseLong</span><span class="token punctuation">(</span>buf<span class="token punctuation">.</span><span class="token function">array</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//理论上文件的长度</span>        <span class="token keyword">long</span> end <span class="token operator">=</span> <span class="token function">getXidPosition</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>xidCounter <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>end <span class="token operator">!=</span> fileLen<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">Panic</span><span class="token punctuation">.</span><span class="token function">panic</span><span class="token punctuation">(</span><span class="token class-name">Error<span class="token punctuation">.</span>BadXIDFileException</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>初始时，该 <code>xxx.xid</code> 文件的长度就为 <strong>8</strong>个字节，记录的xidCounter = 0。 当开启事务时，<code>xxx.xid</code> 文件的前八个字节就会变化，相应的xidCounter 也就会变化。</p><p>对于校验没有通过的，会直接通过 panic 方法，强制停机。在一些基础模块中出现错误都会如此处理，无法恢复的错误只能直接停机。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">kangdb<span class="token punctuation">.</span>backend<span class="token punctuation">.</span>utils</span><span class="token punctuation">;</span><span class="token comment">/** * @author ykangli * @version 1.0 * @date 2022/1/27 21:30 * 通过 panic 方法，强制停机。（终止当前正在运行的Java虚拟机） */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Panic</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">panic</span><span class="token punctuation">(</span><span class="token class-name">Exception</span> err<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        err<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// status 为 0：表示正常退出程序，也就是结束当前正在运行中的java虚拟机。</span>        <span class="token comment">// status 为 1 或 -1 或 任何其他非零值 ：表示非正常退出当前程序。</span>        <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>l<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>private long getXidPosition(long xid)</strong></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * 根据事务xid取得其在xid文件中对应的位置 */</span><span class="token keyword">private</span> <span class="token keyword">long</span> <span class="token function">getXidPosition</span><span class="token punctuation">(</span><span class="token keyword">long</span> xid<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> LEN_XID_HEADER_LENGTH <span class="token operator">+</span> <span class="token punctuation">(</span>xid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> XID_FIELD_SIZE<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>事务 xid 在文件中的状态就存储在 (xid-1)+8 字节处，xid-1 是因为 xid 0（Super XID） 的状态不需要记录。</p><ul><li><strong>private void updateXID(long xid, byte status)</strong></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * 更新xid事务的状态为status */</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">updateXID</span><span class="token punctuation">(</span><span class="token keyword">long</span> xid<span class="token punctuation">,</span> <span class="token keyword">byte</span> status<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">long</span> offset <span class="token operator">=</span> <span class="token function">getXidPosition</span><span class="token punctuation">(</span>xid<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bytes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span>XID_FIELD_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>    bytes<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> status<span class="token punctuation">;</span>    <span class="token class-name">ByteBuffer</span> buffer <span class="token operator">=</span> <span class="token class-name">ByteBuffer</span><span class="token punctuation">.</span><span class="token function">wrap</span><span class="token punctuation">(</span>bytes<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>        fc<span class="token punctuation">.</span><span class="token function">position</span><span class="token punctuation">(</span>offset<span class="token punctuation">)</span><span class="token punctuation">;</span>        fc<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Panic</span><span class="token punctuation">.</span><span class="token function">panic</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//nio中方法，强制同步缓存内容到文件中</span>        fc<span class="token punctuation">.</span><span class="token function">force</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Panic</span><span class="token punctuation">.</span><span class="token function">panic</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>所有文件操作，在执行后都<strong>需要立刻刷入文件中</strong>，防止在崩溃后文件丢失数据，<strong>fileChannel</strong> 的<code>force()</code>方法，强制同步缓存内容到文件中，类似于 BIO 中的 flush() 方法。force 方法的参数是一个布尔，表示是否同步文件的元数据（例如最后修改时间等）。</p><ul><li><strong>public long begin()</strong></li></ul><p><code>begin()</code> 方法会开始一个事务，更具体的，首先设置 xidCounter+1 事务的状态为 committed，随后 xidCounter 自增，并更新文件头。</p><p>最后利用 <code>TransactionManagerImpl</code> 来实现两个方法<code>public static TransactionManagerImpl create(String path)</code> 和 <code>public static TransactionManagerImpl open(String path)</code>，分别表示创建一个 xid 文件并创建 TM 和从一个已有的 xid 文件来创建 TM。</p><p>为了方便管理和使用，没有将这两个方法写在实现类 <code>TransactionManagerImpl</code> 里面，而是将其写在接口<code>TransactionManager</code>里，也就是<strong>静态方法</strong>，详见 <code>TransactionManagerImpl</code> 中的代码。</p>]]></content>
      
      
      <categories>
          
          <category> project </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>0-用Java手写一个数据库的准备工作</title>
      <link href="/2022/01/27/0-%E7%94%A8Java%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/"/>
      <url>/2022/01/27/0-%E7%94%A8Java%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>​        作为非科班转码小菜鸡，一直感觉计算机的专业知识是自己的短板，而且只看视频学习很难真正理解和掌握相关指点，始终有一种好像懂了，又好像没懂的感觉，况且自己是那种不实践就不能深刻理解知识点的人，那么【造轮子】对自己来说好像是一个不错的方法了吧……著名带逛大师 <strong>轮子哥（vczh）</strong>将绝大部分时间都花在了「轮子」上，为了学习轮子哥的<del>带逛本领</del>编程能力，利用寒假时间从0 开始手写一个简单的数据库。恰好最近某天无聊逛牛客时，看到有大佬 [<a href="https://www.nowcoder.com/discuss/825665?source_id=profile_create_nctrack&channel=-1">何人听我楚狂声 MYDB——一个简易的数据库实现完整教程</a>使用Java手写了数据库，有源码+文档，那还说啥，赶紧利用寒假在家的时间撸起来！！！</p><p>​        就叫它 <strong>KangDB</strong> 吧~</p><h2 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h2><p>​        KangDB分为后端和前端，前后端通过 socket 进行交互。</p><h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><p>​        前端（客户端）就是读取用户输入，并发送到后端执行，输出返回结果，并等待下一次输入。</p><h3 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h3><p>​        KangDB后端则需要解析 SQL，如果是合法的 SQL，就尝试执行并返回结果。不包括解析器，KangDB的后端划分为<strong>五个模块</strong>，每个模块都又一定的职责，通过接口向其依赖的模块提供方法。五个模块如下所示：</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220127112245276.png" alt="image-20220127112245276"></p><p>每个模块的职责如下：</p><ul><li><p> TM 通过维护 XID 文件来维护事务的状态，并提供接口供其他模块来查询某个事务的状态。 </p></li><li><p>DM 直接管理数据库 DB 文件和日志文件。</p><p>DM 的主要职责有：</p><ol><li>分页管理 DB 文件，并进行缓存；</li></ol><ol start="2"><li>管理日志文件，保证在发生错误时可以根据日志进行恢复；</li><li>抽象 DB 文件为 DataItem 供上层模块使用，并提供缓存。 </li></ol></li><li><p>VM 基于<strong>两段锁协议</strong>实现了调度序列的可串行化，并实现了 <strong>MVCC</strong> 以消除读写阻塞，同时实现了两种隔离级别（<strong>READ COMMITTED</strong> 和 <strong>REPEATABLE READ</strong> ）。</p></li><li><p> IM 实现了基于 B+ 树的索引，目前 where 只支持已索引字段。 </p></li><li><p>TBM 实现了对字段和表的管理。同时，解析 SQL 语句，并根据语句操作表。</p></li></ul><h2 id="开发环境和运行环境"><a href="#开发环境和运行环境" class="headerlink" title="开发环境和运行环境"></a>开发环境和运行环境</h2><p>​        项目开发时使用的 <strong>WSL2</strong> 和 <strong>JDK17</strong>，如果要在 Windows 上执行，请替换启动参数中的路径为 Windows，<strong>JDK 版本要保证在 11 或以上，不兼容 JDK 8</strong>。</p><h3 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h3><p>​        一般电脑都安装有JDK 8，关于如何在电脑中已有 JDK 8 的基础上再安装其他版本的 JDK ，并且能随意切换，详细教程见 <a href="https://ykangli.top/2022/01/26/JDK-Configuration/">电脑已有jdk 8，再配置一个jdk 17</a></p><h3 id="WSL"><a href="#WSL" class="headerlink" title="WSL"></a>WSL</h3><p>​        <strong>WSL</strong> 全称 <strong>Windows Subsystem for Linux</strong>，官方翻译“<strong>适用于Linux的Windows子系统</strong>”。以下是微软官方对WSL的描述:</p><p>您可以：</p><ul><li><a href="https://aka.ms/wslstore">在 Microsoft Store</a> 中选择你偏好的 GNU/Linux 分发版。</li><li>运行常用的命令行软件工具（例如 <code>grep</code>、<code>sed</code>、<code>awk</code>）或其他 ELF-64 二进制文件。</li><li>运行 Bash shell 脚本和 GNU/Linux 命令行应用程序，包括：<ul><li>工具：vim、emacs、tmux</li><li>语言：<a href="https://docs.microsoft.com/zh-cn/windows/nodejs/setup-on-wsl2">NodeJS</a>、Javascript、<a href="https://docs.microsoft.com/zh-cn/windows/python/web-frameworks">Python</a>、Ruby、C/C++、C# 与 F#、Rust、Go 等</li><li>服务：SSHD、<a href="https://docs.microsoft.com/zh-cn/windows/wsl/tutorials/wsl-database">MySQL</a>、Apache、lighttpd、<a href="https://docs.microsoft.com/zh-cn/windows/wsl/tutorials/wsl-database">MongoDB</a>、<a href="https://docs.microsoft.com/zh-cn/windows/wsl/tutorials/wsl-database">PostgreSQL</a>。</li></ul></li><li>使用自己的 GNU/Linux 分发包管理器安装其他软件。</li><li>使用类似于 Unix 的命令行 shell 调用 Windows 应用程序。</li><li>在 Windows 上调用 GNU/Linux 应用程序。</li></ul><h4 id="什么是-WSL-2？"><a href="#什么是-WSL-2？" class="headerlink" title="什么是 WSL 2？"></a>什么是 WSL 2？</h4><p>​        WSL 2 是适用于 Linux 的 Windows 子系统体系结构的一个新版本，它支持适用于 Linux 的 Windows 子系统在 Windows 上运行 ELF64 Linux 二进制文件。 它的主要目标是<strong>提高文件系统性能</strong>，以及添加<strong>完全的系统调用兼容性</strong>。</p><p>​        这一新的体系结构改变了这些 Linux 二进制文件与Windows 和计算机硬件进行交互的方式，但仍然提供与 WSL 1（当前广泛可用的版本）中相同的用户体验。</p><p>​        单个 Linux 分发版可以在 WSL 1 或 WSL 2 体系结构中运行。 每个分发版可随时升级或降级，并且你可以并行运行 WSL 1 和 WSL 2 分发版。 WSL 2 使用全新的体系结构，该体系结构受益于运行真正的 Linux 内核。</p><h4 id="为什么要使用WSL-amp-WSL-2-？"><a href="#为什么要使用WSL-amp-WSL-2-？" class="headerlink" title="为什么要使用WSL&amp;WSL 2 ？"></a>为什么要使用WSL&amp;WSL 2 ？</h4><p>​        我们日常工作学习中有很多涉及与Linux系统的交互，课程中也有大量的以Linux为基础的知识和命令，如果我们日常工作与使用环境就是Linux那还好，无需切换就可无缝对接。但Windows毕竟是市场占有率最高的操作系统，有大量的人群办公\日常环境需Windows，而开发环境需要Linux。这就产生了一些<strong>在Windows环境下使用Linux的需求</strong>。面对这个需求目前有如下集中常用解决方案：</p><table><thead><tr><th>方案</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>单主机安装双系统</td><td>真正的操作系统</td><td>切换麻烦需要重启</td></tr><tr><td>双主机安装双系统</td><td>物理隔离</td><td>成本高需要两台PC</td></tr><tr><td>远程服务器</td><td>真实的操作系统</td><td>性能、带宽等局限</td></tr><tr><td>虚拟机安装Linux</td><td>完整的使用体验</td><td>资源消耗大、启动慢、运行效率低</td></tr><tr><td>WSL</td><td>资源消耗小、启动快、无缝衔接</td><td>使用体验可能不完整，某些Linux软件不支持</td></tr></tbody></table><p>WSL方案是微软近两年拥抱开源后推出的一个非常棒的解决方案；使用WSL，Windows与Linux子系统将共用同一文件系统，Windows创建的文件Linux子系统也可以访问并修改，反之亦然。我们可以在WSL中使用三剑客命令查询分析windows文档、日志、使用shell命令或者bash脚本运行存储在windows中的linux程序、甚至在WSL中创建docker容器，在windows下使用docker desktop进行可视化管理。特别方便有双系统环境来回切换需求的人。总之<strong>使用WSL既可以使用windows的图形化操作界面又可以使用Linux便捷的命令行工具</strong>，很好的满足了我在windows下使用linux的需求。接下来我将介绍如何打造及使用Winux系统。</p><h4 id="安装WSL"><a href="#安装WSL" class="headerlink" title="安装WSL"></a>安装WSL</h4><p>参照官方文档<a href="https://docs.microsoft.com/zh-cn/windows/wsl/install">安装 WSL</a></p>]]></content>
      
      
      <categories>
          
          <category> project </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>电脑已有jdk 8，再配置一个jdk 17</title>
      <link href="/2022/01/26/JDK-Configuration/"/>
      <url>/2022/01/26/JDK-Configuration/</url>
      
        <content type="html"><![CDATA[<p>如何安装两个以上版本jdk，并可以自由切换。以jdk1.8和jdk-17为例</p><h2 id="一、目标："><a href="#一、目标：" class="headerlink" title="一、目标："></a>一、目标：</h2><p>现在用的 jdk1.8 做开发，私下里想了解和测试最新版 jdk-17 的特性，所以需要两个(甚至多个)版本的 jdk（以 jdk1.8 和 jdk-17 和为例），而且要做到可以随时切换版本。</p><h2 id="二、当前情况"><a href="#二、当前情况" class="headerlink" title="二、当前情况"></a>二、当前情况</h2><p>目前电脑中已有一个 jdk1.8</p><h2 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h2><ol><li>将 jdk 17 压缩包解压</li><li>打开环境变量，找到系统变量中的<strong>Path</strong></li><li>点击编辑把<code>%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin;</code>复制到变量值的最前面，然后确定</li></ol><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126225728779.png" alt="image-20220126225728779"></p><ol start="4"><li>新建两个JAVA_HOME，值为jdk的路径</li></ol><table><thead><tr><th>变量</th><th>值</th><th>说明</th></tr></thead><tbody><tr><td>JAVA_HOME</td><td>%JAVA_HOME8%</td><td>修改此处变量值中的数字来达到启用所对应的jdk</td></tr><tr><td>JAVA_HOME17</td><td>jdk17路径</td><td>12为我的jdk版本；后面的路径是你自己jdk的主目录</td></tr><tr><td>JAVA_HOME8</td><td>jdk8路径</td><td>8也为我的jdk版本；后面的路径是你自己jdk的主目录</td></tr></tbody></table><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126225556573.png" alt="image-20220126225556573"></p><h3 id="切换jdk"><a href="#切换jdk" class="headerlink" title="切换jdk"></a>切换jdk</h3><p>修改JAVA_HOME变量值中的数字来达到启用所对应的jdk</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126225831540.png" alt="image-20220126225831540"></p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>WIN+R输入cmd打开命令提示符，键入<br><code>java -version</code></p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126225911133.png" alt="image-20220126225911133"></p><p>切换版本后，要打开一个新的cmd进行测试</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126225938216.png" alt="image-20220126225938216"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL事务日志</title>
      <link href="/2022/01/26/MySQL%E4%BA%8B%E5%8A%A1%E6%97%A5%E5%BF%97/"/>
      <url>/2022/01/26/MySQL%E4%BA%8B%E5%8A%A1%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL事务日志"><a href="#MySQL事务日志" class="headerlink" title="MySQL事务日志"></a>MySQL事务日志</h1><p>事务有4种特性：原子性、一致性、隔离性和持久性。那么事务的四种特性到底是基于什么机制实现呢？</p><p>事务的<strong>隔离性</strong>由 <strong>锁机制</strong> 实现。</p><p>而事务的<strong>原子性、一致性和持久性</strong>由事务的 <strong>redo 日志和undo 日志</strong>来保证。</p><ul><li>REDO LOG 称为 <strong>重做日志</strong> ，提供再写入操作，恢复提交事务修改的页操作，用来保证事务的<strong>持久性</strong>。</li><li>UNDO LOG 称为 <strong>回滚日志</strong> ，回滚行记录到某个特定版本，用来保证事务的<strong>原子性、一致性</strong>。</li></ul><p>有人或许会认为UNDO是REDO的逆过程，其实不然。REDO 和 UNDO 都可以视为是一种<strong>恢复操作</strong>，但是:</p><ul><li> <strong>redo log</strong>:    是<strong>存储引擎层(innodb)生成的日志</strong>，记录的是”<strong>物理级别</strong>“上的页修改操作，比如页号xx、偏移量y写入了’zzz’数据。主要为了保证数据的可靠性;</li><li><strong>undo log</strong>:    是存储引擎层(innodb)生成的日志，记录的是<strong>逻辑操作</strong>日志，比如对某一行数据进行了INSERT语句操作，那么undo log就记录一条与之相反的DELETE操作。主要用于<strong>事务的回滚</strong>(undo log记录的是每个修改操作的<strong>逆操作</strong>)和<strong>一致性非锁定读</strong>(undo log回滚行记录到某种特定的版本—MVCC，即多版本并发控制)</li></ul><h2 id="1-redo日志"><a href="#1-redo日志" class="headerlink" title="1. redo日志"></a>1. redo日志</h2><p>InnoDB存储引擎是<strong>以页为单位</strong>来管理存储空间的。在真正访问页面之前，需要把在<strong>磁盘上</strong>的页缓存到内存中的<strong>Buffer Pool</strong>之后才可以访问。所有的变更都必须<strong>先更新缓冲池中的数据</strong>，然后缓冲池中的<strong>脏页</strong>会以一定的频率被刷入磁盘（<strong>checkPoint机制</strong>），通过缓冲池来优化CPu和磁盘之间的鸿沟，这样就可以保证整体的性能不会下降太快。</p><h3 id="1-1-为什么需要REDO日志"><a href="#1-1-为什么需要REDO日志" class="headerlink" title="1.1 为什么需要REDO日志"></a>1.1 为什么需要REDO日志</h3><p>一方面，缓冲池可以帮助我们消除CPU和磁盘之间的鸿沟，checkpoint机制可以保证数据的最终落盘，然而由于checkpoint 并不是每次变更的时候就触发 的，而是<strong>master线程隔一段时间去处理的</strong>。</p><p><strong>所以最坏的情况</strong>就是事务提交后，刚写完缓冲池，还没将数据刷新到磁盘（内存中完成了，但磁盘中未完成），数据库宕机了，那么这段数据就是丢失的，无法恢复。</p><p>另一方面，事务包含 <strong>持久性</strong> 的特性，就是说对于一个已经提交的事务，在事务提交后即使系统发生了崩溃，这个事务对数据库中所做的更改也不能丢失。</p><p>那么如何保证这个持久性呢？ <strong>一个简单的做法</strong> ：在事务提交完成之前把该事务所修改的所有页面都刷新到磁盘，但是这个简单粗暴的做法有些问题：</p><ul><li><strong>修改量与刷新磁盘工作量严重不成比例</strong></li></ul><p>有时候我们仅仅修改了某个页面中的一个字节，但是我们知道在InnoDB中是<strong>以页为单位来进行磁盘IO的</strong>，也就是说我们在该事务提交时<strong>不得不将一个完整的页面从内存中刷新到磁盘</strong>，我们又知道一个页面默认是16KB大小，只修改一个字节就要刷新16KB的数据到磁盘上显然是太小题大做了。</p><ul><li><strong>随机lO刷新较慢</strong></li></ul><p>一个事务可能包含很多语句，即使是一条语句也可能修改许多页面，假如该事务修改的这些页面可能并不相邻，这就意味着在将某个事务修改的Buffer Pool中的页面刷新到磁盘时，需要进行很多的随机IO，随机IO比顺序IO要慢，尤其对于传统的机械硬盘来说。</p><p><strong>另一个解决的思路</strong> ：我们只是想让已经提交了的事务对数据库中数据所做的修改永久生效，即使后来系统崩溃，在重启后也能把这种修改恢复出来。所以我们其实没有必要在每次事务提交时就把该事务在内存中修改过的全部页面刷新到磁盘，只需要把<strong>修改了哪些东西记录一下就好</strong>。比如，某个事务将系统表空间中 第10号 页面中偏移量为 100 处的那个字节的值 1 改成 2 。我们只需要记录一下：将第0号表空间的10号页面的偏移量为100处的值更新为 2 。  </p><p>InnoDB引擎的事务采用了WAL技术（<code>Write-Ahead Logging</code>)，这种技术的思想就是<strong>先写日志，再写磁盘</strong>，<strong>只有日志写入成功，才算事务提交成功</strong>，这里的日志就是<strong>redo log</strong>。当发生宕机且数据未刷到磁盘的时候，可以通过redo log来恢复，保证ACID中的D，这就是redo log的作用。</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126162713847.png" alt="image-20220126162713847"></p><h3 id="1-2-REDO日志的好处、特点"><a href="#1-2-REDO日志的好处、特点" class="headerlink" title="1.2 REDO日志的好处、特点"></a>1.2 REDO日志的好处、特点</h3><p><strong>好处：</strong></p><ul><li>redo日志降低了刷盘频率</li><li>redo日志占用的空间非常小</li></ul><p>存储表空间ID、页号、偏移量以及需要更新的值，所需要的存储空间是很小的，刷盘快。</p><p><strong>特点：</strong></p><ul><li>redo日志是顺序写入磁盘的</li></ul><p>在执行事务的过程中，每执行一条语句，就可能产生若干条redo日志，这些日志是按照<strong>产生的顺序写入磁盘的</strong>，也就是使用顺序lo，效率比随机IO快。</p><ul><li>事务执行过程中，redo log不断记录  </li></ul><p>redo log跟bin log的区别，redo log是<strong>存储引擎层</strong>产生的，而<strong>bin log是数据库层</strong>产生的。假设一个事务，对表做10万行的记录插入，在这个过程中，一直不断的往redo log顺序记录，而bin log不会记录，直到这个事务提交，才会一次写入到bin log文件中。</p><h3 id="1-3-redo的组成"><a href="#1-3-redo的组成" class="headerlink" title="1.3 redo的组成"></a>1.3 redo的组成</h3><p>Redo log可以简单分为以下两个部分：</p><ul><li>重做日志的缓冲 (redo log buffer) ，保存在内存中，是易失的。</li></ul><p>在服务器启动时就向操作系统申请了一大片称之为redo log buffer的<strong>连续内存</strong>空间，翻译成中文就是redo日志缓冲区。这片内存空间被划分成若干个连续的redo log block。一个redo log block占用512字节大小。</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126164247620.png" alt="image-20220126164244593"></p><p><strong>参数设置：innodb_log_buffer_size：</strong>  </p><p>redo log buffer 大小，默认 16M ，最大值是4096M，最小值为1M。 </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">show</span> variables <span class="token operator">like</span> <span class="token string">'%innodb_log_buffer_size%'</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">------------------------+----------+</span><span class="token operator">|</span> Variable_name <span class="token operator">|</span> <span class="token keyword">Value</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">------------------------+----------+</span><span class="token operator">|</span> innodb_log_buffer_size <span class="token operator">|</span> <span class="token number">16777216</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">------------------------+----------+   </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>重做日志文件 (redo log file) ，保存在硬盘中，是持久的。  </li></ul><p>REDO日志文件如图所示，其中的ib_logfile0和ib_logfile1即为REDO日志。</p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126164528296.png" alt="image-20220126164528296" style="zoom:67%;"><h3 id="1-4-redo的整体流程"><a href="#1-4-redo的整体流程" class="headerlink" title="1.4 redo的整体流程"></a>1.4 redo的整体流程</h3><p>以一个更新事务为例，redo log 流转过程，如下图所示：  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126164659436.png" alt="image-20220126164659436"></p><ul><li>第1步：先将原始数据从磁盘中读入内存中来，修改数据的内存拷贝</li><li>第2步：生成一条重做日志并写入redo log buffer，记录的是数据被修改后的值</li><li>第3步：当事务commit时，将redo log buffer中的内容刷新到 redo log file，对 redo log file采用追加写的方式</li><li>第4步：定期将内存中修改的数据刷新到磁盘中  </li></ul><h3 id="1-5-redo-log的刷盘策略"><a href="#1-5-redo-log的刷盘策略" class="headerlink" title="1.5 redo log的刷盘策略"></a>1.5 redo log的刷盘策略</h3><p>redo log的写入并不是直接写入磁盘的，InnoDB引擎会在写redo log的时候先写redo log buffer，之后以 <strong>一定的频率</strong> 刷入到真正的redo log file 中。这里的一定频率怎么看待呢？这就是我们要说的刷盘策略。  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126164801521.png" alt="image-20220126164801521"></p><p>注意，redo log buffer刷盘到redo log file的过程并不是真正的刷到磁盘中去，只是刷入到 <strong>文件系统缓存（page cache）</strong>中去（这是现代<strong>操作系统</strong>为了提高文件写入效率做的一个优化），真正的写入会交给系统自己来决定（比如page cache足够大了）。那么对于InnoDB来说就存在一个问题，如果交给系统来同步，同样如果<strong>操作系统系统宕机</strong>，那么数据也丢失了（虽然整个系统宕机的概率还是比较小的）。<br>针对这种情况，InnoDB给出 innodb_flush_log_at_trx_commit 参数，该参数控制 commit提交事务时，如何将 redo log buffer 中的日志刷新到 redo log file 中。它支持三种策略：  </p><ul><li>设置为0 ：表示每次事务提交时不进行刷盘操作。（系统默认master thread每隔1s进行一次重做日志的同步）</li><li>设置为1 ：表示<strong>每次事务提交时都将进行同步，刷盘操作</strong>（ <strong>默认值</strong> ）</li><li>设置为2 ：表示每次事务提交时都只把 redo log buffer 内容写入 page cache，不进行同步。由os自己决定什么时候同步到磁盘文件。  </li></ul><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126165353406.png" alt="image-20220126165353406"></p><p>另外，InnoDB存储引擎有一个后台线程，每隔1秒，就会把 redo log buffer 中的内容写到文件系统缓存( page cache ) ，然后调用刷盘操作。</p><h3 id="1-6-不同刷盘策略演示"><a href="#1-6-不同刷盘策略演示" class="headerlink" title="1.6 不同刷盘策略演示"></a>1.6 不同刷盘策略演示</h3><h4 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h4><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126165559699.png" alt="image-20220126165559699"></p><p><strong>小结</strong>: <code>innodb_flush_log_at_trx_commit=1</code></p><p>为1时，只要事务提交成功,redo log记录就一定在硬盘里，不会有任何数据丢失。</p><p>如果事务执行期间MySQL挂了或宕机，这部分日志丢了，但是事务并没有提交，所以日志丢了也不会有损失。可以保证ACID的D，数据绝对不会丢失，但是<strong>效率最差</strong>的。</p><p>建议使用默认值，虽然操作系统宕机的概率理论小于数据库宕机的概率，但是一般既然使用了事务，那么数据的安全相对来说更重要些。|</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126170043228.png" alt="image-20220126170043228"></p><p><strong>小结</strong>:  <code>innodb_flush_log_at_trx_commit=2</code></p><p>为2时，只要事务提交成功，redo log buffer中的内容只写入文件系统缓存（ page cache )</p><p>如果仅仅只是MysQL挂了不会有任何数据丢失（page cache不归内存管了），但是<strong>操作系统宕机可能会有1秒数据的丢失</strong>，这种情况下无法满足ACID中的D。但是数值2肯定是效率最高的。</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126170251477.png" alt="image-20220126170251477"></p><p><strong>小结</strong>:  <code> innodb_flush_log_at_trx_commit=0</code> </p><p>为0时，master thread中每1秒进行一次重做日志的fsync操作，因此实例crash最多丢失1秒钟内的事务。(master thread是负责将缓冲池中的数据异步刷新到磁盘，保证数据的一致性)</p><p>数值0的话，是一种折中的做法，它的IO效率理论是高于1的，低于2的，这种策略也有丢失数据的风险，这种情况下也无法满足ACID中的D。</p><h3 id="1-7-写入redo-log-buffer-过程"><a href="#1-7-写入redo-log-buffer-过程" class="headerlink" title="1.7 写入redo log buffer 过程"></a>1.7 写入redo log buffer 过程</h3><h4 id="1-补充概念-Mini-Transaction"><a href="#1-补充概念-Mini-Transaction" class="headerlink" title="1.补充概念: Mini-Transaction"></a>1.补充概念: Mini-Transaction</h4><p>MysQL把对底层页面中的一次原子访问的过程称之为一个<strong>Mini-Transaction</strong>，简称<strong>mtr</strong>，比如，<strong>向某个索引对应的B+树中插入一条记录的过程就是一个Mini-Transaction</strong>。一个所谓的mtr可以包含一组redo日志在进行崩溃恢复时这一组redo日志作为一个不可分割的整体。</p><p>一个事务可以包含若干条语句，每一条语句其实是由若干个mtr组成，每一个mtr又可以包含若干条redo日志，画个图表示它们的关系就是这样:</p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126172158478.png" alt="image-20220126172158478" style="zoom:60%;"><h4 id="2-redo-日志写入log-buffer"><a href="#2-redo-日志写入log-buffer" class="headerlink" title="2. redo 日志写入log buffer"></a>2. redo 日志写入log buffer</h4><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126172413359.png" alt="image-20220126172413359"></p><p>每个mtr都会产生一组redo日志，用示意图来描述一下这些mtr产生的日志情况：  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126172424274.png" alt="image-20220126172424274"></p><p>不同的事务可能是 并发 执行的，所以 T1 、 T2 之间的 mtr 可能是 交替执行 的。  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126172438820.png" alt="image-20220126172438820"></p><h4 id="3-redo-log-block的结构图"><a href="#3-redo-log-block的结构图" class="headerlink" title="3. redo log block的结构图"></a>3. redo log block的结构图</h4><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126172453846.png" alt="image-20220126172453846"></p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126172501143.png" alt="image-20220126172501143"></p><h3 id="1-8-redo-log-file"><a href="#1-8-redo-log-file" class="headerlink" title="1.8 redo log file"></a>1.8 redo log file</h3><h4 id="1-相关参数设置"><a href="#1-相关参数设置" class="headerlink" title="1. 相关参数设置"></a>1. 相关参数设置</h4><ul><li><strong>innodb_log_group_home_dir</strong> ：指定 redo log 文件组所在的路径，默认值为 ./ ，表示在数据库的数据目录下。MySQL的默认数据目录（ var/lib/mysql ）下默认有两个名为 ib_logfile0 和ib_logfile1 的文件，log buffer中的日志默认情况下就是刷新到这两个磁盘文件中。此redo日志文件位置还可以修改。</li><li><strong>innodb_log_files_in_group</strong>：指明redo log file的个数，命名方式如：ib_logfile0，iblogfile1…iblogfilen。默认2个，最大100个。  </li></ul><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126172627228.png" alt="image-20220126172627228"></p><ul><li><strong>innodb_flush_log_at_trx_commit</strong>：控制 redo log 刷新到磁盘的策略，默认为1。</li><li><strong>innodb_log_file_size</strong>：单个 redo log 文件设置大小，默认值为 48M 。最大值为512G，注意最大值指的是整个 redo log 系列文件之和，即（innodb_log_files_in_group * innodb_log_file_size ）不能大于最大值512G。  </li></ul><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126172718213.png" alt="image-20220126172718213"></p><p>根据业务修改其大小，以便容纳较大的事务。编辑my.cnf文件并重启数据库生效，如下所示  </p><pre class="line-numbers language-none"><code class="language-none">[root@localhost ~]# vim &#x2F;etc&#x2F;my.cnfinnodb_log_file_size&#x3D;200M  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="2-日志文件组"><a href="#2-日志文件组" class="headerlink" title="2. 日志文件组"></a>2. 日志文件组</h4><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126172743759.png" alt="image-20220126172743759"></p><p>总共的redo日志文件大小其实就是： <code>innodb_log_file_size × innodb_log_files_in_group </code>。</p><p>采用循环使用的方式向redo日志文件组里写数据的话，会导致后写入的redo日志覆盖掉前边写的redo日志？当然！所以InnoDB的设计者提出了checkpoint的概念。  </p><h4 id="3-checkpoint"><a href="#3-checkpoint" class="headerlink" title="3. checkpoint"></a>3. checkpoint</h4><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126172808119.png" alt="image-20220126172808119"></p><p>如果 write pos 追上 checkpoint ，表示<strong>日志文件组满了</strong>，这时候不能再写入新的 redo log记录，MySQL 得停下来，清空一些记录，把 checkpoint 推进一下。  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126172825343.png" alt="image-20220126172825343"></p><h3 id="1-9-redo-log小结"><a href="#1-9-redo-log小结" class="headerlink" title="1.9 redo log小结"></a>1.9 redo log小结</h3><p>相信大家都知道redo log的作用和它的刷盘时机、存储形式:</p><p>InnoDB的更新操作采用的是<strong>Write Ahead Log</strong>(预先日志持久化)策略，即<strong>先写日志，再写入磁盘</strong>。</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126173138431.png" alt="image-20220126173138431"></p><h2 id="2-Undo日志"><a href="#2-Undo日志" class="headerlink" title="2. Undo日志"></a>2. Undo日志</h2><p><strong>redo log</strong>是事务<strong>持久性</strong>的保证，<strong>undo log</strong>是事务<strong>原子性</strong>的保证。在事务中 <strong>更新数据</strong> 的 <strong>前置操作</strong> 其实是要先写入一个 undo log 。</p><h3 id="2-1-如何理解Undo日志"><a href="#2-1-如何理解Undo日志" class="headerlink" title="2.1 如何理解Undo日志"></a>2.1 如何理解Undo日志</h3><p>事务需要保证 <strong>原子性</strong> ，也就是事务中的操作<strong>要么全部完成，要么什么也不做</strong>。但有时候事务执行到一半会出现一些情况，比如：</p><ul><li>情况一：事务执行过程中可能遇到各种错误，比如 <strong>服务器本身的错误</strong> ， <strong>操作系统错误</strong> ，甚至是突然<strong>断电</strong>导致的错误。</li><li>情况二：程序员可以在事务执行过程中手动输入 <strong>ROLLBACK</strong> 语句结束当前事务的执行。</li></ul><p>以上情况出现，我们需要把数据改回原先的样子，这个过程称之为 <strong>回滚</strong> ，这样就可以造成一个假象：这个事务看起来什么都没做，所以符合 <strong>原子性</strong> 要求。  </p><p>每当我们要对一条记录做改动时(这里的<strong>改动</strong>可以指<strong>INSERT、DELETE、UPDATE</strong>)，都需要”留一手”—-把回滚时所需的东西记下来。比如:</p><ul><li>你<strong>插入一条记录</strong>时，至少要把这条记录的主键值记下来，之后回滚的时候只需要把这个主键值对应的记录删掉就好了。(对于每个INSERT,InnoDB存储引擎会完成一个DELETE)</li><li>你<strong>删除了一条记录</strong>，至少要把这条记录中的内容都记下来，这样之后回滚时再把由这些内容组成的记录插入到表中就好了。(对于每个DELETE,InnoDB存储引擎会执行一个INSERT)</li><li>你<strong>修改了一条记录</strong>，至少要把修改这条记录前的旧值都记录下来，这样之后回滚时再把这条记录更新为旧值就好了。(对于每个UPDATE，InnoDB存储引擎会执行一个相反的UPDATE，将修改前的行放回去)</li></ul><p>MysQL把这些为了回滚而记录的这些内容称之为<strong>撤销日志</strong>或者<strong>回滚日志</strong>(即undo log)。注意，由于查询操作( SELECT）并不会修改任何用户记录，所以<strong>在查询操作执行时，并不需要记录相应的undo日志</strong>。</p><p>此外，undo log <strong>会产生redo log</strong>，也就是undo log的产生会伴随着redo log的产生，这是因为undo log也需要持久性的保护。</p><h3 id="2-2-Undo日志的作用"><a href="#2-2-Undo日志的作用" class="headerlink" title="2.2 Undo日志的作用"></a>2.2 Undo日志的作用</h3><ul><li><strong>作用1：回滚数据</strong></li></ul><p>用户对undo日志可能有误解:undo用于将数据库物理地恢复到执行语句或事务之前的样子。但事实并非如此。undo是逻辑日志，因此只是将数据库逻辑地恢复到原来的样子。所有修改都被逻辑地取消了，但是<strong>数据结构和页本身在回滚之后可能大不相同</strong>。</p><p>这是因为在多用户并发系统中，可能会有数十、数百甚至数千个并发事务。数据库的主要任务就是协调对数据记录的并发访问。比如，一个事务在修改当前一个页中某几条记录，同时还有别的事务在对同一个页中另几条记录进行修改。因此，不能将一个页回滚到事务开始的样子，因为这样会影响其他事务正在进行的工作。</p><ul><li><strong>作用2：MVCC</strong>  </li></ul><p>undo的另一个作用是MVCC，即在InnoDB存储引擎中MIcc的实现是通过undo来完成。当用户读取一行记录时，若该记录已经被其他事务占用，当前事务可以通过undo读取之前的行版本信息，以此实现非锁定读取。</p><h3 id="2-3-undo的存储结构"><a href="#2-3-undo的存储结构" class="headerlink" title="2.3 undo的存储结构"></a>2.3 undo的存储结构</h3><h4 id="1-回滚段与undo页"><a href="#1-回滚段与undo页" class="headerlink" title="1. 回滚段与undo页"></a>1. 回滚段与undo页</h4><p>InnoDB对undo log的管理采用段的方式，也就是 <strong>回滚段（rollback segment）</strong> 。每个回滚段记录了<strong>1024</strong> 个 <strong>undo log segment</strong> ，而在每个undo log segment段中进行 undo页 的申请。</p><ul><li>在 InnoDB1.1版本之前 （不包括1.1版本），只有一个rollback segment，因此支持同时在线的事务限制为 1024 。虽然对绝大多数的应用来说都已经够用。</li><li>从1.1版本开始InnoDB支持最大 <strong>128个rollback segment</strong> ，故其支持同时在线的事务限制提高到了 <strong>128*1024</strong> 。  </li></ul><h4 id="2-回滚段与事务"><a href="#2-回滚段与事务" class="headerlink" title="2. 回滚段与事务"></a>2. 回滚段与事务</h4><ol><li><p>每个事务只会使用一个回滚段，一个回滚段在同一时刻可能会服务于多个事务。</p></li><li><p>当一个事务开始的时候，会制定一个回滚段，在事务进行的过程中，当数据被修改时，原始的数据会被复制到回滚段。</p></li><li><p>在回滚段中，事务会不断填充盘区，直到事务结束或所有的空间被用完。如果当前的盘区不够用，事务会在段中请求扩展下一个盘区，如果所有已分配的盘区都被用完，事务会覆盖最初的盘区或者在回滚段允许的情况下扩展新的盘区来使用。</p></li><li><p>回滚段存在于undo表空间中，在数据库中可以存在多个undo表空间，但同一时刻只能使用一个undo表空间。</p></li><li><p>当事务提交时，InnoDB存储引擎会做以下两件事情：</p><p>将undo log放入列表中，以供之后的purge操作</p><p>判断undo log所在的页是否可以重用，若可以分配给下个事务使用</p></li><li><p> 回滚段中的数据分类  </p></li></ol><h4 id="3-回滚段中的数据分类"><a href="#3-回滚段中的数据分类" class="headerlink" title="3. 回滚段中的数据分类"></a>3. 回滚段中的数据分类</h4><ol><li><strong>未提交的回滚数据(uncommitted undo information)</strong>:该数据所关联的事务并未提交，用于实现读一致性，所以该数据不能被其他事务的数据覆盖。</li><li>**已经提交但未过期的回滚数据(committed undo information):**该数据关联的事务已经提交，但是仍受到undo retention参数的保持时间的影响。</li><li>**事务已经提交并过期的数据(expired undo information)**∶事务已经提交，而且数据保存时间已经超过undo retention参数指定的时间，属于已经过期的数据。当回滚段满了之后，会优先覆盖”事务已经提交并过期的数据”。</li></ol><p>事务提交后并不能马上删除undo log及undo log所在的页。这是因为可能还有其他事务需要通过undo log来得到行记录之前的版本。故事务提交时将undo log放入一个链表中，是否可以最终删除undo log及undo log所在页由purge线程来判断。</p><h3 id="2-4-undo的类型"><a href="#2-4-undo的类型" class="headerlink" title="2.4 undo的类型"></a>2.4 undo的类型</h3><p>在InnoDB存储引擎中，undo log分为：</p><ul><li>insert undo log</li><li>update undo log</li></ul><h3 id="2-5-undo-log的生命周期"><a href="#2-5-undo-log的生命周期" class="headerlink" title="2.5 undo log的生命周期"></a>2.5 undo log的生命周期</h3><h4 id="1-简要生成过程"><a href="#1-简要生成过程" class="headerlink" title="1. 简要生成过程"></a>1. 简要生成过程</h4><p><strong>只有Buffer Pool的流程：</strong>  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126192950145.png" alt="image-20220126192950145"></p><p><strong>有了Redo Log和Undo Log之后：</strong>  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126193014963.png" alt="image-20220126193014963"></p><h4 id="2-详细生成过程"><a href="#2-详细生成过程" class="headerlink" title="2. 详细生成过程"></a>2. 详细生成过程</h4><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126193323589.png" alt="image-20220126193323589"></p><p>当我们执行INSERT时：  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">begin</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token keyword">user</span> <span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">"tom"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126193345615.png" alt="image-20220126193345615"></p><p><strong>当我们执行UPDATE时：</strong>  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126193356469.png" alt="image-20220126193356469"></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">UPDATE</span> <span class="token keyword">user</span> <span class="token keyword">SET</span> id<span class="token operator">=</span><span class="token number">2</span> <span class="token keyword">WHERE</span> id<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126193411418.png" alt="image-20220126193411418"></p><h4 id="3-undo-log是如何回滚的"><a href="#3-undo-log是如何回滚的" class="headerlink" title="3. undo log是如何回滚的"></a>3. undo log是如何回滚的</h4><p>以上面的例子来说，假设执行rollback，那么对应的流程应该是这样：</p><ol><li>通过undo no=3的日志把id=2的数据删除</li><li>通过undo no=2的日志把id=1的数据的deletemark还原成0</li><li>通过undo no=1的日志把id=1的数据的name还原成Tom</li><li>通过undo no=0的日志把id=1的数据删除  </li></ol><h4 id="4-undo-log的删除"><a href="#4-undo-log的删除" class="headerlink" title="4. undo log的删除"></a>4. undo log的删除</h4><ul><li>针对于insert undo log</li></ul><p>因为insert操作的记录，只对事务本身可见，对其他事务不可见。故该undo log可以在事务提交后直接删除，不需要进行purge操作。</p><ul><li>针对于update undo log</li></ul><p>该undo log可能需要提供MVCC机制，因此不能在事务提交时就进行删除。提交时放入undo log链表，等待purge线程进行最后的删除。  </p><h3 id="2-6-小结"><a href="#2-6-小结" class="headerlink" title="2.6 小结"></a>2.6 小结</h3><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126193510769.png" alt="image-20220126193510769"></p><p><strong>undo log是逻辑日志</strong>，对事务回滚时，只是将数据库<strong>逻辑地恢复到原来的样子</strong>。<br><strong>redo log是物理日志</strong>，记录的是数据页的物理变化，undo log不是redo log的逆过程。  </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MVCC</title>
      <link href="/2022/01/26/MVCC/"/>
      <url>/2022/01/26/MVCC/</url>
      
        <content type="html"><![CDATA[<h1 id="多版本并发控制-MVCC"><a href="#多版本并发控制-MVCC" class="headerlink" title="多版本并发控制  (MVCC)"></a>多版本并发控制  (MVCC)</h1><h2 id="1-什么是MVCC"><a href="#1-什么是MVCC" class="headerlink" title="1. 什么是MVCC"></a>1. 什么是MVCC</h2><p>MVCC （Multiversion Concurrency Control），多版本并发控制。顾名思义，MVCC 是通过数据行的多个版本管理来实现数据库的 <strong>并发控制</strong> 。这项技术使得在InnoDB的事务隔离级别下执行 <strong>一致性读</strong> 操作有了保证。换言之，就是为了查询一些正在被另一个事务更新的行，并且可以看到它们<strong>被更新之前的值</strong>，这样在做查询的时候就不用等待另一个事务释放锁。  </p><p>MVCC 没有正式的标准，在不同的DBMS中MVCC的实现方式可能是不同的，也不是普遍使用的(大家可以参考相关的DBMS文档)。这里讲解InnoDB中MVcC的实现机制(MySQL其它的存储引擎并不支持它)。</p><h2 id="2-快照读与当前读"><a href="#2-快照读与当前读" class="headerlink" title="2. 快照读与当前读"></a>2. 快照读与当前读</h2><p>MVCC在MySQL InnoDB中的实现主要是为了提高数据库并发性能，用更好的方式去处理 <strong>读-写冲突</strong> ，做到即使有读写冲突时，也能做到 不加锁 ， <strong>非阻塞并发读</strong> ，而这个读指的就是 <strong>快照读</strong> , 而非 <strong>当前读</strong> 。当前读实际上是一种加锁的操作，是悲观锁的实现。而MVCC本质是采用<strong>乐观锁</strong>思想的一种方式。  </p><h3 id="2-1-快照读"><a href="#2-1-快照读" class="headerlink" title="2.1 快照读"></a>2.1 快照读</h3><p><strong>快照读</strong>又叫<strong>一致性读</strong>，读取的是快照数据。不加锁的简单的 SELECT 都属于快照读，即不加锁的非阻塞读；比如这样：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> player <span class="token keyword">WHERE</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>之所以出现快照读的情况，是基于提高并发性能的考虑，<strong>快照读的实现是基于MVCC</strong>，它在很多情况下，避免了加锁操作，降低了开销。</p><p>既然是基于多版本，那么<strong>快照读可能读到的并不一定是数据的最新版本，而有可能是之前的历史版本。</strong></p><p>快照读的前提是隔离级别不是串行级别，串行级别下的快照读会退化成当前读。  </p><h3 id="2-2-当前读"><a href="#2-2-当前读" class="headerlink" title="2.2 当前读"></a>2.2 当前读</h3><p><strong>当前读</strong>读取的是记录的<strong>最新版本</strong>（最新数据，而不是历史版本的数据），读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。加锁的 SELECT，或者对数据进行增删改都会进行当前读。比如：  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> student <span class="token keyword">LOCK</span> <span class="token operator">IN</span> <span class="token keyword">SHARE</span> <span class="token keyword">MODE</span><span class="token punctuation">;</span> <span class="token comment"># 共享锁</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> student <span class="token keyword">FOR</span> <span class="token keyword">UPDATE</span><span class="token punctuation">;</span> <span class="token comment"># 排他锁</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> student <span class="token keyword">values</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment"># 排他锁</span><span class="token keyword">DELETE</span> <span class="token keyword">FROM</span> student <span class="token keyword">WHERE</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment"># 排他锁</span><span class="token keyword">UPDATE</span> student <span class="token keyword">SET</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment"># 排他锁  </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-复习"><a href="#3-复习" class="headerlink" title="3. 复习"></a>3. 复习</h2><h3 id="3-1-再谈隔离级别"><a href="#3-1-再谈隔离级别" class="headerlink" title="3.1 再谈隔离级别"></a>3.1 再谈隔离级别</h3><p>我们知道事务有 4 个隔离级别，可能存在三种并发问题：  </p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126194428047.png" alt="image-20220126194428047" style="zoom: 40%;"><p>在MysQL中，<strong>默认的隔离级别是可重复读</strong>，可以解决脏读和不可重复读的问题，如果仅从定义的角度来看，它并不能解决幻读问题。如果我们想要解决幻读问题，就需要采用串行化的方式，也就是将隔离级别提升到最高，但这样一来就会大幅降低数据库的事务并发能力。</p><p>MVCC 可以不采用锁机制，而是<strong>通过乐观锁的方式来解决不可重复读和幻读问题</strong>!它可以在大多数情况下替代行级锁，降低系统的开销。</p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126194642571.png" alt="image-20220126194642571" style="zoom:40%;"><p>3.2 隐藏字段、Undo Log版本链</p><p>回顾一下undo日志的版本链，对于使用 InnoDB 存储引擎的表来说，它的聚簇索引记录中都包含两个必要的隐藏列。</p><ul><li>trx_id ：每次一个事务对某条聚簇索引记录进行改动时，都会把该事务的 事务id 赋值给trx_id 隐藏列。</li><li>roll_pointer ：每次对某条聚簇索引记录进行改动时，都会把旧的版本写入到 undo日志 中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。  </li></ul><p>假设插入该记录的<strong>事务id为8</strong>，那么此刻该条记录示意图如下所示：</p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126202340372.png" alt="image-20220126202340372" style="zoom:50%;"><pre class="line-numbers language-none"><code class="language-none">insert undo只在事务回滚时起作用，当事务提交后，该类型的undo日志就没用了，它占用的Undo LogSegment也会被系统回收（也就是该undo日志占用的Undo页面链表要么被重用，要么被释放)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>假设之后两个<strong>事务id分别为10，20</strong>的事务对这条记录进行 UPDATE 操作，操作流程如下：  </p><table><thead><tr><th>发生时间 顺序</th><th>事务10</th><th>事务20</th></tr></thead><tbody><tr><td>1</td><td>BEGIN;</td><td></td></tr><tr><td>2</td><td></td><td>BEGIN;</td></tr><tr><td>3</td><td>UPDATE student SET name=”李四” WHERE id=1;</td><td></td></tr><tr><td>4</td><td>UPDATE student SET name=”王五” WHERE id=1;</td><td></td></tr><tr><td>5</td><td>COMMIT;</td><td></td></tr><tr><td>6</td><td></td><td>UPDATE student SET name=”钱七” WHERE id=1;</td></tr><tr><td>7</td><td></td><td>UPDATE student SET name=”宋八” WHERE id=1;</td></tr><tr><td>8</td><td></td><td>COMMIT;</td></tr></tbody></table><p>每次对记录进行改动，都会记录一条undo日志，每条undo日志也都有一个 <strong>roll_pointer</strong> 属性（ <strong>INSERT</strong> 操作对应的undo日志没有该属性，因为该记录并没有更早的版本），可以将这些 <strong>undo日志</strong>都连起来，串成一个链表：  </p><p><strong>能不能在两个事务中交叉更新同一条记录呢?</strong> 不能!    这不就是一个事务修改了另一个未提交事务修改过的数据，<strong>脏写</strong>。<br>InnoDB<strong>使用锁来保证不会有脏写</strong>情况的发生，也就是在第一个事务更新了某条记录后，就会给这条记录加锁，另一个事务再次更新时就需要等待第一个事务提交了，把锁释放之后才可以继续更新。</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126202751482.png" alt="image-20220126202751482"></p><p>对该记录每次更新后，都会将旧值放到一条 <strong>undo日志</strong> 中，就算是该记录的一个旧版本，随着更新次数的增多，所有的版本都会被 <strong>roll_pointer</strong> 属性连接成一个链表，我们把这个链表称之为 <strong>版本链</strong> ，版本链的<strong>头节点就是当前记录最新的值。</strong></p><p>每个版本中还包含生成该版本时对应的 <strong>事务id</strong> 。  </p><h2 id="4-MVCC实现原理之ReadView"><a href="#4-MVCC实现原理之ReadView" class="headerlink" title="4. MVCC实现原理之ReadView"></a>4. MVCC实现原理之ReadView</h2><p>MVCC 的实现依赖于：<strong>隐藏字段（trx_id ，roll_pointer）、Undo Log、Read View</strong>。  </p><h3 id="4-1-什么是ReadView"><a href="#4-1-什么是ReadView" class="headerlink" title="4.1 什么是ReadView"></a>4.1 什么是ReadView</h3><p>在MVCC机制中，多个事务对同一个行记录进行更新会产生多个历史快照，这些<strong>历史快照</strong>保存在<strong>Undo Log</strong>里。如果一个事务想要查询这个行记录，需要读取哪个版本的行记录呢?这时就需要用到ReadView了，它帮我们解决了行的可见性问题。</p><p>ReadView就是事务A (ReadView和事务是一对一的关系) 在使用MVCC机制进行快照读操作时产生的读视图。当事务启动时，会生成数据库系统当前的一个快照，InnoDB为每个事务构造了一个数组，用来记录并维护系统当前<strong>活跃事务</strong>的ID(<strong>“活跃”指的就是，启动了但还没提交</strong>)。</p><h3 id="4-2-设计思路"><a href="#4-2-设计思路" class="headerlink" title="4.2 设计思路"></a>4.2 设计思路</h3><p>使用 <strong>READ UNCOMMITTED</strong> 隔离级别的事务，由于可以读到未提交事务修改过的记录（<strong>脏读</strong>），所以直接读取记录的最新版本就好了。</p><p>使用 <strong>SERIALIZABLE</strong> 隔离级别的事务，InnoDB规定使用<strong>加锁</strong>的方式来访问记录。</p><p>使用 <strong>READ COMMITTED</strong> 和 <strong>REPEATABLE READ</strong> 隔离级别的事务，都必须保证读到 <strong>已经提交了的</strong> 事务修改过的记录。假如另一个事务已经修改了记录但是尚未提交，是不能直接读取最新版本的记录的，核心问题就是<strong>需要判断一下版本链中的哪个版本是当前事务可见的</strong>，这是ReadView要解决的主要问题。</p><p>这个ReadView中主要包含<strong>4个比较重要的内容</strong>，分别如下：</p><ol><li><strong>creator_trx_id</strong> ，创建这个 Read View 的事务 ID。  </li></ol><pre class="line-numbers language-none"><code class="language-none">说明：只有在对表中的记录做改动时（执行INSERT、DELETE、UPDATE这些语句时）才会为事务分配事务id，否则在一个只读事务中的事务id值都默认为0。  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li><p><strong>trx_ids</strong> ，表示在生成ReadView时当前系统中活跃的读写事务的 <strong>事务id列表</strong> 。  <strong>“活跃”指的就是，启动了但还没提交 !!!</strong></p></li><li><p><strong>up_limit_id</strong> ，活跃的事务中最小的事务 ID。  </p></li><li><p><strong>low_limit_id</strong> ，表示生成ReadView时系统中<strong>应该分配给下一个事务的 id 值</strong>。low_limit_id 是系统最大的事务id值，这里要注意是系统中的事务id，需要区别于正在活跃的事务ID。  </p></li></ol><pre class="line-numbers language-none"><code class="language-none">注意：low_limit_id并不是trx_ids中的最大值，事务id是递增分配的。比如，现在有id为1，2，3这三个事务，之后id为3的事务提交了。那么一个新的读事务在生成ReadView时，trx_ids就包括1和2，up_limit_id的值就是1，low_limit_id的值就是4。  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126204438809.png" alt="image-20220126204438809" style="zoom:70%;"><h3 id="4-3-ReadView的规则"><a href="#4-3-ReadView的规则" class="headerlink" title="4.3 ReadView的规则"></a>4.3 ReadView的规则</h3><ul><li><p>有了这个ReadView，这样在访问某条记录时，只需要按照下边的步骤判断记录的某个版本是否可见。</p></li><li><p>如果被访问版本的trx_id属性值与ReadView中的 <strong>creator_trx_id</strong> 值相同，意味着当前事务在访问它自己修改过的记录，所以该版本可以被当前事务访问。</p></li><li><p>如果被访问版本的trx_id属性值小于ReadView中的 <strong>up_limit_id</strong> 值，表明生成该版本的事务在当前事务生成ReadView前已经提交，所以该版本可以被当前事务访问。</p></li><li><p>如果被访问版本的trx_id属性值大于或等于ReadView中的 <strong>low_limit_id</strong> 值，表明生成该版本的事务在当前事务生成ReadView后才开启，所以该版本不可以被当前事务访问。</p></li><li><p>如果被访问版本的trx_id属性值在ReadView的 <strong>up_limit_id 和 low_limit_id 之间</strong>，那就需要判断一下trx_id属性值<strong>是不是在 trx_ids 列表中。</strong></p><ul><li><p>如果<strong>在</strong>，说明创建ReadView时生成该版本的<strong>事务还是活跃的，该版本不可以被访问</strong>。</p></li><li><p>如果不在，说明创建ReadView时生成该版本的事务已经被提交，该版本可以被访问。  </p></li></ul></li></ul><h3 id="4-4-MVCC整体操作流程"><a href="#4-4-MVCC整体操作流程" class="headerlink" title="4.4 MVCC整体操作流程"></a>4.4 MVCC整体操作流程</h3><p>了解了这些概念之后，我们来看下当查询一条记录的时候，系统如何通过MVCC找到它：</p><ol><li>首先获取事务自己的版本号，也就是事务 ID；</li><li>获取 ReadView；</li><li>查询得到的数据，然后与 ReadView 中的事务版本号进行比较；</li><li>如果不符合 ReadView 规则，就需要从 Undo Log 中获取历史快照；</li><li>最后返回符合规则的数据。</li></ol><p>在隔离级别为读已提交（Read Committed）时，一个事务中的每一次 SELECT 查询都会重新获取一次Read View。</p><p>如表所示：  </p><table><thead><tr><th>事务</th><th>说明</th></tr></thead><tbody><tr><td>begin;</td><td></td></tr><tr><td>select * from student where id &gt;2;</td><td>获取一次Read View</td></tr><tr><td>………</td><td></td></tr><tr><td>select * from student where id &gt;2;</td><td>获取一次Read View</td></tr><tr><td>commit;</td><td></td></tr></tbody></table><p>注意，此时同样的查询语句都会重新获取一次 Read View，这时如果 Read View 不同，就可能产生不可重复读或者幻读的情况。</p><p>当隔离级别为可重复读的时候，就避免了不可重复读，这是因为一个事务只在第一次 SELECT 的时候会获取一次 Read View，而后面所有的 SELECT 都会复用这个 Read View，如下表所示：  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126211628720.png" alt="image-20220126211628720"></p><h2 id="5-举例说明"><a href="#5-举例说明" class="headerlink" title="5. 举例说明"></a>5. 举例说明</h2><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126205017653.png" alt="image-20220126205017653" style="zoom:80%;"><h3 id="5-1-READ-COMMITTED隔离级别下"><a href="#5-1-READ-COMMITTED隔离级别下" class="headerlink" title="5.1 READ COMMITTED隔离级别下"></a>5.1 READ COMMITTED隔离级别下</h3><p><strong>READ COMMITTED ：每次读取数据前都生成一个ReadView。</strong></p><p>现在有两个 事务id 分别为 <strong>10 、 20</strong> 的事务在执行：  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># Transaction 10</span><span class="token keyword">BEGIN</span><span class="token punctuation">;</span><span class="token keyword">UPDATE</span> student <span class="token keyword">SET</span> name<span class="token operator">=</span><span class="token string">"李四"</span> <span class="token keyword">WHERE</span> id<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">UPDATE</span> student <span class="token keyword">SET</span> name<span class="token operator">=</span><span class="token string">"王五"</span> <span class="token keyword">WHERE</span> id<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment"># Transaction 20</span><span class="token keyword">BEGIN</span><span class="token punctuation">;</span><span class="token comment"># 更新了一些别的表的记录</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此刻，表student 中 id 为 1 的记录得到的版本链表如下所示：  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126205759475.png" alt="image-20220126205759475"></p><p>假设现在有一个使用 <strong>READ COMMITTED</strong> 隔离级别的事务开始执行：  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># 使用READ COMMITTED隔离级别的事务</span><span class="token keyword">BEGIN</span><span class="token punctuation">;</span><span class="token comment"># SELECT1：Transaction 10、20未提交</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> student <span class="token keyword">WHERE</span> id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment"># 得到的列name的值为'张三'  </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这个<strong>SELECT1</strong>的执行过程如下:</p><ul><li>步骤1∶在执行SELECT语句时会先生成一个<strong>ReadView</strong> ,ReadView的<strong>trx_ids</strong>列表的内容就是**[10，20]**，up_limit_id为10,    low_limit_id为21,   creator_trx_id为0。</li><li>步骤2:从版本链中挑选可见的记录，从图中看出，最新版本的列name的内容是’王五’，该版本的trx_id值为<strong>10</strong>，在<strong>trx_ids</strong>列表内，所以不符合可见性要求(<strong>trx_ids</strong>列表内为未提交的)，根据roll_pointer跳到下一个版本。</li><li>步骤3:下一个版本的列name的内容是’李四’，该版本的trx_id值也为10，<strong>也在trx_ids列表内</strong>，所以也不符合要求，继续跳到下一个版本。</li><li>步骤4∶下一个版本的列name的内容是’张三’，该版本的trx_id值为8，小于ReadView中的up_limit_id值10，所以这个版本是符合要求的，最后返回给用户的版本就是这条列name为‘张三’的记录。</li></ul><p>之后，我们把 事务id 为 <strong>10</strong> 的事务提交一下：  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># Transaction 10</span><span class="token keyword">BEGIN</span><span class="token punctuation">;</span><span class="token keyword">UPDATE</span> student <span class="token keyword">SET</span> name<span class="token operator">=</span><span class="token string">"李四"</span> <span class="token keyword">WHERE</span> id<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">UPDATE</span> student <span class="token keyword">SET</span> name<span class="token operator">=</span><span class="token string">"王五"</span> <span class="token keyword">WHERE</span> id<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">COMMIT</span><span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后再到 事务id 为 <strong>20</strong> 的事务中更新一下表 student 中 id 为 1 的记录：  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># Transaction 20</span><span class="token keyword">BEGIN</span><span class="token punctuation">;</span><span class="token comment"># 更新了一些别的表的记录</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">UPDATE</span> student <span class="token keyword">SET</span> name<span class="token operator">=</span><span class="token string">"钱七"</span> <span class="token keyword">WHERE</span> id<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">UPDATE</span> student <span class="token keyword">SET</span> name<span class="token operator">=</span><span class="token string">"宋八"</span> <span class="token keyword">WHERE</span> id<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此刻，表student中 id 为 1 的记录的版本链就长这样：  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126212223762.png" alt="image-20220126212223762"></p><p>然后再到刚才使用 READ COMMITTED 隔离级别的事务中继续查找这个 id 为 1 的记录，如下  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># 使用READ COMMITTED隔离级别的事务</span><span class="token keyword">BEGIN</span><span class="token punctuation">;</span><span class="token comment"># SELECT1：Transaction 10、20均未提交</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> student <span class="token keyword">WHERE</span> id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment"># 得到的列name的值为'张三'</span><span class="token comment"># SELECT2：Transaction 10提交，Transaction 20未提交</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> student <span class="token keyword">WHERE</span> id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment"># 得到的列name的值为'王五'  </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个<strong>SELECT2</strong>的执行过程如下:</p><ul><li>步骤1:在执行SELECT语句时会又会<strong>单独生成一个ReadView</strong>，该ReadView的trx_ids列表的内容就是[20]，up_limit_id为20，low_limit_id为21, creator_trx_id为0。</li><li>步骤2:从版本链中挑选可见的记录，从图中看出，最新版本的列name 的内容是’宋八’，该版本的trx_id值为20，在trx_ids列表内，所以不符合可见性要求，根据roll_pointer跳到下一个版本。</li><li>步骤3:下一个版本的列name的内容是’钱七’，该版本的trx_id值为20，也在trx_ids列表内，所以也不符合要求，继续跳到下一个版本。</li><li>步骤4:下一个版本的列name的内容是’王五’，该版本的trx_id值为<strong>10</strong>，小于ReadView中的up_limit_id值20，所以这个版本是符合要求的，最后返回给用户的版本就是这条列name为’王五’的记录。</li><li>以此类推，如果之后事务id为20的记录也提交了，再次在使用READ COMMITTED隔离级别的事务中查询表student中id值为1的记录时，得到的结果就是‘宋八’了，具体流程我们就不分析了。</li></ul><p><strong>强调</strong>:    使用READ COMMITTED隔离级别的事务在每次查询开始时都会生成一个独立的ReadView。</p><h3 id="5-2-REPEATABLE-READ隔离级别下"><a href="#5-2-REPEATABLE-READ隔离级别下" class="headerlink" title="5.2 REPEATABLE READ隔离级别下"></a>5.2 REPEATABLE READ隔离级别下</h3><p>使用 <strong>REPEATABLE READ</strong> 隔离级别的事务来说，<strong>只会在第一次执行查询语句时生成一个 ReadView</strong> ，之后的查询就不会重复生成了。</p><p>比如，系统里有两个 事务id 分别为 10 、 20 的事务在执行：  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># Transaction 10</span><span class="token keyword">BEGIN</span><span class="token punctuation">;</span><span class="token keyword">UPDATE</span> student <span class="token keyword">SET</span> name<span class="token operator">=</span><span class="token string">"李四"</span> <span class="token keyword">WHERE</span> id<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">UPDATE</span> student <span class="token keyword">SET</span> name<span class="token operator">=</span><span class="token string">"王五"</span> <span class="token keyword">WHERE</span> id<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment"># Transaction 20</span><span class="token keyword">BEGIN</span><span class="token punctuation">;</span><span class="token comment"># 更新了一些别的表的记录</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此刻，表student 中 id 为 1 的记录得到的版本链表如下所示：  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126213111591.png" alt="image-20220126213111591"></p><p>假设现在有一个使用 REPEATABLE READ 隔离级别的事务开始执行：  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># 使用REPEATABLE READ隔离级别的事务</span><span class="token keyword">BEGIN</span><span class="token punctuation">;</span><span class="token comment"># SELECT1：Transaction 10、20未提交</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> student <span class="token keyword">WHERE</span> id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment"># 得到的列name的值为'张三'  </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这个<strong>SELECT1</strong>的执行过程如下：</p><ul><li>步骤1∶在执行SELECT语句时会先生成一个ReadView ,ReadView的trx_ids列表的内容就是[10,20]，up_limit_id为10, low_limit_id为21, creator_trx_id为0。</li><li>步骤2:然后从版本链中挑选可见的记录，从图中看出，最新版本的列 name的内容是’王五’，该版本的trx_id值为10，在trx_ids列表内，所以不符合可见性要求，根 据roll_pointer跳到下一个版本。</li><li>步骤3:下一个版本的列name的内容是’李四’，该版本的trx_id值也为10，也在trx_ids列表内列内是符合要求，继续跳到下一个版本。</li><li>步骤4:下一个版本的列name的内容是‘张三’，该版本的trx_id值为8，小于ReadView中的up_limit_id值10，所以这个版本是符合要求的，最后返回给用户的版本就是这条列name为’张三’的记录。</li></ul><p>之后，我们把事务id为<strong>10</strong>的事务提交一下，就像这样:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># Transaction 10</span><span class="token keyword">BEGIN</span><span class="token punctuation">;</span><span class="token keyword">UPDATE</span> student <span class="token keyword">SET</span> name<span class="token operator">=</span><span class="token string">"李四"</span> <span class="token keyword">WHERE</span> id<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">UPDATE</span> student <span class="token keyword">SET</span> name<span class="token operator">=</span><span class="token string">"王五"</span> <span class="token keyword">WHERE</span> id<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">COMMIT</span><span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后再到 事务id 为 20 的事务中更新一下表 student 中 id 为 1 的记录：  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># Transaction 20</span><span class="token keyword">BEGIN</span><span class="token punctuation">;</span><span class="token comment"># 更新了一些别的表的记录</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">UPDATE</span> student <span class="token keyword">SET</span> name<span class="token operator">=</span><span class="token string">"钱七"</span> <span class="token keyword">WHERE</span> id<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">UPDATE</span> student <span class="token keyword">SET</span> name<span class="token operator">=</span><span class="token string">"宋八"</span> <span class="token keyword">WHERE</span> id<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此刻，表student 中 id 为 1 的记录的版本链长这样：  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126213955053.png" alt="image-20220126213955053"></p><p>然后再到刚才使用 REPEATABLE READ 隔离级别的事务中继续查找这个 id 为 1 的记录，如下：  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># 使用REPEATABLE READ隔离级别的事务</span><span class="token keyword">BEGIN</span><span class="token punctuation">;</span><span class="token comment"># SELECT1：Transaction 10、20均未提交</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> student <span class="token keyword">WHERE</span> id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment"># 得到的列name的值为'张三'</span><span class="token comment"># SELECT2：Transaction 10提交，Transaction 20未提交</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> student <span class="token keyword">WHERE</span> id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment"># 得到的列name的值仍为'张三'  </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>SELECT2的执行过程如下:</p><ul><li>步骤1∶因为当前事务的隔离级别为<strong>REPEATABLE READ</strong>，而之前在执行SELECT1时<strong>已经生成过ReadView了</strong>，所以此时直接<strong>复用之前的ReadView</strong>，之前的ReadView的trx_ids列表的内容就是[10, 20]，up_limit_id为10,low_limit_id为21, creator_trx_id为0。</li><li>步骤2∶然后从版本链中挑选可见的记录，从图中可以看出，最新版本的列name的内容是’宋八’，该版本的trx_id值为20，在trx_ids列表内，所以不符合可见性要求，根据roll_pointer跳到下一个版本。步骤3:下一个版本的列name的内容是’钱七’，该版本的trx_id值为20，也在trx_ids列表内,所以也不符合要求，继续跳到下一个版本。</li><li>步骤4:下一个版本的列 name的内容是’王五’，该版本的trx_id值为10，而trx_ids列表中是包含值为10的事务id的，所以该版本也不符合要求，同理下一个列name的内容是’‘李四’的版本也不符合要求继续跳到下一个版本。</li><li>步骤5∶下一个版本的列 name的内容是‘张三’，该版本的trx_id值为80，小于ReadView中的up_limit_id值10，所以这个版本是符合要求的，最后返回给用户的版本就是这条列c为’张三’的记录。</li></ul><p><strong>实现重复读：</strong>    <strong>两次SELECT</strong>查询得到的结果是<strong>重复的</strong>，记录的列c值都是‘张三’，这就是<strong>可重复读的含义</strong>。如果我们之后再把事务id为20的记录提交了，然后再到刚才使用<strong>REPEATABLE READ</strong>隔离级别的事务中继续查找这个id为1的记录，得到的结果还是‘张三’，具体执行过程大家可以自己分析一下。</p><h3 id="5-3-如何解决幻读"><a href="#5-3-如何解决幻读" class="headerlink" title="5.3 如何解决幻读"></a>5.3 如何解决幻读</h3><p><strong>幻读</strong>：对于两个事务Session A、Session B, Session A 从一个表中 <strong>读取</strong> 了一个字段, 然后 Session B 在该表中 <strong>插入</strong> 了一些新的行。 之后, 如果 Session A 再次读取 <strong>同一个表</strong>, 就会<strong>多出几行</strong>。那就意味着发生了幻读。</p><p>接下来说明InnoDB 是如何解决幻读的（在<strong>REPEATABLE READ隔离级别</strong>下实现）。</p><p>假设现在表 student 中只有一条数据，数据内容中，主键 id=1，隐藏的 trx_id=10，它的 undo log 如下图所示。  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126214744710.png" alt="image-20220126214744710"></p><p>假设现在有事务 A 和事务 B 并发执行， <strong>事务 A</strong> 的事务 id 为 <strong>20</strong> ， <strong>事务 B</strong> 的事务 id 为 <strong>30</strong> 。</p><p>步骤1：事务 A 开始第一次查询数据，查询的 SQL 语句如下。  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> student <span class="token keyword">where</span> id <span class="token operator">>=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在开始查询之前，MySQL 会为事务 A 产生一个 ReadView，此时 ReadView 的内容如下： <strong>trx_ids=[20,30] ， up_limit_id=20 ， low_limit_id=31 ， creator_trx_id=20</strong> 。</p><p>由于此时表 student 中只有一条数据，且符合 where id&gt;=1 条件，因此会查询出来。然后根据 ReadView机制，发现该行数据的trx_id=10，小于事务 A 的 ReadView 里 up_limit_id，这表示这条数据是事务 A 开启之前，其他事务就已经提交了的数据，因此事务 A 可以读取到。</p><p>结论：事务 A 的第一次查询，能读取到一条数据，id=1。</p><p>步骤2：接着<strong>事务 B(trx_id=30)<strong>，往表 student 中</strong>新插入两条数据</strong>，<strong>并提交事务。</strong>  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">insert</span> <span class="token keyword">into</span> student<span class="token punctuation">(</span>id<span class="token punctuation">,</span>name<span class="token punctuation">)</span> <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">'李四'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">insert</span> <span class="token keyword">into</span> student<span class="token punctuation">(</span>id<span class="token punctuation">,</span>name<span class="token punctuation">)</span> <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token string">'王五'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>此时表student 中就有三条数据了，对应的 undo 如下图所示：  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126215023440.png" alt="image-20220126215023440"></p><p>步骤3：接着事务 A 开启第二次查询，根据可重复读隔离级别的规则，此时<strong>事务 A 并不会再重新生成ReadView</strong>。此时表 student 中的 3 条数据都满足 where id&gt;=1 的条件，因此会先查出来。然后根据ReadView 机制，<strong>判断每条数据是不是都可以被事务 A 看到</strong>。</p><p>1）首先 id=1 的这条数据，前面已经说过了，可以被事务 A 看到。</p><p>2）然后是 id=2 的数据，它的 trx_id=30，此时事务 A 发现，这个值处于 up_limit_id 和 low_limit_id 之间，因此还需要再判断 30 是否处于 trx_ids 数组内。由于事务 A 的 **trx_ids=[20,30]**，因此在数组内，这表示 id=2 的这条数据是与事务 A 在同一时刻启动的其他事务提交的，所以这条数据不能让事务 A 看到。</p><p>3）同理，id=3 的这条数据，trx_id 也为 30，因此也不能被事务 A 看见。  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126215044078.png" alt="image-20220126215044078"></p><p><strong>结论</strong>：最终事务 A 的第二次查询，只能查询出 id=1 的这条数据。这和事务 A 的第一次查询的结果是一样的，因此没有出现幻读现象，所以说<strong>在 MySQL 的可重复读隔离级别下，不存在幻读问题</strong>。  </p><h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h2><p>这里介绍了 MVCC 在 READ COMMITTD 、 REPEATABLE READ 这两种隔离级别的事务在执行快照读操作时访问记录的版本链的过程。这样使不同事务的 读-写 、 写-读 操作并发执行，从而提升系统性能。</p><p>核心点在于 ReadView 的原理， READ COMMITTD 、 REPEATABLE READ 这两个隔离级别的一个很大不同就是<strong>生成ReadView的时机不同</strong>：</p><ul><li>READ COMMITTD 在<strong>每一次进行普通SELECT操作前都会生成一个ReadView</strong></li><li>REPEATABLE READ <strong>只在第一次进行普通SELECT操作前生成一个ReadView</strong>，<strong>之后</strong>的查询操作<strong>都重复使用这个ReadView</strong>就好了。  </li></ul><pre class="line-numbers language-none"><code class="language-none">说明:我们之前说执行DELETE语句或者更新主键的UPDATE语句并不会立即把对应的记录完全从页面中删除,而是执行一个所谓的delete mark操作，相当于只是对记录打上了一个删除标志位，这主要就是为MVCC服务的。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>通过MVCC 我们可以解决:</strong></p><p>1.<strong>读写之间阻塞的问题</strong>。通过MVCC可以让读写互相不阻塞，即读不阻塞写，写不阻塞读，这样就可以提升事务并发处理能力。</p><p>2.<strong>降低了死锁的概率</strong>。这是因为MCC采用了乐观锁的方式，读取数据时并不需要加锁，对于写操作，也只锁定必要的行。</p><p>3.<strong>解决快照读的问题</strong>。当我们查询数据库在某个时间点的快照时，只能看到这个时间点之前事务提交更新的结果，而不能看到这个时间点之后事务提交的更新结果。</p>]]></content>
      
      
      <categories>
          
          <category> database </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL数据类型</title>
      <link href="/2022/01/26/MySQL%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2022/01/26/MySQL%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL数据类型精讲"><a href="#MySQL数据类型精讲" class="headerlink" title="MySQL数据类型精讲"></a>MySQL数据类型精讲</h1><h2 id="1-MySQL中的数据类型"><a href="#1-MySQL中的数据类型" class="headerlink" title="1. MySQL中的数据类型"></a>1. MySQL中的数据类型</h2><table><thead><tr><th>类型</th><th>类型举例</th></tr></thead><tbody><tr><td>整数类型</td><td>TINYINT、SMALLINT、MEDIUMINT、INT(或INTEGER)、BIGINT</td></tr><tr><td>浮点类型</td><td>FLOAT、DOUBLE</td></tr><tr><td>定点数类型</td><td>DECIMAL</td></tr><tr><td>位类型</td><td>BIT</td></tr><tr><td>日期时间类型</td><td>YEAR、TIME、DATE、DATETIME、TIMESTAMP</td></tr><tr><td>文本字符串类型</td><td>CHAR、VARCHAR、TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT</td></tr><tr><td>枚举类型</td><td>ENUM</td></tr><tr><td>集合类型</td><td>SET</td></tr><tr><td>二进制字符串类 型</td><td>BINARY、VARBINARY、TINYBLOB、BLOB、MEDIUMBLOB、LONGBLOB</td></tr><tr><td>JSON类型</td><td>JSON对象、JSON数组</td></tr><tr><td>空间数据类型</td><td>单值类型：GEOMETRY、POINT、LINESTRING、POLYGON； 集合类型：MULTIPOINT、MULTILINESTRING、MULTIPOLYGON、 GEOMETRYCOLLECTION</td></tr></tbody></table><p>常见数据类型的属性，如下：  </p><table><thead><tr><th>MySQL关键字</th><th>含义</th></tr></thead><tbody><tr><td>NULL</td><td>数据列可包含NULL值</td></tr><tr><td>NOT NULL</td><td>数据列不允许包含NULL值</td></tr><tr><td>DEFAULT</td><td>默认值</td></tr><tr><td>PRIMARY KEY</td><td>主键</td></tr><tr><td>AUTO_INCREMENT</td><td>自动递增，适用于整数类型</td></tr><tr><td>UNSIGNED</td><td>无符号</td></tr><tr><td>CHARACTER SET name</td><td>指定一个字符集</td></tr></tbody></table><h2 id="2-整数类型"><a href="#2-整数类型" class="headerlink" title="2.整数类型"></a>2.整数类型</h2><h3 id="2-1-类型介绍"><a href="#2-1-类型介绍" class="headerlink" title="2.1 类型介绍"></a>2.1 类型介绍</h3><p>整数类型一共有 5 种，包括 TINYINT、SMALLINT、MEDIUMINT、INT（INTEGER）和 BIGINT。它们的区别如下表所示：  </p><table><thead><tr><th>整数类型</th><th>字节</th><th>有符号数取值范围</th><th>无符号数取值范围</th></tr></thead><tbody><tr><td>TINYINT</td><td>1</td><td>-128~127 （1byte=8bit 共2^8个）</td><td>0~255</td></tr><tr><td>SMALLINT</td><td>2</td><td>-32768~32767</td><td>0~65535</td></tr><tr><td>MEDIUMINT</td><td>3</td><td>-8388608~8388607</td><td>0~16777215</td></tr><tr><td>INT、INTEGER</td><td>4</td><td>-2147483648~2147483647</td><td>0~4294967295</td></tr><tr><td>BIGINT</td><td>8</td><td>-9223372036854775808~9223372036854775807</td><td>0~18446744073709551615</td></tr></tbody></table><p><strong>超出范围会报错</strong>：<code>Out of range value for column &#39;f1&#39; at row 1</code></p><h3 id="2-2-可选属性"><a href="#2-2-可选属性" class="headerlink" title="2.2 可选属性"></a>2.2 可选属性</h3><p><strong>整数类型的可选属性有三个：</strong>  </p><h4 id="2-2-1-M"><a href="#2-2-1-M" class="headerlink" title="2.2.1 M"></a>2.2.1 M</h4><p>M : 表示<strong>显示宽度</strong>，M的取值范围是(0, 255)。例如，int(5)：当数据宽度小于5位的时候在数字前面需要用字符填满宽度。该项功能需要配合“ <strong>ZEROFILL</strong> ”使用，<strong>表示用“0”填满宽度</strong>，否则指定显示宽度无效。例如: TINYINT有符号数取值范围为 -128 ~ 127，TINYINT的默认显示宽度M=4，因为符号占1位，数字占3位。</p><p>如果设置了显示宽度，那么插入的数据宽度超过显示宽度限制，会不会截断或插入失败？</p><p>答案：不会对插入的数据有任何影响，还是按照类型的实际宽度进行保存，<strong>只要不超过该类型的范围</strong>，即 <strong>显示宽度与类型可以存储的值范围无关</strong> 。<strong>从MySQL 8.0.17开始，整数数据类型不推荐使用显示宽度属性。</strong></p><p>整型数据类型可以在定义表结构时指定所需要的显示宽度，如果不指定，则系统为每一种类型指定默认的宽度值。</p><p>举例：  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> test_int1 <span class="token punctuation">(</span> x <span class="token keyword">TINYINT</span><span class="token punctuation">,</span> y <span class="token keyword">SMALLINT</span><span class="token punctuation">,</span> z <span class="token keyword">MEDIUMINT</span><span class="token punctuation">,</span> m <span class="token keyword">INT</span><span class="token punctuation">,</span> n <span class="token keyword">BIGINT</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看表结构 （MySQL5.7中显式如下，MySQL8中不再显式范围）  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126110751054.png" alt="image-20220126110751054"></p><h4 id="2-2-2-UNSIGNED"><a href="#2-2-2-UNSIGNED" class="headerlink" title="2.2.2 UNSIGNED"></a>2.2.2 UNSIGNED</h4><p>UNSIGNED : 无符号类型（非负），所有的整数类型都有一个可选的属性UNSIGNED（无符号属性），无符号整数类型的最小取值为0。所以，如果需要在MySQL数据库中保存非负整数值时，可以将整数类型设置为无符号类型。</p><p>int类型默认显示宽度为int(11)，无符号int类型默认显示宽度为int(10)。  </p><h4 id="2-2-3-ZEROFILL"><a href="#2-2-3-ZEROFILL" class="headerlink" title="2.2.3 ZEROFILL"></a>2.2.3 ZEROFILL</h4><p>ZEROFILL : 0填充,（如果某列是ZEROFILL，那么MySQL会自动为当前列添加UNSIGNED属性），如果指定了ZEROFILL只是表示不够M位时，用0在左边填充，如果超过M位，只要不超过数据存储范围即可。</p><p>原来，在 int(M) 中，<strong>M 的值跟 int(M) 所占多少存储空间并无任何关系</strong>。 int(3)、int(4)、int(8) 在磁盘上<strong>都是占用 4 byte</strong> 的存储空间。也就是说，<strong>int(M)，必须和UNSIGNED ZEROFILL一起使用才有意义</strong>。如果整数值超过M位，就<strong>按照实际位数存储</strong>。只是无须再用字符 0 进行填充。  </p><h3 id="2-3-适用场景"><a href="#2-3-适用场景" class="headerlink" title="2.3 适用场景"></a>2.3 适用场景</h3><ul><li><strong>TINYINT</strong> ：一般用于枚举数据，比如系统设定取值范围很小且固定的场景。</li><li><strong>SMALLINT</strong> ：可以用于较小范围的统计数据，比如统计工厂的固定资产库存数量等。</li><li><strong>MEDIUMINT</strong> ：用于较大整数的计算，比如车站每日的客流量等。</li><li><strong>INT（INTEGER）</strong> ：取值范围足够大，一般情况下不用考虑超限问题，用得最多。比如商品编号。</li><li><strong>BIGINT</strong> ：只有当你处理特别巨大的整数时才会用到。比如双十一的交易量、大型门户网站点击量、证券公司衍生产品持仓等。  </li></ul><h3 id="2-4-如何选择？"><a href="#2-4-如何选择？" class="headerlink" title="2.4 如何选择？"></a>2.4 如何选择？</h3><p>在评估用哪种整数类型的时候，你需要考虑 存储空间 和 可靠性 的平衡问题：一方 面，用占用字节数少的整数类型可以节省存储空间；另一方面，要是为了节省存储空间， 使用的整数类型取值范围太小，一旦遇到超出取值范围的情况，就可能引起 系统错误 ，影响可靠性。</p><p>举个例子，商品编号采用的数据类型是 INT。原因就在于，客户门店中流通的商品种类较多，而且，每天都有旧商品下架，新商品上架，这样不断迭代，日积月累。</p><p>如果使用 SMALLINT 类型，虽然占用字节数比 INT 类型的整数少，但是却不能保证数据不会超出范围65535。相反，使用 INT，就能确保有足够大的取值范围，不用担心数据超出范围影响可靠性的问题。你要注意的是，在实际工作中，<strong>系统故障产生的成本远远超过增加几个字段存储空间所产生的成本。</strong>因此，我建议你首先确保数据不会超过取值范围，在这个前提之下，再去考虑如何节省存储空间。  </p><h2 id="3-浮点类型"><a href="#3-浮点类型" class="headerlink" title="3.浮点类型"></a>3.浮点类型</h2><h3 id="3-1-类型介绍"><a href="#3-1-类型介绍" class="headerlink" title="3.1 类型介绍"></a>3.1 类型介绍</h3><p>浮点数和定点数类型的特点是可以 <strong>处理小数</strong> ，你可以把整数看成小数的一个特例。因此，浮点数和定点数的使用场景，比整数大多了。 MySQL支持的浮点数类型，分别是 FLOAT、DOUBLE、REAL。</p><ul><li>FLOAT 表示单精度浮点数；</li><li>DOUBLE 表示双精度浮点数；  </li></ul><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126111542104.png" alt="image-20220126111542104"></p><p>REAL默认就是 DOUBLE。如果你把 SQL 模式设定为启用“ <strong>REAL_AS_FLOAT</strong> ”，那 么，MySQL 就认为REAL 是 FLOAT。如果要启用“REAL_AS_FLOAT”，可以通过以下 SQL 语句实现：  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SET</span> sql_mode <span class="token operator">=</span> “REAL_AS_FLOAT”<span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>问题1</strong>：FLOAT 和 DOUBLE 这两种数据类型的区别是啥呢？  </p><p>FLOAT 占用字节数少，取值范围小；DOUBLE 占用字节数多，取值范围也大。  </p><p><strong>问题2</strong>：为什么浮点数类型的无符号数取值范围，只相当于有符号数取值范围的一半，也就是<strong>只相当于有符号数取值范围大于等于零的部分</strong>呢？  有符号数取值范围大于等于零的部分呢？  </p><p>MySQL 存储浮点数的格式为： 符号(S) 、 尾数(M) 和 阶码(E) 。因此，无论有没有符号，MySQL 的浮点数都会存储表示符号的部分。因此， 所谓的无符号数取值范围，其实就是有符号数取值范围大于等于零的部分。  </p><h3 id="3-2-浮点数缺陷"><a href="#3-2-浮点数缺陷" class="headerlink" title="3.2 浮点数缺陷"></a>3.2 浮点数缺陷</h3><p>浮点数类型有个缺陷，就是不精准。下面我来重点解释一下为什么 MySQL 的浮点数不够精准。比如，我们设计一个表，有f1这个字段，插入值分别为0.47,0.44,0.19，我们期待的运行结果是：0.47 + 0.44 + 0.19 =1.1。而使用sum之后查询：  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> test_double2<span class="token punctuation">(</span>f1 <span class="token keyword">DOUBLE</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> test_double2<span class="token keyword">VALUES</span><span class="token punctuation">(</span><span class="token number">0.47</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">0.44</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">0.19</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126112530621.png" alt="image-20220126112530621"><p>查询结果是 1.0999999999999999。看到了吗？虽然误差很小，但确实有误差。 你也可以尝试把数据类型改成 FLOAT，然后运行求和查询，得到的是， 1.0999999940395355。显然，误差更大了。</p><p>那么，为什么会存在这样的误差呢？问题还是<strong>出在 MySQL 对浮点类型数据的存储方式上</strong>。</p><p>MySQL 用 4 个字节存储 FLOAT 类型数据，用 8 个字节来存储 DOUBLE 类型数据。无论哪个，都是采用二进制的方式来进行存储的。比如 9.625，用二进制来表达，就是 1001.101，或者表达成 1.001101×2^3。如果尾数不是 0 或 5（比如 9.624），你就无法用一个二进制数来精确表达。进而，就只好在取值允许的范围内进行四舍五入。</p><p>在编程中，如果用到浮点数，要特别注意误差问题，因为浮点数是不准确的，所以我们要<strong>避免使用“=”来判断两个数是否相等</strong>。同时，在一些对精确度要求较高的项目中，千万不要使用浮点数，不然会导致结果错误，甚至是造成不可挽回的损失。</p><p>那么，MySQL 有没有精准的数据类型呢？当然有，这就是<strong>定点数类型</strong>： <strong>DECIMAL</strong> 。  </p><h2 id="4-定点数类型"><a href="#4-定点数类型" class="headerlink" title="4. 定点数类型"></a>4. 定点数类型</h2><h3 id="4-1-类型介绍"><a href="#4-1-类型介绍" class="headerlink" title="4.1 类型介绍"></a>4.1 类型介绍</h3><p>MySQL中的定点数类型只有 DECIMAL 一种类型。  </p><table><thead><tr><th>数据类型</th><th>字节数</th><th>含义</th></tr></thead><tbody><tr><td>DECIMAL(M,D),DEC,NUMERIC</td><td>M+2字节</td><td>有效范围由M和D决定</td></tr></tbody></table><p>使用 DECIMAL(M,D) 的方式表示高精度小数。其中，M被称为精度，D被称为标度。<strong>0&lt;=M&lt;=65，0&lt;=D&lt;=30，D&lt;M</strong>。例如，定义DECIMAL（5,2）的类型，表示该列取值范围是-999.99~999.99。</p><p>DECIMAL(M,D)的<strong>最大取值范围与DOUBLE类型一样</strong>，但是有效的数据范围是由M和D决定的。DECIMAL 的存储空间并不是固定的，由精度值M决定，总共占用的存储空间为M+2个字节。也就是说，在一些对精度要求不高的场景下，比起占用同样字节长度的定点数，浮点数表达的数值范围可以更大一些。</p><p>定点数在MySQL内部是以 <strong>字符串</strong> 的形式进行存储，这就<strong>决定了它一定是精准的</strong>。当DECIMAL类型不指定精度和标度时，其默认为DECIMAL(10,0)。当数据的精度超出了定点数类型的精度范围时，则MySQL同样会进行四舍五入处理。  </p><p><strong>浮点数 vs 定点数</strong></p><p>浮点数相对于定点数的优点是在长度一定的情况下，浮点类型取值范围大，但是不精准，适用于需要取值范围大，又可以容忍微小误差的科学计算场景（比如计算化学、分子建模、流体动力学等）</p><p>定点数类型取值范围相对小，但是精准，没有误差，适合于对精度要求极高的场景 （比如涉及金额计算的场景）  </p><h3 id="4-2-开发中经验"><a href="#4-2-开发中经验" class="headerlink" title="4.2 开发中经验"></a>4.2 开发中经验</h3><p>“由于 DECIMAL 数据类型的精准性，在我们的项目中，除了极少数（比如商品编号）用到整数类型外，其他的数值都用的是 <strong>DECIMAL</strong>，原因就是这个项目所处的零售行业，要求精准，一分钱也不能差。 ” ——来自某项目经理  </p><h2 id="5-位类型：BIT"><a href="#5-位类型：BIT" class="headerlink" title="5.位类型：BIT"></a>5.位类型：BIT</h2><table><thead><tr><th>二进制字符串类型</th><th>长度</th><th>长度范围</th><th>占用空间</th></tr></thead><tbody><tr><td>BIT(M)</td><td>M</td><td>1 &lt;= M &lt;= 64</td><td>约为(M + 7)/8个字节</td></tr></tbody></table><p>BIT类型中存储的是二进制值，类似010110。</p><p>BIT类型，如果没有指定(M)，默认是1位。这个1位，表示只能存1位的二进制值。这里(M)是表示二进制的<br>位数，位数最小值为1，最大值为64。  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> test_bit1<span class="token punctuation">(</span>f1 <span class="token keyword">BIT</span><span class="token punctuation">,</span>f2 <span class="token keyword">BIT</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span>f3 <span class="token keyword">BIT</span><span class="token punctuation">(</span><span class="token number">64</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> test_bit1<span class="token punctuation">(</span>f1<span class="token punctuation">)</span><span class="token keyword">VALUES</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">#Data too long for column 'f1' at row 1</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> test_bit1<span class="token punctuation">(</span>f1<span class="token punctuation">)</span><span class="token keyword">VALUES</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> test_bit1<span class="token punctuation">(</span>f2<span class="token punctuation">)</span><span class="token keyword">VALUES</span><span class="token punctuation">(</span><span class="token number">23</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：在向BIT类型的字段中插入数据时，一定要确保插入的数据在BIT类型支持的范围内 。</p><h2 id="6-日期与时间类型"><a href="#6-日期与时间类型" class="headerlink" title="6.日期与时间类型"></a>6.日期与时间类型</h2><p>日期与时间是重要的信息，在我们的系统中，几乎所有的数据表都用得到。原因是客户需要知道数据的时间标签，从而进行数据查询、统计和处理。</p><p>MySQL有多种表示日期和时间的数据类型，不同的版本可能有所差异，MySQL8.0版本支持的日期和时间类型主要有：YEAR类型、TIME类型、DATE类型、DATETIME类型和TIMESTAMP类型。  </p><ul><li><strong>YEAR</strong> 类型通常用来表示年</li><li><strong>DATE</strong> 类型通常用来表示年、月、日</li><li><strong>TIME</strong> 类型通常用来表示时、分、秒</li><li><strong>DATETIME</strong> 类型通常用来表示年、月、日、时、分、秒</li><li><strong>TIMESTAMP</strong> 类型通常用来表示<strong>带时区</strong>的年、月、日、时、分、秒  </li></ul><table><thead><tr><th>类型</th><th>名称</th><th>字节</th><th>日期格式</th><th>最小值</th><th>最大值</th></tr></thead><tbody><tr><td>YEAR</td><td>年</td><td>1</td><td>YYYY或YY</td><td>1901</td><td>2155</td></tr><tr><td>TIME</td><td>时间</td><td>3</td><td>HH:MM:SS</td><td>-838:59:59</td><td>838:59:59</td></tr><tr><td>DATE</td><td>日期</td><td>3</td><td>YYYY-MM-DD</td><td>1000-01-01</td><td>9999-12-03</td></tr><tr><td>DATETIME</td><td>日期 时间</td><td>8</td><td>YYYY-MM-DD HH:MM:SS</td><td>1000-01-01 00:00:00</td><td>9999-12-31 23:59:59</td></tr><tr><td>TIMESTAMP</td><td>日期 时间</td><td>4</td><td>YYYY-MM-DD HH:MM:SS</td><td>1970-01-01 00:00:00 UTC</td><td>2038-01-19 03:14:07UTC</td></tr></tbody></table><p>为什么时间类型 TIME 的取值范围不是 -23:59:59～23:59:59 呢？原因是 MySQL 设计的 TIME 类型，不光表示一天之内的时间，而且可以用来<strong>表示一个时间间隔</strong>，这个时间间隔可以超过 24 小时。  </p><h3 id="6-1-YEAR类型"><a href="#6-1-YEAR类型" class="headerlink" title="6.1 YEAR类型"></a>6.1 YEAR类型</h3><p>YEAR类型用来表示年份，在所有的日期时间类型中所占用的存储空间最小，只需要 <strong>1个字节</strong> 的存储空间。</p><p>在MySQL中，YEAR有以下几种存储格式：</p><ul><li><p>以4位字符串或数字格式表示YEAR类型，其格式为YYYY，<strong>最小值为1901，最大值为2155</strong>。</p></li><li><p>以2位字符串格式表示YEAR类型，最小值为00，最大值为99。</p><ul><li><p>当取值为01到69时，表示2001到2069；</p></li><li><p>当取值为70到99时，表示1970到1999；</p></li><li><p>当取值整数的0或00添加的话，那么是0000年；</p></li><li><p>当取值是日期/字符串的’0’添加的话，是2000年。</p></li></ul></li></ul><p>从MySQL5.5.27开始，<strong>2位格式的YEAR已经不推荐使用。</strong>YEAR默认格式就是“YYYY”，没必要写成YEAR(4)，</p><p>从MySQL 8.0.19开始，<strong>不推荐使用指定显示宽度的YEAR(4)数据类型。</strong>  </p><h3 id="6-2-DATE类型"><a href="#6-2-DATE类型" class="headerlink" title="6.2 DATE类型"></a>6.2 DATE类型</h3><p>DATE类型<strong>表示日期，没有时间部分</strong>，格式为 <strong>YYYY-MM-DD</strong> ，其中，YYYY表示年份，MM表示月份，DD表示日期。需要 <strong>3个字节</strong> 的存储空间。在向DATE类型的字段插入数据时，同样需要满足一定的格式条件。</p><ul><li>以 <strong>YYYY-MM-DD</strong> 格式或者 <strong>YYYYMMDD</strong> 格式表示的字符串日期，其<strong>最小取值为1000-01-01，最大取值为9999-12-03</strong>。YYYYMMDD格式会被转化为YYYY-MM-DD格式。</li><li>以 <strong>YY-MM-DD</strong> 格式或者 <strong>YYMMDD</strong> 格式表示的字符串日期，此格式中，年份为两位数值或字符串满足YEAR类型的格式条件为：当年份取值为00到69时，会被转化为2000到2069；当年份取值为70到99时，会被转化为1970到1999。</li><li>使用 <strong>CURRENT_DATE()</strong> 或者 <strong>NOW()</strong> 函数，会插入当前系统的日期。</li></ul><p><strong>举例</strong> ： </p><p>创建数据表，表中只包含一个DATE类型的字段f1。  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> test_date1<span class="token punctuation">(</span>f1 <span class="token keyword">DATE</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Query OK<span class="token punctuation">,</span> <span class="token number">0</span> <span class="token keyword">rows</span> affected <span class="token punctuation">(</span><span class="token number">0.13</span> sec<span class="token punctuation">)</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>插入数据：</strong>  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> test_date1<span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'2020-10-01'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'20201001'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">20201001</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> test_date1<span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'00-01-01'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'000101'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'69-10-01'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'691001'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'70-01-01'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'700101'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">'99-01-01'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'990101'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> test_date1<span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">000301</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">690301</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">700301</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">990301</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> test_date1<span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token keyword">CURRENT_DATE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token function">NOW</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> <span class="token operator">*</span><span class="token keyword">FROM</span> test_date1<span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-3-TIME类型"><a href="#6-3-TIME类型" class="headerlink" title="6.3 TIME类型"></a>6.3 TIME类型</h3><p>TIME类型用来表示时间，不包含日期部分。在MySQL中，需要 3个字节 的存储空间来存储TIME类型的数据，可以使用“HH:MM:SS”格式来表示TIME类型，其中，HH表示小时，MM表示分钟，SS表示秒。</p><p>在MySQL中，向TIME类型的字段插入数据时，也可以使用几种不同的格式。 （1）可以使用带有冒号的字符串，比如’ D HH:MM:SS’ 、’ HH:MM:SS ‘、’ HH:MM ‘、’ D HH:MM ‘、’ D HH ‘或’ SS ‘格式，都能被正确地插入TIME类型的字段中。其中D表示天，其最小值为0，最大值为34。如果使用带有D格式的字符串插入TIME类型的字段时，D会被转化为小时，计算格式为D*24+HH。当使用带有冒号并且不带D的字符串表示时间时，表示当天的时间，比如12:10表示12:10:00，而不是00:12:10。 （2）可以使用不带有冒号的字符串或者数字，格式为’ HHMMSS ‘或者 HHMMSS 。如果插入一个不合法的字符串或者数字，MySQL在存储数据时，会将其自动转化为00:00:00进行存储。比如1210，MySQL会将最右边的两位解析成秒，表示00:12:10，而不是12:10:00。 （3）使用 CURRENT_TIME() 或者 NOW() ，会插入当前系统的时间。  </p><h3 id="6-4-DATETIME类型"><a href="#6-4-DATETIME类型" class="headerlink" title="6.4 DATETIME类型"></a>6.4 DATETIME类型</h3><p>DATETIME类型在所有的日期时间类型中占用的存储空间最大，总共需要 <strong>8</strong> 个字节的存储空间。在格式上为DATE类型和TIME类型的组合，可以表示为 <strong>YYYY-MM-DD HH:MM:SS</strong> ，其中YYYY表示年份，MM表示月份，DD表示日期，HH表示小时，MM表示分钟，SS表示秒。</p><p>在向DATETIME类型的字段插入数据时，同样需要满足一定的格式条件。</p><ul><li><p>以 <strong>YYYY-MM-DD HH:MM:SS</strong> 格式或者 <strong>YYYYMMDDHHMMSS</strong> 格式的字符串插入DATETIME类型的字段时，<strong>最小值为1000-01-01 00:00:00，最大值为9999-12-03 23:59:59</strong>。</p><ul><li><p>以YYYYMMDDHHMMSS格式的<strong>数字</strong>插入DATETIME类型的字段时，会被转化为YYYY-MM-DDHH:MM:SS格式。  </p></li><li><p>以 YY-MM-DD HH:MM:SS 格式或者 YYMMDDHHMMSS 格式的<strong>字符串</strong>插入DATETIME类型的字段时，两位数的年份规则符合YEAR类型的规则，00到69表示2000到2069；70到99表示1970到1999。  </p></li></ul></li><li><p>使用函数 <strong>CURRENT_TIMESTAMP()</strong> 和 <strong>NOW()</strong> ，可以向DATETIME类型的字段插入系统的当前日期和时间。  </p></li></ul><p><strong>举例：</strong></p><p>创建数据表，表中包含一个DATETIME类型的字段dt。  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> test_datetime1<span class="token punctuation">(</span>dt <span class="token keyword">DATETIME</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Query OK<span class="token punctuation">,</span> <span class="token number">0</span> <span class="token keyword">rows</span> affected <span class="token punctuation">(</span><span class="token number">0.02</span> sec<span class="token punctuation">)</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>插入数据：  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> test_datetime1<span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'2021-01-01 06:50:30'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'20210101065030'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> test_datetime1<span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'99-01-01 00:00:00'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'990101000000'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'20-01-01 00:00:00'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">'200101000000'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> test_datetime1<span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">20200101000000</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">200101000000</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">19990101000000</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">990101000000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> test_datetime1<span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token keyword">CURRENT_TIMESTAMP</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token function">NOW</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-5-TIMESTAMP类型"><a href="#6-5-TIMESTAMP类型" class="headerlink" title="6.5 TIMESTAMP类型"></a>6.5 TIMESTAMP类型</h3><p>TIMESTAMP类型也可以表示日期时间，其显示格式与DATETIME类型相同，都是 <strong>YYYY-MM-DD HH:MM:SS</strong> ，需要<strong>4个字节</strong>的存储空间。但是TIMESTAMP存储的<strong>时间范围比DATETIME要小很多</strong>，只能存储“<strong>1970-01-01 00:00:01 UTC”到“2038-01-19 03:14:07 UTC</strong>”之间的时间。其中，UTC表示世界统一时间，也叫作世界标准时间。</p><ul><li>存储数据的时候需要对当前时间所在的时区进行转换，查询数据的时候再将时间转换回当前的时区。因此，<strong>使用TIMESTAMP存储的同一个时间值，在不同的时区查询时会显示不同的时间</strong>。</li></ul><p>向TIMESTAMP类型的字段插入数据时，当插入的数据格式满足YY-MM-DD HH:MM:SS和YYMMDDHHMMSS时，两位数值的年份同样符合YEAR类型的规则条件，只不过表示的时间范围要小很多。</p><p>如果向TIMESTAMP类型的字段插入的时间超出了TIMESTAMP类型的范围，则MySQL会抛出错误信息。  </p><p><strong>举例：</strong></p><p>创建数据表，表中包含一个TIMESTAMP类型的字段ts。  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> test_timestamp1<span class="token punctuation">(</span>ts <span class="token keyword">TIMESTAMP</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>插入数据：  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> test_timestamp1<span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'1999-01-01 03:04:50'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'19990101030405'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'99-01-01 03:04:05'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">'990101030405'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> test_timestamp1<span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'2020@01@01@00@00@00'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'20@01@01@00@00@00'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> test_timestamp1<span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token keyword">CURRENT_TIMESTAMP</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token function">NOW</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">#Incorrect datetime value</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> test_timestamp1<span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'2038-01-20 03:14:07'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>TIMESTAMP和DATETIME的区别：</strong></p><ul><li>TIMESTAMP存储空间比较小，表示的日期时间范围也比较小</li><li>底层存储方式不同，TIMESTAMP底层存储的是毫秒值，距离1970-1-1 0:0:0 0毫秒的毫秒值。</li><li>两个日期比较大小或日期计算时，TIMESTAMP更方便、更快。</li><li>TIMESTAMP和时区有关。TIMESTAMP会根据用户的时区不同，显示不同的结果。而DATETIME则只能反映出插入时当地的时区，其他时区的人查看数据必然会有误差的  </li></ul><h3 id="6-6-开发中经验"><a href="#6-6-开发中经验" class="headerlink" title="6.6 开发中经验"></a>6.6 开发中经验</h3><p>用得最多的日期时间类型，就是 <strong>DATETIME</strong> 。虽然 MySQL 也支持 YEAR（年）、 TIME（时间）、DATE（日期），以及 TIMESTAMP 类型，但是在实际项目中，尽量用 DATETIME 类型。因为这个数据类型包括了完整的日期和时间信息，取值范围也最大，使用起来比较方便。毕竟，如果日期时间信息分散在好几个字段，很不容易记，而且查询的时候，SQL 语句也会更加复杂。</p><p>此外，一般存注册时间、商品发布时间等，不建议使用DATETIME存储，而是使用 <strong>时间戳</strong> ，因为DATETIME虽然直观，但不便于计算。</p><h2 id="7-文本字符串类型"><a href="#7-文本字符串类型" class="headerlink" title="7.文本字符串类型"></a>7.文本字符串类型</h2><p>在实际的项目中，我们还经常遇到一种数据，就是字符串数据。<br>MySQL中，文本字符串总体上分为 CHAR 、 VARCHAR 、 TINYTEXT 、 TEXT 、 MEDIUMTEXT 、LONGTEXT 、 ENUM 、 SET 等类型。  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126125947693.png" alt="image-20220126125947693"></p><h3 id="7-1-CHAR与VARCHAR类型"><a href="#7-1-CHAR与VARCHAR类型" class="headerlink" title="7.1 CHAR与VARCHAR类型"></a>7.1 CHAR与VARCHAR类型</h3><p>CHAR和VARCHAR类型都可以存储比较短的字符串。  </p><table><thead><tr><th>字符串(文本)类型</th><th>特点</th><th>长度</th><th>长度范围</th><th>占用的存储空间</th></tr></thead><tbody><tr><td>CHAR(M)</td><td>固定长度</td><td>M</td><td>0 &lt;= M &lt;= 255</td><td>M个字节</td></tr><tr><td>VARCHAR(M)</td><td>可变长度</td><td>M</td><td>0 &lt;= M &lt;= 65535</td><td>(实际长度 + 1) 个字节</td></tr></tbody></table><p><strong>CHAR类型：</strong></p><ul><li>CHAR(M) 类型<strong>一般需要预先定义字符串长度</strong>。如果不指定(M)，则表示长度默认是1个字符。</li><li>如果保存时，数据的实际长度比CHAR类型声明的长度小，则会在 <strong>右侧填充</strong> 空格以达到指定的长度。当MySQL检索CHAR类型的数据时，CHAR类型的字段会去除尾部的空格。</li><li>定义CHAR类型字段时，<strong>声明的字段长度即为CHAR类型字段所占的存储空间的字节数</strong>。  </li></ul><p><strong>VARCHAR类型：</strong></p><ul><li>VARCHAR(M) 定义时， <strong>必须指定长度M，否则报错</strong>。</li><li>MySQL4.0版本以下，varchar(20)：指的是20字节，如果存放UTF8汉字时，只能存6个（每个汉字3字节） ；MySQL5.0版本以上，varchar(20)：指的是20字符。</li><li>检索VARCHAR类型的字段数据时，会保留数据尾部的空格。VARCHAR类型的字段所占用的存储空间为字符串实际长度加1个字节。  </li></ul><p><strong>哪些情况使用 CHAR 或 VARCHAR 更好</strong>  </p><table><thead><tr><th>类型</th><th>特点</th><th>空间上</th><th>时间上</th><th>适用场景</th></tr></thead><tbody><tr><td>CHAR(M)</td><td>固定长度</td><td>浪费存储空间</td><td>效率高</td><td>存储不大，速度要求高</td></tr><tr><td>VARCHAR(M)</td><td>可变长度</td><td>节省存储空间</td><td>效率低</td><td>非CHAR的情况</td></tr></tbody></table><p>情况1：存储很短的信息用char。比如门牌号码101，201……这样很短的信息应该用char，因为varchar还要占个byte用于存储信息长度，本来打算节约存储的，结果得不偿失。  </p><p>情况2：固定长度的用char。比如<strong>使用<code>UUID</code>作为主键，那用char应该更合适</strong>。因为他<strong>固定长度</strong>，varchar动态根据长度的特性就消失了，而且还要占个长度信息。  </p><p>情况3：十分频繁改变的column用char。因为varchar每次存储都要有额外的计算，得到长度等工作，如果一个非常频繁改变的，那就要有很多的精力用于计算，而这些对于char来说是不需要的。</p><p>情况4：具体存储引擎中的情况：</p><ul><li>MyISAM 数据存储引擎和数据列：MyISAM数据表，最好使用固定长度(CHAR)的数据列代替可变长度(VARCHAR)的数据列。这样使得整个表静态化，从而使 数据检索更快 ，用空间换时间。</li><li>MEMORY 存储引擎和数据列：MEMORY数据表目前都使用固定长度的数据行存储，因此无论使用CHAR或VARCHAR列都没有关系，两者都是作为CHAR类型处理的。</li><li><strong>InnoDB 存储引擎，建议使用VARCHAR类型</strong>。因为对于InnoDB数据表，内部的行存储格式并没有区分固定长度和可变长度列（所有数据行都使用指向数据列值的头指针），而且主要影响性能的因素是数据行使用的存储总量，由于char平均占用的空间多于varchar，所以<strong>除了简短并且固定长度的，其他考虑varchar</strong>。这样节省空间，对磁盘I/O和数据存储总量比较好。  </li></ul><h3 id="7-2-TEXT类型"><a href="#7-2-TEXT类型" class="headerlink" title="7.2 TEXT类型"></a>7.2 TEXT类型</h3><p>在MySQL中，TEXT用来保存文本类型的字符串，总共包含4种类型，分别为TINYTEXT、TEXT、MEDIUMTEXT 和 LONGTEXT 类型。</p><p>在向TEXT类型的字段保存和查询数据时，系统自动按照实际长度存储，不需要预先定义长度。这一点和VARCHAR类型相同。</p><p>每种TEXT类型保存的数据长度和所占用的存储空间不同，如下：  </p><table><thead><tr><th>文本字符串类 型</th><th>特点</th><th>长 度</th><th>长度范围</th><th>占用的存储空 间</th></tr></thead><tbody><tr><td>TINYTEXT</td><td>小文本、可变长 度</td><td>L</td><td>0 &lt;= L &lt;= 255</td><td>L + 2 个字节</td></tr><tr><td>TEXT</td><td>文本、可变长度</td><td>L</td><td>0 &lt;= L &lt;= 65535</td><td>L + 2 个字节</td></tr><tr><td>MEDIUMTEXT</td><td>中等文本、可变 长度</td><td>L</td><td>0 &lt;= L &lt;= 16777215</td><td>L + 3 个字节</td></tr><tr><td>LONGTEXT</td><td>大文本、可变长 度</td><td>L</td><td>0 &lt;= L&lt;= 4294967295（相当于 4GB）</td><td>L + 4 个字节</td></tr></tbody></table><p>由于实际存储的长度不确定，<strong>MySQL 不允许 TEXT 类型的字段做主键</strong>。遇到这种情况，你只能采用CHAR(M)，或者 VARCHAR(M)。  </p><p><strong>举例：</strong></p><p>创建数据表：  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> test_text<span class="token punctuation">(</span>tx <span class="token keyword">TEXT</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> test_text<span class="token keyword">VALUES</span><span class="token punctuation">(</span><span class="token string">'atguigu '</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> CHAR_LENGTH<span class="token punctuation">(</span>tx<span class="token punctuation">)</span><span class="token keyword">FROM</span> test_text<span class="token punctuation">;</span> <span class="token comment">#10  </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明在保存和查询数据时，并没有删除TEXT类型的数据尾部的空格。</p><h3 id="开发中经验："><a href="#开发中经验：" class="headerlink" title="开发中经验："></a>开发中经验：</h3><p>TEXT文本类型，可以存比较大的文本段，搜索速度稍慢，因此如果不是特别大的内容，建议使用CHAR，VARCHAR来代替。还有<strong>TEXT类型不用加默认值</strong>，加了也没用。而且text和blob类型的数据删除后容易导致“<strong>空洞”，使得文件碎片比较多</strong>，所以频繁使用的表不建议包含TEXT类型字段，建议单独分出去，单独用一个表。  </p><h2 id="8-ENUM类型"><a href="#8-ENUM类型" class="headerlink" title="8.ENUM类型"></a>8.ENUM类型</h2><p>ENUM类型也叫作枚举类型，ENUM类型的取值范围需要在定义字段时进行指定。设置字段值时，ENUM类型只允许从成员中选取单个值，不能一次选取多个值。</p><p>其所需要的存储空间由定义ENUM类型时指定的成员个数决定。  </p><table><thead><tr><th>文本字符串类型</th><th>长度</th><th>长度范围</th><th>占用的存储空间</th></tr></thead><tbody><tr><td>ENUM</td><td>L</td><td>1 &lt;= L &lt;= 65535</td><td>1或2个字节</td></tr></tbody></table><ul><li>当ENUM类型包含1～255个成员时，需要<strong>1</strong>个字节的存储空间；</li><li>当ENUM类型包含256～65535个成员时，需要<strong>2</strong>个字节的存储空间。</li><li>ENUM类型的成员个数的上限为<strong>65535</strong>个。  </li></ul><p>举例：</p><p>创建表如下：  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> test_enum<span class="token punctuation">(</span>season <span class="token keyword">ENUM</span><span class="token punctuation">(</span><span class="token string">'春'</span><span class="token punctuation">,</span><span class="token string">'夏'</span><span class="token punctuation">,</span><span class="token string">'秋'</span><span class="token punctuation">,</span><span class="token string">'冬'</span><span class="token punctuation">,</span><span class="token string">'unknow'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>添加数据：  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> test_enum<span class="token keyword">VALUES</span><span class="token punctuation">(</span><span class="token string">'春'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">'秋'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment"># 忽略大小写</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> test_enum<span class="token keyword">VALUES</span><span class="token punctuation">(</span><span class="token string">'UNKNOW'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment"># 允许按照角标的方式获取指定索引位置的枚举值</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> test_enum<span class="token keyword">VALUES</span><span class="token punctuation">(</span><span class="token string">'1'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment"># Data truncated for column 'season' at row 1</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> test_enum<span class="token keyword">VALUES</span><span class="token punctuation">(</span><span class="token string">'ab'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment"># 当ENUM类型的字段没有声明为NOT NULL时，插入NULL也是有效的</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> test_enum<span class="token keyword">VALUES</span><span class="token punctuation">(</span><span class="token boolean">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="9-SET类型"><a href="#9-SET类型" class="headerlink" title="9. SET类型"></a>9. SET类型</h2><p>SET表示一个字符串对象，可以包含0个或多个成员，但成员个数的上限为 64 。设置字段值时，可以取取值范围内的 0 个或多个值。  </p><p>当SET类型包含的成员个数不同时，其所占用的存储空间也是不同的，具体如下 :</p><table><thead><tr><th>成员个数范围（L表示实际成员个数）</th><th>占用的存储空间</th></tr></thead><tbody><tr><td>1 &lt;= L &lt;= 8</td><td>1个字节</td></tr><tr><td>9 &lt;= L &lt;= 16</td><td>2个字节</td></tr><tr><td>17 &lt;= L &lt;= 24</td><td>3个字节</td></tr><tr><td>25 &lt;= L &lt;= 32</td><td>4个字节</td></tr><tr><td>33 &lt;= L &lt;= 64</td><td>8个字节</td></tr></tbody></table><p>SET类型在存储数据时成员个数越多，其占用的存储空间越大。注意：SET类型在选取成员时，可以一次选择多个成员，这一点与ENUM类型不同。</p><p>举例：</p><p>创建表：  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> test_set<span class="token punctuation">(</span>s <span class="token keyword">SET</span> <span class="token punctuation">(</span><span class="token string">'A'</span><span class="token punctuation">,</span> <span class="token string">'B'</span><span class="token punctuation">,</span> <span class="token string">'C'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>向表中插入数据：  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> test_set <span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'A'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'A,B'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">#插入重复的SET类型成员时，MySQL会自动删除重复的成员</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> test_set <span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'A,B,C,A'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">#向SET类型的字段插入SET成员中不存在的值时，MySQL会抛出错误。</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> test_set <span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'A,B,C,D'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> <span class="token operator">*</span><span class="token keyword">FROM</span> test_set<span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>举例：  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> temp_mul<span class="token punctuation">(</span>gender <span class="token keyword">ENUM</span><span class="token punctuation">(</span><span class="token string">'男'</span><span class="token punctuation">,</span><span class="token string">'女'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>hobby <span class="token keyword">SET</span><span class="token punctuation">(</span><span class="token string">'吃饭'</span><span class="token punctuation">,</span><span class="token string">'睡觉'</span><span class="token punctuation">,</span><span class="token string">'打豆豆'</span><span class="token punctuation">,</span><span class="token string">'写代码'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> temp_mul <span class="token keyword">VALUES</span><span class="token punctuation">(</span><span class="token string">'男'</span><span class="token punctuation">,</span><span class="token string">'睡觉,打豆豆'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">#成功</span><span class="token comment"># Data truncated for column 'gender' at row 1</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> temp_mul <span class="token keyword">VALUES</span><span class="token punctuation">(</span><span class="token string">'男,女'</span><span class="token punctuation">,</span><span class="token string">'睡觉,写代码'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">#失败</span><span class="token comment"># Data truncated for column 'gender' at row 1</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> temp_mul <span class="token keyword">VALUES</span><span class="token punctuation">(</span><span class="token string">'妖'</span><span class="token punctuation">,</span><span class="token string">'睡觉,写代码'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">#失败</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> temp_mul <span class="token keyword">VALUES</span><span class="token punctuation">(</span><span class="token string">'男'</span><span class="token punctuation">,</span><span class="token string">'睡觉,写代码,吃饭'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">#成功  </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="10"><li>二进制字符串类型  </li></ol><p>MySQL中的二进制字符串类型主要存储一些二进制数据，比如<strong>可以存储图片、音频和视频等二进制数据</strong>。</p><p>MySQL中支持的二进制字符串类型主要包括BINARY、VARBINARY、TINYBLOB、BLOB、MEDIUMBLOB 和LONGBLOB类型。</p><h3 id="BINARY与VARBINARY类型"><a href="#BINARY与VARBINARY类型" class="headerlink" title="BINARY与VARBINARY类型"></a><strong>BINARY与VARBINARY类型</strong></h3><p>BINARY和VARBINARY类似于CHAR和VARCHAR，只是它们存储的是二进制字符串。</p><p>BINARY (M)为固定长度的二进制字符串，M表示最多能存储的字节数，取值范围是0~255个字符。如果未指定(M)，表示只能存储 <strong>1个字节</strong> 。例如BINARY (8)，表示最多能存储8个字节，如果字段值不足(M)个字节，将在右边填充’\0’以补齐指定长度。</p><p>VARBINARY (M)为可变长度的二进制字符串，M表示最多能存储的字节数，总字节数不能超过行的字节长度限制65535，另外还要考虑额外字节开销，VARBINARY类型的数据除了存储数据本身外，还需要1或2个字节来存储数据的字节数。<strong>VARBINARY类型 必须指定(M) ，否则报错。</strong>  </p><table><thead><tr><th>二进制字符串类型</th><th>特点</th><th>值的长度</th><th>占用空间</th></tr></thead><tbody><tr><td>BINARY(M)</td><td>固定长度</td><td>M （0 &lt;= M &lt;= 255）</td><td>M个字节</td></tr><tr><td>VARBINARY(M)</td><td>可变长度</td><td>M（0 &lt;= M &lt;= 65535）</td><td>M+1个字节</td></tr></tbody></table><h3 id="BLOB类型"><a href="#BLOB类型" class="headerlink" title="BLOB类型"></a>BLOB类型</h3><p>BLOB是一个 <strong>二进制大对象</strong> ，可以容纳可变数量的数据。  </p><p>MySQL中的BLOB类型包括TINYBLOB、BLOB、MEDIUMBLOB和LONGBLOB 4种类型，它们可容纳值的最大长度不同。可以存储一个二进制的大对象，比如 图片 、 音频 和 视频 等。</p><p>需要注意的是，在实际工作中，往往不会在MySQL数据库中使用BLOB类型存储大对象数据，通常会将图片、音频和视频文件存储到 <strong>服务器的磁盘上</strong> ，并将图片、音频和视频的<strong>访问路径存储到MySQL中</strong>。  </p><table><thead><tr><th>二进制字符串类型</th><th>值的长度</th><th>长度范围</th><th>占用空间</th></tr></thead><tbody><tr><td>TINYBLOB</td><td>L</td><td>0 &lt;= L &lt;= 255</td><td>L + 1 个字节</td></tr><tr><td>BLOB</td><td>L</td><td>0 &lt;= L &lt;= 65535（相当于64KB）</td><td>L + 2 个字节</td></tr><tr><td>MEDIUMBLOB</td><td>L</td><td>0 &lt;= L &lt;= 16777215 （相当于16MB）</td><td>L + 3 个字节</td></tr><tr><td>LONGBLOB</td><td>L</td><td>0 &lt;= L &lt;= 4294967295（相当于4GB）</td><td>L + 4 个字节</td></tr></tbody></table><p>举例：  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> test_blob1<span class="token punctuation">(</span>id <span class="token keyword">INT</span><span class="token punctuation">,</span>img <span class="token keyword">MEDIUMBLOB</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>TEXT和BLOB的使用注意事项：</p><p>在使用text和blob字段类型时要注意以下几点，以便更好的发挥数据库的性能。</p><ul><li>① BLOB和TEXT值也会引起自己的一些问题，特别是执行了大量的删除或更新操作的时候。删除这种值会在数据表中留下很大的” <strong>空洞</strong> “，以后填入这些”空洞”的记录可能长度不同。为了提高性能，建议定期使用 OPTIMIZE TABLE 功能对这类表进行 <strong>碎片整理</strong> 。</li><li>② 如果需要对大文本字段进行模糊查询，MySQL 提供了 <strong>前缀索引</strong> 。但是仍然要在不必要的时候避免检索大型的BLOB或TEXT值。例如，SELECT * 查询就不是很好的想法，除非你能够确定作为约束条件的WHERE子句只会找到所需要的数据行。否则，你可能毫无目的地在网络上传输大量的值。</li><li>③ 把BLOB或TEXT列 <strong>分离到单独的表</strong> 中。在某些环境中，如果把这些数据列移动到第二张数据表中，可以让你把原数据表中的数据列转换为固定长度的数据行格式，那么它就是有意义的。这会 <strong>减少主表中的碎片</strong> ，使你得到固定长度数据行的性能优势。它还使你在主数据表上运行 SELECT * 查询的时候不会通过网络传输大量的BLOB或TEXT值。  </li></ul><h2 id="11-JSON-类型"><a href="#11-JSON-类型" class="headerlink" title="11. JSON 类型"></a>11. JSON 类型</h2><p>JSON（JavaScript Object Notation）是一种轻量级的 <strong>数据交换格式</strong> 。简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。它易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。JSON 可以将 JavaScript 对象中表示的一组数据转换为字符串，然后就可以在网络或者程序之间轻松地传递这个字符串，并在需要的时候将它还原为各编程语言所支持的数据格式。</p><p>在MySQL 5.7中，就已经支持JSON数据类型。在MySQL 8.x版本中，JSON类型提供了可以进行自动验证的JSON文档和优化的存储结构，使得在MySQL中存储和读取JSON类型的数据更加方便和高效。 创建数据表，表中包含一个JSON类型的字段 js 。  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> test_json<span class="token punctuation">(</span>js json<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>向表中插入JSON数据。  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> test_json <span class="token punctuation">(</span>js<span class="token punctuation">)</span><span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'&#123;"name":"songhk", "age":18, "address":&#123;"province":"beijing","city":"beijing"&#125;&#125;'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>查询t19表中的数据  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">SELECT</span> <span class="token operator">*</span><span class="token operator">-</span><span class="token operator">></span> <span class="token keyword">FROM</span> test_json<span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>当需要检索JSON类型的字段中数据的某个具体值时，可以使用“-&gt;”和“-&gt;&gt;”符号。  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126132424633.png" alt="image-20220126132424633"></p><p>通过“-&gt;”和“-&gt;&gt;”符号，从JSON字段中正确查询出了指定的JSON数据的值。  </p><h2 id="12-小结及选择建议"><a href="#12-小结及选择建议" class="headerlink" title="12. 小结及选择建议"></a>12. 小结及选择建议</h2><p>在定义数据类型时，如果确定是 <strong>整数</strong> ，就用 INT ； 如果是 小数 ，一定用定点数类型DECIMAL(M,D) ； 如果是日期与时间，就用 DATETIME 。<br>这样做的好处是，首先确保你的系统不会因为数据类型定义出错。不过，凡事都是有两面的，可靠性好，并不意味着高效。比如，TEXT 虽然使用方便，但是效率不如 CHAR(M) 和 VARCHAR(M)。</p><p>关于字符串的选择，建议参考如下阿里巴巴的《Java开发手册》规范：  </p><p><strong>阿里巴巴《Java开发手册》之MySQL数据库：</strong></p><ul><li>任何字段如果为<strong>非负数</strong>，必须是 <code>UNSIGNED</code></li><li><strong>【 强制 】</strong>小数类型为 <strong>DECIMAL</strong>，禁止使用 FLOAT 和 DOUBLE。<br>说明：在存储的时候，FLOAT 和 DOUBLE 都存在精度损失的问题，很可能在比较值的时候，得到不正确的结果。如果存储的数据范围超过 DECIMAL 的范围，建议将数据拆成整数和小数并分开存储。</li><li><strong>【 强制 】</strong>如果存储的字符串长度几乎相等，使用 <strong>CHAR</strong> 定长字符串类型。</li><li><strong>【 强制 】</strong>VARCHAR 是可变长字符串，不预先分配存储空间，长度不要超过 <strong>5000</strong>。如果存储长度大于此值，定义字段类型为 TEXT，独立出来一张表，用主键来对应，避免影响其它字段索引效率。  </li></ul>]]></content>
      
      
      <categories>
          
          <category> database </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>多表查询</title>
      <link href="/2022/01/25/%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2/"/>
      <url>/2022/01/25/%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h1><p>多表查询，也称为关联查询，指两个或更多个表一起完成查询操作。</p><p>前提条件：这些一起查询的表之间是有关系的（一对一、一对多），它们之间一定是有关联字段，这个关联字段可能建立了外键，也可能没有建立外键。比如：员工表和部门表，这两个表依靠“部门编号”进行关联。  </p><h2 id="1-一个案例引发的多表连接"><a href="#1-一个案例引发的多表连接" class="headerlink" title="1.一个案例引发的多表连接"></a>1.一个案例引发的多表连接</h2><h3 id="1-1-案例说明"><a href="#1-1-案例说明" class="headerlink" title="1.1 案例说明"></a>1.1 案例说明</h3><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220125162712644.png" alt="image-20220125162712644"></p><p>从多个表中获取数据：  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220125162742939.png" alt="image-20220125162742939"></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">#案例：查询员工的姓名及其部门名称</span><span class="token keyword">SELECT</span> last_name<span class="token punctuation">,</span> department_name <span class="token keyword">FROM</span> employees<span class="token punctuation">,</span> departments<span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220125162802341.png" alt="image-20220125162802341"></p><p>查询结果：  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220125162830410.png" alt="image-20220125162830410"></p><p><strong>2889 rows in set (0.01 sec)</strong>  </p><p><strong>分析错误情况 ：</strong></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token function">COUNT</span><span class="token punctuation">(</span>employee_id<span class="token punctuation">)</span> <span class="token keyword">FROM</span> employees<span class="token punctuation">;</span><span class="token comment">#输出107行</span><span class="token keyword">SELECT</span> <span class="token function">COUNT</span><span class="token punctuation">(</span>department_id<span class="token punctuation">)</span><span class="token keyword">FROM</span> departments<span class="token punctuation">;</span><span class="token comment">#输出27行</span><span class="token keyword">SELECT</span> <span class="token number">107</span><span class="token operator">*</span><span class="token number">27</span> <span class="token keyword">FROM</span> dual<span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们把上述多表查询中出现的问题称为：笛卡尔积的错误。  </p><h3 id="1-2-笛卡尔积（或交叉连接）的理解"><a href="#1-2-笛卡尔积（或交叉连接）的理解" class="headerlink" title="1.2 笛卡尔积（或交叉连接）的理解"></a>1.2 笛卡尔积（或交叉连接）的理解</h3><p>笛卡尔乘积是一个数学运算。假设我有两个集合 X 和 Y，那么 X 和 Y 的笛卡尔积就是 X 和 Y 的所有可能组合，也就是第一个对象来自于 X，第二个对象来自于 Y 的所有可能。组合的个数即为两个集合中元素个数的乘积数。  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220125162944790.png" alt="image-20220125162944790"></p><p>SQL92中，笛卡尔积也称为 <strong>交叉连接</strong> ，英文是 <strong>CROSS JOIN</strong> 。在 SQL99 中也是使用 CROSS JOIN表示交叉连接。它的作用就是可以把任意表进行连接，即使这两张表不相关。在MySQL中如下情况会出现笛卡尔积：</p><ul><li><p><strong>笛卡尔积的错误会在下面条件下产生：</strong></p><ul><li><p>省略多个表的连接条件（或关联条件）</p></li><li><p>连接条件（或关联条件）无效</p></li><li><p>所有表中的所有行互相连接</p></li></ul></li></ul><p>为了避免笛卡尔积， <strong>可以在 WHERE 加入有效的连接条件</strong>。</p><p>加入连接条件后，查询语法：  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> table1<span class="token punctuation">.</span><span class="token keyword">column</span><span class="token punctuation">,</span> table2<span class="token punctuation">.</span><span class="token keyword">column</span><span class="token keyword">FROM</span> table1<span class="token punctuation">,</span> table2<span class="token keyword">WHERE</span> table1<span class="token punctuation">.</span>column1 <span class="token operator">=</span> table2<span class="token punctuation">.</span>column2<span class="token punctuation">;</span> <span class="token comment">#连接条件  </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>正确写法：  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">#案例：查询员工的姓名及其部门名称</span><span class="token keyword">SELECT</span> last_name<span class="token punctuation">,</span> department_name<span class="token keyword">FROM</span> employees<span class="token punctuation">,</span> departments<span class="token keyword">WHERE</span> employees<span class="token punctuation">.</span>department_id <span class="token operator">=</span> departments<span class="token punctuation">.</span>department_id<span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>在表中有相同列时，在列名之前加上表名前缀。</strong>  <code>从SQL优化的角度，建议多表查询时，每个字段都指明其所在的表。</code></p><h2 id="2-多表查询分类讲解"><a href="#2-多表查询分类讲解" class="headerlink" title="2.多表查询分类讲解"></a>2.多表查询分类讲解</h2><h3 id="分类1：等值连接-vs-非等值连接"><a href="#分类1：等值连接-vs-非等值连接" class="headerlink" title="分类1：等值连接 vs 非等值连接"></a>分类1：等值连接 vs 非等值连接</h3><h4 id="等值连接"><a href="#等值连接" class="headerlink" title="等值连接"></a>等值连接</h4><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220125163431595.png" alt="image-20220125163431595"></p><p>例如上图中，从表<code> EMPLOYEES</code>中的 <code>DEPARTMENT_ID</code>对应表 <code>DEPARTMENTS</code>中的<code>DEPARTMENT_ID</code>， 我们要查询通过两张表中查询某员工的部门名称，那么就是通过两张表的<code>DEPARTMENT_ID</code>来进行连接的。通过两张表中字段确定的值来查询，这样的就叫做<strong>等值连接</strong>。</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220125163915473.png" alt="image-20220125163915473"></p><p><strong>拓展1：区分重复的列名</strong>  </p><ul><li>多个表中有相同列时，必须在列名之前加上表名前缀。</li><li>在不同表中具有相同列名的列可以用 <strong>表名</strong> 加以区分。  </li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> employees<span class="token punctuation">.</span>last_name<span class="token punctuation">,</span> departments<span class="token punctuation">.</span>department_name<span class="token punctuation">,</span>employees<span class="token punctuation">.</span>department_id<span class="token keyword">FROM</span> employees<span class="token punctuation">,</span> departments<span class="token keyword">WHERE</span> employees<span class="token punctuation">.</span>department_id <span class="token operator">=</span> departments<span class="token punctuation">.</span>department_id<span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>拓展2：表的别名</strong>  </p><ul><li>使用别名可以简化查询。</li><li>列名前使用表名前缀可以提高查询效率。  </li><li><strong>需要注意的是</strong>，如果我们使用了表的别名，在查询字段中、过滤条件中就只能使用别名进行代替，不能使用原有的表名，否则就会报错  </li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> e<span class="token punctuation">.</span>employee_id<span class="token punctuation">,</span> e<span class="token punctuation">.</span>last_name<span class="token punctuation">,</span> e<span class="token punctuation">.</span>department_id<span class="token punctuation">,</span>d<span class="token punctuation">.</span>department_id<span class="token punctuation">,</span> d<span class="token punctuation">.</span>location_id<span class="token keyword">FROM</span> employees e <span class="token punctuation">,</span> departments d<span class="token keyword">WHERE</span> e<span class="token punctuation">.</span>department_id <span class="token operator">=</span> d<span class="token punctuation">.</span>department_id<span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>【强制】</strong>对于数据库中表记录的查询和变更，只要涉及多个表，都需要在列名前加表的别名（或表名）进行限定。</p><p><strong>说明</strong> ：对多表进行查询记录、更新记录、删除记录时，如果对操作列没有限定表的别名（或表名），并且操作列在多个表中存在时，就会抛异常。</p><p><strong>正例</strong> ：select t1.name from table_first as t1 , table_second as t2 where t1.id=t2.id;</p><p><strong>反例</strong> ：在某业务中，由于多表关联查询语句没有加表的别名（或表名）的限制，正常运行两年后，最近在 某个表中增加一个同名字段，在预发布环境做数据库变更后，线上查询语句出现出1052 异常：Column ‘name’ in field list is ambiguous。  </p><p><strong>拓展3：连接多个表</strong>  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220125164547569.png" alt="image-20220125164547569"></p><p><strong>总结：连接 n个表,至少需要n-1个连接条件</strong>。比如，连接三个表，至少需要两个连接条件。  </p><h4 id="非等值连接"><a href="#非等值连接" class="headerlink" title="非等值连接"></a>非等值连接</h4><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220125164609522.png" alt="image-20220125164609522"></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> e<span class="token punctuation">.</span>last_name<span class="token punctuation">,</span> e<span class="token punctuation">.</span>salary<span class="token punctuation">,</span> j<span class="token punctuation">.</span>grade_level<span class="token keyword">FROM</span> employees e<span class="token punctuation">,</span> job_grades j<span class="token keyword">WHERE</span> e<span class="token punctuation">.</span>salary <span class="token operator">BETWEEN</span> j<span class="token punctuation">.</span>lowest_sal <span class="token operator">AND</span> j<span class="token punctuation">.</span>highest_sal<span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220125164952009.png" alt="image-20220125164952009"></p><p>例如通过表<code>EMPLOYEES</code>查询该员工所在的工资等级GRA，是利用表<code>EMPLOYEES</code>的<code>SALARY</code>字段的值，看其处于表<code>JOB_GRADES</code>的那个范围，这就是<strong>非等值查询连接</strong>。</p><h3 id="分类2：自连接-vs-非自连接"><a href="#分类2：自连接-vs-非自连接" class="headerlink" title="分类2：自连接 vs 非自连接"></a>分类2：自连接 vs 非自连接</h3><p>之前查询并且连接不同的表，都是<strong>非自连接</strong>。</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220125165056389.png" alt="image-20220125165056389"></p><p>利用一张表<code>EMPLOYEES</code>，使得一行中显示员工的管理者，也就是表自己和自己连接。</p><p>当table1和table2本质上是同一张表，只是<strong>用取别名的方式虚拟成两张表</strong>以代表不同的意义。然后两个表再进行内连接，外连接等查询。  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> employee_id<span class="token punctuation">,</span> department_nameFROMemployees e<span class="token punctuation">,</span>departments d<span class="token keyword">WHERE</span> e<span class="token punctuation">.</span> 'department_id<span class="token punctuation">`</span> <span class="token operator">=</span> d<span class="token punctuation">.</span>department_id<span class="token punctuation">;</span> <span class="token comment">#只有106条记录，表EMPLOYEES中共107条记录</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>因为这是<strong>内连接查询</strong>，只会将符合查询条件的查询出来。（剩余一个员工是最上级，再没有管理者）</p><h3 id="分类3：内连接-vs-外连接"><a href="#分类3：内连接-vs-外连接" class="headerlink" title="分类3：内连接 vs 外连接"></a>分类3：内连接 vs 外连接</h3><p>除了查询满足条件的记录以外，外连接还可以查询某一方<strong>不满足条件的记录</strong> 。</p><ul><li><p><strong>内连接:</strong> 合并具有同一列的两个以上的表的行, 结果集中不包含一个表与另一个表不匹配的行 （<strong>满足匹配条件的查出来，不满足条件的不会查出来</strong>）</p></li><li><p><strong>外连接:</strong> 两个表在连接过程中除了返回满足连接条件的行以外还返回左（或右）表中不满足条件的行 ，这种连接称为左（或右） 外连接。没有匹配的行时, 结果表中相应的列为空(NULL)。(<strong>把不满足条件的也查询出来</strong>)</p><ul><li>如果是<strong>左外连接</strong><code>LEFT JOIN</code>，则连接条件中左边的表也称为 <strong>主表</strong> ，右边的表称为 <strong>从表</strong> 。（左边不满足的查出来）</li></ul><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/img_leftjoin.gif" alt="SQL LEFT JOIN"></p><ul><li>如果是<strong>右外连接</strong><code>RIGHT JOIN</code> ，则连接条件中右边的表也称为 <strong>主表</strong> ，左边的表称为 <strong>从表</strong> 。 （右边不满足的查出来）</li></ul></li></ul><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/img_rightjoin.gif" alt="SQL RIGHT JOIN"></p><ul><li><strong>满外连接</strong> <code>FULL OUTER JOIN </code>关键字<strong>只要左表（table1）和右表（table2）其中一个表中存在匹配</strong>，则返回行。<code>FULL OUTER JOIN </code>关键字结合了<code> LEFT JOIN</code> 和 <code>RIGHT JOIN </code>的结果。</li></ul><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/img_fulljoin.gif" alt="SQL FULL OUTER JOIN"></p><p>SQL92语法实现内连接：见上</p><h3 id="SQL92：使用-创建连接"><a href="#SQL92：使用-创建连接" class="headerlink" title="SQL92：使用(+)创建连接"></a>SQL92：使用(+)创建连接</h3><p>在 SQL92 中采用（+）代表从表所在的位置。即左或右外连接中，(+) 表示哪个是从表。</p><p>Oracle 对 SQL92 支持较好，而 <strong>MySQL 则不支持 SQL92 的外连接</strong>  （！！！！！说了个卵）</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">#左外连接</span><span class="token keyword">SELECT</span> last_name<span class="token punctuation">,</span>department_name<span class="token keyword">FROM</span> employees <span class="token punctuation">,</span>departments<span class="token keyword">WHERE</span> employees<span class="token punctuation">.</span>department_id <span class="token operator">=</span> departments<span class="token punctuation">.</span>department_id<span class="token punctuation">(</span><span class="token operator">+</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">#右外连接</span><span class="token keyword">SELECT</span> last_name<span class="token punctuation">,</span>department_name<span class="token keyword">FROM</span> employees <span class="token punctuation">,</span>departments<span class="token keyword">WHERE</span> employees<span class="token punctuation">.</span>department_id<span class="token punctuation">(</span><span class="token operator">+</span><span class="token punctuation">)</span> <span class="token operator">=</span> departments<span class="token punctuation">.</span>department_id<span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而且在 SQL92 中，只有左外连接和右外连接，没有满（或全）外连接。  </p><p>因此我们要学习SQL99语法实现多表查询 。</p><h2 id="3-SQL99语法实现多表查询"><a href="#3-SQL99语法实现多表查询" class="headerlink" title="3. SQL99语法实现多表查询"></a>3. SQL99语法实现多表查询</h2><p>SQL99语法使用<code>JOIN ... ON</code>的方式实现多表查询，可解决外连接的问题。<strong>MySQL支持SQL99的外连接</strong>。</p><h4 id="3-1-基本语法"><a href="#3-1-基本语法" class="headerlink" title="3.1 基本语法"></a>3.1 基本语法</h4><p><strong>使用<code>JOIN...ON子</code>句创建连接的语法结构：</strong>  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> table1<span class="token punctuation">.</span><span class="token keyword">column</span><span class="token punctuation">,</span> table2<span class="token punctuation">.</span><span class="token keyword">column</span><span class="token punctuation">,</span>table3<span class="token punctuation">.</span><span class="token keyword">column</span><span class="token keyword">FROM</span> table1<span class="token keyword">JOIN</span> table2 <span class="token keyword">ON</span> table1 和 table2 的连接条件<span class="token keyword">JOIN</span> table3 <span class="token keyword">ON</span> table2 和 table3 的连接条件  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>它的嵌套逻辑类似我们使用的 FOR 循环：  </p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">for</span> t1 in table1<span class="token operator">:</span><span class="token keyword">for</span> t2 in table2<span class="token operator">:</span><span class="token keyword">if</span> condition1<span class="token operator">:</span><span class="token keyword">for</span> t3 in table3<span class="token operator">:</span><span class="token keyword">if</span> condition2<span class="token operator">:</span>output t1 <span class="token operator">+</span> t2 <span class="token operator">+</span> t3  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>SQL99 采用的这种嵌套结构非常清爽、层次性更强、可读性更强，即使再多的表进行连接也都清晰可见。如果你采用 SQL92，可读性就会大打折扣。  </p><p><strong>语法说明：</strong></p><ul><li>可以使用 ON 子句指定额外的连接条件。</li><li>这个连接条件是与其它条件分开的。</li><li>ON 子句使语句具有更高的易读性。</li><li>关键字 JOIN、INNER JOIN、CROSS JOIN 的含义是一样的，都表示内连接  </li></ul><h4 id="3-2-内连接-INNER-JOIN-的实现"><a href="#3-2-内连接-INNER-JOIN-的实现" class="headerlink" title="3.2 内连接(INNER JOIN)的实现"></a>3.2 内连接(INNER JOIN)的实现</h4><p><strong>语法：</strong></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> 字段列表<span class="token keyword">FROM</span> A表 <span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> B表<span class="token keyword">ON</span> 关联条件<span class="token keyword">WHERE</span> 等其他子句<span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>例：</p><p>三张表<code>employees</code>,<code>locations</code>,<code>departments</code></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> last_name<span class="token punctuation">,</span> department_name <span class="token keyword">FROM</span> employees e <span class="token keyword">JOIN</span> departments d<span class="token keyword">ON</span> e<span class="token punctuation">.</span>department_id <span class="token operator">=</span> d<span class="token punctuation">.</span>department_id<span class="token keyword">JOIN</span> locations l <span class="token keyword">ON</span> d<span class="token punctuation">.</span>location_id <span class="token operator">=</span> l<span class="token punctuation">.</span>location_id<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-3-外连接-OUTER-JOIN-的实现"><a href="#3-3-外连接-OUTER-JOIN-的实现" class="headerlink" title="3.3 外连接(OUTER JOIN)的实现"></a>3.3 外连接(OUTER JOIN)的实现</h4><h5 id="3-3-1-左外连接-LEFT-OUTER-JOIN"><a href="#3-3-1-左外连接-LEFT-OUTER-JOIN" class="headerlink" title="3.3.1 左外连接(LEFT OUTER JOIN)"></a>3.3.1 左外连接(LEFT OUTER JOIN)</h5><ul><li>语法：</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">#实现查询结果是A</span><span class="token keyword">SELECT</span> 字段列表<span class="token keyword">FROM</span> A表 <span class="token keyword">LEFT</span> <span class="token keyword">JOIN</span><span class="token punctuation">(</span>或 <span class="token keyword">LEFT</span> <span class="token keyword">OUTER</span> <span class="token keyword">JOIN</span><span class="token punctuation">)</span> B表<span class="token keyword">ON</span> 关联条件<span class="token keyword">WHERE</span> 等其他子句<span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>举例：</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> e<span class="token punctuation">.</span>last_name<span class="token punctuation">,</span> e<span class="token punctuation">.</span>department_id<span class="token punctuation">,</span> d<span class="token punctuation">.</span>department_name<span class="token keyword">FROM</span> employees e <span class="token keyword">LEFT</span> <span class="token keyword">OUTER</span> <span class="token keyword">JOIN</span> departments d<span class="token keyword">ON</span> e<span class="token punctuation">.</span>department_id <span class="token operator">=</span> d<span class="token punctuation">.</span>department_id<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220125191635213.png" alt="image-20220125191635213"></p><p>3.3.2 右外连接(RIGHT OUTER JOIN)  </p><ul><li>语法</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> 字段列表<span class="token keyword">FROM</span> A表 <span class="token keyword">RIGHT</span> JOI<span class="token keyword">ON</span> 关联条件<span class="token keyword">WHERE</span> 等其他子句<span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>举例：  </li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> e<span class="token punctuation">.</span>last_name<span class="token punctuation">,</span> e<span class="token punctuation">.</span>department_id<span class="token punctuation">,</span> d<span class="token punctuation">.</span>department_name<span class="token keyword">FROM</span> employees e<span class="token keyword">RIGHT</span> <span class="token keyword">OUTER</span> <span class="token keyword">JOIN</span> departments  d<span class="token keyword">ON</span> e<span class="token punctuation">.</span>department_id <span class="token operator">=</span> d<span class="token punctuation">.</span>department_id<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220125192045048.png" alt="image-20220125192045048"></p><p><strong>需要注意的是</strong>，LEFT JOIN 和 RIGHT JOIN 只存在于 SQL99 及以后的标准中，在 SQL92 中不存在，<br>只能用 (+) 表示。  </p><h5 id="3-3-3-满外连接-FULL-OUTER-JOIN"><a href="#3-3-3-满外连接-FULL-OUTER-JOIN" class="headerlink" title="3.3.3 满外连接(FULL OUTER JOIN)"></a>3.3.3 满外连接(FULL OUTER JOIN)</h5><ul><li>满外连接的结果 = 左右表匹配的数据 + 左表没有匹配到的数据 + 右表没有匹配到的数据。</li><li>SQL99是支持满外连接的。使用<code>FULL JOIN</code> 或 <code>FULL OUTER JOIN</code>来实现。</li><li>需要注意的是，<strong>MySQL不支持</strong><code>FULL JOIN</code>，但是可以用 <code>LEFT JOIN UNION RIGHT JOIN</code>代替  </li></ul><h2 id="4-UNION的使用"><a href="#4-UNION的使用" class="headerlink" title="4.UNION的使用"></a>4.UNION的使用</h2><p><strong>合并查询结果</strong> 利用UNION关键字，可以给出多条SELECT语句，并将它们的结果组合成单个结果集。合并时，两个表对应的列数和数据类型必须相同，并且相互对应。各个SELECT语句之间使用UNION或UNIONALL关键字分隔。</p><p>语法格式：  </p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">SELECT column,... FROM table1UNION [ALL]SELECT column,... FROM table2  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>UNION操作符</strong>  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220125193620957.png" alt="image-20220125193620957"></p><p><code>UNION </code>操作符返回两个查询的结果集的并集，<strong>去除重复记录</strong></p><p><strong>UNION ALL操作符</strong>  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220125193701666.png" alt="image-20220125193701666"></p><p><code>UNION ALL</code>操作符返回两个查询的结果集的并集。对于两个结果集的重复部分，<strong>不去重</strong>。  </p><p><strong>注意：</strong>执行<code>UNION ALL</code>语句时所需要的资源比<code>UNION</code>语句少。如果明确知道合并数据后的结果数据<br>不存在重复数据，或者不需要去除重复的数据，则<strong>尽量使用</strong><code>UNION ALL</code>语句，以提高数据查询的效<br>率。  </p><h2 id="5-7种SQL-JOINS的实现"><a href="#5-7种SQL-JOINS的实现" class="headerlink" title="5.   7种SQL JOINS的实现"></a>5.   7种SQL JOINS的实现</h2><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220125193922411.png" alt="image-20220125193922411" style="zoom:60%;"><p>5.7.1 代码实现</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">#中图：内连接 A∩BSELECT employee_id,last_name,department_nameFROM employees e JOIN departments dON e.&#96;department_id&#96; &#x3D; d.&#96;department_id&#96;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">#左上图：左外连接SELECT employee_id,last_name,department_nameFROM employees e LEFT JOIN departments dON e.&#96;department_id&#96; &#x3D; d.&#96;department_id&#96;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">#右上图：右外连接SELECT employee_id,last_name,department_nameFROM employees e RIGHT JOIN departments dON e.&#96;department_id&#96; &#x3D; d.&#96;department_id&#96;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">#左中图：A - A∩BSELECT employee_id,last_name,department_nameFROM employees e LEFT JOIN departments dON e.&#96;department_id&#96; &#x3D; d.&#96;department_id&#96;WHERE d.&#96;department_id&#96; IS NULL<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">#右中图：B-A∩BSELECT employee_id,last_name,department_nameFROM employees e RIGHT JOIN departments dON e.&#96;department_id&#96; &#x3D; d.&#96;department_id&#96;WHERE e.&#96;department_id&#96; IS NULL  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">#左下图：满外连接</span><span class="token comment">#利用左中图 + 右上图 A∪B</span><span class="token keyword">SELECT</span> employee_id<span class="token punctuation">,</span>last_name<span class="token punctuation">,</span>department_name<span class="token keyword">FROM</span> employees e <span class="token keyword">LEFT</span> <span class="token keyword">JOIN</span> departments d<span class="token keyword">ON</span> e<span class="token punctuation">.</span><span class="token punctuation">`</span>department_id<span class="token punctuation">`</span> <span class="token operator">=</span> d<span class="token punctuation">.</span><span class="token punctuation">`</span>department_id<span class="token punctuation">`</span><span class="token keyword">WHERE</span> d<span class="token punctuation">.</span><span class="token punctuation">`</span>department_id<span class="token punctuation">`</span> <span class="token operator">IS</span> <span class="token boolean">NULL</span><span class="token keyword">UNION</span> <span class="token keyword">ALL</span> <span class="token comment">#没有去重操作，效率高</span><span class="token keyword">SELECT</span> employee_id<span class="token punctuation">,</span>last_name<span class="token punctuation">,</span>department_name<span class="token keyword">FROM</span> employees e <span class="token keyword">RIGHT</span> <span class="token keyword">JOIN</span> departments d<span class="token keyword">ON</span> e<span class="token punctuation">.</span><span class="token punctuation">`</span>department_id<span class="token punctuation">`</span> <span class="token operator">=</span> d<span class="token punctuation">.</span><span class="token punctuation">`</span>department_id<span class="token punctuation">`</span><span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">#右下图</span><span class="token comment">#左中图 + 右中图 A ∪B- A∩B 或者 (A - A∩B) ∪ （B - A∩B）</span><span class="token keyword">SELECT</span> employee_id<span class="token punctuation">,</span>last_name<span class="token punctuation">,</span>department_name<span class="token keyword">FROM</span> employees e <span class="token keyword">LEFT</span> <span class="token keyword">JOIN</span> departments d<span class="token keyword">ON</span> e<span class="token punctuation">.</span><span class="token punctuation">`</span>department_id<span class="token punctuation">`</span> <span class="token operator">=</span> d<span class="token punctuation">.</span><span class="token punctuation">`</span>department_id<span class="token punctuation">`</span><span class="token keyword">WHERE</span> d<span class="token punctuation">.</span><span class="token punctuation">`</span>department_id<span class="token punctuation">`</span> <span class="token operator">IS</span> <span class="token boolean">NULL</span><span class="token keyword">UNION</span> <span class="token keyword">ALL</span><span class="token keyword">SELECT</span> employee_id<span class="token punctuation">,</span>last_name<span class="token punctuation">,</span>department_name<span class="token keyword">FROM</span> employees e <span class="token keyword">RIGHT</span> <span class="token keyword">JOIN</span> departments d<span class="token keyword">ON</span> e<span class="token punctuation">.</span><span class="token punctuation">`</span>department_id<span class="token punctuation">`</span> <span class="token operator">=</span> d<span class="token punctuation">.</span><span class="token punctuation">`</span>department_id<span class="token punctuation">`</span><span class="token keyword">WHERE</span> e<span class="token punctuation">.</span><span class="token punctuation">`</span>department_id<span class="token punctuation">`</span> <span class="token operator">IS</span> <span class="token boolean">NULL</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6-SQL99语法新特性"><a href="#6-SQL99语法新特性" class="headerlink" title="6. SQL99语法新特性"></a>6. SQL99语法新特性</h2><h3 id="6-1-自然连接"><a href="#6-1-自然连接" class="headerlink" title="6.1 自然连接"></a>6.1 自然连接</h3><p>SQL99 在 SQL92 的基础上提供了一些特殊语法，比如 <strong>NATURAL JOIN</strong> 用来表示自然连接。我们可以把自然连接理解为 SQL92 中的等值连接。它会帮你自动查询两张连接表中 <strong>所有相同的字段</strong> ，然后进行 <strong>等值连接</strong> 。  </p><p>在SQL92标准中：  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> employee_id<span class="token punctuation">,</span>last_name<span class="token punctuation">,</span>department_name<span class="token keyword">FROM</span> employees e <span class="token keyword">JOIN</span> departments d<span class="token keyword">ON</span> e<span class="token punctuation">.</span><span class="token punctuation">`</span>department_id<span class="token punctuation">`</span> <span class="token operator">=</span> d<span class="token punctuation">.</span><span class="token punctuation">`</span>department_id<span class="token punctuation">`</span><span class="token operator">AND</span> e<span class="token punctuation">.</span><span class="token punctuation">`</span>manager_id<span class="token punctuation">`</span> <span class="token operator">=</span> d<span class="token punctuation">.</span><span class="token punctuation">`</span>manager_id<span class="token punctuation">`</span><span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在 SQL99 中你可以写成：  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> employee_id<span class="token punctuation">,</span>last_name<span class="token punctuation">,</span>department_name<span class="token keyword">FROM</span> employees e <span class="token keyword">NATURAL</span> <span class="token keyword">JOIN</span> departments d<span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="6-2-USING连接"><a href="#6-2-USING连接" class="headerlink" title="6.2 USING连接"></a>6.2 USING连接</h3><p>当我们进行连接的时候，SQL99还支持使用 <strong>USING</strong> 指定数据表里的 <strong>同名字段</strong> 进行等值连接。但是只能配合JOIN一起使用。比如：  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> employee_id<span class="token punctuation">,</span>last_name<span class="token punctuation">,</span>department_name<span class="token keyword">FROM</span> employees e <span class="token keyword">JOIN</span> departments d<span class="token keyword">USING</span> <span class="token punctuation">(</span>department_id<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>你能看出与自然连接 <code>NATURAL JOIN </code>不同的是，<code>USING </code>指定了具体的相同的字段名称，你需要在<code> USING</code>的括号 () 中填入要指定的同名字段。同时使用 <code>JOIN...USING</code> 可以简化 JOIN ON 的等值连接。它与下面的 SQL 查询结果是相同的：  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> employee_id<span class="token punctuation">,</span>last_name<span class="token punctuation">,</span>department_name<span class="token keyword">FROM</span> employees e <span class="token punctuation">,</span>departments d<span class="token keyword">WHERE</span> e<span class="token punctuation">.</span>department_id <span class="token operator">=</span> d<span class="token punctuation">.</span>department_id<span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="7-章节小结"><a href="#7-章节小结" class="headerlink" title="7. 章节小结"></a>7. 章节小结</h2><p>表连接的约束条件可以有三种方式：<code>WHERE, ON, USING  </code></p><ul><li>WHERE：适用于所有关联查询</li><li>ON ：只能和JOIN一起使用，只能写关联条件。虽然关联条件可以并到WHERE中和其他条件一起写，但分开写可读性更好。</li><li>USING：只能和JOIN一起使用，而且要求两个关联字段在关联表中名称一致，而且只能表示关联字段值相等  </li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">#关联条件</span><span class="token comment">#把关联条件写在where后面</span><span class="token keyword">SELECT</span> last_name<span class="token punctuation">,</span>department_name<span class="token keyword">FROM</span> employees<span class="token punctuation">,</span>departments<span class="token keyword">WHERE</span> employees<span class="token punctuation">.</span>department_id <span class="token operator">=</span> departments<span class="token punctuation">.</span>department_id<span class="token punctuation">;</span><span class="token comment">#把关联条件写在on后面，只能和JOIN一起使用</span><span class="token keyword">SELECT</span> last_name<span class="token punctuation">,</span>department_name<span class="token keyword">FROM</span> employees <span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> departments<span class="token keyword">ON</span> employees<span class="token punctuation">.</span>department_id <span class="token operator">=</span> departments<span class="token punctuation">.</span>department_id<span class="token punctuation">;</span><span class="token keyword">SELECT</span> last_name<span class="token punctuation">,</span>department_name<span class="token keyword">FROM</span> employees <span class="token keyword">CROSS</span> <span class="token keyword">JOIN</span> departments<span class="token keyword">ON</span> employees<span class="token punctuation">.</span>department_id <span class="token operator">=</span> departments<span class="token punctuation">.</span>department_id<span class="token punctuation">;</span><span class="token keyword">SELECT</span> last_name<span class="token punctuation">,</span>department_name<span class="token keyword">FROM</span> employees <span class="token keyword">JOIN</span> departments<span class="token keyword">ON</span> employees<span class="token punctuation">.</span>department_id <span class="token operator">=</span> departments<span class="token punctuation">.</span>department_id<span class="token punctuation">;</span><span class="token comment">#把关联字段写在using()中，只能和JOIN一起使用</span><span class="token comment">#而且两个表中的关联字段必须名称相同，而且只能表示=</span><span class="token comment">#查询员工姓名与基本工资</span><span class="token keyword">SELECT</span> last_name<span class="token punctuation">,</span>job_title<span class="token keyword">FROM</span> employees <span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> jobs <span class="token keyword">USING</span><span class="token punctuation">(</span>job_id<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">#n张表关联，需要n-1个关联条件</span><span class="token comment">#查询员工姓名，基本工资，部门名称</span><span class="token keyword">SELECT</span> last_name<span class="token punctuation">,</span>job_title<span class="token punctuation">,</span>department_name <span class="token keyword">FROM</span> employees<span class="token punctuation">,</span>departments<span class="token punctuation">,</span>jobs<span class="token keyword">WHERE</span> employees<span class="token punctuation">.</span>department_id <span class="token operator">=</span> departments<span class="token punctuation">.</span>department_id<span class="token operator">AND</span> employees<span class="token punctuation">.</span>job_id <span class="token operator">=</span> jobs<span class="token punctuation">.</span>job_id<span class="token punctuation">;</span><span class="token keyword">SELECT</span> last_name<span class="token punctuation">,</span>job_title<span class="token punctuation">,</span>department_name<span class="token keyword">FROM</span> employees <span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> departments <span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> jobs<span class="token keyword">ON</span> employees<span class="token punctuation">.</span>department_id <span class="token operator">=</span> departments<span class="token punctuation">.</span>department_id<span class="token operator">AND</span> employees<span class="token punctuation">.</span>job_id <span class="token operator">=</span> jobs<span class="token punctuation">.</span>job_id<span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意：</strong><br>我们要 <strong>控制连接表的数量</strong> 。多表连接就<strong>相当于嵌套 for 循环一样，非常消耗资源</strong>，会让 SQL 查询性能下降得很严重，因此不要连接不必要的表。在许多 DBMS 中，也都会有最大连接表的限制。  </p><p><strong>【强制】****超过三个表禁止 join</strong>。需要 join 的字段，数据类型保持绝对一致；多表关联查询时， 保证被关联的字段需要有索引。<br>说明：即使双表 join 也要注意表索引、SQL 性能。来源：阿里巴巴《Java开发手册》  </p><h2 id="附录：常用的-SQL-标准有哪些"><a href="#附录：常用的-SQL-标准有哪些" class="headerlink" title="附录：常用的 SQL 标准有哪些"></a>附录：常用的 SQL 标准有哪些</h2><p>在正式开始讲连接表的种类时，我们首先需要知道 SQL 存在不同版本的标准规范，因为不同规范下的表连接操作是有区别的。</p><p>SQL 有两个主要的标准，分别是 SQL92 和 SQL99 。92 和 99 代表了标准提出的时间，SQL92 就是 92 年提出的标准规范。当然除了 SQL92 和 SQL99 以外，还存在 SQL-86、SQL-89、SQL:2003、SQL:2008、SQL:2011 和 SQL:2016 等其他的标准。</p><p>这么多标准，到底该学习哪个呢？<strong>实际上最重要的 SQL 标准就是 SQL92 和 SQL99</strong>。一般来说 SQL92 的形式更简单，但是写的 SQL 语句会比较长，可读性较差。而 <strong>SQL99 相比于 SQL92 来说，语法更加复杂，但可读性更强</strong>。我们从这两个标准发布的页数也能看出，SQL92 的标准有 500 页，而 SQL99 标准超过了1000 页。实际上从 SQL99 之后，很少有人能掌握所有内容，因为确实太多了。就好比我们使用Windows、Linux 和 Office 的时候，很少有人能掌握全部内容一样。我们只需要掌握一些核心的功能，满<br>足日常工作的需求即可。</p><p><strong>SQL92 和 SQL99 是经典的 SQL 标准，也分别叫做 SQL-2 和 SQL-3 标准。</strong>也正是在这两个标准发布之<br>后，SQL 影响力越来越大，甚至超越了数据库领域。现如今 SQL 已经不仅仅是数据库领域的主流语言，<br>还是信息领域中信息处理的主流语言。在图形检索、图像检索以及语音检索中都能看到 SQL 语言的使<br>用。  </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>锁</title>
      <link href="/2022/01/19/%E9%94%81/"/>
      <url>/2022/01/19/%E9%94%81/</url>
      
        <content type="html"><![CDATA[<p>事务的 <strong>隔离性</strong> 由这章讲述的 <strong>锁</strong> 来实现。  </p><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p><strong>锁</strong>是计算机协调多个进程或线程<strong>并发访问某一资源</strong>的机制。在程序开发中会存在多线程同步的问题，当多个线程并发访问某个数据的时候，尤其是针对一些敏感的数据(比如订单、金额等)，我们就需要保证这个数据在任何时刻<strong>最多只有一个线程在访问</strong>，保证数据的<strong>完整性</strong>和一致性。在开发过程中加锁是为了保证数据的一致性，这个思想在数据库领域中同样很重要。</p><p>在数据库中，除传统的计算资源（如CPU、RAM、/O等）的争用以外，数据也是一种供计多用厂共寻的负源。乃保证数据的一致性，需要对<strong>并发操作进行控制</strong>，因此产生了<strong>锁</strong>。同时<strong>锁机制</strong>也为实现MysQL的各个隔离级别提供了保证。<strong>锁冲突</strong>也是影响数据库<strong>并发访问性能</strong>的一个重要因素。所以锁对数据库而言显得尤其重要，也更加复杂。</p><h2 id="2-MySQL并发事务访问相同记录"><a href="#2-MySQL并发事务访问相同记录" class="headerlink" title="2. MySQL并发事务访问相同记录"></a>2. MySQL并发事务访问相同记录</h2><p>并发事务访问相同记录的情况大致可以分为3种：</p><h3 id="2-1-读-读情况"><a href="#2-1-读-读情况" class="headerlink" title="2.1 读-读情况"></a>2.1 读-读情况</h3><p>读-读 情况，即并发事务相继 读取相同的记录 。读取操作本身不会对记录有任何影响，并不会引起什么<br>问题，所以允许这种情况的发生。  </p><p>怎么解决 <strong>脏读 、 不可重复读 、 幻读</strong> 这些问题呢？其实有两种可选的解决方案：  </p><h3 id="2-2-写-写情况"><a href="#2-2-写-写情况" class="headerlink" title="2.2 写-写情况"></a>2.2 写-写情况</h3><p>写-写 情况，即并发事务相继对相同的记录做出改动。</p><p>在这种情况下会发生 <strong>脏写</strong> 的问题，任何一种隔离级别都不允许这种问题的发生。所以在多个未提交事务相继对一条记录做改动时，需要让它们 排队执行 ，这个排队的过程其实是通过 <strong>锁</strong> 来实现的。这个所谓的锁其实是一个 <strong>内存中的结构</strong> ，在事务执行前本来是没有锁的，也就是说一开始是没有 锁结构 和记录进行关联的，如图所示：  </p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220119173930092.png" alt="image-20220119173930092" style="zoom: 50%;"><p>当一个事务想对这条记录做改动时，首先会看看内存中有没有与这条记录关联的 锁结构 ，当没有的时候就会在内存中生成一个 锁结构 与之关联。比如，事务 T1 要对这条记录做改动，就需要生成一个 锁结构与之关联 ：</p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220119173952962.png" alt="image-20220119173952962" style="zoom:50%;"><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220119174002208.png" alt="image-20220119174002208" style="zoom:50%;"><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220119174010815.png" alt="image-20220119174010815" style="zoom:50%;"><p>小结几种说法：</p><ul><li>不加锁</li></ul><p>意思就是不需要在内存中生成对应的 锁结构 ，可以直接执行操作。</p><ul><li>获取锁成功，或者加锁成功</li></ul><p>意思就是在内存中生成了对应的 锁结构 ，而且锁结构的 <code>is_waiting </code>属性为 <code>false</code> ，也就是事务可以继续执行操作。</p><ul><li>获取锁失败，或者加锁失败，或者没有获取到锁</li></ul><p>意思就是在内存中生成了对应的 <strong>锁结构</strong> ，不过锁结构的<code>is_waiting</code>属性为 <strong>true</strong> ，也就是事务需要等待，不可以继续执行操作。  </p><h3 id="2-3-读-写或写-读情况"><a href="#2-3-读-写或写-读情况" class="headerlink" title="2.3 读-写或写-读情况"></a>2.3 读-写或写-读情况</h3><p>读-写 或 写-读 ，即一个事务进行读取操作，另一个进行改动操作。这种情况下可能发生 <strong>脏读 、 不可重复读 、 幻读</strong> 的问题。</p><p>各个数据库厂商对 SQL标准 的支持都可能不一样。比如MySQL在 <strong>REPEATABLE READ</strong> 隔离级别上就已经解决了 <strong>幻读</strong> 问题。  </p><h3 id="2-4-并发问题的解决方案"><a href="#2-4-并发问题的解决方案" class="headerlink" title="2.4 并发问题的解决方案"></a>2.4 并发问题的解决方案</h3><p>怎么解决 脏读 、 不可重复读 、 幻读 这些问题呢？其实有<strong>两种可选的解决方案</strong>：  </p><p><strong>方案一</strong>：读操作利用多版本并发控制（ MVCC ，下章讲解），<strong>写</strong>操作进行 <code>加锁</code> 。  </p><p>所谓的<strong>MVCC</strong>，就是生成一个<strong>ReadView</strong>，通过ReadView找到符合条件的记录版本（历史版本由<strong>undo日志</strong>构建)。查询语句只能<strong>读</strong>到在生成ReadView之前<strong>已提交事务所做的更改</strong>，在生成ReadView之前未提交的事务或者之后才开启的事务所做的更改是看不到的。而<strong>写操作</strong>肯定的是<strong>最新版本的记录</strong>，读记录的历史版本和改动记录的最新版本本身并不冲突，也就是采用MVCC时，<strong>读-写操作并不冲突</strong>。</p><p>普通的SELECT语句在READ COMMITTED和REPEATABLE READ隔离级别下会使用到MVCC读取记录。</p><ul><li>在 <strong>READ COMMITTED</strong> 隔离级别下，一个事务在执行过程中每次执行SELECT操作时都会生成一个ReadView，ReadView的存在本身就保证了 <strong>事务不可以读取到未提交的事务所做的更改</strong> ，也就是避免了脏读现象；</li><li>在 <strong>REPEATABLE READ</strong> 隔离级别下，一个事务在执行过程中只有 <strong>第一次执行SELECT操作</strong> 才会生成一个ReadView，之后的SELECT操作都 <strong>复用</strong> 这个ReadView，这样也就避免了不可重复读和幻读的问题。  </li></ul><p><strong>方案二</strong>：读、写操作都采用 加锁 的方式。  </p><p>如果我们的一些业务场景不允许读取记录的旧版本，而是每次都必须去<strong>读取记录的最新版本</strong>。比如，在银行存款的事务中，你需要先把账户的余额读出来，然后将其加上本次存款的数额，最后再写到数据库中。在将账户余额读取出来后，就不想让别的事务再访问该余额，直到本次存款事务执行完成，其他事务才可以访问账户的余额。这样在读取记录的时候就需要对其进行<strong>加锁</strong>操作，这样也就意味着读操作和写操作也像<strong>写-写操作那样排队执行</strong>。</p><p><strong>脏读</strong>的产生是因为当前事务读取了另一个未提交事务写的一条记录，如果另一个事务在写记录的时候就给这条记录加锁，那么当前事务就无法继续读取该记录了，所以也就不会有脏读问题的产生了。</p><p><strong>不可重复读</strong>的产生是因为当前事务先读取一条记录，另外一个事务对该记录做了改动之后并提交之后，当前事务再次读取时会获得不同的值，如果在当前事务读取记录时就给该记录加锁，那么另一个事务就无法修改该记录，自然也不会发生不可重复读了。</p><p><strong>幻读</strong>问题的产生是因为当前事务读取了一个范围的记录，然后另外的事务向该范围内插入了新记录，当前事务再次读取该范围的记录时发现了新插入的新记录。采用加锁的方式解决幻读问题就有一些麻烦，因为当前事务在第一次读取记录时幻影记录并不存在，所以读取的时候加锁就有点尴尬（因为你并不知道给谁加锁，通过间隙锁和临键锁来解决，详见后面的InnoDB的行锁)。  </p><p><strong>小结对比发现：</strong></p><ul><li>采用 MVCC 方式的话， 读-写 操作彼此并不冲突， 性能更高 。</li><li>采用 加锁 方式的话， 读-写 操作彼此需要 排队执行 ，影响性能。</li></ul><p>一般情况下我们当然愿意采用 <strong>MVCC</strong> 来解决 <strong>读-写</strong> 操作并发执行的问题，但是业务在某些特殊情况下，要求必须采用 <strong>加锁</strong> 的方式执行。下面就讲解下MySQL中不同类别的锁。  </p><h2 id="3-锁的不同角度分类"><a href="#3-锁的不同角度分类" class="headerlink" title="3. 锁的不同角度分类"></a>3. 锁的不同角度分类</h2><p>锁的分类图，如下：  </p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220119173448654.png" alt="image-20220119173448654" style="zoom:40%;"><h3 id="3-1-从数据操作的类型划分：读锁、写锁"><a href="#3-1-从数据操作的类型划分：读锁、写锁" class="headerlink" title="3.1 从数据操作的类型划分：读锁、写锁"></a>3.1 从数据操作的类型划分：读锁、写锁</h3><p>对于数据库中并发事务的读-读情况并不会引起什么问题。对于<strong>写-写、读-写</strong>或<strong>写-读</strong>这些情况可能会引起一些问题，需要使用<strong>MVCC</strong>或者<strong>加锁</strong>的方式来解决它们。在使用加锁的方式解决问题时，由于既要<strong>允许读-读</strong>情况不受影响，又要使<strong>写-写、读-写</strong>或<strong>写-读</strong>情况中的操作<strong>相互阻塞</strong>，所以MySQL实现一个由两种类型的锁组成的锁系统来解决。这两种类型的锁通常被称为<strong>共享锁(Shared Lock，SLock)<strong>和</strong>排他锁(Exclusive Lock，XLock)<strong>，也叫读</strong>锁(readlock)<strong>和</strong>写锁(write lock)</strong> 。</p><ul><li><strong>读锁</strong> ：也称为 <strong>共享锁</strong> 、英文用 <strong>S</strong> 表示。针对同一份数据，多个事务的读操作可以同时进行而<strong>不会互相影响，相互不阻塞</strong>的。</li><li><strong>写锁</strong> ：也称为 <strong>排他锁</strong> 、英文用 <strong>X</strong> 表示。当前写操作没有完成前，它<strong>会阻断其他写锁和读锁</strong>。这样就能确保在给定的时间里，只有一个事务能执行写入，并防止其他用户读取正在写入的同一资源。  </li></ul><p><strong>需要注意的是对于 InnoDB 引擎来说，读锁和写锁可以加在表上，也可以加在行上。</strong>  </p><p>**举例（行级读写锁)**︰如果一个事务T1已经获得了某个行r的读锁，那么此时另外的一个事务T2是可以去获得这个行r的读锁的，因为读取操作并没有改变行r的数据;但是，如果某个事务T3想获得行r的写锁，则它必须等待事务T1、T2释放掉行r上的读锁才行。</p><p>总结:这里的兼容是指对同一张表或记录的锁的兼容性情况。</p><table><thead><tr><th align="center"></th><th align="center">X锁</th><th align="center">S锁</th></tr></thead><tbody><tr><td align="center">X锁</td><td align="center">不兼容</td><td align="center">不兼容</td></tr><tr><td align="center">S锁</td><td align="center">不兼容</td><td align="center"><strong>兼容</strong></td></tr></tbody></table><h4 id="1-锁定读"><a href="#1-锁定读" class="headerlink" title="1.锁定读"></a>1.锁定读</h4><p>在采用<strong>加锁</strong>方式解决<strong>脏读、不可重复读、幻读</strong>这些问题时，读取一条记录时需要获取该记录的S锁，其实是<strong>不严谨的</strong>，有时候需要在读取记录时就获取记录的<strong>X锁</strong>，<strong>来禁止别的事务读写该记录</strong>，为此MysQL提出了两种比较特殊的SELECT语句格式:</p><ul><li>对读取的记录加S锁∶</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">LOCK</span> <span class="token operator">IN</span> <span class="token keyword">SHARE</span> <span class="token keyword">MODE</span><span class="token punctuation">;</span><span class="token comment">#或</span><span class="token keyword">SELECT</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">FOR</span> <span class="token keyword">SHARE</span><span class="token punctuation">;</span><span class="token comment">#(8.0新增语法)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在普通的SELECT语句后边加<code>LOCK IN SHARE MODE</code>，如果当前事务执行了该语句，那么它会为读取到的记录加s锁，这样<strong>允许别的事务继续获取这些记录的S锁(<strong>比方说别的事务也使用<code>SELECT ... LOCK IN SHAREMODE</code>语句来读取这些记录)，但是不能获取这些记录的</strong>X锁</strong>(比如使用<code>SELECT ... FOR UPDATE</code>语句来读取这些记录，或者直接修改这些记录)。如果别的事务想要获取这些记录的<strong>X锁</strong>，那么它们会<strong>阻塞</strong>，<strong>直到当前事务提交之后将这些记录上的S锁释放掉</strong>。</p><ul><li>对读取的记录加X锁︰</li></ul><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">SELECT ... FOR UPDATE; <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在普通的SELECT语句后边加<code>FOR UPDATE</code>，如果当前事务执行了该语句，那么它会为读取到的记录加X锁，这样<strong>既不允许别的事务获取这些记录的S锁(<strong>比方说别的事务使用<code>SELECT ... LOCK IN SHARE MODE</code>语句来读取这些记录)，也不允许获取这些记录的X锁(比如使用<code>SELECT ... FOR UPDATE</code>语句来读取这些记录，或者直接修改这些记录)。如果别的事务想要获取这些记录的S锁或者X锁，那么它们会</strong>阻塞</strong>，<strong>直到当前事务提交之后将这些记录上的X锁释放掉</strong>。</p><p><strong>MySQL 8.0 新特性</strong></p><p>在5.7及之前的版本，<code>SELECT ... FOR UPDATE</code>，如果获取不到锁，会一直等待，直到<code>innodb_lock_wait_timeout</code>超时。在8.0版本中，<code>SELECT ... FOR UPDATE，SELECT...FOR SHARE </code>添加<code>NOWAIT、SKIP LOCKED</code>语法，跳过锁等待，或者跳过锁定。</p><ul><li>通过添加<code>NOWAIT、SKIP LOCKED</code>语法，能够立即返回。如果查询的行已经加锁:</li><li>那么<code>NOWAIT</code>会立即报错返回</li><li>而<code>SKIP LOCKED</code>也会立即返回，只是返回的结果中不包含被锁定的行。</li></ul><h4 id="2-写操作"><a href="#2-写操作" class="headerlink" title="2.写操作"></a>2.写操作</h4><p>平常所用到的写操作无非是 DELETE、UPDATE、INSERT这三种:</p><p><strong>DELETE:</strong></p><p>对一条记录做DELETE操作的过程其实是先在B+树中定位到这条记录的位置，然后获取这条记录的X锁，再执行delete mark操作。我们也可以把这个定位待删除记录在B+树中位置的过程看成是一个获取X锁的锁定读。</p><p><strong>UPDATE</strong>:     在对一条记录做UPDATE操作时分为三种情况:</p><ul><li>情况1:未修改该记录的键值，并且被更新的列占用的存储空间在修改前后未发生变化。则先在B+树中定位到这条记录的位置，然后再获取一下记录的X锁，最后在原记录的位置进行修改操作。我们也可以把这个定位待修改记录在B+树中位置的过程看成是一个获取X锁的锁定读。</li><li>情况2∶未修改该记录的键值，并且至少有一个被更新的列占用的存储空间在修改前后发生变化。则先在B+树中定位到这条记录的位置，然后获取一下记录的X锁，将该记录彻底删除掉(就是把记录彻底移入垃圾链表)，最后再插入一条新记录。这个定位待修改记录在B+树中位置的过程看成是一个获取×锁的锁定读，新插入的记录由INSERT 操作提供的隐式锁进行保护。|</li><li>情况3:修改了该记录的键值，则相当于在原记录上做DELETE操作之后再来一次INSERT操作，加锁操作就需要按照DELETE 和INSERT的规则进行了。</li></ul><p><strong>INSERT :</strong></p><p>一般情况下，新插入一条记录的操作并不加锁，通过一种称之为隐式锁的结构来保护这条新插入的记录在本事务提交前不被别的事务访问。</p><h3 id="3-2-从数据操作的粒度划分：表级锁、页级锁、行锁"><a href="#3-2-从数据操作的粒度划分：表级锁、页级锁、行锁" class="headerlink" title="3.2 从数据操作的粒度划分：表级锁、页级锁、行锁"></a>3.2 从数据操作的粒度划分：表级锁、页级锁、行锁</h3><p>为了尽可能提高数据库的并发度，每次锁定的数据范围越小越好，理论上每次只锁定当前操作的数据的方案会得到最大的并发度，但是管理锁是很耗资源的事情（涉及获取、检查、释放锁等动作)。因此数据库系统需要在<strong>高并发响应</strong>和<strong>系统性能</strong>两方面进行平衡，这样就产生了“**锁粒度（Lock granularity)**”的概念。</p><p>对一条记录加锁影响的也只是这条记录而已，我们就说这个锁的粒度比较细;其实一个事务也可以在<strong>表级别</strong>进行加锁，自然就被称之为<strong>表级锁</strong>或者<strong>表锁</strong>，对一个表加锁影响整个表中的记录，我们就说这个锁的粒度比较粗。锁的粒度主要分为<strong>表级锁、页级锁</strong>和<strong>行锁</strong>。</p><h4 id="1-表锁（Table-Lock）"><a href="#1-表锁（Table-Lock）" class="headerlink" title="1. 表锁（Table Lock）"></a>1. 表锁（Table Lock）</h4><p>该锁会<strong>锁定整张表</strong>，它是MySQL中最基本的锁策略，并<strong>不依赖于存储引擎</strong>(不管你是MySQL的什么存储引擎，对于表锁的策略都是一样的)，并且<strong>表锁是开销最小的策略</strong>（因为粒度比较大)。由于表级锁一次会将整个表锁定，所以可以很好的<strong>避免死锁问题</strong>。当然，锁的粒度大所带来最大的负面影响就是出现锁资源争用的概率也会最高，导致并发率大打折扣。</p><h5 id="①-表级别的S锁、X锁"><a href="#①-表级别的S锁、X锁" class="headerlink" title="① 表级别的S锁、X锁"></a>① 表级别的S锁、X锁</h5><p>在对某个表执行<code>SELECT、INSERT、DELETE、UPDATE</code>语句时，InnoDB存储引擎是不会为这个表添加表级别的 S锁 或者 X锁 的。在对某个表执行一些诸如<code>ALTER TABLE 、 DROP TABLE</code>这类的 <strong>DDL 语句时</strong>，<strong>其他事务对这个表并发执行诸如<code>SELECT、INSERT、DELETE、UPDATE</code>的语句会发生阻塞</strong>。同理，某个事务中对某个表执行<code>SELECT、INSERT、DELETE、UPDATE</code>语句时，在其他会话中对这个表执行 DDL 语句也会发生阻塞。这个过程其实是通过在 <strong>server层</strong> 使用一种称之为 <strong>元数据锁</strong> （英文名： Metadata Locks ，简称 <strong>MDL</strong> ）结构来实现的。</p><p>一般情况下，不会使用InnoDB存储引擎提供的表级别的 S锁 和 X锁 。只会在一些特殊情况下，比方说 崩溃恢复 过程中用到。比如，在系统变量<code> autocommit=0，innodb_table_locks = 1</code> 时， 手动 获取InnoDB存储引擎提供的表t 的 S锁 或者 X锁 可以这么写：</p><ul><li><strong>LOCK TABLES t READ</strong> ：InnoDB存储引擎会对表 t 加表级别的 S锁 。</li><li><strong>LOCK TABLES t WRITE</strong> ：InnoDB存储引擎会对表 t 加表级别的 X锁 。</li></ul><p>不过尽量避免在使用InnoDB存储引擎的表上使用 LOCK TABLES  这样的手动锁表语句，它们并不会提供什么额外的保护，只是会降低并发能力而已。<strong>InnoDB的厉害之处还是实现了更细粒度的行锁</strong> ，关于InnoDB表级别的 S锁 和 X锁 大家了解一下就可以了。</p><p>MySQL的表级锁有两种模式：（以MyISAM表进行操作的演示）  </p><ul><li>表共享读锁（Table Read Lock）</li><li>表独占写锁（Table Write Lock）  </li></ul><table><thead><tr><th>锁类型</th><th>自己可读</th><th>自己可写</th><th>自己可操作其他表</th><th>他人可读</th><th>他人可写</th></tr></thead><tbody><tr><td>读锁</td><td>是</td><td>否</td><td>否</td><td>是</td><td>否，等</td></tr><tr><td>写锁</td><td>是</td><td>是</td><td>否</td><td>否，等</td><td>否，等</td></tr></tbody></table><h5 id="②-意向锁-（intention-lock）"><a href="#②-意向锁-（intention-lock）" class="headerlink" title="② 意向锁 （intention lock）"></a>② 意向锁 （intention lock）</h5><p>InnoDB 支持 <strong>多粒度锁（multiple granularity locking）</strong> ，它允许 <strong>行级锁</strong> 与 <strong>表级锁</strong> 共存，而<strong>意向锁</strong>就是其中的一种 <strong>表锁</strong> 。  </p><p>意向锁分为两种：  </p><p>1、意向锁的存在是<strong>为了协调行锁和表锁的关系</strong>，支持多粒度（表锁与行锁)的锁并存。</p><p>2、意向锁是一种<strong>不与行级锁冲突表级锁</strong>，这一点非常重要。</p><p>3、表明“某个事务正在某些行持有了锁或该事务准备去持有锁”</p><p><strong>意向共享锁（intention shared lock, IS）</strong>：事务有意向对表中的某些行加共享锁（S锁）  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 事务要获取某些行的 S 锁，必须先获得表的 IS 锁。</span><span class="token keyword">SELECT</span> <span class="token keyword">column</span> <span class="token keyword">FROM</span> <span class="token keyword">table</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">LOCK</span> <span class="token operator">IN</span> <span class="token keyword">SHARE</span> <span class="token keyword">MODE</span><span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>意向排他锁（intention exclusive lock, IX）</strong>：事务有意向对表中的某些行加排他锁（X锁）  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 事务要获取某些行的 X 锁，必须先获得表的 IX 锁。</span><span class="token keyword">SELECT</span> <span class="token keyword">column</span> <span class="token keyword">FROM</span> <span class="token keyword">table</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">FOR</span> <span class="token keyword">UPDATE</span><span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>即：意向锁是由存储引擎 <strong>自己维护的</strong> ，用户无法手动操作意向锁，在为数据行加共享 / 排他锁之前，InooDB 会先获取该数据行 <strong>所在数据表的对应意向锁</strong> 。  </p><p><strong>1.意向锁要解决的问题</strong></p><p>现在有两个事务，分别是T1和T2，其中T2试图在该表级别上应用共享或排它锁，如果没有意向锁存在，那么T2就需要去检查各个页或行是否存在锁;如果存在意向锁，那么此时就会受到由T1控制的<strong>表级别意向锁的阻塞</strong>。T2在锁定该表前不必检查各个页或行锁，而只需检查表上的意向锁。简单来说就是<strong>给更大一级别的空间示意里面是否已经上过锁</strong>。</p><p>在数据表的场景中，<strong>如果我们给某一行数据加上了排它锁，数据库会自动给更大一级的空间，比如数据页或数据表加上意向锁，告诉其他人这个数据页或数据表已经有人上过排它锁了</strong>，这样当其他人想要获取数据表排它锁的时候，只需要了解是否有人已经获取了这个数据表的意向排他锁即可。</p><ul><li>如果事务想要获得数据表中某些记录的共享锁，就需要在数据表上<strong>添加意向共享锁。</strong></li><li>如果事务想要获得数据表中某些记录的排他锁，就需要在数据表上<strong>添加意向排他锁</strong>。</li></ul><p>这时，意向锁会告诉其他事务已经有人锁定了表中的某些记录。</p><p>举例:创建表teacher，插入6条数据，事务的隔离级别默认为Repeatable-Read，如下所示。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token string">'teacher`('</span>id<span class="token punctuation">`</span> <span class="token keyword">int</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span><span class="token punctuation">`</span>name <span class="token punctuation">`</span> <span class="token keyword">varchar</span> <span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span><span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span><span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span> <span class="token punctuation">`</span>id <span class="token punctuation">`</span><span class="token punctuation">)</span>）<span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8mb4 <span class="token keyword">COLLATE</span><span class="token operator">=</span>utf8mb4_0900_ai_ci<span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token string">'teacher` VALUES( '</span><span class="token number">1</span> <span class="token string">', '</span>zhangsan <span class="token string">' ),( '</span><span class="token number">2</span><span class="token string">', '</span>lisi <span class="token string">'),( '</span><span class="token number">3</span> <span class="token string">' , '</span>wangwu <span class="token string">' ) ，( '</span><span class="token number">4</span><span class="token string">', '</span>zhaoliu <span class="token string">')，( '</span><span class="token number">5</span><span class="token string">', '</span>songhongkang <span class="token string">' ),( '</span><span class="token number">6</span><span class="token string">', '</span>leifengyang'<span class="token punctuation">)</span><span class="token punctuation">;</span>mysql<span class="token operator">></span> <span class="token keyword">SELECT</span> @<span class="token variable">@transaction_isolation</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">----------------------------+</span><span class="token operator">|</span>  @<span class="token variable">@transaction_isolationl</span>  <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">----------------------------+</span><span class="token operator">|</span>  REAPEATABKE<span class="token operator">-</span><span class="token keyword">READ</span>          <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">----------------------------+</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>假设事务A获取了某一行的排他锁，并未提交，语句如下所示。</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">begin ;SELECT * FROM teacher WHERE id &#x3D; 6 FOR UPDATE;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>事务B想要获取teacher 表的表读锁，语句如下。</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">begin;LOCK TABLES teacher READ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>因为共享锁与排他锁互斥，所以事务B在试图对teacher表加共享锁的时候，必须保证两个条件。</p><ul><li>当前没有其他事务持有teacher表的排他锁</li><li>当前没有其他事务持有teacher表中任意一行的排他锁。</li></ul><p>为了检测是否满足第二个条件，事务B必须在确保teacher表不存在任何排他锁的前提下，去检测表中的每一行是否存在排他锁。很明显这是一个效率很差的做法，但是有了意向锁之后，情况就不一样了。</p><p>意向锁是怎么解决这个问题的呢?首先，我们需要知道意向锁之间的兼容互斥性，如下所示。</p><table><thead><tr><th align="center"></th><th align="center">意向共享锁（IS）</th><th align="center">意向排他锁（IX）</th></tr></thead><tbody><tr><td align="center">意向共享锁（IS）</td><td align="center">兼容</td><td align="center">兼容</td></tr><tr><td align="center">意向排他锁（IX）</td><td align="center">兼容</td><td align="center">兼容</td></tr></tbody></table><p>即<strong>意向锁之间是互相兼容的</strong>，虽然意向锁和自家兄弟互相兼容，但是它<strong>会与普通的排他/共享锁互斥</strong>。</p><table><thead><tr><th align="center"></th><th align="center">意向共享锁（IS）</th><th align="center">意向排他锁（IX）</th></tr></thead><tbody><tr><td align="center">共享锁（S）</td><td align="center">兼容</td><td align="center">互斥</td></tr><tr><td align="center">排他锁（X）</td><td align="center">互斥</td><td align="center">互斥</td></tr></tbody></table><p>注意这里的排他/共享锁指的都是<strong>表锁</strong>，意向锁不会与行级的共享/排他锁互斥。回到刚才teacher表的例子。</p><p>事务A获取了某一行的排他锁，并未提交:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">BEGIN</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> teacher <span class="token keyword">WHERE</span> id <span class="token operator">=</span> <span class="token number">6</span> <span class="token keyword">FOR</span> <span class="token keyword">UPDATE</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>此时teacher表存在两把锁: teacher表上的<strong>意向排他锁</strong>与id为6的<strong>数据行上的排他锁</strong>。事务B想要获取 teacher表的共享锁。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">BEGIN</span><span class="token punctuation">;</span><span class="token keyword">LOCK</span> <span class="token keyword">TABLES</span> teacher <span class="token keyword">READ</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>此时事务B检测事务A持有teacher表的意向排他锁，就可以得知事务A必然持有该表中某些数据行的排他锁，那么事务B对teacher表的加锁请求就会被**排斥（阻塞)**，而无需去检测表中的每一行数据是否存在排他锁。</p><p><strong>意向锁的并发性</strong></p><p>意向锁不会与行级的共享 / 排他锁互斥！正因为如此，<strong>意向锁并不会影响到多个事务对不同数据行加排他锁时的并发性。</strong>（不然我们直接用普通的表锁就行了）</p><p>我们扩展一下上面 teacher表的例子来概括一下意向锁的作用（一条数据从被锁定到被释放的过程中，可能存在多种不同锁，但是这里我们只着重表现意向锁）。</p><p>事务A先获取了某一行的排他锁，并<strong>未提交:</strong></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">BEGIN</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> teacher <span class="token keyword">WHERE</span> id <span class="token operator">=</span> <span class="token number">6</span> <span class="token keyword">FOR</span> <span class="token keyword">UPDATE</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>事务A获取了teacher表上的意向排他锁，事务A获取了id为6的数据行上的排他锁。之后事务B想要获取teacher表的共享锁。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">BEGIN</span><span class="token punctuation">;</span><span class="token keyword">LOCK</span> <span class="token keyword">TABLES</span> teacher <span class="token keyword">READ</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>事务B检测到事务A持有teacher表的意向排他锁。事务B对teacher表的加锁请求被阻塞(排斥)。最后事务C也想获取 teacher表中某一行的排他锁。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">BEGIN</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> teacher <span class="token keyword">WHERE</span> id <span class="token operator">=</span> <span class="token number">5</span> <span class="token keyword">FOR</span> <span class="token keyword">UPDATE</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>事务c申请teacher表的意向排他锁。事务c检测到事务A持有teacher表的意向排他锁。因为<strong>意向锁之间并不互斥</strong>，所以事务c获取到了teacher表的意向排他锁。因为id为<strong>5</strong>的数据行上不存在任何排他锁最终事务C成功获取到了该数据行上的排他锁。</p><p>从上面的案例可以得到如下结论：</p><ol><li>InnoDB 支持 <strong>多粒度锁</strong> ，特定场景下，<strong>行级锁可以与表级锁共存</strong>。</li><li>意向锁之间互不排斥，但除了 IS 与 S 兼容外， <strong>意向锁会与 共享锁 / 排他锁 互斥</strong> 。</li><li>IX，IS是表级锁，不会和行级的X，S锁发生冲突。只会和表级的X，S发生冲突。</li><li>意向锁在保证并发性的前提下，实现了 <strong>行锁和表锁共存</strong> 且 <strong>满足事务隔离性</strong> 的要求。  </li></ol><h5 id="③-自增锁（AUTO-INC锁）"><a href="#③-自增锁（AUTO-INC锁）" class="headerlink" title="③ 自增锁（AUTO-INC锁）"></a>③ 自增锁（AUTO-INC锁）</h5><p>在使用MySQL过程中，我们可以为表的某个列添加 AUTO_INCREMENT 属性。举例：  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span>teacher<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span> <span class="token keyword">int</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span><span class="token punctuation">`</span>name<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span><span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8mb4 <span class="token keyword">COLLATE</span><span class="token operator">=</span>utf8mb4_0900_ai_ci<span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于这个表的id字段声明了AUTO_INCREMENT，意味着在书写插入语句时不需要为其赋值，SQL语句修改<br>如下所示。  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token punctuation">`</span>teacher<span class="token punctuation">`</span> <span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'zhangsan'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'lisi'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上边的插入语句并没有为id列显式赋值，所以系统会自动为它赋上递增的值。</p><p>现在我们看到的上面插入数据只是一种简单的插入模式，所有插入数据的方式总共分为三类，分别是<code>“ Simple inserts ”，“ Bulk inserts ”和“ Mixed-mode inserts ”</code>。  </p><ol><li><strong>“Simple inserts” （简单插入）</strong></li></ol><p>可以 预先确定要插入的行数 （当语句被初始处理时）的语句。包括没有嵌套子查询的单行和多行<br>INSERT…VALUES() 和 REPLACE 语句。比如我们上面举的例子就属于该类插入，已经确定要插入的行<br>数。</p><ol start="2"><li><strong>“Bulk inserts” （批量插入）</strong></li></ol><p>事先不知道要插入的行数 （和所需自动递增值的数量）的语句。比如 INSERT … SELECT ， REPLACE<br>… SELECT 和 LOAD DATA 语句，但不包括纯INSERT。 InnoDB在每处理一行，为AUTO_INCREMENT列<br>分配一个新值。</p><ol start="3"><li><strong>“Mixed-mode inserts” （混合模式插入）</strong></li></ol><p>这些是“Simple inserts”语句但是指定部分新行的自动递增值。例如 <code>INSERT INTO teacher (id,name) VALUES (1,&#39;a&#39;), (NULL,&#39;b&#39;), (5,&#39;c&#39;), (NULL,&#39;d&#39;); </code>只是指定了部分id的值。另一种类型的“混合模式插入”是 <code>INSERT ... ON DUPLICATE KEY UPDATE </code>。  </p><p>innodb_autoinc_lock_mode有三种取值，分别对应与不同锁定模式：  </p><p>（1）innodb_autoinc_lock_mode = 0(“传统”锁定模式)  </p><p>在此锁定模式下，所有类型的insert语句都会获得一个特殊的表级AUTO-INC锁，用于插入具有AUTO_INCREMENT列的表。这种模式其实就如我们上面的例子，即每当执行insert的时候，都会得到一个表级锁(AUTO-INC锁)，使得语句中生成的auto_increment为顺序，且在binlog中重放的时候，可以保证master与slave中数据的auto_increment是相同的。因为是表级锁，当在同一时间多个事务中执行insert的<br>时候，对于AUTO-INC锁的争夺会 <strong>限制并发</strong> 能力 。</p><p>（2）innodb_autoinc_lock_mode = 1(“连续”锁定模式)  </p><p>在 <strong>MySQL 8.0 之前</strong>，<strong>连续锁定模式是 默认 的</strong>。</p><p>在这个模式下，“bulk inserts”仍然使用AUTO-INC表级锁，并保持到语句结束。这适用于所有<code>INSERT ...SELECT，REPLACE ... SELECT和LOAD DATA</code>语句。同一时刻只有一个语句可以持有AUTO-INC锁。</p><p>对于“Simple inserts”（要插入的行数事先已知），则通过在 mutex（轻量锁） 的控制下获得所需数量的自动递增值来避免表级AUTO-INC锁， 它只在分配过程的持续时间内保持，而不是直到语句完成。不使用表级AUTO-INC锁，除非AUTO-INC锁由另一个事务保持。如果另一个事务保持AUTO-INC锁，则“Simple inserts”等待AUTO-INC锁，如同它是一个“bulk inserts”。  </p><p>（3）innodb_autoinc_lock_mode = 2(“交错”锁定模式)  </p><p>从 <strong>MySQL 8.0</strong> 开始，<strong>交错锁模式</strong>是 <strong>默认</strong> 设置。</p><p>在此锁定模式下，自动递增值 保证 在所有并发执行的所有类型的insert语句中是 唯一 且 单调递增 的。但是，由于多个语句可以同时生成数字（即，跨语句交叉编号），<strong>为任何给定语句插入的行生成的值可能不是连续的</strong>。  </p><h5 id="④-元数据锁（MDL锁）"><a href="#④-元数据锁（MDL锁）" class="headerlink" title="④ 元数据锁（MDL锁）"></a>④ 元数据锁（MDL锁）</h5><p>MySQL5.5引入了meta data lock，简称MDL锁，属于表锁范畴。MDL 的作用是，保证读写的正确性。比如，如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个 <strong>表结构做变更</strong> ，增加了一列，那么查询线程拿到的结果跟表结构对不上，肯定是不行的。</p><p>因此，<strong>当对一个表做增删改查操作的时候，加 MDL读锁；当要对表做结构变更操作的时候，加 MDL 写锁</strong>。  </p><p>select name from world where GDP &gt;= ALL(select GDP from world where continent =’Europe’ and population &gt;0);</p>]]></content>
      
      
      <categories>
          
          <category> database </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>索引的创建与设计原则</title>
      <link href="/2022/01/18/%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
      <url>/2022/01/18/%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</url>
      
        <content type="html"><![CDATA[<h1 id="索引的创建与设计原则"><a href="#索引的创建与设计原则" class="headerlink" title="索引的创建与设计原则"></a>索引的创建与设计原则</h1><h2 id="1-索引的声明与使用"><a href="#1-索引的声明与使用" class="headerlink" title="1.索引的声明与使用"></a>1.索引的声明与使用</h2><h3 id="1-1-索引的分类"><a href="#1-1-索引的分类" class="headerlink" title="1.1 索引的分类"></a>1.1 索引的分类</h3><p>MySQL的索引包括普通索引、唯一性索引、全文索引、单列索引、多列索引和空间索引等。</p><ul><li>从 <strong>功能逻辑</strong> 上说，索引主要有 4 种，分别是普通索引、唯一索引、主键索引、全文索引。</li><li>按照 <strong>物理实现方式</strong> ，索引可以分为 2 种：聚簇索引和非聚簇索引。</li><li>按照 作用字段个数 进行划分，分成单列索引和联合索引。  </li></ul><p>1.普通索引</p><p>在创建普通索引时，不附加任何限制条件，只是用于提高查询效率。这类索引可以创建在<strong>任何数据类型</strong>中，其值是否唯一和非空，要由字段本身的完整性约束条件决定。建立索引以后，可以通过索引进行查询。例如，在表student的字段name上建立一个普通索引，查询记录时就可以根据该索引进行查询。</p><p>2.唯一性索引</p><p>使用<strong>UNIQUE参数</strong>可以设置索引为唯一性索引，在创建唯一性索引时，限制该索引的值必须是唯一的，但允许有空值。在一张数据表里<strong>可以有多个唯一索引</strong>。</p><p>例如，在表student的字段email中创建唯一性索引，那么字段email的值就必须是唯一的。通过唯一性索引，可以更快速地确定某条记录。</p><p>3.主键索引</p><p>主键索引就是一种<strong>特殊的唯一性索引</strong>，在唯一索引的基础上增加了不为空的约束，也就是NOT NULL+UNIQUE，<strong>一张表里最多只有一个主键索引</strong>。</p><p><strong>Why?</strong> 这是由主键索引的物理实现方式决定的，因为数据存储在文件中只能按照一种顺序进行存储。</p><p>4.单列索引</p><p>在表中的单个字段上创建索引。单列索引只根据该字段进行索引。单列索引可以是普通索引，也可以是唯一性索引，还可以是全文索引。只要保证该索引只对应一个字段即可。一个表可以有多个单列索引。</p><p>5.多列(组合、联合)索引</p><p>多列索引是在表的多个字段组合上创建一个索引。该索引指向创建时对应的多个字段，可以通过这几个子段进仃查询，但是只有查询条件中使用了这些字段中的第一个字段时才会被使用。例如，在表中的字段id、name和gender上建立一个多列索引idx_id_name_gender，只有在查询条件中使用了字段id时该索引才会被使用。使用组合索引时遵循最左前缀集合。</p><p>6.全文索引</p><p>全文索引(也称全文检索)是目前<strong>搜索引擎</strong>使用的一种关键技术。它能够利用【<strong>分词技术</strong>】等多种算法智能分析出文本文字中关键词的频率和重要性，然后按照一定的算法规则智能地筛选出我们想要的搜索结果。全文索引非常适合大型数据集，对于小的数据集，它的用处比较小。</p><p>使用参数<strong>FULLTEXT</strong>可以设置索引为全文索引。在定义索引的列上支持值的全文查找，允许在这些索引例中插入重复值和空值。全文索引只能创建在<strong>CHAR 、VARCHAR</strong>或TEXT类型及其系列类型的字段上，查<strong>询数据重较大的字符串类型的字段时，使用全文索引可以提高查询速度</strong>。例如，表student的字段information是I庆尖丝，该字段包含了很多文字信息。在字段information上建立全文索引后，可以提高查询字段information的速度。</p><p>全文索引典型的有两种类型:自然语言的全文索引和布尔全文索引。</p><ul><li>自然语言搜索引擎将计算每一个文档对象和查询的相关度。这里，相关度是基于匹配的关键词的个数，以及关键词在文档中出现的次数。<strong>在整个索引中出现次数越少的词语，匹配时的相关度就越高</strong>。相反，非常常见的单词将不会被搜索，如果一个词语的在超过50%的记录中都出现了，那么自然语言的搜索将不会搜索这类词语。</li></ul><p>MysQL数据库从3.23.23版开始支持全文索引，但MySQL5.6.4以前只有<strong>Myisam</strong>支持，5.6.4版本以后<strong>innodb</strong>才支持，但是官方版本不支持<strong>中文分词</strong>，需要第三方分词插件。在5.7.6版本，MySQL内置了ngram全文解析器，用来支持亚洲语种的分词。测试或使用全文索引时，要先看一下自己的MysQL版本、存储引擎和数据类型是否支持全文索引。</p><p>随着大数据时代的到来，关系型数据库应对全文索引的需求已力不从心，逐渐被solr、<strong>ElasticSearch</strong>等专门的搜索引擎所替代。</p><p>7.补充:空间索引</p><p>使用<strong>参数SPATIAL</strong>可以设置索引为<strong>空间索引</strong>。空间索引只能建立在空间数据类型上，这样可以提高系统获取空间数据的效率。MySQL中的空间数据类型包括<strong>GEOMETRY、POINT、LINESTRING和POLYGON</strong>等。目前只有MyISAM存储引擎支持空间检索，而且索引的字段不能为空值。对于初学者来说，这类索引很少会用到</p><p><strong>小结：</strong>不同的存储引擎支持的索引类型也不一样 InnoDB ：支持 B-tree、Full-text 等索引，不支持 Hash索引； MyISAM ： 支持 B-tree、Full-text 等索引，不支持 Hash 索引； Memory ：支持 B-tree、Hash 等索引，不支持 Full-text 索引； NDB ：支持 Hash 索引，不支持 B-tree、Full-text 等索引； Archive ：不支持 B-tree、Hash、Full-text 等索引；  </p><h3 id="1-2-创建索引"><a href="#1-2-创建索引" class="headerlink" title="1.2 创建索引"></a>1.2 创建索引</h3><p>MySQL支持多种方法在单个或多个列上创建索引:在创建表的定义语句<strong>CREATE TABLE</strong>中指定索引列，使用<strong>ALTER TABLE</strong>语句在存在的表上创建索引，或者使用<strong>CREATE INDEX</strong>语句在已存在的表上添加索引。</p><h4 id="1-创建表的时候创建索引"><a href="#1-创建表的时候创建索引" class="headerlink" title="1.创建表的时候创建索引"></a>1.创建表的时候创建索引</h4><p>使用CREATE TABLE创建表时，除了可以定义列的数据类型外，还可以定义主键约束、外键约束或者唯一性约束,而不论创建哪种约束，<strong>在定义约束的同时相当于在指定列上创建了一个索引</strong>。</p><p>举例：  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">#隐式的方式创建索引 在主键约束、外键约束或者唯一性约束的字段上，会自动的添加相关的索引</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> dept<span class="token punctuation">(</span>dept_id <span class="token keyword">INT</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span>dept_name <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> emp<span class="token punctuation">(</span>emp_id <span class="token keyword">INT</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span>emp_name <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token keyword">UNIQUE</span><span class="token punctuation">,</span>dept_id <span class="token keyword">INT</span><span class="token punctuation">,</span><span class="token keyword">CONSTRAINT</span> emp_dept_id_fk <span class="token keyword">FOREIGN</span> <span class="token keyword">KEY</span><span class="token punctuation">(</span>dept_id<span class="token punctuation">)</span> <span class="token keyword">REFERENCES</span> dept<span class="token punctuation">(</span>dept_id<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 但是，如果显式创建表时创建索引的话，基本语法格式如下：  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> table_name <span class="token punctuation">[</span>col_name data_type<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token keyword">UNIQUE</span> <span class="token operator">|</span> FULLTEXT <span class="token operator">|</span> SPATIAL<span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token keyword">INDEX</span> <span class="token operator">|</span> <span class="token keyword">KEY</span><span class="token punctuation">]</span> <span class="token punctuation">[</span>index_name<span class="token punctuation">]</span> <span class="token punctuation">(</span>col_name <span class="token punctuation">[</span>length<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token keyword">ASC</span> <span class="token operator">|</span><span class="token keyword">DESC</span><span class="token punctuation">]</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><strong>UNIQUE 、 FULLTEXT</strong> 和 <strong>SPATIAL</strong> 为可选参数，分别表示唯一索引、全文索引和空间索引；</li><li><strong>INDEX</strong> 与 <strong>KEY</strong> 为同义词，两者的作用相同，用来指定创建索引；</li><li><strong>index_name</strong> 指定索引的名称，为可选参数，如果不指定，那么MySQL默认<strong>col_name为索引名</strong>；</li><li><strong>col_name</strong> 为需要创建索引的字段列，该列必须从数据表中定义的多个列中选择；</li><li><strong>length</strong> 为可选参数，表示索引的长度，只有字符串类型的字段才能指定索引长度；</li><li><strong>ASC 或 DESC</strong> 指定升序或者降序的索引值存储。  </li></ul><p><strong>通过命令查看索引：</strong></p><p>方式一：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SHOW</span> <span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> BOOK<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>方式二：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SHOW</span> <span class="token keyword">INDEX</span> <span class="token keyword">FROM</span> BOOK<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>1.创建普通索引</strong></p><p>在book表中的year_publication字段上建立普通索引，SQL语句如下：  </p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">CREATE TABLE book(book_id INT ,book_name VARCHAR(100),authors VARCHAR(100),info VARCHAR(100) ,comment VARCHAR(100),year_publication YEAR,INDEX(year_publication));  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用EXPLAIN语句查看索引是否正在使用:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">EXPLAIN</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> book <span class="token keyword">WHERE</span> year_publication<span class="token operator">=</span> <span class="token string">'1990'</span> <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>EXPLAIN语句输出结果的各个行我们在下一章讲解。这里主要关注两个字段:</p><ol><li> possible_keys行给出了MySQL在搜索数据记录时可选用的各个索引。</li><li> key行是MySQL实际选用的索引。</li></ol><p>可以看到possible_keys和key的值都为year_publication，查询时使用了索引。</p><p><strong>2.创建唯一索引</strong></p><p>举例：  </p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">CREATE TABLE test1(id INT NOT NULL,name varchar(30) NOT NULL,UNIQUE INDEX uk_idx_id(id));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该语句执行完毕之后，使用SHOW CREATE TABLE查看表结构  :</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">SHOW INDEX FROM test1;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>3.主键索引</strong></p><p>设定为主键后数据库会自动建立索引，innodb为聚簇索引，语法：</p><ul><li><p>随表一起建索引：  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">#隐式的方式创建索引</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> student <span class="token punctuation">(</span>id <span class="token keyword">INT</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token keyword">UNSIGNED</span> <span class="token keyword">AUTO_INCREMENT</span> <span class="token punctuation">,</span>student_no <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">,</span>student_name <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>删除主键索引：  </p></li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> student<span class="token keyword">drop</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>修改主键索引：必须先删除掉(drop)原索引，再新建(add)索引  </p><p><strong>4.创建单列索引</strong>  </p><p>举例：  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> test2<span class="token punctuation">(</span>id <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>name <span class="token keyword">CHAR</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span><span class="token keyword">INDEX</span> single_idx_name<span class="token punctuation">(</span>name<span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该语句执行完毕之后，使用SHOW CREATE TABLE查看表结构：  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SHOW</span> <span class="token keyword">INDEX</span> <span class="token keyword">FROM</span> test2 <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>5.创建组合索引</strong>  </p><p>举例：创建表test3，在表中的id、name和age字段上建立组合索引，SQL语句如下：  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> test3<span class="token punctuation">(</span>id <span class="token keyword">INT</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>name <span class="token keyword">CHAR</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>age <span class="token keyword">INT</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>info <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">INDEX</span> multi_idx<span class="token punctuation">(</span>id<span class="token punctuation">,</span>name<span class="token punctuation">,</span>age<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该语句执行完毕之后，使用SHOW INDEX 查看：  </p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">SHOW INDEX FROM test3 ;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>由结果可以看到，id、name和age字段上已经成功建立了一个名为multi_idx的组合索引。</p><p>组合索引可起几个索引的作用，但是使用时并不是随便查询哪个字段都可以使用索引，而是遵从“最左前缀”。例如，索引可以搜索的字段组合为: (id, name, age) . (id, name)或者id。而(age)或者(name,age)组合不能使用索引查询。</p><p>在test3表中，查询id和name字段，使用EXPLAIN语句查看索引的使用情况:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">EXPLAIN</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> test3 <span class="token keyword">WHERE</span> id<span class="token operator">=</span><span class="token number">1</span> <span class="token operator">AND</span> name<span class="token operator">=</span> <span class="token string">'songhongkang'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以看到，查询id和name字段时，使用了名称为Multildx的索引</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">EXPLAIN</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> test3 <span class="token keyword">WHERE</span> name<span class="token operator">=</span> <span class="token string">'songhongkang'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果查询(name,age)组合或者单独查询name和age字段，会发现结果中possible_keys和key值为NULL（<strong>索引失效</strong>），并没有使用在t3表中创建的索引进行查询。(具体知识点详见 <strong>索引优化与查询优化笔记</strong>)</p><p><strong>6.创建全文索引</strong>  </p><p>FULLTEXT全文索引可以用于全文搜索，并且只为<strong>CHAR、VARCHAR和TEXT</strong>列创建索引。索引总是对整个列进行，不支持局部（前缀)索引。</p><p>举例1：创建表test4，在表中的info字段上建立全文索引，SQL语句如下：  </p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">CREATE TABLE test4(id INT NOT NULL,name CHAR(30) NOT NULL,age INT NOT NULL,info VARCHAR(255),FULLTEXT INDEX futxt_idx_info(info)) ENGINE&#x3D;MyISAM;  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在MySQL5.7及之后版本中可以不指定最后的ENGINE了，因为在此版本中InnoDB支持全文索引。  </p><p>举例2：  </p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">CREATE TABLE articles (id INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,title VARCHAR (200),body TEXT,FULLTEXT index (title, body)) ENGINE &#x3D; INNODB ;  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>创建了一个给title和body字段添加全文索引的表.</p><p>举例3：  </p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">CREATE TABLE &#96;papers&#96; (&#96;id&#96; int(10) unsigned NOT NULL AUTO_INCREMENT,&#96;title&#96; varchar(200) DEFAULT NULL,&#96;content&#96; text,PRIMARY KEY (&#96;id&#96;),FULLTEXT KEY &#96;title&#96; (&#96;title&#96;,&#96;content&#96;)) ENGINE&#x3D;MyISAM DEFAULT CHARSET&#x3D;utf8;  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">SELECT * FROM papers WHERE content LIKE ‘%查询字符串%’;  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>全文索引用match+against方式查询：  </p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">SELECT * FROM papers WHERE MATCH(title,content) AGAINST (‘查询字符串’);  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">注意点:1. 使用全文索引前，搞清楚版本支持情况；2. 全文索引比 like + % 快 N 倍，但是可能存在精度问题；3. 如果需要全文索引的是大量数据，建议先添加数据，再创建索引。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>7.创建空间索引</strong>  </p><p>空间索引创建中，要求空间类型的字段必须为 非空 。</p><p>举例：创建表test5，在空间类型为GEOMETRY的字段上创建空间索引，SQL语句如下：  </p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">CREATE TABLE test5(geo GEOMETRY NOT NULL,SPATIAL INDEX spa_idx_geo(geo)) ENGINE&#x3D;MyISAM;  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-在已经存在的表上创建索引"><a href="#2-在已经存在的表上创建索引" class="headerlink" title="2.在已经存在的表上创建索引"></a>2.在已经存在的表上创建索引</h4><p>在已经存在的表中创建索引可以使用<strong>ALTER TABLE</strong>语句或者<strong>CREATE INDEX</strong>语句  </p><p><strong>1.使用ALTER TABLE ADD语句创建索引</strong> </p><p>ALTER TABLE语句创建索引的基本语法如下：  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> table_name <span class="token keyword">ADD</span> <span class="token punctuation">[</span><span class="token keyword">UNIQUE</span> <span class="token operator">|</span> FULLTEXT <span class="token operator">|</span> SPATIAL<span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token keyword">INDEX</span> <span class="token operator">|</span> <span class="token keyword">KEY</span><span class="token punctuation">]</span><span class="token punctuation">[</span>index_name<span class="token punctuation">]</span> <span class="token punctuation">(</span>col_name<span class="token punctuation">[</span>length<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token keyword">ASC</span> <span class="token operator">|</span> <span class="token keyword">DESC</span><span class="token punctuation">]</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>2.使用CREATE INDEX创建索引</strong> </p><p>CREATE INDEX语句可以在已经存在的表上添加索引，在MySQL中，<strong>CREATE INDEX</strong>被映射到一个<strong>ALTER TABLE</strong>语句上，基本语法结构为：  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token punctuation">[</span><span class="token keyword">UNIQUE</span> <span class="token operator">|</span> FULLTEXT <span class="token operator">|</span> SPATIAL<span class="token punctuation">]</span> <span class="token keyword">INDEX</span> index_name<span class="token keyword">ON</span> table_name <span class="token punctuation">(</span>col_name<span class="token punctuation">[</span>length<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token keyword">ASC</span> <span class="token operator">|</span> <span class="token keyword">DESC</span><span class="token punctuation">]</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="1-3-删除索引"><a href="#1-3-删除索引" class="headerlink" title="1.3 删除索引"></a>1.3 删除索引</h3><ol><li><strong>使用ALTER TABLE删除索引</strong>  </li></ol><p>ALTER TABLE删除索引的基本语法格式如下：  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> table_name <span class="token keyword">DROP</span> <span class="token keyword">INDEX</span> index_name<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>提示</strong>        添加<strong>AUTO_INCERMENT</strong>约束字段的唯一索引<strong>不能被删除</strong>  </p><ol start="2"><li><strong>使用DROP INDEX语句删除索引</strong> </li></ol><p>DROP INDEX删除索引的基本语法格式如下：  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">DROP</span> <span class="token keyword">INDEX</span> index_name <span class="token keyword">ON</span> table_name<span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>提示</strong>     </p><p>删除表中的列时，如果要删除的列为索引的组成部分，则该列也会从索引中删除。如果组成索引的所有列都被删除，则整个索引将被删除。</p><h2 id="2-MySQL8-0索引新特性"><a href="#2-MySQL8-0索引新特性" class="headerlink" title="2. MySQL8.0索引新特性"></a>2. MySQL8.0索引新特性</h2><h3 id="2-1-支持降序索引"><a href="#2-1-支持降序索引" class="headerlink" title="2.1 支持降序索引"></a>2.1 支持降序索引</h3><p>降序索引以降序存储键值。虽然在语法上，从MysQL 4版本开始就已经支持降序索引的语法了但实际上该DESC定义是被忽略的，直到MysQL 8.x版本才开始真正支持降序索引（仅限于InnoDB存储引擎)。</p><p>MySQL在<strong>8.0版本之前创建的仍然是升序索引，使用时进行反向扫描，这大大降低了数据库的效率</strong>。在某些场景下，降序索引意义重大。例如，如果一个查询，需要对多个列进行排序，且顺序要求不一致，那么使用降序索引将会避免数据库使用额外的文件排序操作，从而提高性能。</p><p>举例：分别在MySQL 5.7版本和MySQL 8.0版本中创建数据表ts1，结果如下：  </p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">CREATE TABLE ts1(a int,b int,index idx_a_b(a,b desc));  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在MySQL 5.7版本中查看数据表ts1的结构，结果如下  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220119112409791.png" alt="image-20220119112409791"></p><p>从结果可以看出，索引仍然是默认的升序。在MySQL 8.0版本中查看数据表ts1的结构，结果如下：  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220119113035239.png" alt="image-20220119113035239"></p><p>从结果可以看出，索引已经是降序了。下面继续测试降序索引在执行计划中的表现。</p><p>分别在MySQL 5.7版本和MySQL 8.0版本的数据表ts1中插入800条随机数据，执行语句如下：  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">DELIMITER</span> <span class="token comment">//</span><span class="token keyword">CREATE</span> <span class="token keyword">PROCEDURE</span> ts_insert<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">BEGIN</span><span class="token keyword">DECLARE</span> i <span class="token keyword">INT</span> <span class="token keyword">DEFAULT</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">WHILE</span> i <span class="token operator">&lt;</span> <span class="token number">800</span><span class="token keyword">DO</span><span class="token keyword">insert</span> <span class="token keyword">into</span> ts1 <span class="token keyword">select</span> rand<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">80000</span><span class="token punctuation">,</span>rand<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">80000</span><span class="token punctuation">;</span><span class="token keyword">SET</span> i <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">END</span> <span class="token keyword">WHILE</span><span class="token punctuation">;</span><span class="token keyword">commit</span><span class="token punctuation">;</span><span class="token keyword">END</span> <span class="token comment">//</span><span class="token keyword">DELIMITER</span> <span class="token punctuation">;</span>\#调用  <span class="token keyword">CALL</span> ts_insert<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在MySQL 5.7版本中查看数据表ts1的执行计划，结果如下：  </p><pre class="line-numbers language-none"><code class="language-none">EXPLAIN SELECT * FROM ts1 ORDER BY a,b DESC LIMIT 5;  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>从结果可以看出，执行计划中扫描数为799，而且使用了Using filesort。</p><pre class="line-numbers language-none"><code class="language-none">提示 Using filesort是MySQL中一种速度比较慢的外部排序，能避免是最好的。多数情况下，管理员可以通过优化索引来尽量避免出现Using filesort，从而提高数据库执行速度。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在MySQL 8.0版本中查看数据表ts1的执行计划。从结果可以看出，执行计划中扫描数为5，而且没有使用Using filesort。</p><pre class="line-numbers language-none"><code class="language-none">注意 降序索引只对查询中特定的排序顺序有效，如果使用不当，反而查询效率更低。例如，上述查询排序条件改为order by a desc, b desc，MySQL 5.7的执行计划要明显好于MySQL 8.0。将排序条件修改为order by a desc, b desc后，下面来对比不同版本中执行计划的效果。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> 在MySQL 5.7版本中查看数据表ts1的执行计划，结果如下：  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">EXPLAIN</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> ts1 <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> a <span class="token keyword">DESC</span><span class="token punctuation">,</span>b <span class="token keyword">DESC</span> <span class="token keyword">LIMIT</span> <span class="token number">5</span><span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在MySQL 8.0版本中查看数据表ts1的执行计划。从结果可以看出，修改后MySQL 5.7的执行计划要明显好于MySQL 8.0。  </p><h3 id="2-2-隐藏索引"><a href="#2-2-隐藏索引" class="headerlink" title="2.2 隐藏索引"></a>2.2 隐藏索引</h3><p>在MySQL 5.7版本及之前，只能通过显式的方式删除索引。此时，如果发现删除索引后出现错误，又只能通过显式创建索引的方式将删除的索引创建回来。如果数据表中的数据量非常大，或者数据表本身比较大，这种操作就会消耗系统过多的资源，操作成本非常高。</p><p>从MySQL 8.x开始支持 <strong>隐藏索引</strong>（invisible indexes） ，只需要将待删除的索引设置为隐藏索引，使查询优化器不再使用这个索引（即使使用force index（强制使用索引），优化器也不会使用该索引），确认将索引设置为隐藏索引后系统不受任何响应，就可以彻底删除索引。 <strong>这种通过先将索引设置为隐藏索引，再删除索引的方式就是软删除</strong> 。  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220119113551533.png" alt="image-20220119113551533"></p><p>索引默认是可见的，在使用<strong>CREATE TABLE，CREATE INDEX</strong>或者ALTERTABLE等语句时可以通过VISIBLE或者INVISIBLE 关键词设置索引的可见性。</p><ol><li><strong>创建表时直接创建</strong> </li></ol><p>在MySQL中创建隐藏索引通过SQL语句INVISIBLE来实现，其语法形式如下：  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> tablename<span class="token punctuation">(</span>propname1 type1<span class="token punctuation">[</span>CONSTRAINT1<span class="token punctuation">]</span><span class="token punctuation">,</span>propname2 type2<span class="token punctuation">[</span>CONSTRAINT2<span class="token punctuation">]</span><span class="token punctuation">,</span>……propnamen typen<span class="token punctuation">,</span><span class="token keyword">INDEX</span> <span class="token punctuation">[</span>indexname<span class="token punctuation">]</span><span class="token punctuation">(</span>propname1 <span class="token punctuation">[</span><span class="token punctuation">(</span>length<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span> INVISIBLE<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220119114052830.png" alt="image-20220119114052830"></p><p>上述语句比普通索引多了一个关键字INVISIBLE，用来标记索引为不可见索引。  </p><ol start="2"><li><strong>在已经存在的表上创建</strong>  </li></ol><p>可以为已经存在的表设置隐藏索引，其语法形式如下：  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">INDEX</span> indexname<span class="token keyword">ON</span> tablename<span class="token punctuation">(</span>propname<span class="token punctuation">[</span><span class="token punctuation">(</span>length<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span> INVISIBLE<span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220119114207883.png" alt="image-20220119114207883"></p><ol start="3"><li><strong>通过ALTER TABLE语句创建</strong>  </li></ol><p>语法形式如下：  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> tablename<span class="token keyword">ADD</span> <span class="token keyword">INDEX</span> indexname <span class="token punctuation">(</span>propname <span class="token punctuation">[</span><span class="token punctuation">(</span>length<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span> INVISIBLE<span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol start="4"><li><p><strong>切换索引可见状态</strong></p><p> 已存在的索引可通过如下语句切换可见状态：  </p></li></ol><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> tablename <span class="token keyword">ALTER</span> <span class="token keyword">INDEX</span> index_name INVISIBLE<span class="token punctuation">;</span> <span class="token comment">#切换成隐藏索引</span><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> tablename <span class="token keyword">ALTER</span> <span class="token keyword">INDEX</span> index_name VISIBLE<span class="token punctuation">;</span> <span class="token comment">#切换成非隐藏索引  </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果将index_cname索引切换成可见状态，通过explain查看执行计划，发现优化器选择了index_cname索引。  </p><pre class="line-numbers language-none"><code class="language-none">注意 当索引被隐藏时，它的内容仍然是和正常索引一样实时更新的。如果一个索引需要长期被隐藏，那么可以将其删除，因为索引的存在会影响插入、更新和删除的性能。  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="3-索引的设计原则"><a href="#3-索引的设计原则" class="headerlink" title="3.索引的设计原则"></a>3.索引的设计原则</h2><h3 id="3-1-数据准备"><a href="#3-1-数据准备" class="headerlink" title="3.1 数据准备"></a>3.1 数据准备</h3><p>第1步：创建数据库、创建表  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">DATABASE</span> atguigudb1<span class="token punctuation">;</span><span class="token keyword">USE</span> atguigudb1<span class="token punctuation">;</span><span class="token comment">#1.创建学生表和课程表</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span>student_info<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span> <span class="token keyword">INT</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span><span class="token punctuation">`</span>student_id<span class="token punctuation">`</span> <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token punctuation">,</span><span class="token punctuation">`</span>name<span class="token punctuation">`</span> <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span><span class="token punctuation">`</span>course_id<span class="token punctuation">`</span> <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token punctuation">,</span><span class="token punctuation">`</span>class_id<span class="token punctuation">`</span> <span class="token keyword">INT</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span><span class="token punctuation">`</span>create_time<span class="token punctuation">`</span> <span class="token keyword">DATETIME</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CURRENT_TIMESTAMP</span> <span class="token keyword">ON</span> <span class="token keyword">UPDATE</span> <span class="token keyword">CURRENT_TIMESTAMP</span><span class="token punctuation">,</span><span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">INNODB</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token operator">=</span><span class="token number">1</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8<span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span>course<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span> <span class="token keyword">INT</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span><span class="token punctuation">`</span>course_id<span class="token punctuation">`</span> <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token punctuation">,</span><span class="token punctuation">`</span>course_name<span class="token punctuation">`</span> <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">40</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span><span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">INNODB</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token operator">=</span><span class="token number">1</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8<span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第2步：创建模拟数据必需的存储函数  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">#函数1：创建随机产生字符串函数</span><span class="token keyword">DELIMITER</span> <span class="token comment">//</span><span class="token keyword">CREATE</span> <span class="token keyword">FUNCTION</span> rand_string<span class="token punctuation">(</span>n <span class="token keyword">INT</span><span class="token punctuation">)</span><span class="token keyword">RETURNS</span> <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span> <span class="token comment">#该函数会返回一个字符串</span><span class="token keyword">BEGIN</span><span class="token keyword">DECLARE</span> chars_str <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span><span class="token string">'abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ'</span><span class="token punctuation">;</span><span class="token keyword">DECLARE</span> return_str <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token string">''</span><span class="token punctuation">;</span><span class="token keyword">DECLARE</span> i <span class="token keyword">INT</span> <span class="token keyword">DEFAULT</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">WHILE</span> i <span class="token operator">&lt;</span> n <span class="token keyword">DO</span><span class="token keyword">SET</span> return_str <span class="token operator">=</span>CONCAT<span class="token punctuation">(</span>return_str<span class="token punctuation">,</span>SUBSTRING<span class="token punctuation">(</span>chars_str<span class="token punctuation">,</span>FLOOR<span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">+</span>RAND<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">52</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">SET</span> i <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">END</span> <span class="token keyword">WHILE</span><span class="token punctuation">;</span><span class="token keyword">RETURN</span> return_str<span class="token punctuation">;</span><span class="token keyword">END</span> <span class="token comment">//</span><span class="token keyword">DELIMITER</span> <span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">#函数2：创建随机数函数</span><span class="token keyword">DELIMITER</span> <span class="token comment">//</span><span class="token keyword">CREATE</span> <span class="token keyword">FUNCTION</span> rand_num <span class="token punctuation">(</span>from_num <span class="token keyword">INT</span> <span class="token punctuation">,</span>to_num <span class="token keyword">INT</span><span class="token punctuation">)</span> <span class="token keyword">RETURNS</span> <span class="token keyword">INT</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span><span class="token keyword">BEGIN</span><span class="token keyword">DECLARE</span> i <span class="token keyword">INT</span> <span class="token keyword">DEFAULT</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">SET</span> i <span class="token operator">=</span> FLOOR<span class="token punctuation">(</span>from_num <span class="token operator">+</span>RAND<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">(</span>to_num <span class="token operator">-</span> from_num<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">;</span><span class="token keyword">RETURN</span> i<span class="token punctuation">;</span><span class="token keyword">END</span> <span class="token comment">//</span><span class="token keyword">DELIMITER</span> <span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>创建函数，假如报错：</p><p>由于开启过慢查询日志bin-log, 我们就必须为我们的function指定一个参数。</p><p>主从复制，主机会将写操作记录在bin-log日志中。从机读取bin-log日志，执行语句来同步数据。如果使用函数来操作数据，会导致从机和主键操作时间不一致。所以，默认情况下，<strong>mysql不开启创建函数设置</strong>。</p><p>查看mysql是否允许创建函数：</p><pre class="line-numbers language-none"><code class="language-none">show variables like &#39;log_bin_trust_function_creators&#39;;  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>命令开启：允许创建函数设置：</p><pre class="line-numbers language-none"><code class="language-none">set global log_bin_trust_function_creators&#x3D;1; # 不加global只是当前窗口有效。 <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> mysqld重启，上述参数又会消失。永久方法：</p><p>windows下：my.ini[mysqld]加上：</p><pre class="line-numbers language-none"><code class="language-none">log_bin_trust_function_creators&#x3D;1  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>linux下：/etc/my.cnf下my.cnf[mysqld]加上：</p><pre class="line-numbers language-none"><code class="language-none">log_bin_trust_function_creators&#x3D;1  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>第3步：创建插入模拟数据的存储过程</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL"># 存储过程1：创建插入课程表存储过程DELIMITER &#x2F;&#x2F;CREATE PROCEDURE insert_course( max_num INT )BEGINDECLARE i INT DEFAULT 0;    SET autocommit &#x3D; 0; #设置手动提交事务    REPEAT #循环    SET i &#x3D; i + 1; #赋值    INSERT INTO course (course_id, course_name ) VALUES    (rand_num(10000,10100),rand_string(6));    UNTIL i &#x3D; max_num    END REPEAT;    COMMIT; #提交事务END &#x2F;&#x2F;DELIMITER ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL"># 存储过程2：创建插入学生信息表存储过程DELIMITER &#x2F;&#x2F;CREATE PROCEDURE insert_stu( max_num INT )BEGINDECLARE i INT DEFAULT 0;    SET autocommit &#x3D; 0;  #设置手动提交事务     REPEAT #循环      SET i &#x3D; i + 1; #赋值    INSERT INTO student_info (course_id, class_id ,student_id ,NAME ) VALUES    (rand_num(10000,10100),rand_num(10000,10200),rand_num(1,200000),rand_string(6));    UNTIL i &#x3D; max_num    END REPEAT;    COMMIT; #提交事务END &#x2F;&#x2F;DELIMITER ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第4步：调用存储过程  </p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">CALL insert_course(100);CALL insert_stu(1000000);  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="3-2-哪些情况适合创建索引"><a href="#3-2-哪些情况适合创建索引" class="headerlink" title="3.2 哪些情况适合创建索引"></a>3.2 哪些情况适合创建索引</h3><p>索引本身可以起到约束的作用，比如唯一索引、主键索引都是可以起到唯一性约束的，因此在我们的数据表中,如果某个字段是唯一性的，就可以直接创建唯一性索引，或者主键索引。这样可以更快速地通过该索引来确定某条记录。</p><p>例如，学生表中学号是具有唯一性的字段，为该字段建立唯一性索引可以很快确定某个学生的信息，如果使用姓名的话，可能存在同名现象，从而降低查询速度。</p><h4 id="1-字段的数值有唯一性的限制"><a href="#1-字段的数值有唯一性的限制" class="headerlink" title="1.字段的数值有唯一性的限制"></a>1.字段的数值有唯一性的限制</h4><pre class="line-numbers language-none"><code class="language-none">业务上具有唯一特性的字段，即使是组合字段，也必须建成唯一索引。（来源：Alibaba）说明：不要以为唯一索引影响了 insert 速度，这个速度损耗可以忽略，但提高查找速度是明显的。  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="2-频繁作为-WHERE-查询条件的字段"><a href="#2-频繁作为-WHERE-查询条件的字段" class="headerlink" title="2. 频繁作为 WHERE 查询条件的字段"></a>2. 频繁作为 WHERE 查询条件的字段</h4><p>某个字段在SELECT语句的 WHERE 条件中经常被使用到，那么就需要给这个字段创建索引了。尤其是在数据量大的情况下，创建普通索引就可以大幅提升数据查询的效率。</p><p>比如student_info数据表（含100万条数据），假设我们想要查询 student_id=123110 的用户信息。  </p><h4 id="3-经常-GROUP-BY-和-ORDER-BY-的列"><a href="#3-经常-GROUP-BY-和-ORDER-BY-的列" class="headerlink" title="3.    经常 GROUP BY 和 ORDER BY 的列"></a>3.    经常 GROUP BY 和 ORDER BY 的列</h4><p>索引就是让数据按照某种顺序进行存储或检索，因此当我们使用 GROUP BY 对数据进行分组查询，或者使用 ORDER BY 对数据进行排序的时候，就需要 <strong>对分组或者排序的字段进行索引</strong> 。如果待排序的列有多个，那么可以在这些列上建立 组合索引 。  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220119121104654.png" alt="image-20220119121104654"></p><p>说明:多个单列索引在多条件查询时只会生效一个索引(MySQL会选择其中一个限制最严格的作为索引)，所以在多条件联合查询的时候最好创建联合索引。接着，我们创建联合索引(student_id, create_time)，查询时间为0.22s，效率提升了很多。</p><p>如果我们创建联合索引的顺序为(create_time, student_id)呢?运行时间为2.164s，因为在进行SELECT查询的时候，<strong>先进行GROUP BY，再对数据进行ORDER BY的操作</strong>，所以按照(student_id, create_time)这个联合索引的顺序效率是最高的。</p><h4 id="4-UPDATE、DELETE-的-WHERE-条件列"><a href="#4-UPDATE、DELETE-的-WHERE-条件列" class="headerlink" title="4. UPDATE、DELETE 的 WHERE 条件列"></a>4. UPDATE、DELETE 的 WHERE 条件列</h4><p>对数据按照某个条件进行查询后再进行 UPDATE 或 DELETE 的操作，如果对 WHERE 字段创建了索引，就能大幅提升效率。原理是因为我们需要先根据 WHERE 条件列检索出来这条记录，然后再对它进行更新或删除。<strong>如果进行更新的时候，更新的字段是非索引字段，提升的效率会更明显，这是因为非索引字段更新不需要对索引进行维护</strong>。  </p><h4 id="5-DISTINCT-字段需要创建索引"><a href="#5-DISTINCT-字段需要创建索引" class="headerlink" title="5. DISTINCT 字段需要创建索引"></a>5. DISTINCT 字段需要创建索引</h4><p>有时候我们需要对某个字段进行去重，使用 DISTINCT，那么对这个字段创建索引，也会提升查询效率。比如，我们想要查询课程表中不同的 student_id 都有哪些，如果我们没有对 student_id 创建索引，执行SQL 语句：  </p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">SELECT DISTINCT(student_id) FROM &#96;student_info&#96;;  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>运行结果（600637 条记录，运行时间 0.683s ）</p><p>如果我们对 student_id 创建索引，再执行 SQL 语句：  </p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">SELECT DISTINCT(student_id) FROM &#96;student_info&#96;;  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>运行结果（600637 条记录，运行时间 0.010s ）：</p><p>你能看到 SQL 查询效率有了提升，同时显示出来的 student_id 还是按照 <strong>递增的顺序</strong> 进行展示的。这是因为索引会对数据按照某种顺序进行排序，所以在去重的时候也会快很多。  </p><h4 id="6-多表-JOIN-连接操作时，创建索引注意事项"><a href="#6-多表-JOIN-连接操作时，创建索引注意事项" class="headerlink" title="6. 多表 JOIN 连接操作时，创建索引注意事项"></a>6. 多表 JOIN 连接操作时，创建索引注意事项</h4><p>首先， <strong>连接表的数量尽量不要超过 3 张</strong> ，因为每增加一张表就相当于增加了一次嵌套的循环，数量级增长会非常快，严重影响查询的效率。</p><p>其次， <strong>对 WHERE 条件创建索引</strong> ，因为 WHERE 才是对数据条件的过滤。如果在数据量非常大的情况下，没有 WHERE 条件过滤是非常可怕的。</p><p>最后， <strong>对用于连接的字段创建索引</strong> ，并且该字段在多张表中的 <strong>类型必须一致</strong> 。比如 course_id 在student_info 表和 course 表中都为 int(11) 类型，而不能一个为 int 另一个为 varchar 类型。  </p><p>举个例子，如果我们只对 student_id 创建索引，执行 SQL 语句：  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> course_id<span class="token punctuation">,</span> name<span class="token punctuation">,</span> student_info<span class="token punctuation">.</span>student_id<span class="token punctuation">,</span> course_name<span class="token keyword">FROM</span> student_info <span class="token keyword">JOIN</span> course<span class="token keyword">ON</span> student_info<span class="token punctuation">.</span>course_id <span class="token operator">=</span> course<span class="token punctuation">.</span>course_id<span class="token keyword">WHERE</span> name <span class="token operator">=</span> <span class="token string">'462eed7ac6e791292a79'</span><span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果（1 条数据，运行时间 0.189s ）：</p><p>这里我们对 name 创建索引，再执行上面的 SQL 语句，运行时间为 0.002s 。  </p><h4 id="7-使用列的类型小的创建索引"><a href="#7-使用列的类型小的创建索引" class="headerlink" title="7. 使用列的类型小的创建索引"></a>7. 使用列的类型小的创建索引</h4><p>我们这里所说的<strong>类型大小</strong>指的就是该类型表示的<strong>数据范围的大小</strong>。</p><p>我们在定义表结构的时候要显式的指定列的类型，以整数类型为例，有<strong>TINYINT、MEDIUMINTINT 、BIGINT</strong>等，它们占用的存储空间依次递增，能表示的整数范围当然也是依次递增。如果我们想要对某个整数列建立索引的话，<strong>在表示的整数范围允许的情况下，尽量让索引列使用较小的类型</strong>，比如我们能使用<strong>INT</strong>就不要使用BIGINT，能使用<strong>MEDIUMINT</strong>就不要使用<strong>INT</strong>。这是因为:</p><p><strong>BINGINT:</strong>    从 <strong>-2^63</strong> (-9223372036854775808) 到 <strong>2^63-1</strong> (9223372036854775807) 的整型数据（所有数字），无符号的范围是0到</p><p>18446744073709551615。一位为 <strong>8</strong> 个字节。</p><p><strong>INT :</strong>     <strong>-2^31 (-2,147,483,648) 到 2^31 – 1 (2,147,483,647)</strong> 的整型数据（所有数字），存储大小为<strong>4</strong>个字节；</p><p><strong>MEDIUMINT:</strong>    一个中等大小整数，有符号的范围是**-8388608到8388607<strong>，无符号的范围是0到16777215。 一位大小为</strong>3**个字节。</p><p><strong>SMALLINT:</strong>    一个小整数。有符号的范围是**-2^15 (-32,768) 到 2^15 - 1 (32,767)** 的整型数据，无符号的范围是<strong>0到65535</strong>。一位大小为 <strong>2</strong> 个字节。</p><p><strong>TINYINT:</strong>     带符号的范围是**-128到127<strong>，无符号的范围是</strong>0到255**。</p><ul><li>数据类型越小，在查询时进行的比较操作越快。</li><li>数据类型越小，索引占用的存储空间就越少，<strong>在一个数据页内就可以放下更多的记录</strong>，从而<strong>减少磁盘I/0带来的性能损耗</strong>，也就意味着可以把更多的数据页缓存在内存中，从而加快读写效率。</li></ul><p>这个建议对于表的<strong>主键来说更加适用</strong>，因为不仅是聚簇索引中会存储主键值，其他所有的<strong>二级索引的节点处都会存储一份记录的主键值</strong>，如果主键使用更小的数据类型，也就意味着节省更多的存储空间和更高效的IO。</p><h4 id="8-使用字符串前缀创建索引"><a href="#8-使用字符串前缀创建索引" class="headerlink" title="8. 使用字符串前缀创建索引"></a>8. 使用字符串前缀创建索引</h4><p>假设我们的字符串很长，那存储一个字符串就需要占用很大的存储空间。在我们需要为这个字符串列建立索引时，那就意味着在对应的B+树中有这么两个问题:</p><ul><li>B+树索引中的记录需要把该列的完整字符串存储起来，更费时。而且<strong>字符串越长，在索引中占用的存储空间越大</strong>。</li><li>如果B+树索引中索引列存储的字符串很长，那在做字符串<strong>比较时会占用更多的时间</strong>。</li></ul><p>我们可以通过截取字段的前面一部分内容建立索引，这个就叫<strong>前缀索引</strong>。这样在查找记录时虽然不能精确的定位到记录的位置，但是能定位到相应前缀所在的位置，然后根据前缀相同的记录的主键值回表查询完整的字符串值。既<strong>节约空间</strong>，又<strong>减少了字符串的比较时间</strong>，还大体能解决排序的问题。</p><p>例如，TEXT和BLOG类型的字段，进行全文检索会很浪费时间，如果只检索字段前面的若干字符，这样可以提高检索速度。</p><p>创建一张商户表，因为地址字段比较长，在地址字段上建立前缀索引  </p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">create table shop(address varchar(120) not null);alter table shop add index(address(12));  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>问题是，截取多少呢？截取得多了，达不到节省索引存储空间的目的；截取得少了，重复内容太多，字段的散列度(选择性)会降低。怎么<strong>计算不同的长度的选择性呢</strong>？  </p><p>先看一下字段在全部数据中的选择度：  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token keyword">distinct</span> address<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">from</span> shop<span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>通过不同长度去计算，与全表的选择性对比：  </p><p>公式：  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token function">count</span><span class="token punctuation">(</span><span class="token keyword">distinct</span> <span class="token keyword">left</span><span class="token punctuation">(</span>列名<span class="token punctuation">,</span> 索引长度<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>例如：  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token keyword">distinct</span> <span class="token keyword">left</span><span class="token punctuation">(</span>address<span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">as</span> sub10<span class="token punctuation">,</span> <span class="token comment">-- 截取前10个字符的选择度</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token keyword">distinct</span> <span class="token keyword">left</span><span class="token punctuation">(</span>address<span class="token punctuation">,</span><span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">as</span> sub11<span class="token punctuation">,</span> <span class="token comment">-- 截取前15个字符的选择度</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token keyword">distinct</span> <span class="token keyword">left</span><span class="token punctuation">(</span>address<span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">as</span> sub12<span class="token punctuation">,</span> <span class="token comment">-- 截取前20个字符的选择度</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token keyword">distinct</span> <span class="token keyword">left</span><span class="token punctuation">(</span>address<span class="token punctuation">,</span><span class="token number">25</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">as</span> sub13 <span class="token comment">-- 截取前25个字符的选择度</span><span class="token keyword">from</span> shop<span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>越接近 1 越好！！</p><p><strong>引申另一个问题：索引列前缀对排序的影响</strong></p><p>如果使用了索引列前缀，比方说前边只把address列的前12个字符放到了二级索引中，下边这个查询可能就有点儿尴尬了:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> shop <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> addressLIMIT <span class="token number">12</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>因为二级索引中不包含完整的address列信息，所以无法对前12个字符相同，后边的字符不同的记录进行排序，也就是使用索引列前缀的方式<strong>无法支持使用索引排序</strong>，只能使用<strong>文件排序</strong>。</p><p><strong>拓展：Alibaba《Java开发手册》</strong></p><p>【 强制 】在 varchar 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据实际文本<br>区分度决定索引长度。</p><p>说明：索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为 20 的索引，区分度会 <strong>高达</strong><br><strong>90% 以上</strong> ，可以使用<code> count(distinct left(列名, 索引长度)) / count(*)</code>的区分度来确定。  </p><h4 id="9-区分度高-散列性高-的列适合作为索引"><a href="#9-区分度高-散列性高-的列适合作为索引" class="headerlink" title="9. 区分度高(散列性高)的列适合作为索引"></a>9. 区分度高(散列性高)的列适合作为索引</h4><p><strong>列的基数</strong>指的是<strong>某一列中不重复数据的个数</strong>，比方说某个列包含值2，5，8，2，5，8，2，5，8，虽然有9条记录，但该列的基数却是3。也就是说，<strong>在记录行数一定的情况下，列的基数越大，该列中的值越分散;列的基数越小，该列中的值越集中</strong>。这个列的基数指标非常重要，直接影响我们是否能有效的利用索引。最好为列的基数大的列建立索引，为基数太小列的建立索引效果可能不好。</p><p>可以使用公式 <code>select count(distinct a)/count(*) from t1</code>计算区分度，越接近1越好。一般超过33%就算是比较高效的索引了。</p><p>拓展:联合索引把区分度高(散列性高)的列放在前面。</p><h4 id="10-使用最频繁的列放到联合索引的左侧"><a href="#10-使用最频繁的列放到联合索引的左侧" class="headerlink" title="10. 使用最频繁的列放到联合索引的左侧"></a>10. 使用最频繁的列放到联合索引的左侧</h4><p>这样也可以较少的建立一些索引。同时，由于”最左前缀原则”，可以增加联合索引的使用率。  </p><h4 id="11-在多个字段都要创建索引的情况下，联合索引优于单值索引"><a href="#11-在多个字段都要创建索引的情况下，联合索引优于单值索引" class="headerlink" title="11. 在多个字段都要创建索引的情况下，联合索引优于单值索引"></a>11. 在多个字段都要创建索引的情况下，联合索引优于单值索引</h4><h3 id="3-3限制索引的数目"><a href="#3-3限制索引的数目" class="headerlink" title="3.3限制索引的数目"></a>3.3限制索引的数目</h3><h3 id="3-4-哪些情况不适合创建索引"><a href="#3-4-哪些情况不适合创建索引" class="headerlink" title="3.4 哪些情况不适合创建索引"></a>3.4 哪些情况不适合创建索引</h3><h4 id="1-在where中使用不到的字段，不要设置索引"><a href="#1-在where中使用不到的字段，不要设置索引" class="headerlink" title="1. 在where中使用不到的字段，不要设置索引"></a>1. 在where中使用不到的字段，不要设置索引</h4><h4 id="2-数据量小的表最好不要使用索引"><a href="#2-数据量小的表最好不要使用索引" class="headerlink" title="2. 数据量小的表最好不要使用索引"></a>2. 数据量小的表最好不要使用索引</h4><p>结论：在数据表中的数据行数比较少的情况下，比如不到 <strong>1000</strong> 行，是不需要创建索引的。</p><h4 id="3-有大量重复数据的列上不要建立索引"><a href="#3-有大量重复数据的列上不要建立索引" class="headerlink" title="3. 有大量重复数据的列上不要建立索引"></a>3. 有大量重复数据的列上不要建立索引</h4><p> 举例1：要在 100 万行数据中查找其中的 50 万行（比如性别为男的数据），一旦创建了索引，你需要先访问 50 万次索引，然后再访问 50 万次数据表，这样加起来的开销比不使用索引可能还要大。</p><p>举例2：假设有一个学生表，学生总数为 100 万人，男性只有 10 个人，也就是占总人口的 10 万分之 1。学生表 student_gender 结构如下。其中数据表中的 student_gender 字段取值为 0 或 1，0 代表女性，1 代表男性。  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> student_gender<span class="token punctuation">(</span>student_id <span class="token keyword">INT</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>student_name <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>student_gender <span class="token keyword">TINYINT</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span><span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">(</span>student_id<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">ENGINE</span> <span class="token operator">=</span> <span class="token keyword">INNODB</span><span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果我们要筛选出这个学生表中的男性，可以使用：  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> student_gender <span class="token keyword">WHERE</span> student_gender <span class="token operator">=</span> <span class="token number">1</span> <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结论：当数据重复度大，比如 高于 10% 的时候，也不需要对这个字段使用索引。  </p><h4 id="4-避免对经常更新的表创建过多的索引"><a href="#4-避免对经常更新的表创建过多的索引" class="headerlink" title="4. 避免对经常更新的表创建过多的索引"></a>4. 避免对经常更新的表创建过多的索引</h4><h4 id="5-不建议用无序的值作为索引"><a href="#5-不建议用无序的值作为索引" class="headerlink" title="5. 不建议用无序的值作为索引"></a>5. 不建议用无序的值作为索引</h4><p>例如身份证、UUID(在索引比较时需要转为ASCII，并且插入时可能造成页分裂)、MD5、HASH、无序长字符串等。  </p><h4 id="6-删除不再使用或者很少使用的索引"><a href="#6-删除不再使用或者很少使用的索引" class="headerlink" title="6. 删除不再使用或者很少使用的索引"></a>6. 删除不再使用或者很少使用的索引</h4><h4 id="7-不要定义冗余或重复的索引"><a href="#7-不要定义冗余或重复的索引" class="headerlink" title="7. 不要定义冗余或重复的索引"></a>7. 不要定义冗余或重复的索引</h4><p><strong>① 冗余索引</strong>  </p><p>举例：建表语句如下  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> person_info<span class="token punctuation">(</span>id <span class="token keyword">INT</span> <span class="token keyword">UNSIGNED</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span>name <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>birthday <span class="token keyword">DATE</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>phone_number <span class="token keyword">CHAR</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>country <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span><span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">KEY</span> idx_name_birthday_phone_number <span class="token punctuation">(</span>name<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span> birthday<span class="token punctuation">,</span> phone_number<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">KEY</span> idx_name <span class="token punctuation">(</span>name<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们知道，通过<code> idx_name_birthday_phone_number (联合索引)</code> 索引就可以对<code>name</code>列进行快速搜索，再创建一个专门针对<code>name</code>列的索引就算是一个 <strong>冗余索引</strong> ，维护这个索引只会增加维护的成本，并不会对搜索有什么好处。  </p><p><strong>② 重复索引</strong>  </p><p>另一种情况，我们可能会对某个列 <strong>重复建立索引</strong> ，比方说这样：  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> repeat_index_demo <span class="token punctuation">(</span>col1 <span class="token keyword">INT</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">,</span>col2 <span class="token keyword">INT</span><span class="token punctuation">,</span><span class="token keyword">UNIQUE</span> uk_idx_c1 <span class="token punctuation">(</span>col1<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">INDEX</span> idx_c1 <span class="token punctuation">(</span>col1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们看到，col1 既是主键、又给它定义为一个唯一索引，还给它定义了一个普通索引，可是主键本身就会生成聚簇索引，所以定义的唯一索引和普通索引是重复的，这种情况要避免。  </p>]]></content>
      
      
      <categories>
          
          <category> database </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>索引</title>
      <link href="/2022/01/15/%E7%B4%A2%E5%BC%95/"/>
      <url>/2022/01/15/%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<h1 id="1-为什么使用索引"><a href="#1-为什么使用索引" class="headerlink" title="1.为什么使用索引"></a>1.为什么使用索引</h1><p>索引是存储引擎用于快速找到数据记录的一种数据结构，就好比一本教课书的目录部分，通过目录中找到对应文章的页码，便可快速定位到需要的文章。MySQL中也是一样的道理，进行数据查找时，首先查查询条件是否命中某条索引，符合则<strong>通过索引查找</strong>相关数据，如果不符合则需要<strong>全表扫描</strong>，即需要一条一条地查找记录，直到找到与条件符合的记录。</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220115100536189.png" alt="image-20220115100536189"></p><p>如上图所示，数据库没有索引的情况下，数据 <strong>分布在硬盘不同的位置上面</strong>，读取数据时，摆臂需要前后摆动查找数据，这样操作非常消耗时间。如果数据 <strong>顺序摆放</strong>，那么也需要从1到6行按顺序读取，这样就相当于进行了6次I0操作，<strong>依旧非常耗时</strong>。如果我们不借助任何索引结构帮助我们快速定位数据的话，我们查找Col2=89这条记录，就要逐行去查找、去比较。从Col 2= 34开始，进行比较，发现不是，继续下一行。我们当前的表只有不到10行数据，但如果表很大的话，有<strong>上千万条数据</strong>，就意味着要做很多很多次磁盘I/0才能找到。现在要查找Col 2=89这条记录。CPu必须先去磁盘查找这条记录，找到之后加载到内存，再对数据进行处理。这个过程最耗时间的就是磁盘I/o(涉及到磁盘的旋转时间（速度较快)、磁头的寻道时间(速度慢、费时))</p><p>假如给数据使用 **二叉树 **这样的数据结构进行存储，如下图所示</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220115101032427.png" alt="image-20220115101032427"></p><p>对字段Col2添加了索引，就相当于在硬盘上为Col 2维护了一个索引的数据结构，即这个 <strong>二叉搜索树</strong>。二叉搜索树的每个结点存储的是<strong>（K，V)结构</strong>，key是Col2，value是该key 所在行的文件指针(地址)。比如:该二叉搜索树的根节点就是: <strong>(34,0x07）</strong>。现在对Col2添加了索引，这时再去查找Col 2=89这条记录的时候会先去查找该二叉搜索树（二叉树的遍历查找)。读34到内存，89&gt;34; 继续右侧数据，读89到内存，89 == 89; 找到数据返回。找到之后就根据当前结点的value快速定位到要查找的记录对应的地址。我们可以发现只需要<strong>查找两次</strong>就可以定位到记录的地址，查询速度就提高了。</p><p>这就是我们为什么要建索引，目的就是为了<strong>减少磁盘I/0的次数</strong>，加快查询速率。</p><h1 id="2-索引及其优缺点"><a href="#2-索引及其优缺点" class="headerlink" title="2.索引及其优缺点"></a>2.索引及其优缺点</h1><p>MySQL官方对索引的定义为：<strong>索引（Index）是帮助MySQL高效获取数据的数据结构</strong>。  </p><p><strong>索引的本质</strong>：<strong>索引是数据结构</strong>。你可以简单理解为“排好序的快速查找数据结构”，满足特定查找算法。这些数据结构以某种方式指向数据， 这样就可以在这些数据结构的基础上实现 <strong>高级查找算法</strong> 。  </p><p><strong>索引是在存储引擎中实现</strong>的，因此每种存储引擎的索引不一定完全相同，并且每种存储引擎不一定支持所有索引类型。同时，存储引擎可以定义每个表的<strong>最大索引数</strong>和<strong>最大索引长度</strong>。所有存储引擎支持每个表至少<strong>16</strong>个索引，总索引长度至少为256字节。有些存储引擎支持更多的索引数和更大的索引长度。|</p><h2 id="2-1-优点"><a href="#2-1-优点" class="headerlink" title="2.1 优点"></a>2.1 优点</h2><p>（1）类似大学图书馆建书目索引，提高数据检索的效率，降低 <strong>数据库的IO成本</strong> ，这也是创建索引最主要的原因。 </p><p>（2）通过创建唯一索引，可以保证数据库表中每一行 <strong>数据的唯一性</strong> 。 </p><p>（3）在实现数据的参考完整性方面，可以 <strong>加速表和表之间的连接</strong> 。换句话说，对于有依赖关系的子表和父表联合查询时，可以提高查询速度。 </p><p>（4）在使用分组和排序子句进行数据查询时，可以显著 <strong>减少查询中分组和排序的时间</strong> ，降低了CPU的消耗。  </p><h2 id="2-2-缺点"><a href="#2-2-缺点" class="headerlink" title="2.2 缺点"></a>2.2 缺点</h2><p>增加索引也有许多不利的方面，主要表现在如下几个方面： </p><p>（1）创建索引和维护索引要 <strong>耗费时间</strong> ，并且随着数据量的增加，所耗费的时间也会增加。 </p><p>（2）索引需要占 <strong>磁盘空间</strong> ，除了数据表占数据空间之外，每一个索引还要占一定的物理空间， <strong>存储在磁盘上</strong> ，如果有大量的索引，索引文件就可能比数据文件更快达到最大文件尺寸。 </p><p>（3）虽然索引大大提高了查询速度，同时却会 <strong>降低更新表的速度</strong> 。当对表<br>中的数据进行增加、删除和修改的时候，索引也要动态地维护，这样就降低了数据的维护速度。因此，选择使用索引时，需要综合考虑索引的优点和缺点。  </p><p>因此，选择使用索引时，需要综合考虑索引的优点和缺点。  </p><p>提示:<br>索引可以提高查询的速度，但是会影响插入记录的速度。这种情况下，最好的办法是先删除表中的索引，然后插入数据，插入完成后再创建索引。</p><h1 id="3-InnoDB中索引的推演"><a href="#3-InnoDB中索引的推演" class="headerlink" title="3.InnoDB中索引的推演"></a>3.InnoDB中索引的推演</h1><h2 id="3-1-索引之前的查找"><a href="#3-1-索引之前的查找" class="headerlink" title="3.1 索引之前的查找"></a>3.1 索引之前的查找</h2><p>先来看一个精确匹配的例子：  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token punctuation">[</span>列名列表<span class="token punctuation">]</span> <span class="token keyword">FROM</span> 表名 <span class="token keyword">WHERE</span> 列名 <span class="token operator">=</span> xxx<span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>1.<strong>在一个页中的查找</strong></p><p>假设目前表中的记录比较少，所有的记录都可以被存放到一个页中，在查找记录的时候可以根据搜索条件的不同分为两种情况:</p><ul><li><strong>以主键为搜索条件</strong></li></ul><p>​    可以在页目录中使用<strong>二分法</strong>快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录。</p><ul><li><strong>以其他列作为搜索条件</strong></li></ul><p>​    因为在数据页中并没有对非主键列建立所谓的页目录，所以我们无法通过<strong>二分法</strong>快速定位相应的槽。这种情况下只能从<strong>最小记录</strong>开始<strong>依次遍历</strong>单链表中的每条记录，然后对比每条记录是不是符合搜索条件。很显然，这种查找的效率是非常低的。</p><p>2.<strong>在很多页中查找</strong></p><p>大部分情况下我们表中存放的记录都是非常多的，需要好多的数据页来存储这些记录。在很多页中查找记录的话可以分为两个步骤:</p><p>​    1.定位到记录所在的页。</p><p>​    2.从所在的页内中查找相应的记录。</p><p>在没有索引的情况下，不论是根据主键列或者其他列的值进行查找，由于我们<strong>并不能快速的定位到记录所在的页</strong>，所以只能 <strong>从第一个页</strong> 沿着 <strong>双向链表</strong> 一直往下找，在每一个页中根据我们上面的查找方式去查找指定的记录。因为要遍历所有的数据页，所以这种方式显然是 <strong>超级耗时</strong> 的。如果一个表有一亿条记录呢？此时 <strong>索引</strong> 应运而生。  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220115102738099.png" alt="image-20220115102738099"></p><h2 id="3-2-设计索引"><a href="#3-2-设计索引" class="headerlink" title="3.2 设计索引"></a>3.2 设计索引</h2><p>建一个表：  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> index_demo<span class="token punctuation">(</span>    <span class="token operator">-</span><span class="token operator">></span>c1 <span class="token keyword">INT</span><span class="token punctuation">,</span>     <span class="token operator">-</span><span class="token operator">></span>c2 <span class="token keyword">INT</span><span class="token punctuation">,</span>    <span class="token operator">-</span><span class="token operator">></span>c3 <span class="token keyword">CHAR</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token operator">-</span><span class="token operator">></span><span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">(</span>c1<span class="token punctuation">)</span> <span class="token operator">|</span>    <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">)</span> ROW_FORMAT <span class="token operator">=</span> Compact<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个新建的 <strong>index_demo</strong> 表中有2个INT类型的列，1个CHAR(1)类型的列，而且我们规定了c1列为主键，这个表使用 <strong>Compact</strong> 行格式来实际存储记录的。这里我们简化了index_demo表的行格式示意图：  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220115103558132.png" alt="image-20220115103558132"></p><p>我们只在示意图里展示记录的这几个部分：</p><ul><li><strong>record_type</strong> ：记录头信息的一项属性，表示记录的类型， 0 表示普通记录、 2 表示最小记录、 3 表示最大记录、 1 暂时还没用过，下面讲。</li><li>next_record ：记录头信息的一项属性，表示下一条地址相对于本条记录的地址偏移量，我们用箭头来表明下一条记录是谁。</li><li><strong>各个列的值</strong> ：这里只记录在 index_demo 表中的三个列，分别是 c1 、 c2 和 c3 。</li><li><strong>其他信息</strong> ：除了上述3种信息以外的所有信息，包括其他隐藏列的值以及记录的额外信息。将记录格式示意图的其他信息项暂时去掉并把它竖起来的效果就是这样：</li></ul><p>将记录格式示意图的其他信息项暂时去掉并把它竖起来的效果就是这样：  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220115103713866.png" alt="image-20220115103713866"></p><p>把一些记录放到页里的示意图就是：  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220115103726133.png" alt="image-20220115103726133"></p><h3 id="1-一个简单的索引设计方案"><a href="#1-一个简单的索引设计方案" class="headerlink" title="1. 一个简单的索引设计方案"></a>1. 一个简单的索引设计方案</h3><p>我们在根据某个搜索条件查找一些记录时为什么要遍历所有的数据页呢？因为各个页中的记录并没有规律，我们并不知道我们的搜索条件匹配哪些页中的记录，所以不得不依次遍历所有的数据页。所以如果我们 <strong>想快速的定位到需要查找的记录在哪些数据页</strong> 中该咋办？我们可以为快速定位记录所在的数据页而 <strong>建立一个目录</strong> ，建这个目录必须完成下边这些事  </p><ul><li>下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值。  </li></ul><p>假设:每个数据页最多能存放3条记录(实际上一个数据页非常大，可以存放下好多记录)。有了这个假设之后我们向index_demo表插入3条记录:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> index_demo <span class="token keyword">VALUES</span><span class="token punctuation">(</span><span class="token number">1</span>，<span class="token number">4</span>，<span class="token string">'u'</span><span class="token punctuation">)</span>，<span class="token punctuation">(</span><span class="token number">3</span>， <span class="token number">9</span>，<span class="token string">'d'</span><span class="token punctuation">)</span>，<span class="token punctuation">(</span><span class="token number">5</span> <span class="token number">3</span>， <span class="token string">'y'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Query oK<span class="token punctuation">,</span><span class="token number">3</span> <span class="token keyword">rows</span> affected <span class="token punctuation">(</span><span class="token number">0.01</span> sec<span class="token punctuation">)</span>Records : <span class="token number">3</span> Duplicates: <span class="token number">0</span> <span class="token keyword">warnings</span> : <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>那么这些记录已经按照主键值的大小串联成一个单向链表了，如图所示：</p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220115104243828.png" alt="image-20220115104243828" style="zoom:67%;"><p>从图中可以看出来, <strong>index_demo</strong>表中的3条记录都被插入到了编号为10的数据页中了。此时我们再来插入一条记录:</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">mysql&gt; INSERT INTO index_demo VALUES(4,4,&#39;a&#39;);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> <img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220115104413616.png" alt="image-20220115104413616"></p><p>注意，新分配的<strong>数据页编号</strong>可能并不是连续的。它们只是通过维护着上一个页和下一个页的编号而建立了<strong>链表</strong>关系。另外，<strong>页10</strong>中用户记录最大的主键值是5，而<strong>页28</strong>中有一条记录的主键值是4，因为<strong>5 &gt;4</strong>，所以这就不符合下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值的要求，所以在插入主键值为4的记录的时候需要伴随着一次<strong>记录移动</strong>，也就是把主键值为5的记录移动到页28中，然后再把主键值为4的记录插入到页10中，这个过程的示意图如下:</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220115104730152.png" alt="image-20220115104730152"></p><p>这个过程表明了在对页中的记录进行增删改操作的过程中，我们必须通过一些诸如记录移动的操作来始终保证这个状态一直成立:下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值。这个过程我们称为<strong>页分裂</strong>。</p><ul><li>给所有的页建立一个目录项  </li></ul><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220115105020632.png" alt="image-20220115105020632"></p><p>所以我们为上边几个页做好的目录就像这样子：  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220115104858560.png" alt="image-20220115104858560"></p><p>以 页28 为例，它对应 目录项2 ，这个目录项中包含着该页的页号 28 以及该页中用户记录的最小主键值 5 。我们只需要把几个目录项在物理存储器上连续存储（比如：数组），就可以实现根据主键值快速查找某条记录的功能了。比如：查找主键值为 20 的记录，具体查找过程分两步：</p><ol><li><p>先从<strong>目录项</strong>中根据 二分法 快速确定出主键值为 20 的记录在 目录项3 中（因为 12 &lt; 20 &lt;209 ），它对应的页是 页9 。</p></li><li><p>再根据前边说的在页中查找记录的方式去 页9 中定位具体的记录。</p></li></ol><p>至此，针对数据页做的简易目录就搞定了。这个目录有一个别名，称为 <strong>索引</strong> 。  </p><h3 id="2-InnoDB中的索引方案"><a href="#2-InnoDB中的索引方案" class="headerlink" title="2.InnoDB中的索引方案"></a>2.InnoDB中的索引方案</h3><p><strong>① 迭代1次：目录项纪录的页</strong>  </p><p>我们把前边使用到的目录项放到数据页中的样子就是这样：  </p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220117111135749.png" alt="image-20220117111135749" style="zoom: 67%;"><p>从图中可以看出来，我们新分配了一个编号为30的页来专门存储目录项记录。这里再次强调 目录项记录和普通的 用户记录 的不同点：  </p><ul><li><strong>目录项记录</strong> 的<code> record_type</code> 值是 <strong>1</strong>，而 普通用户记录 的<code> record_type</code> 值是 <strong>0</strong>。</li><li>目录项记录只有 <strong>主键值和页的编号</strong> 两个列，而普通的用户记录的列是用户自己定义的，可能包含** <strong>很</strong><br>多列** ，另外还有<code>InnoDB</code>自己添加的隐藏列。</li><li>了解：记录头信息里还有一个叫 min_rec_mask 的属性，只有在存储 目录项记录 的页中的主键值<br>最小的 目录项记录 的 min_rec_mask 值为 1 ，其他别的记录的 min_rec_mask 值都是 0 。  </li></ul><p>相同点：两者用的是一样的数据页，都会为主键值生成 Page Directory （页目录），从而在按照主键值进行查找时可以使用 <strong>二分法</strong> 来加快查询速度。  </p><p>现在以查找主键为 20 的记录为例，根据某个主键值去查找记录的步骤就可以大致拆分成下边两步：  </p><ol><li>先到存储 <strong>目录项记录</strong> 的页，也就是页30中通过 <strong>二分法</strong> 快速定位到对应目录项，因为 12 &lt; 20 &lt; 209 ，所以定位到对应的记录所在的页就是页 <strong>9</strong>。</li><li>再到存储用户记录的页9中根据 <strong>二分法</strong> 快速定位到主键值为 20 的用户记录  </li></ol><p><strong>② 迭代2次：多个目录项纪录的页</strong>  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220117111536071.png" alt="image-20220117111536071"></p><p>从图中可以看出，我们插入了一条主键值为320的用户记录之后需要两个新的数据页：</p><ul><li>为存储该用户记录而新生成了 页31 。</li><li>因为原先存储目录项记录的 页30的容量已满 （我们前边假设只能存储4条目录项记录），所以不得<br>不需要一个新的 页32 来存放 页31 对应的目录项。  </li></ul><p>现在因为存储目录项记录的页不止一个，所以如果我们想根据主键值查找一条用户记录大致需要3个步<br>骤，以查找主键值为 20 的记录为例：  </p><ul><li><ol><li>确定 <strong>目录项记录页</strong><br>我们现在的存储目录项记录的页有两个，即 页30 和 页32 ，又因为页30表示的目录项的主键值的范围是 [1, 320) ，页32表示的目录项的主键值不小于 <strong>320</strong> ，所以主键值为 <strong>20</strong> 的记录对应的目录项记录在 页30 中。</li></ol></li><li><ol start="2"><li>通过目录项记录页 <strong>确定用户记录真实所在的页 。</strong><br>在一个存储 <strong>目录项记录</strong> 的页中通过主键值定位一条目录项记录的方式说过了。</li></ol></li><li><ol start="3"><li>在真实存储用户记录的页中定位到具体的记录。  </li></ol></li></ul><p><strong>③ 迭代3次：目录项记录页的目录页</strong>  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220117111848240.png" alt="image-20220117111848240"></p><p>如图，我们生成了一个存储更高级目录项的 <strong>页33</strong> ，这个页中的两条记录分别代表页30和页32，如果用户记录的主键值在 <strong>[1, 320)</strong> 之间，则到页30中查找更详细的目录项记录，如果主键值 不小于320 的话，就到页32中查找更详细的目录项记录。</p><p>我们可以用下边这个图来描述它：  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220117111947930.png" alt="image-20220117111947930"></p><p>这个数据结构，它的名称是 <strong>B+树</strong>  。</p><p><strong>④ B+Tree</strong>  </p><p>一个B+树的节点其实可以分成好多层，规定最下边的那层，也就是存放我们用户记录的那层为第 0 层，之后依次往上加。之前我们做了一个非常极端的假设：存放用户记录的页 最多存放3条记录 ，存放目录项记录的页 最多存放4条记录 。其实真实环境中一个页存放的记录数量是非常大的，假设所有存放用户记录的叶子节点代表的数据页可以存放 100条用户记录 ，所有存放目录项记录的内节点代表的数据页可以存放 1000条目录项记录 ，那么：  </p><ul><li>如果B+树只有1层，也就是只有1个用于存放用户记录的节点，最多能存放 100 条记录  </li><li>如果B+树有2层，最多能存放 1000×100=10,0000 条记录。</li><li>如果B+树有3层，最多能存放 1000×1000×100=1,0000,0000 条记录。</li><li>如果B+树有4层，最多能存放 1000×1000×1000×100=1000,0000,0000 条记录。相当多的记<br>录！！！  </li></ul><p>你的表里能存放 100000000000 条记录吗？所以一般情况下，我们 <strong>用到的B+树都不会超过4层</strong> ，那我们<br>通过主键值去查找某条记录<strong>最多只需要做4个页面内的查找</strong>（查找3个目录项页和一个用户记录页），又<br>因为在每个页面内有所谓的 Page Directory （页目录），所以在页面内也可以通过 <strong>二分法</strong> 实现快速<br>定位记录 。</p><h2 id="3-3-常见索引概念"><a href="#3-3-常见索引概念" class="headerlink" title="3.3 常见索引概念"></a>3.3 常见索引概念</h2><p>索引按照物理实现方式，索引可以分为 2 种：聚簇（聚集）和非聚簇（非聚集）索引。我们也把非聚集</p><p>索引称为二级索引或者辅助索引。  </p><h3 id="1-聚簇索引"><a href="#1-聚簇索引" class="headerlink" title="1.聚簇索引"></a>1.聚簇索引</h3><p><strong>索引即数据，数据即索引。</strong></p><p>特点：</p><ol><li>使用记录<strong>主键值</strong>的大小进行记录和页的排序，这包括三个方面的含义：</li></ol><ul><li>页内 的记录是按照主键的大小顺序排成一个 <strong>单向链表</strong> 。</li><li>各个存放 <strong>用户记录的页</strong> 也是根据页中用户记录的主键大小顺序排成一个 双向链表 。</li><li>存放 <strong>目录项记录的页</strong> 分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个 <strong>双向链表</strong> 。</li></ul><ol start="2"><li>B+树的 叶子节点 存储的是完整的用户记录。</li></ol><p>所谓完整的用户记录，就是指这个记录中存储了所有列的值（包括隐藏列）。  </p><p><strong>优点：</strong></p><ul><li>数据访问更快 ，因为<strong>聚簇索引将索引和数据保存在同一个B+树中</strong>，因此从聚簇索引中获取数据比非聚簇索引更快</li><li>聚簇索引对于<strong>主键的 排序查找 和 范围查找 速度非常快</strong></li><li>按照聚簇索引排列顺序，查询显示一定范围数据的时候，由于数据都是紧密相连，数据库不用从多个数据块中提取数据，所以 <strong>节省了大量的io操作</strong> 。  </li></ul><p>缺点：</p><ul><li><strong>插入速度严重依赖于插入顺序</strong> ，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们<strong>一般都会定义一个自增的ID列为主键</strong></li><li><strong>更新主键的代价很高</strong> ，因为将会导致被更新的行移动。因此，对于InnoDB表，我们<strong>一般定义主键为不可更新</strong></li><li>二级索引访问需要两次索引查找 ，第一次找到主键值，第二次根据主键值找到行数据  </li></ul><h3 id="2-二级索引（辅助索引、非聚簇索引）"><a href="#2-二级索引（辅助索引、非聚簇索引）" class="headerlink" title="2. 二级索引（辅助索引、非聚簇索引）"></a>2. 二级索引（辅助索引、非聚簇索引）</h3><p>上边介绍的<strong>聚簇索引</strong>只能在<strong>搜索条件是主键值时</strong>才能发挥作用，因为B+树中的数据都是按照主键进行排序的。那如果我们想以别的列作为搜索条件该怎么办呢? 肯定不能是从头到尾沿着链表依次遍历记录一遍</p><p>答案:我们可以<strong>多建几棵B+树</strong>，不同的B+树中的数据采用不同的排序规则。比方说我们用 <strong>c2</strong> 列的大小作为数据页、页中记录的排序规则，再建一棵B+树，效果如下图所示:</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220117112703079.png" alt="image-20220117112703079"></p><p>这个B+树与上边介绍的聚簇索引有几处不同：  </p><ul><li><p>使用记录c2列的大小进行记录和页的排序，这包括三个方面的含义:</p><ul><li><p>页内的记录是按照c2列的大小顺序排成一个<strong>单向链表</strong>。</p></li><li><p>各个存放用户记录的页也是根据页中记录的c2列大小顺序排成一个<strong>双向链表</strong>。</p></li><li><p>存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的c2列大小顺序排成一个<strong>双向链表</strong>。</p></li></ul></li><li><p>B+树的叶子节点存储的并不是完整的用户记录，而只是<strong>c2列+主键</strong>这两个列的值。</p></li><li><p>目录项记录中不再是<strong>主键+页号</strong>的搭配，而变成了<strong>c2列+页号</strong>的搭配。</p></li></ul><p>所以如果我们现在想通过c2列的值查找某些记录的话就可以使用我们刚刚建好的这个B+树了。以查找c2列的值为 <strong>4</strong> 的记录为例，查找过程如下:</p><p>1.确定<strong>目录项记录页</strong></p><p>根据<strong>根页面</strong>，也就是页44，可以快速定位到<strong>目录项记录</strong>所在的页为页42(因为2&lt;4&lt;9 )。</p><p>2．通过<strong>目录项记录</strong>页确定用户记录真实所在的页。</p><p>在页42中可以快速定位到实际存储用户记录的页，但是由于c2列并没有唯一性约束，所以c2列值为4的记录可能分布在多个数据页中，又因为2&lt; 4≤4，所以确定实际存储用户记录的页在页34和页35中。</p><p>3．在真实存储用户记录的页中定位到具体的记录。</p><p>到页34和页35中定位到具体的记录。</p><p>4、但是这个B+树的叶子节点中的记录只存储了<strong>c2</strong>和c1(也就是<strong>主键</strong>）两个列，所以我们<strong>必须再根据主键值去聚簇索引中再查找</strong>一遍完整的用户记录。</p><p><strong>概念</strong>：<strong>回表</strong> 我们根据这个以c2列大小排序的B+树只能确定我们要查找记录的主键值，所以如果我们想根据c2列的值查找到完整的用户记录的话，仍然需要到 <strong>聚簇索引</strong> 中再查一遍，这个过程称为 <strong>回表</strong> 。也就是根据c2列的值查询一条完整的用户记录需要使用到<code> 2 棵 B+树</code>！   </p><p><strong>问题</strong>：为什么我们还需要一次 <strong>回表</strong> 操作呢？直接把完整的用户记录放到二级索引的叶子节点不OK吗？  </p><p><strong>答</strong>：如果把完整的用户记录放到叶子节点是可以不用回表。但是<strong>太占地方了</strong>，相当于每建立一棵B+树都需要把所有的用户记录再都拷贝一遍，这就有点太浪费存储空间了。</p><p>因为这种按照非主键列建立的B+树需要一次回表操作才可以定位到完整的用户记录，所以这种B+树也被称为<strong>二级索引</strong>(英文名secondary index)，或者辅助索引。由于我们使用的是c2列的大小作为B+树的排序规则，所以我们也称这个B+树是为c2列建立的索引。</p><p>非聚簇索引的存在不影响数据在聚簇索引中的组织，所以<strong>一张表可以有多个非聚簇索引</strong>。</p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220118102446241.png" alt="image-20220118102446241" style="zoom:40%;"><h3 id="3-联合索引"><a href="#3-联合索引" class="headerlink" title="3. 联合索引"></a>3. 联合索引</h3><p>我们也可以同时以多个列的大小作为排序规则，也就是同时为多个列建立索引，比方说我们想让B+树按照 c2和c3列 的大小进行排序，这个包含两层含义：</p><ul><li>先把各个记录和页按照c2列进行排序。</li><li>在记录的c2列相同的情况下，采用c3列进行排序</li></ul><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220118102859128.png" alt="image-20220118102859128"></p><p>注意一点，以<strong>c2和c3列的大小为排序规则</strong>建立的B+树称为 <strong>联合索引</strong> ，本质上也是一个<strong>二级索引</strong>。它的意思与分别为c2和c3列分别建立索引的表述是不同的，不同点如下：</p><p>建立 <strong>联合索引</strong> 只会建立如上图一样的1棵B+树。</p><p>为c2和c3列分别建立索引会分别以c2和c3列的大小为排序规则建立2棵B+树。  </p><h2 id="3-4-InnoDB-的B-树索引的注意事项"><a href="#3-4-InnoDB-的B-树索引的注意事项" class="headerlink" title="3.4 InnoDB 的B+树索引的注意事项"></a>3.4 InnoDB 的B+树索引的注意事项</h2><h3 id="1-根页面位置万年不动"><a href="#1-根页面位置万年不动" class="headerlink" title="1. 根页面位置万年不动"></a>1. 根页面位置万年不动</h3><p>我们前边介绍B+树索引的时候，为了大家理解上的方便，先把存储用户记录的叶子节点都画出来，然后接着画存储目录项记录的内节点，实际上B+树的形成过程是这样的:</p><ul><li>每当为某个表创建一个B+树索引(聚簇索引不是人为创建的，默认就有）的时候，都会为这个索引创建一个<br><strong>根节点</strong>页面。最开始表中没有数据的时候，每个B+树索引对应的根节点中既没有用户记录，也没有目录项记录。</li><li>随后向表中插入用户记录时，先把用户记录存储到这个根节点中。</li><li>当根节点中的可用空间用完时继续插入记录，此时会将根节点中的所有记录<strong>复制到一个新分配的页</strong>，比如页a中，然后对这个新页进行页分裂的操作，得到另一个新页，比如页b。这时新插入的记录根据键值（也就是聚簇索引中的主键值，二级索引中对应的索引列的值)的大小就会被分配到页a或者页b中，而<strong>根节点便升级为存储目录项记录的页</strong>。</li></ul><p>这个过程特别注意的是:一个B+树索引的根节点自诞生之日起，便不会再移动。这样只要我们对某个表建立一个索引，那么它的根节点的页号便会被记录到某个地方，然后凡是InnoDB存储引擎需要用到这个索引的时候，都会从那个固定的地方取出根节点的页号，从而来访问这个索引。</p><h3 id="2-内节点中目录项记录的唯一性"><a href="#2-内节点中目录项记录的唯一性" class="headerlink" title="2. 内节点中目录项记录的唯一性"></a>2. 内节点中目录项记录的唯一性</h3><p>我们知道B+树索引的内节点中目录项记录的内容是索引列＋页号的搭配，但是这个搭配对于二级索引来说有点儿不严谨。还拿<code>index_demo</code>表为例，假设这个表中的数据是这样的:</p><table><thead><tr><th align="center">c1</th><th align="center">c2</th><th align="center">c3</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">1</td><td align="center">‘u’</td></tr><tr><td align="center">3</td><td align="center">1</td><td align="center">‘d’</td></tr><tr><td align="center">5</td><td align="center">1</td><td align="center">‘y’</td></tr><tr><td align="center">7</td><td align="center">1</td><td align="center">‘a’</td></tr></tbody></table><p>如果二级索引中目录项记录的内容只是索引列＋页号的搭配的话，那么为c2列建立索引后的B+树应该长这样:</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220118104232145.png" alt="image-20220118104232145"></p><p>如果我们想新插入一行记录，其中c1、c2、c3的值分别是:9、1、 ‘c’，那么在修改这个为c2列建立的二级索引对应的B+树时便碰到驽个大问题:由于贝3.中仔储的日以的C的值也是1，那我们这条新插入的记录两条目录项记录对应的c2列的值都是1，而我们新插入的这条记录的c2列的值也是1，那我们这条新插入的记录到底应该放到页4中，还是应该放到页5中啊?答案是:对不起，懵了。</p><p>为了让新插入记录能找到自己在那个页里，我们<strong>需要保证在B+树的同一层内节点的目录项记录除页号这个字段以外是唯一的</strong>。所以对于二级索引的内节点的目录项记录的内容实际上是由三个部分构成的:</p><ul><li>索引列的值</li><li>主键值</li><li>页号</li></ul><p>也就是我们把主键值也添加到二级索引内节点中的目录项记录了，这样就能保证B+树每一层节点中各条目录项记录除页号这个字段外是唯一的，所以我们为c2列建立二级索引后的示意图实际上应该是这样子的:</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220118104430530.png" alt="image-20220118104430530"></p><p>这样我们再插入记录<code>(9，1，&#39;c&#39;)</code>时，由于页3中存储的目录项记录是由<code>c2列＋主键＋页号</code>的值构成的，可以先把新记录的c2列的值和页3中各目录项记录的c2列的值作比较，如果c2列的值相同的话，可以接着比较主键值，因为B+树同一层中不同目录项记录的<strong>c2列＋主键</strong>的值肯定是不一样的，所以最后肯定能定位<strong>唯一的一条目录项记录</strong>，在本例中最后确定新记录应该被插入到页<strong>5</strong>中。</p><h3 id="3-一个页面最少存储2条记录"><a href="#3-一个页面最少存储2条记录" class="headerlink" title="3. 一个页面最少存储2条记录"></a>3. 一个页面最少存储2条记录</h3><p>一个B+树只需要很少的层级就可以轻松存储数亿条记录，查询速度相当不错!这是因为B+树本质上就是一个大的多层级目录，每经过一个目录时都会过滤掉许多无效的子目录，直到最后访问到存储真实数据的目录。那如果一个大的目录中只存放一个子目录是个啥效果呢?那就是目录层级非常非常非常多，而且最后的那个存放真实数据的目录中只能存放一条记录。费了半天劲只能存放一条真实的用户记录?<strong>所以InnoDB的一个数据页至少可以存放两条记录</strong>。</p><h1 id="4-MyISAM中的索引方案"><a href="#4-MyISAM中的索引方案" class="headerlink" title="4. MyISAM中的索引方案"></a>4. MyISAM中的索引方案</h1><p>B树索引适用存储引擎如表所示：  </p><table><thead><tr><th align="center">索引 / 存储引擎</th><th align="center">MyISAM</th><th align="center">InnoDB</th><th align="center">Memory</th></tr></thead><tbody><tr><td align="center">B-Tree索引</td><td align="center">支持</td><td align="center">支持</td><td align="center">支持</td></tr></tbody></table><p>即使多个存储引擎支持同一种类型的索引，但是他们的实现原理也是不同的。Innodb和MyISAM默认的索引是Btree索引；而Memory默认的索引是<strong>Hash索引</strong>。</p><p>MyISAM引擎使用 B+Tree 作为索引结构，叶子节点的data域存放的是 <strong>数据记录的地址</strong> 。</p><h3 id="4-2-MyISAM索引的原理"><a href="#4-2-MyISAM索引的原理" class="headerlink" title="4.2 MyISAM索引的原理"></a>4.2 MyISAM索引的原理</h3><p>下图是MyISAM索引的原理图。  </p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220118111201081.png" alt="image-20220118111201081" style="zoom:45%;"><p>如果我们在Col2上建立一个二级索引，则此索引的结构如下图所示：  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220118111212222.png" alt="image-20220118111212222"></p><h3 id="4-3-MyISAM-与-InnoDB对比"><a href="#4-3-MyISAM-与-InnoDB对比" class="headerlink" title="4.3 MyISAM 与 InnoDB对比"></a>4.3 MyISAM 与 InnoDB对比</h3><p>MyISAM的索引方式都是“非聚簇”的，与InnoDB包含1个聚簇索引是不同的。小结两种引擎中索引的区别：</p><p>① 在InnoDB存储引擎中，我们只需要根据主键值对 <strong>聚簇索引</strong> 进行一次查找就能找到对应的记录，而在MyISAM 中却需要进行一次 <strong>回表</strong> 操作，意味着MyISAM中建立的索引相当于全部都是 <strong>二级索引</strong> 。</p><p>② <code>InnoDB</code>的数据文件<strong>本身就是索引文件</strong>，<strong>而MyISAM索引文件和数据文件是 分离的</strong> ，索引文件仅保存<strong>数据记录的地址</strong>。</p><p>③ InnoDB的非聚簇索引data域存储相应记录 <strong>主键的值</strong> ，而MyISAM索引记录的是 地址 。换句话说，InnoDB的所有非聚簇索引都引用主键作为data域。</p><p>④ MyISAM的回表操作是十分 快速 的，因为是拿着地址偏移量直接到文件中取数据的，反观InnoDB是通过<strong>获取主键之后</strong>再去聚簇索引里找记录，虽然说也不慢，但还是比不上直接用地址去访问。</p><p>⑤ InnoDB要求表 <strong>必须有主键</strong> （ MyISAM可以没有 ）。如果没有显式指定，则MySQL系统会自动选择一个可以非空且唯一标识数据记录的列作为主键。如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整型。  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220118111349480.png" alt="image-20220118111349480"></p><h1 id="5-索引的代价"><a href="#5-索引的代价" class="headerlink" title="5. 索引的代价"></a>5. 索引的代价</h1><p>索引是个好东西，可不能乱建，它在空间和时间上都会有消耗：  </p><ul><li><strong>空间上的代价</strong></li></ul><p>每建立一个索引都要为它建立一棵B+树，每一棵B+树的每一个节点都是一个数据页，一个页默认会占用 16KB 的存储空间，一棵很大的B+树由许多数据页组成，那就是很大的一片存储空间。</p><ul><li><strong>时间上的代价</strong></li></ul><p>每次对表中的数据进行 <strong>增、删、改</strong> 操作时，都需要去修改各个B+树索引。而且我们讲过，B+树每层节点都是按照索引列的值 <strong>从小到大的顺序排序</strong> 而组成了 <strong>双向链表</strong> 。不论是叶子节点中的记录，还是内节点中的记录（也就是不论是用户记录还是目录项记录）都是按照索引列的值从小到大的顺序而形成了一个单向链表。而增、删、改操作可能会对节点和记录的排序造成破坏，所以存储引擎需要额外的时间进行一些 <strong>记录移位 ， 页面分裂 、 页面回收</strong> 等操作来维护好节点和记录的排序。如果我们建了许多索引，每个索引对应的B+树都要进行相关的维护操作，会给性能拖后腿。  </p><h1 id="6-MySQL数据结构选择的合理性"><a href="#6-MySQL数据结构选择的合理性" class="headerlink" title="6.MySQL数据结构选择的合理性"></a>6.MySQL数据结构选择的合理性</h1><h2 id="6-1-全表遍历"><a href="#6-1-全表遍历" class="headerlink" title="6.1 全表遍历"></a>6.1 全表遍历</h2><h2 id="6-2-Hash结构"><a href="#6-2-Hash结构" class="headerlink" title="6.2 Hash结构"></a>6.2 Hash结构</h2><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220118111726111.png" alt="image-20220118111726111"></p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220118111731791.png" alt="image-20220118111731791"></p><p>上图中哈希函数h有可能将两个不同的关键字映射到相同的位置，这叫做 碰撞 ，在数据库中一般采用 <strong>链接法</strong> 来解决。在链接法中，将散列到同一槽位的元素放在一个链表中，如下图所示：  </p><h3 id="Hash结构效率高，那为什么索引结构要设计成树型呢"><a href="#Hash结构效率高，那为什么索引结构要设计成树型呢" class="headerlink" title="Hash结构效率高，那为什么索引结构要设计成树型呢?"></a>Hash结构效率高，那为什么索引结构要设计成树型呢?</h3><p>原因1: Hash索引仅能满足(=) (&lt;&gt;) 和 IN查询(<strong>等值判断</strong>)。如果进行<strong>范围查询</strong>，哈希型的索引，时间复杂度会退化为<strong>o(n)</strong>; 而树型的 “有序” 特性，依然能够保持O(log2N)的高效率。</p><p>原因2: Hash索引还有一个缺陷，数据的存储是<strong>没有顺序</strong>的，在ORDER BY的情况下，使用Hash索引还需要对数据重新排序。</p><p>原因3:对于联合索引的情况，Hash值是将联合索引键合并后一起来计算的，无法对单独的一个键或者几个索引键进行查询。</p><p>原因4:∶对于等值查询来说，通常Hash索引的效率更高，不过也存在一种情况，就是<strong>索引列的重复值如果很多，效率就会降低</strong>。这是因为遇到<strong>Hash冲突</strong>时，需要遍历桶中的<strong>行指针</strong>来进行比较，找到查询的关键字，非常耗时。所以，Hash索引通常不会用到重复值多的列上，比如列为性别、年龄的情况等。</p><p>Hash索引适用存储引擎如表所示：  </p><table><thead><tr><th>索引 / 存储引擎</th><th>MyISAM</th><th>InnoDB</th><th>Memory</th></tr></thead><tbody><tr><td>HASH索引</td><td>不支持</td><td>不支持</td><td>支持</td></tr></tbody></table><p>Hash索引的适用性：<br>Hash 索引存在着很多限制，相比之下在数据库中B+树索引的使用面会更广，不过也有一些场景采用Hash索引效率更高，比如在键值型(Key-Value)数据库中，<strong>Redis存储的核心就是Hash表</strong>。</p><p>MySQL中的Memory存储引|擎支持Hash存储，如果我们需要用到查询的临时表时，就可以选择Memory存储引擎，把某个字段设置为Hash索引，比如字符串类型的字段，进行Hash计算之后长度可以缩短到几个字节。当字段的重复度低，而且经常需要进行<strong>等值查询</strong>的时候，采用Hash索引是个不错的选择。</p><p>另外，InnoDB本身不支持 Hash索引，但是提供<strong>自适应Hash索引</strong>(Adaptive Hash Index)。什么情况下才会使用自适应Hash索引呢? 如果某个数据经常被访问，当满足一定条件的时候，就会将这个数据页的地址存放到Hash表中。这样下次查询的时候，就可以直接找到这个页面的所在位置。这样让B+树也具备了Hash 索引的优点。</p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220118111831329.png" alt="image-20220118111831329" style="zoom:30%;"><p>采用自适应 Hash 索引目的是<strong>方便根据 SQL 的查询条件加速定位到叶子节点</strong>，特别是当 B+ 树比较深的时候，通过自适应 Hash 索引可以明显提高数据的检索效率。</p><p>我们可以通过<code> innodb_adaptive_hash_index</code> 变量来查看是否开启了自适应 Hash，比如：  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">show</span> variables <span class="token operator">like</span> <span class="token string">'%adaptive_hash_index'</span><span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220118112043877.png" alt="image-20220118112043877"></p><h2 id="6-3-二叉搜索树"><a href="#6-3-二叉搜索树" class="headerlink" title="6.3 二叉搜索树"></a>6.3 二叉搜索树</h2><p>如果我们利用二叉树作为索引结构，那么磁盘的IO次数和索引树的高度是相关的 。</p><p>1.二叉搜索树的特点</p><ul><li>一个节点只能有两个子节点，也就是一个节点度不能超过2</li><li>左子节点 <code>&lt;</code> 本节点;右子节点 <code>&gt;=</code> 本节点，比我大的向右，比我小的向左</li></ul><p>2.查找规则我们先来看下最基础的二叉搜索树(Binary Search Tree)，搜索某个节点和插入节点的规则一样，我们假设搜索插入的数值为key:</p><ul><li>1.如果key大于根节点，则在右子树中进行查找;</li><li>2如果key 小于根节点，则在左子树中进行查找;</li><li>3.如果 key等于根节点，也就是找到了这个节点，返回根节点即可。</li></ul><p>举个例子，我们对数列(34，22，89，5，23，77，91）创造出来的二分查找树如下图所示:</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220118113202984.png" alt="image-20220118113202984"></p><p>但是存在特殊的情况，就是有时候二叉树的深度非常大。比如我们给出的数据顺序是<code>(5,22,23,34,77,89,91)</code>，创造出来的二分搜索树如下图所示:│</p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220118113325362.png" alt="image-20220118113325362" style="zoom:80%;"><p>上面第二棵树也属于二分查找树，但是性能上已经退化成了一条链表，查找数据的时间复杂度变成了0(n)。你能看出来第一个树的深度是3，也就是说最多只需3次比较，就可以找到节点，而第二个树的深度是7，最多需要7次比较才能找到节点。</p><p>为了提高查询效率，就需要<strong>减少磁盘IO数</strong>。为了减少磁盘lo的次数，就需要尽量<strong>降低树的高度</strong>。需要把原来“瘦高”的树结构变的“矮胖”，树的每层的分叉越多越好。</p><h2 id="6-4-AVL树"><a href="#6-4-AVL树" class="headerlink" title="6.4 AVL树"></a>6.4 AVL树</h2><p>为了解决上面二叉查找树退化成链表的问题，人们提出了<strong>平衡二叉搜索树</strong>(Balanced Binary Tree)，又称为AVL树(有别于AVL算法)，它在二叉搜索树的基础上增加了约束，具有以下性质:</p><p><strong>它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</strong></p><p>这里说一下，常见的平衡二叉树有很多种，包括了<strong>平衡二叉搜索树、红黑树、数堆、伸展树</strong>。平衡二叉搜索树是最早提出来的自平衡二叉搜索树，当我们提到平衡二叉树时一般指的就是平衡二叉搜索树。事实上，第一棵树就属于平衡二叉搜索树，搜索时间复杂度就是**0(log2n)**。</p><p>数据查询的时间主要依赖于磁盘I/O的次数，如果我们采用二叉树的形式，即使通过平衡二叉搜索树进行了改进，树的深度也是 o(log2n)，当n 比较大时，深度也是比较高的，比如下图的情况:</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220118113703965.png" alt="image-20220118113703965"></p><p>每访问一次节点就需要进行一次磁盘 I/0操作，对于上面的树来说，我们需要进行5次I/0操作虽然平衡二叉树的效率高，但是树的深度也同样高，这就意味着磁盘I/o操作次数多，会影响整体数据查询的效率。，对于上面的树来说，我们需要进行5次I/0操作虽然平衡二叉树的效率高，但是树的深度也同样高，这就意味着磁盘I/o操作次数多，会影响整体数据查询的效率。</p><p>针对同样的数据，如果我们把二叉树改成 <strong>M 叉树</strong> （M&gt;2）呢？当 M=3 时，同样的 31 个节点可以由下面的三叉树来进行存储：  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220118113631329.png" alt="image-20220118113631329"></p><p>你能看到此时树的高度降低了，当数据量N大的时候，以及树的分叉数M大的时候，M叉树的高度会远小于二叉树的高度(M&gt;2)。所以，我们需要把<strong>树从“瘦高”变“矮胖”</strong>。</p><h2 id="6-5-B-Tree"><a href="#6-5-B-Tree" class="headerlink" title="6.5 B-Tree"></a>6.5 B-Tree</h2><p>B 树的结构如下图所示：  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220118114836279.png" alt="image-20220118114836279"></p><p>B树作为多路平衡查找树，它的每一个节点最多可以包括M个子节点，<strong>M称为 B树的阶</strong>。每个磁盘块中包括了<strong>关键字</strong>和<strong>子节点的指针</strong>。如果一个磁盘块中包括了×个关键字，那么指针数就是x+1。对于一个10o阶的B树来说，如果有3层的话最多可以存储约100万的索引数据。对于大量的索引数据来说，采用B树的结构是非常适合的，因为树的高度要远小于二叉树的高度。一个 M 阶的 B 树（M&gt;2）有以下的特性：</p><ol><li><p>根节点的儿子数的范围是 [2,M]。</p></li><li><p>每个中间节点包含 k-1 个关键字和 k 个孩子，孩子的数量 = 关键字的数量 +1，k 的取值范围为[ceil(M/2), M]。</p></li><li><p>叶子节点包括 k-1 个关键字（叶子节点没有孩子），k 的取值范围为 [ceil(M/2), M]。</p></li><li><p>假设中间节点节点的关键字为：Key[1], Key[2], …, Key[k-1]，且关键字按照升序排序，即 Key[i]&lt;Key[i+1]。此时 k-1 个关键字相当于划分了 k 个范围，也就是对应着 k 个指针，即为：P[1], P[2], …,P[k]，其中 P[1] 指向关键字小于 Key[1] 的子树，P[i] 指向关键字属于 (Key[i-1], Key[i]) 的子树，P[k]指向关键字大于 Key[k-1] 的子树。</p></li><li><p>所有叶子节点位于同一层。</p></li></ol><p>上面那张图所表示的 B 树就是一棵 3 阶的 B 树。我们可以看下磁盘块 2，里面的关键字为（8，12），它有 3 个孩子 (3，5)，(9，10) 和 (13，15)，你能看到 (3，5) 小于 8，(9，10) 在 8 和 12 之间，而 (13，15)大于 12，刚好符合刚才我们给出的特征。  </p><p>然后我们来看下如何用 B 树进行查找。假设我们想要 <strong>查找的关键字是 9</strong> ，那么步骤可以分为以下几步：</p><ol><li>我们与根节点的关键字 (17，35）进行比较，9 小于 17 那么得到指针 P1；</li><li>按照指针 P1 找到磁盘块 2，关键字为（8，12），因为 9 在 8 和 12 之间，所以我们得到指针 P2；</li><li>按照指针 P2 找到磁盘块 6，关键字为（9，10），然后我们找到了关键字 9。</li></ol><p>你能看出来在 B 树的搜索过程中，我们比较的次数并不少，但如果把数据读取出来然后在内存中进行比较，这个时间就是可以忽略不计的。而读取磁盘块本身需要进行 I/O 操作，消耗的时间比在内存中进行比较所需要的时间要多，是数据查找用时的重要因素。 <strong>B 树相比于平衡二叉树来说磁盘 I/O 操作要少</strong> ，在数据查询中比平衡二叉树效率要高。所以 <strong>只要树的高度足够低，IO次数足够少，就可以提高查询性能</strong> 。  </p><p><strong>小结:</strong></p><ol><li>B树在插入和删除节点的时候如果导致树不平衡，就通过自动调整节点的位置来保持树的自平衡。</li><li>关键字集合分布在整棵树中,即**叶子节点和非叶子节点都存放数据 **(如8这个非叶子节点就会存放数据)。搜索有可能在非叶子节点结束.</li><li>其搜索性能等价于在关键字全集内做一次二分查找。</li></ol><p><strong>再举例1：</strong>  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220118115030993.png" alt="image-20220118115030993"></p><h2 id="6-6-B-Tree"><a href="#6-6-B-Tree" class="headerlink" title="6.6 B+Tree"></a>6.6 B+Tree</h2><p>B+树也是一种多路搜索树，<strong>基于B树做出了改进</strong>，主流的DBMS都支持B+树的索引方式，比如MySQL。相比于B-Tree，B+Tree适合文件索引系统。</p><p>MySQL官网说明：  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220118115713457.png" alt="image-20220118115713457"></p><p><strong>B+ 树和 B 树的差异：</strong></p><ol><li>有 k 个孩子的节点就有 k 个关键字。也就是孩子数量 = 关键字数，而 B 树中，孩子数量 = 关键字数+1。</li><li>非叶子节点的关键字也会同时存在在子节点中，并且是在子节点中所有关键字的最大（或最小）。</li><li>非叶子节点仅用于索引，不保存数据记录，跟记录有关的信息都放在叶子节点中。而 B 树中， <strong>非叶子节点既保存索引，也保存数据记录</strong> 。</li><li>所有关键字都在叶子节点出现，叶子节点构成一个有序链表，而且叶子节点本身按照关键字的大小从小到大顺序链接。</li></ol><pre class="line-numbers language-none"><code class="language-none">B 树和 B+ 树都可以作为索引的数据结构，在 MySQL 中采用的是 B+ 树。但B树和B+树各有自己的应用场景，不能说B+树完全比B树好，反之亦然  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>整个过程一共进行了3次I/O操作，看起来B+树和B树的查询过程差不多，但是B+树和B树有个根本的差异在于，<strong>B+树的中间节点并不直接存储数据</strong>。这样的好处都有什么呢?</p><p>首先，B+树查询效率更稳定。因为B+树每次只有访问到叶子节点才能找到对应的数据，而在B树中，非叶子节点也会存储数据，这样就会造成查询效率不稳定的情况，有时候访问到了非叶子节点就可以找到关键字，而有时需要访问到叶子节点才能找到关键字。</p><p>其次，B+树的查询效率更高。这是因为通常B+树比B树更矮胖(阶数更大，深度更低)，查询所需要的磁盘I/o也会更少。同样的磁盘页大小，B+树可以存储更多的节点关键字。</p><p>不仅是对单个关键字的查询上，<strong>在查询范围上，B+树的效率也比B树高。</strong>这是因为所有关键字都出现在B+树的叶子节点中，叶子节点之间会有指针，数据又是递增的，这使得我们范围查找可以通过指针连接查找。而在B树中则需要通过中序遍历才能完成查询范围的查找，效率要低很多。</p><h1 id="面试造火箭计划！！！"><a href="#面试造火箭计划！！！" class="headerlink" title="面试造火箭计划！！！"></a>面试造火箭计划！！！</h1><p><strong>思考题：为了减少IO，索引树会一次性加载吗？</strong></p><p>1、数据库索引是存储在磁盘上的，如果数据量很大，必然导致索引的大小也会很大，超过几个G。<br>2、当我们利用索引查询时候，是不可能将全部几个G的索引都加载进内存的，我们能做的只能是:逐一加载每一个磁盘页，因为磁盘页对应着索引树的节点。</p><p><strong>思考题：B+树的存储能力如何？为何说一般查找行记录，最多只需1~3次磁盘IO</strong></p><p>InnoDB存储引擎中页的大小为1<strong>6KB</strong>，一般表的主键类型为INT(占用4个字节)或BIGINT(占用8个字节)，指针类型也一般为4或8个字节，也就是说一个页(B+Tree中的一个节点)中大概存储16KB/(8B+8B)=<strong>1K个键值</strong>(因为是估值，为方便计算，这里的K取值为10^3。也就是说一个深度为3的B+Tree索引可以维护10^3<em>10^3</em>10^3= <strong>10亿条记录</strong>。(这里假定一个数据页也存储10^3条行记录数据了)</p><p>实际情况中每个节点可能不能填充满，因此在数据库中，<strong>B+Tree 的高度一般都在2~4层</strong>。MySQL的InnoDB存储引擎在设计时是将根<strong>节点常驻内存的</strong>，也就是说查找某一键值的行记录时最多只需要<strong>1~3次</strong>磁盘1/o操作。</p><p><strong>思考题：为什么说B+树比B-树更适合实际应用中操作系统的文件索引和数据库索引？</strong></p><p>1、B+树的磁盘读写代价更低</p><p>B+树的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。</p><p>2、B+树的查询效率更加稳定</p><p>由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</p><p><strong>思考题：Hash 索引与 B+ 树索引的区别</strong></p><p>我们之前讲到过B+树索引的结构，Hash索引结构和B+树的不同，因此在索引使用上也会有差别</p><p>1、Hash索引<strong>不能进行范围查询，而B+树可以</strong>。这是因为Hash索引指向的数据是无序的，而B+树的叶子节点是个有序的链表。</p><p>2、Hash索引<strong>不支持联合索引的最左侧原则</strong>(即联合索引的部分索引无法使用)，而B+树可以。对于联合索引来说，Hash索引在计算Hash值的时候是将索引键合并后再一起计算Hash值，所以不会针对每个索引单独计算 Hash值。因此如果用到联合索引的一个或者几个索引时，联合索引无法被利用。</p><p>3、Hash索引<strong>不支持ORDER BY排序</strong>，因为Hash索引指向的数据是无序的，因此无法起到排序优化的作用，而<strong>B+树索引数据是有序的</strong>，可以起到对该字段ORDER BY排序优化的作用。同理，我们也<strong>无法用Hash索引进行模糊查询</strong>，而B+树使用LIKE进行模糊查询的时候，LIKE后面后模糊查询（比如%结尾）的话就可以起到优化的作用。</p><p>4.InnoDB不支持哈希索引。</p><p><strong>思考题：Hash 索引与 B+ 树索引是在建索引的时候手动指定的吗？</strong>  </p><p>如果使用的是MysQL的话，我们需要了解MySQL的存储引擎都支持哪些索引结构，如下图所示（参考来源https:/dev.mysql.com/doc/refman/8.0/en/create-index.html)。如果是其他的DBMS，可以参考相关的DBMS文档。</p><p><img src="/2022/01/15/%E7%B4%A2%E5%BC%95/01/15/%E7%B4%A2%E5%BC%95/Users/Li\AppData\Roaming\Typora\typora-user-images\image-20220118120907649.png" alt="image-20220118120907649"></p><p>你能看到，针对 <strong>InnoDB和MyISAM</strong>存储引擎，都会<strong>默认采用B+树索引，无法使用 Hash索引</strong>。InnoDB提供的<strong>自适应Hash是不需要手动指定的</strong>。如果是Memory/Heap和NDB存储引擎，是可以进行选择Hash索引的。</p>]]></content>
      
      
      <categories>
          
          <category> database </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>02 | 日志系统：一条SQL更新语句是如何执行的？（数据库使用InnoDB恢复原理）</title>
      <link href="/2022/01/13/%E4%B8%A4%E4%B8%AA%E9%87%8D%E8%A6%81%E6%97%A5%E5%BF%97%E5%8F%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D/"/>
      <url>/2022/01/13/%E4%B8%A4%E4%B8%AA%E9%87%8D%E8%A6%81%E6%97%A5%E5%BF%97%E5%8F%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="两个重要日志及数据库恢复"><a href="#两个重要日志及数据库恢复" class="headerlink" title="两个重要日志及数据库恢复"></a>两个重要日志及数据库恢复</h1><p>一条更新语句的执行流程又是怎样的呢？</p><p>之前你可能经常听 DBA 同事说，MySQL 可以恢复到半个月内任意一秒的状态，惊叹的同时，你是不是心中也会不免会好奇，这是怎样做到的呢？</p><p>我们还是从一个表的一条更新语句说起，下面是这个表的创建语句，这个表有一个主键 ID 和一个整型字段 age：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">create</span> <span class="token keyword">table</span> T<span class="token punctuation">(</span>ID <span class="token keyword">int</span> <span class="token keyword">primary</span> <span class="token keyword">key</span><span class="token punctuation">,</span> age <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果要将 ID=2 这一行的值加 1，SQL 语句就会这么写：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">update</span> T <span class="token keyword">set</span> age<span class="token operator">=</span>age<span class="token operator">+</span><span class="token number">1</span> <span class="token keyword">where</span> ID<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>前面我有跟你介绍过 SQL 语句基本的执行链路，这里我再把那张图拿过来，你也可以先简单看看这个图回顾下。首先，可以确定的说，查询语句的那一套流程，更新语句也是同样会走一遍。</p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/0d2070e8f84c4801adbfa03bda1f98d9.png" alt="MySQL 的逻辑架构图" style="zoom:33%;"><p>执行语句前要先连接数据库，这是连接器的工作。</p><p>前面我们说过，在一个表上有更新的时候，跟这个表有关的查询缓存会失效，所以这条语句就会把表 T 上所有缓存结果都清空。这也就是我们一般不建议使用查询缓存的原因。</p><p>接下来，分析器会通过词法和语法解析知道这是一条更新语句。优化器决定要使用 ID 这个索引。然后，执行器负责具体执行，找到这一行，然后更新。</p><p>与查询流程不一样的是，更新流程还涉及两个重要的日志模块，它们正是我们今天要讨论的主角：<code>redo log（重做日志）</code>和<code> binlog（归档日志）</code>。</p><h2 id="重要的日志模块：redo-log"><a href="#重要的日志模块：redo-log" class="headerlink" title="重要的日志模块：redo log"></a>重要的日志模块：redo log</h2><p>不知道你还记不记得《孔乙己》这篇文章，酒店掌柜有一个粉板，专门用来记录客人的赊账记录。如果赊账的人不多，那么他可以把顾客名和账目写在板上。但如果赊账的人多了，粉板总会有记不下的时候，这个时候掌柜一定还有一个专门记录赊账的账本。</p><p>如果有人要赊账或者还账的话，掌柜一般有两种做法：</p><ul><li>一种做法是直接把账本翻出来，把这次赊的账加上去或者扣除掉；</li><li>另一种做法是先在粉板上记下这次的账，等打烊以后再把账本翻出来核算。</li></ul><p>在生意红火柜台很忙时，掌柜一定会选择后者，因为前者操作实在是太麻烦了。首先，你得找到这个人的赊账总额那条记录。你想想，密密麻麻几十页，掌柜要找到那个名字，可能还得带上老花镜慢慢找，找到之后再拿出算盘计算，最后再将结果写回到账本上。</p><p>这整个过程想想都麻烦。相比之下，还是先在粉板上记一下方便。你想想，如果掌柜没有粉板的帮助，每次记账都得翻账本，效率是不是低得让人难以忍受？</p><p>同样，在 MySQL 里也有这个问题，如果每一次的更新操作都需要写进磁盘，然后磁盘也要找到对应的那条记录，然后再更新，整个过程 IO 成本、查找成本都很高。为了解决这个问题，MySQL 的设计者就用了类似酒店掌柜粉板的思路来提升更新效率。</p><p>而粉板和账本配合的整个过程，其实就是 MySQL 里经常说到的 <code>WAL 技术</code>，WAL 的全称是 <code>Write-Ahead Logging</code>，它的关键点就是<strong>先写日志，再写磁盘</strong>，也就是先写粉板，等不忙的时候再写账本。</p><p>具体来说，当有一条记录需要更新的时候，<code>InnoDB </code>引擎就会<strong>先把记录写到 redo log</strong>（粉板）里面，<strong>并更新内存</strong>，这个时候更新就算完成了。同时，<code>InnoDB </code>引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做，这就像打烊以后掌柜做的事。</p><p>如果今天赊账的不多，掌柜可以等打烊后再整理。但如果某天赊账的特别多，粉板写满了，又怎么办呢？这个时候掌柜只好放下手中的活儿，把粉板中的一部分赊账记录更新到账本中，然后把这些记录从粉板上擦掉，为记新账腾出空间。</p><p>与此类似，<strong>InnoDB 的 redo log 是固定大小的</strong>，比如可以配置为一组 4 个文件，每个文件的大小是 1GB，那么这块“粉板”总共就可以记录 4GB 的操作。从头开始写，写到末尾就又回到开头<strong>循环写</strong>，如下面这个图所示。</p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/16a7950217b3f0f4ed02db5db59562a7.png" alt style="zoom: 67%;"><p><strong>write pos</strong> 是当前记录的位置，一边写一边后移，写到第 3 号文件末尾后就回到 0 号文件开头。<strong>checkpoint</strong> 是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。</p><p>write pos 和 checkpoint 之间的是“粉板”上还空着的部分，可以用来记录新的操作。如果 write pos 追上 checkpoint，表示“粉板”满了，这时候不能再执行新的更新，得停下来先擦掉一些记录，把 checkpoint 推进一下。</p><p>有了 redo log，<code>InnoDB</code> 就<strong>可以保证即使数据库发生异常重启，之前提交的记录都不会丢失</strong>，这个能力称为 <strong>crash-safe</strong>。</p><p>要理解 crash-safe 这个概念，可以想想我们前面赊账记录的例子。只要赊账记录记在了粉板上或写在了账本上，之后即使掌柜忘记了，比如突然停业几天，恢复生意后依然可以通过账本和粉板上的数据明确赊账账目。</p><h2 id="重要的日志模块：binlog"><a href="#重要的日志模块：binlog" class="headerlink" title="重要的日志模块：binlog"></a>重要的日志模块：binlog</h2><p>前面我们讲过，MySQL 整体来看，其实就有两块：一块是 Server 层，它主要做的是 MySQL 功能层面的事情；还有一块是引擎层，负责存储相关的具体事宜。上面我们聊到的粉板 <strong>redo log 是 <code>InnoDB </code>引擎特有的日志</strong>，而 Server 层也有自己的日志，称为 <code>binlog</code>（归档日志）。</p><p>为什么会有两份日志呢？</p><p>因为最开始 MySQL 里并没有<code>InnoDB</code>引擎。MySQL 自带的引擎是 <code>MyISAM</code>，但是<code>MyISAM</code>没有 crash-safe 的能力，<code>binlog </code>日志只能用于归档。而<code>InnoDB</code>是另一个公司以插件形式引入 MySQL 的，既然只依靠 <code>binlog </code>是没有 crash-safe 能力的，所以 <code>InnoDB</code> 使用另外一套日志系统——也就是 <strong>redo log 来实现 crash-safe 能力</strong>。</p><h2 id="redo-log-和-binlog的区别"><a href="#redo-log-和-binlog的区别" class="headerlink" title="redo log 和 binlog的区别"></a>redo log 和 binlog的区别</h2><p>两种日志有以下三点不同。</p><ol><li>redo log 是 InnoDB 引擎特有的；<strong>binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用</strong>。redo log 是<strong>物理日志</strong>，记录的是“在某个数据页上做了什么修改”；</li><li>binlog 是<strong>逻辑日志</strong>，记录的是这个语句的原始逻辑，比如“给 ID=2 这一行的 age字段加 1 ”。<strong>redo log 是循环写的，空间固定会用完</strong>；</li><li>binlog 是可以<strong>追加写</strong>入的。“追加写”是指 binlog 文件写到一定大小后会切换到下一个，<strong>并不会覆盖以前的日志</strong>。</li></ol><h2 id="update-语句的执行流程"><a href="#update-语句的执行流程" class="headerlink" title="update 语句的执行流程"></a><strong>update 语句的执行流程</strong></h2><h3 id="update-语句执行流程图"><a href="#update-语句执行流程图" class="headerlink" title="update 语句执行流程图"></a><strong>update 语句执行流程图</strong></h3><p>图中浅色框表示是在 InnoDB 内部执行的，深色框表示是在执行器中执行的。</p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/2e5bff4910ec189fe1ee6e2ecc7b4bbe.png" alt="update 语句的执行流程图" style="zoom:67%;"><h3 id="update-语句执行步骤"><a href="#update-语句执行步骤" class="headerlink" title="update 语句执行步骤"></a>update 语句执行步骤</h3><ol><li><p>执行器：找存储引擎取到 id = 2 这一行记录</p></li><li><p>存储引擎：根据主键索引树找到这一行，如果 id = 2 这一行所在的数据页本来就在内存池（Buffer Pool）中，就直接返回给执行器；否则，需要先从磁盘读入内存池，然后再返回</p></li><li><p><a href="https://www.zhihu.com/search?q=%E6%89%A7%E8%A1%8C%E5%99%A8&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2280710259%7D">执行器</a>：拿到存储引擎返回的行记录，把 age 字段加上 1，得到一行新的记录，然后再调用存储引擎的接口写入这行新记录</p></li><li><p>存储引擎：将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 <code>prepare</code> 状态。然后告知执行器执行完成了，随时可以提交事务</p><p>注意:不要把这里的提交事务和我们 sql 语句中的提交事务 commit 命令搞混了哈，我们这里说的提交事务，指的是事务提交过程中的一个小步骤，也是最后一步。当这个步骤执行完成后，commit 命令就执行成功了。</p></li><li><p>执行器：生成这个操作的 bin log，并把 bin log 写入磁盘</p></li><li><p>执行器：调用存储引擎的提交事务接口</p></li><li><p>存储引擎：把刚刚写入的 redo log 状态改成提交（<code>commit</code>）状态，更新完成</p></li></ol><p>请格外注意和理解为什么将<code>redo log</code>的写入拆成了<strong>两个步骤</strong>：<code>prepare </code>和 <code>commit</code>，这就是**”两阶段提交”**。</p><p>为什么这样设计就能<strong>实现数据库崩溃后还能恢复数据</strong>呢？</p><h2 id="为什么说-redo-log-具有崩溃恢复的能力"><a href="#为什么说-redo-log-具有崩溃恢复的能力" class="headerlink" title="为什么说 redo log 具有崩溃恢复的能力"></a>为什么说 redo log 具有崩溃恢复的能力</h2><p>redo log 和 bin log 的一个很大的区别就是，一个是<strong>循环写</strong>，一个是追加写。也就是说 <strong>redo log 只会记录未刷入磁盘的日志</strong>，已经刷入磁盘的数据都会从 redo log 这个有限大小的日志文件里删除。</p><p>而 bin log 是追加日志，<strong>保存的是全量的日志</strong>。这就会导致一个问题，那就是没有标志能让 InnoDB 从 bin log 中判断哪些数据已经刷入磁盘了，哪些数据还没有。</p><p>举个例子，bin log 记录了两条日志：</p><pre class="line-numbers language-none"><code class="language-none">记录 1：给 id &#x3D; 1 这一行的 age 字段加 1记录 2：给 id &#x3D; 1 这一行的 age 字段加 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>假设在记录 1 刷盘后，记录 2 未刷盘时，数据库崩溃。重启后，只通过 bin log 数据库是无法判断这两条记录哪条已经写入磁盘，哪条没有写入磁盘，不管是两条都恢复至内存，还是都不恢复，对 id = 1 这行数据来说，都是不对的。</p><p>但 redo log 不一样，只要刷入磁盘的数据，都会从 redo log 中被抹掉，数据库重启后，直接把 redo log 中的数据都恢复至内存就可以了。</p><p>这就是为什么说 <strong>redo log 具有崩溃恢复的能力，而 bin log 不具备</strong>。</p><h2 id="崩溃恢复时的判断规则"><a href="#崩溃恢复时的判断规则" class="headerlink" title="崩溃恢复时的判断规则"></a>崩溃恢复时的判断规则</h2><p>根据两阶段提交，<strong>崩溃恢复时的判断规则</strong>是这样的：</p><ol><li>如果 redo log 里面的事务是完整的，也就是已经有了 commit 标识，则直接提交</li><li>如果 redo log 里面的事务处于 prepare 状态，则判断对应的事务 binlog 是否存在并完整</li></ol><ul><li>a. 如果 binlog 存在并完整，则提交事务；</li><li>b. 否则，回滚事务。</li></ul><h3 id="数据库崩溃例一"><a href="#数据库崩溃例一" class="headerlink" title="数据库崩溃例一"></a>数据库崩溃例一</h3><p>如下图所示，假设数据库在<strong>写入 redo log(prepare) 阶段之后、写入 binlog 之前</strong>，发生了崩溃，此时 redo log 里面的事务处于 prepare 状态，binlog 还没写（对应 2b），所以崩溃的时候，这个事务会回滚。</p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/v2-a26e4c7c6d2e1c89ed9c2296798e7899_720w.jpg" alt="img" style="zoom: 67%;"><p>原因：</p><p>此时 redo log 里面的事务处于 prepare 状态，binlog 还没写，之后从库进行同步的时候，无法执行这个操作，但是实际上主库已经完成了这个操作，所以为了主备一致，MySQL 崩溃时会在主库上回滚这个事务。并且，由于 binlog 还没写，所以也就不会传到备库，从而避免主备不一致的情况。</p><h3 id="数据库崩溃例二"><a href="#数据库崩溃例二" class="headerlink" title="数据库崩溃例二"></a>数据库崩溃例二</h3><p>如果数据库在写入 binlog 之后，redo log 状态修改为 commit 前发生崩溃，此时 redo log 里面的事务仍然是 prepare 状态，binlog 存在并完整（对应 2a），所以即使在这个时刻数据库崩溃了，事务仍然会被正常提交。</p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/v2-94ec46b4b750cdf6bd913b5d9eedcb53_720w.jpg" alt="img" style="zoom:67%;"><p>原因：</p><p>因为 binlog 已经写入成功了，这样之后就会被从库同步过去，但是实际上主库并没有完成这个操作，所以为了主备一致，在<a href="https://www.zhihu.com/search?q=%E4%B8%BB%E5%BA%93&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2280710259%7D">主库</a>上需要提交这个事务。</p><h2 id="redo-log-两阶段提交的必要性"><a href="#redo-log-两阶段提交的必要性" class="headerlink" title="redo log 两阶段提交的必要性"></a>redo log <strong>两阶段提交的必要性</strong></h2><p>可不可以先 redo log 写完，再写 bin log 或者反过来？</p><h3 id="1）对于先写完-redo-log-后写-bin-log-的情况："><a href="#1）对于先写完-redo-log-后写-bin-log-的情况：" class="headerlink" title="1）对于先写完 redo log 后写 bin log 的情况："></a>1）对于先写完 redo log 后写 bin log 的情况：</h3><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/v2-b690e860bdb751e57e14af362ba16647_720w.jpg" alt="img" style="zoom:67%;"><p>假设在 <strong>redo log 写完，binlog 还没有写完</strong>的时候，MySQL 进程异常重启。由于我们前面说过的，redo log 写完之后，系统即使崩溃，仍然能够把数据恢复回来，所以恢复后这一行 age 的值是 1。但是由于 binlog 没写完就 crash 了，这时候 binlog 里面就没有记录这个语句。</p><p>因此，之后备份日志的时候，存起来的 binlog 里面就没有这条语句。然后你会发现，如果需要用这个 binlog 来恢复临时库的话，由于这个语句的 binlog 丢失，这个临时库就会少了这一次更新，恢复出来的这一行 c 的值就是 0，与原库的值不同。</p><h3 id="2）对于先写完-binlog-后写-redo-log-的情况："><a href="#2）对于先写完-binlog-后写-redo-log-的情况：" class="headerlink" title="2）对于先写完 binlog 后写 redo log 的情况："></a>2）对于先写完 binlog 后写 redo log 的情况：</h3><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/v2-df3f63c6451613af1dcc4324677f1e4f_720w.jpg" alt="img" style="zoom:67%;"><p>如果在 binlog 写完之后 crash，由于 redo log 还没写，崩溃恢复以后这个事务无效，所以这一行 c 的值是 0。但是 binlog 里面已经记录了“把 c 从 0 改成 1”这个日志。所以，在之后用 binlog 来恢复的时候就多了一个事务出来，恢复出来的这一行 c 的值就是 1，与原库的值不同。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Bin log 用于记录了完整的逻辑记录，所有的逻辑记录在 bin log 里都能找到，所以在备份恢复时，是以 bin log 为基础，通过其记录的完整逻辑操作，备份出一个和原库完整的数据。</p><h2 id="面试造火箭计划！！！"><a href="#面试造火箭计划！！！" class="headerlink" title="面试造火箭计划！！！"></a>面试造火箭计划！！！</h2><ol><li><p>redo log的概念是什么? 为什么会存在.</p><p>答： redo log是重做日志。主要用于MySQL异常重启后的一种数据恢复手段，确保了数据的一致性。归根到底是MySQL为了实现WAL机制的一种手段。因为MySQL进行更新操作，为了能够快速响应，所以采用了异步写回磁盘的技术，写入内存后就返回。但是会存在crash后内存数据丢失的隐患，而redo log具备crash safe能力。</p></li><li><p>什么是<code>WAL(write-ahead log)</code>机制, 好处是什么.</p><p>答： WAL机制是<strong>先写日志，再写磁盘</strong>。也就是MySQL更新操作后在真正把数据写入到磁盘前先记录日志。好处是不用每一次操作都实时把数据写盘，就算crash后也可以通过redo log重放恢复，所以能够实现快速响应SQL语句。</p></li><li><p>redo log 为什么可以保证crash safe机制.</p><p>答： 因为redo log是每次更新操作完成后，就一定会写入的，如果写入失败，这说明此次操作失败，事务也不可能提交。redo log内部结构是基于页的，记录了这个页的字段值变化，只要crash后读取redo log进行重放就可以恢复数据。（因为redo log是循环写的，如果满了InnoDB就会执行真正写盘）</p></li><li><p>binlog的概念是什么, 起到什么作用, 可以做crash safe吗?</p><p>答：  bin log是归档日志，属于MySQL Server层的日志。可以起到全量备份的作用。当需要恢复数据时，可以取出某个时间范围内的bin log进行重放恢复。但是bin log不可以做crash safe，因为crash之前，bin log可能没有写入完全MySQL就挂了。所以需要配合redo log才可以进行crash safe。</p></li><li><p>binlog 和 redolog的不同点有哪些?</p><p>答案：参考上面笔记。</p></li><li><p>物理一致性和逻辑一直性各应该怎么理解?</p><p>答: binlog 是逻辑日志，可以给别的数据库，别的引擎使用，已经大家都讲得通这个“逻辑”；redolog是物理日志，就只有“我”自己能用，别人没有共享我的“物理格式”</p></li><li><p>执行器和innoDB在执行update语句时候的流程是什么样的?</p><p>答案：参考上面笔记。</p></li><li><p>如果数据库误操作, 如何执行数据恢复?</p><p>答：数据库在某一天误操作，就可以找到距离误操作最近的时间节点前的bin log，重放到临时数据库里，然后选择当天误删的数据恢复到线上数据库。</p></li><li><p>什么是两阶段提交, 为什么需要两阶段提交, 两阶段提交怎么保证数据库中两份日志间的逻辑一致性(什么叫逻辑一致性)?</p><p>答案：参考上面笔记。</p></li><li><p>如果不是两阶段提交, 先写redo log和先写bin log两种情况各会遇到什么问题?</p><p>答案：参考上面笔记。</p></li></ol><h2 id="一些名词"><a href="#一些名词" class="headerlink" title="一些名词"></a>一些名词</h2><p>数据页 ：MySQL的记录是以“页”为单位存取的，默认大小16K。也就是说，你要访问磁盘中一个记录，不会只读这个记录，而会把它所在的16K数据一起读入内存</p>]]></content>
      
      
      <categories>
          
          <category> database </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>01 | 基础架构：一条SQL查询语句是如何执行的？</title>
      <link href="/2022/01/12/%E4%B8%80%E6%9D%A1SQL%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/"/>
      <url>/2022/01/12/%E4%B8%80%E6%9D%A1SQL%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/</url>
      
        <content type="html"><![CDATA[<h1 id="基础架构：一条SQL查询语句是如何执行的？"><a href="#基础架构：一条SQL查询语句是如何执行的？" class="headerlink" title="基础架构：一条SQL查询语句是如何执行的？"></a>基础架构：一条SQL查询语句是如何执行的？</h1><p>下面我给出的是 <strong>MySQL 的基本架构示意图</strong>，从中你可以清楚地看到 SQL 语句在 MySQL 的各个功能模块中的执行过程。</p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/0d2070e8f84c4801adbfa03bda1f98d9.png" alt="img" style="zoom: 33%;"><p>大体来说，MySQL 可以分为 <code>Server 层</code>和<code>存储引擎层</code>两部分。</p><p><strong>Server 层</strong>包括连接器、查询缓存、分析器、优化器、执行器等，涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），<strong>所有跨存储引擎的功能都在这一层实现</strong>，比如存储过程、触发器、视图等。</p><p><strong>存储引擎层</strong>负责<code>数据的存储和提取</code>。其架构模式是<strong>插件式</strong>的，支持 InnoDB、MyISAM、Memory 等多个存储引擎。现在最常用的存储引擎是 InnoDB（支持事务），它从 MySQL 5.5.5 版本开始成为了默认存储引擎。</p><p>从图中不难看出，<strong>不同的存储引擎共用一个 Server 层</strong>，也就是从连接器到执行器的部分。</p><h2 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h2><p>第一步，你会先连接到这个数据库上，这时候接待你的就是连接器。连接器负责跟客户端建立连接、获取权限、维持和管理连接。连接命令一般是这么写的：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql <span class="token operator">-</span>h$ip <span class="token operator">-</span>P$port <span class="token operator">-</span>u$<span class="token keyword">user</span> <span class="token operator">-</span>p<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>输完命令之后，你就需要在交互对话里面输入密码。</p><p>连接完成后，如果你没有后续的动作，这个连接就处于空闲状态，你可以在<code>show processlist</code>命令中看到它。文本中这个图是 <code>show processlist </code>的结果，其中的 Command 列显示为“Sleep”的这一行，就表示现在系统里面有一个空闲连接。</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/f2da4aa3a672d48ec05df97b9f992fed.png" alt="img"></p><p>客户端如果太长时间没动静，连接器就会自动将它断开。这个时间是由参数 <code>wait_timeout </code>控制的，默认值是 8 小时。</p><p>数据库里面，长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。</p><p>建立连接的过程通常是比较复杂的，<strong>尽量减少建立连接的动作，也就是尽量使用长连接。</strong></p><p>但是全部使用长连接后，你可能会发现，有些时候 MySQL 占用内存涨得特别快，这是因为 MySQL 在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候才释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉（OOM），从现象看就是 MySQL 异常重启了。</p><p>怎么解决这个问题呢？你可以考虑以下两种方案。</p><ol><li>定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。</li><li>如果你用的是 <code>MySQL 5.7 </code>或更新版本，可以在每次执行一个比较大的操作后，通过执行<code>mysql_reset_connection</code>来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。</li></ol><h2 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h2><p>连接建立完成后，你就可以执行 <code>select</code> 语句了。执行逻辑就会来到第二步：查询缓存。</p><p>MySQL 拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。之前执行过的语句及其结果可能会以 key-value 对的形式，被直接缓存在内存中。key 是查询的语句，value 是查询的结果。如果你的查询能够直接在这个缓存中找到 key，那么这个 value 就会被直接返回给客户端。如果语句不在查询缓存中，就会继续后面的执行阶段。执行完成后，执行结果会被存入查询缓存中。你可以看到，如果查询命中缓存，MySQL 不需要执行后面的复杂操作，就可以直接返回结果，这个效率会很高。</p><p>缺点：</p><p>查询缓存的失效非常频繁，<strong>只要有对一个表的更新，这个表上所有的查询缓存都会被清空</strong>。因此很可能你费劲地把结果存起来，还没使用呢，就被一个更新全清空了。对于更新压力大的数据库来说，查询缓存的命中率会非常低。除非你的业务就是有一张静态表，很长时间才会更新一次。比如，一个系统配置表，那这张表上的查询才适合使用查询缓存。</p><p><strong>MySQL 8.0 版本直接将查询缓存的整块功能删掉了，也就是说 8.0 开始彻底没有这个功能了。</strong></p><h2 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h2><p>如果没有命中查询缓存，就要开始真正执行语句了。首先，MySQL 需要知道你要做什么，因此需要对 SQL 语句做解析。</p><p>分析器先会做“词法分析”。你输入的是由多个字符串和空格组成的一条 SQL 语句，MySQL 需要识别出里面的字符串分别是什么，代表什么。</p><p>MySQL 从你输入的”select”这个关键字识别出来，这是一个查询语句。它也要把字符串“T”识别成“表名 T”，把字符串“ID”识别成“列 ID”。</p><p>做完了这些识别以后，就要做“语法分析”。根据词法分析的结果，语法分析器会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法。</p><p>如果你的语句不对，就会收到<code>“You have an error in your SQL syntax”</code>的错误提醒，比如下面这个语句 select 少打了开头的字母“s”。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">></span> elect <span class="token operator">*</span> <span class="token keyword">from</span> t <span class="token keyword">where</span> ID<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>ERROR <span class="token number">1064</span> <span class="token punctuation">(</span><span class="token number">42000</span><span class="token punctuation">)</span>: You have an error <span class="token operator">in</span> your <span class="token keyword">SQL</span> syntax<span class="token punctuation">;</span> <span class="token keyword">check</span> the manual that corresponds <span class="token keyword">to</span> your MySQL server version <span class="token keyword">for</span> the <span class="token keyword">right</span> syntax <span class="token keyword">to</span> <span class="token keyword">use</span> near <span class="token string">'elect * from t where ID=1'</span> at line <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>一般语法错误会<strong>提示第一个出现错误的位置</strong>，所以你要关注的是紧接<code>“use near”</code>的内容。</p><h2 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h2><p>经过了分析器，MySQL 就知道你要做什么了。在开始执行之前，还要先经过优化器的处理。</p><p>优化器是在表里面有多个索引的时候，<strong>决定使用哪个索引</strong>；或者在一个语句有多表关联（join）的时候，<strong>决定各个表的连接顺序</strong>。比如你执行下面这样的语句，这个语句是执行两个表的 join：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t1 <span class="token keyword">join</span> t2 <span class="token keyword">using</span><span class="token punctuation">(</span>ID<span class="token punctuation">)</span> <span class="token keyword">where</span> t1<span class="token punctuation">.</span>c<span class="token operator">=</span><span class="token number">10</span> <span class="token operator">and</span> t2<span class="token punctuation">.</span>d<span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>既可以先从表 t1 里面取出 c=10 的记录的 ID 值，再根据 ID 值关联到表 t2，再判断 t2 里面 d 的值是否等于 20。</p><p>也可以先从表 t2 里面取出 d=20 的记录的 ID 值，再根据 ID 值关联到 t1，再判断 t1 里面 c 的值是否等于 10。</p><p>这两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪一个方案。优化器阶段完成后，这个语句的执行方案就确定下来了，然后进入执行器阶段。</p><h2 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h2><p>MySQL 通过分析器知道了你要做什么，通过优化器知道了该怎么做，于是就进入了执行器阶段，开始执行语句。</p><p>开始执行的时候，要先判断一下你对这个表 T 有没有执行查询的权限，如果没有，就会返回没有权限的错误，如下所示 (在工程实现上，如果命中查询缓存，会在查询缓存返回结果的时候，做权限验证。查询也会在优化器之前调用 precheck 验证权限)。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> T <span class="token keyword">where</span> ID<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">;</span>ERROR <span class="token number">1142</span> <span class="token punctuation">(</span><span class="token number">42000</span><span class="token punctuation">)</span>: <span class="token keyword">SELECT</span> command denied <span class="token keyword">to</span> <span class="token keyword">user</span> <span class="token string">'b'</span><span class="token variable">@'localhost'</span> <span class="token keyword">for</span> <span class="token keyword">table</span> <span class="token string">'T'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口。</p><p>比如我们这个例子中的表 T 中，ID 字段没有索引，那么执行器的执行流程是这样的：</p><p>调用 InnoDB 引擎接口取这个表的第一行，判断 ID 值是不是 10，如果不是则跳过，如果是则将这行存在结果集中；</p><p>调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。</p><p>执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。</p><p>至此，这个语句就执行完成了。</p><p>对于有索引的表，执行的逻辑也差不多。第一次调用的是“取满足条件的第一行”这个接口，之后循环取“满足条件的下一行”这个接口，这些接口都是引擎中已经定义好的。</p><p>你会在数据库的慢查询日志中看到一个<code>rows_examined</code>的字段，表示这个语句执行过程中扫描了多少行。这个值就是在执行器每次调用引擎获取数据行的时候累加的。</p><p>在有些场景下，执行器调用一次，在引擎内部则扫描了多行，因此<strong>引擎扫描行数跟 rows_examined 并不是完全相同的</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> database </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Spiral Matrix</title>
      <link href="/2022/01/11/Spiral-Matrix/"/>
      <url>/2022/01/11/Spiral-Matrix/</url>
      
        <content type="html"><![CDATA[<h2 id="54-螺旋矩阵"><a href="#54-螺旋矩阵" class="headerlink" title="54. 螺旋矩阵"></a><a href="https://leetcode-cn.com/problems/spiral-matrix/">54. 螺旋矩阵</a></h2><p>给你一个 <code>m</code> 行 <code>n</code> 列的矩阵 <code>matrix</code> ，请按照 <strong>顺时针螺旋顺序</strong> ，返回矩阵中的所有元素。</p><p><strong>Example 1:</strong></p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220111194853048.png" alt="image-20220111194853048"></p><pre class="line-numbers language-none"><code class="language-none">Input: matrix &#x3D; [[1,2,3],[4,5,6],[7,8,9]]Output: [1,2,3,6,9,8,7,4,5]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>Example 2:</strong></p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220111195003770.png" alt="image-20220111195003770"></p><pre class="line-numbers language-none"><code class="language-none">Input: matrix &#x3D; [[1,2,3,4],[5,6,7,8],[9,10,11,12]]Output: [1,2,3,4,8,12,11,10,9,5,6,7]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>提示:</strong></p><ul><li><code>m == matrix.length</code></li><li><code>n == matrix[i].length</code></li><li><code>1 &lt;= m, n &lt;= 10</code></li><li><code>-100 &lt;= matrix[i][j] &lt;= 100</code></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>参考<code>[59. 螺旋矩阵 II]</code>，模拟顺时针顺序，依次将数字填入结果链表<code>result</code>中</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> <span class="token function">spiralOrder</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> matrix<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> matrix<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span> top <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> bottom <span class="token operator">=</span> m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> right <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> m <span class="token operator">*</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">//从左到右</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> left<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> right<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                result<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>top<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> m <span class="token operator">*</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">return</span> result<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>            top<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token comment">//从上往下</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> top<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> bottom<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                result<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> m <span class="token operator">*</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">return</span> result<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>            right<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token comment">//从右往左</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> right<span class="token punctuation">;</span> i <span class="token operator">>=</span> left<span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                result<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>bottom<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> m <span class="token operator">*</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">return</span> result<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>            bottom<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token comment">//从下往后上</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> bottom<span class="token punctuation">;</span> i <span class="token operator">>=</span> top<span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                result<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> m <span class="token operator">*</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">return</span> result<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>            left<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="59-螺旋矩阵-II"><a href="#59-螺旋矩阵-II" class="headerlink" title="59. 螺旋矩阵 II"></a><a href="https://leetcode-cn.com/problems/spiral-matrix-ii/">59. 螺旋矩阵 II</a></h2><p>给你一个正整数 <code>n</code> ，生成一个包含 <code>1</code> 到 <code>n2</code> 所有元素，且元素按顺时针顺序螺旋排列的 <code>n x n</code> 正方形矩阵 <code>matrix</code> 。</p><p><strong>示例 1：</strong></p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220111194853048.png" alt="image-20220111194853048"></p><pre class="line-numbers language-none"><code class="language-none">输入：n &#x3D; 3输出：[[1,2,3],[8,9,4],[7,6,5]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>示例 2：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：n &#x3D; 1输出：[[1]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 20</code></li></ul><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ul><li><p>生成一个 <code>n × n </code>空矩阵 mat，随后模拟整个向内环绕的填入过程：</p><ol><li>定义当前左右上下边界<code> l,r,t,b</code>，初始值 num = 1，迭代终止值 <code>tar = n * n</code>；</li><li>当 <code>num &lt;= tar</code> 时，始终按照 从左到右 从上到下 从右到左 从下到上 填入顺序循环，每次填入后：<ul><li>执行 num += 1：得到下一个需要填入的数字；</li><li>更新边界：例如从左到右填完后，上边界 t += 1，相当于上边界向内缩 1。</li></ul></li><li>使用<code>num &lt;= tar</code>而不是<code>l &lt; r || t &lt; b</code>作为迭代条件，是为了解决当n为奇数时，矩阵中心数字无法在迭代过程中被填充的问题。</li></ol></li><li><p>最终返回 mat 即可。</p></li></ul><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/ccff416fa39887c938d36fec8e490e1861813d3bba7836eda941426f13420759-Picture1.png" alt="Picture1.png" style="zoom:67%;"><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">generateMatrix</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> top <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> bottom <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> right <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>         <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> target <span class="token operator">=</span> n <span class="token operator">*</span> n<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>num <span class="token operator">&lt;=</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">//从左到右</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> left<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> right<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                result<span class="token punctuation">[</span>top<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> num<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            top<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token comment">//从上往下</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> top<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> bottom<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                result<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">=</span> num<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            right<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token comment">//从右往左</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> right<span class="token punctuation">;</span> i <span class="token operator">>=</span> left<span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                result<span class="token punctuation">[</span>bottom<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> num<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            bottom<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token comment">//从下往后上</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> bottom<span class="token punctuation">;</span> i <span class="token operator">>=</span> top<span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                result<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">=</span> num<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            left<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="剑指-Offer-29-顺时针打印矩阵"><a href="#剑指-Offer-29-顺时针打印矩阵" class="headerlink" title="剑指 Offer 29. 顺时针打印矩阵"></a><a href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/">剑指 Offer 29. 顺时针打印矩阵</a></h2><p>难度简单335</p><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p><p><strong>示例 1：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：matrix &#x3D; [[1,2,3],[4,5,6],[7,8,9]]输出：[1,2,3,6,9,8,7,4,5]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>示例 2：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：matrix &#x3D; [[1,2,3,4],[5,6,7,8],[9,10,11,12]]输出：[1,2,3,4,8,12,11,10,9,5,6,7]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>限制：</strong></p><ul><li><code>0 &lt;= matrix.length &lt;= 100</code></li><li><code>0 &lt;= matrix[i].length &lt;= 100</code></li></ul><p>注意：本题与主站 54 题相同：<a href="https://leetcode-cn.com/problems/spiral-matrix/">https://leetcode-cn.com/problems/spiral-matrix/</a></p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数组中的双指针相关题目</title>
      <link href="/2022/01/10/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E5%8F%8C%E6%8C%87%E9%92%88%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/"/>
      <url>/2022/01/10/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E5%8F%8C%E6%8C%87%E9%92%88%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="数组中的双指针"><a href="#数组中的双指针" class="headerlink" title="数组中的双指针"></a>数组中的双指针</h1><h2 id="leetcode-26-删除有序数组中的重复项"><a href="#leetcode-26-删除有序数组中的重复项" class="headerlink" title="leetcode 26. 删除有序数组中的重复项"></a><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/">leetcode 26. 删除有序数组中的重复项</a></h2><p>给你一个有序数组 <code>nums</code> ，请你**<a href="http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95"> 原地</a>** 删除重复出现的元素，使每个元素 <strong>只出现一次</strong> ，返回删除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在 <strong><a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地 </a>修改输入数组</strong> 并在使用 O(1) 额外空间的条件下完成。</p><p><strong>说明:</strong></p><p>为什么返回数值是整数，但输出的答案是数组呢?</p><p>请注意，输入数组是以<strong>「引用」</strong>方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下:</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝int len &#x3D; removeDuplicates(nums);&#x2F;&#x2F; 在函数里修改输入数组对于调用者是可见的。&#x2F;&#x2F; 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。for (int i &#x3D; 0; i &lt; len; i++) &#123;    print(nums[i]);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例 1：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：nums &#x3D; [1,1,2]输出：2, nums &#x3D; [1,2]解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>示例 2：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：nums &#x3D; [0,0,1,1,1,2,2,3,3,4]输出：5, nums &#x3D; [0,1,2,3,4]解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>提示：</strong></p><ul><li><code>0 &lt;= nums.length &lt;= 3 * 104</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li><li><code>nums</code> 已按升序排列</li></ul><h3 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h3><p>数组一旦创建，就不能改变其长度，因此题目的“删除”其实是把不重复的放在前面。</p><p>题目要求不使用额外的数组，那么就在原数组上修改。</p><p>使用双指针 <code>slow</code> 和 <code>fast</code>  ，<code>slow</code>指针用来标记下一个不重复元素应该存储的位置，<code>fast</code>指针用来遍历数组。</p><h3 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h3><ol><li><p>当数组为空时，则返回 0 ；</p></li><li><p>当数组长度 &gt; 0时， 不管有没有重复元素，至少有一个不重复的元素，nums[0]一定是最后结果数组中的。因此我们从nums[1]开始遍历。设置 slow = 1, fast = 1</p></li><li><p><code>fast</code> 指针遍历数组</p><ul><li><p>当 nums[fast] == nums[fast - 1]时，说明当前fast元素已经重复，那么 fast指针继续后移（slow不动）；</p><p>当 nums[fast]  != nums[fast - 1]时，说明当前fast元素与之前不重复，将其放入<code>slow</code>的位置，<code>slow</code>和<code>fast</code>均后移。</p><p>牢记<code>slow</code>表示下一个不重复元素要放置的位置！！！！</p></li></ul></li><li><p>不重复数组长度为 <code>slow</code></p></li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">removeDuplicates</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">int</span> slow <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> fast <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>fast <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// nums[fast] == nums[fast - 1]时，说明当前fast元素已经重复，那么 fast指针继续后移（slow不动）</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>fast<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>fast <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                fast<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                 <span class="token comment">// 当 nums[fast]  != nums[fast - 1]时，说明当前fast元素与之前不重复，</span>                <span class="token comment">// 将其放入`slow`的位置，`slow`和`fast`均后移</span>                nums<span class="token punctuation">[</span>slow<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>fast<span class="token punctuation">]</span><span class="token punctuation">;</span>                slow<span class="token operator">++</span><span class="token punctuation">;</span>                fast<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> slow<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><p>时间复杂度： 由于利用双指针只遍历一次数组，所以时间复杂度为<code>O(N)</code></p><p>空间复杂度：为创建新数组，只是创建slow，fast指针，所以空间复杂度为<code>O(1)</code></p><h2 id="leetcode-27-移除元素"><a href="#leetcode-27-移除元素" class="headerlink" title="leetcode 27. 移除元素"></a><a href="https://leetcode-cn.com/problems/remove-element/">leetcode 27. 移除元素</a></h2><p>给你一个数组 <code>nums</code> 和一个值 <code>val</code>，你需要 <strong><a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a></strong> 移除所有数值等于 <code>val</code> 的元素，并返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须仅使用 <code>O(1)</code> 额外空间并 <strong><a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地 </a>修改输入数组</strong>。</p><p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p><p><strong>说明:</strong></p><p>为什么返回数值是整数，但输出的答案是数组呢?</p><p>请注意，输入数组是以<strong>「引用」</strong>方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下:</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝int len &#x3D; removeElement(nums, val);&#x2F;&#x2F; 在函数里修改输入数组对于调用者是可见的。&#x2F;&#x2F; 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。for (int i &#x3D; 0; i &lt; len; i++) &#123;    print(nums[i]);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例 1：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：nums &#x3D; [3,2,2,3], val &#x3D; 3输出：2, nums &#x3D; [2,2]解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums &#x3D; [2,2,3,3] 或 nums &#x3D; [2,2,0,0]，也会被视作正确答案。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>示例 2：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：nums &#x3D; [0,1,2,2,3,0,4,2], val &#x3D; 2输出：5, nums &#x3D; [0,1,4,0,3]解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>提示：</strong></p><ul><li><code>0 &lt;= nums.length &lt;= 100</code></li><li><code>0 &lt;= nums[i] &lt;= 50</code></li><li><code>0 &lt;= val &lt;= 100</code></li></ul><h3 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h3><p>这道题和第 27 题很像。这道题和第 283 题，第 27 题基本一致，283 题是删除 0，27 题是删除指定元素，这一题是删除重复元素，实质是一样的。</p><p>这里数组的删除并不是真的删除，只是将不需移除的元素放在数组前面。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">removeElement</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> slow <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> fast <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>fast <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>fast<span class="token punctuation">]</span> <span class="token operator">==</span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                fast<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                nums<span class="token punctuation">[</span>slow<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>fast<span class="token punctuation">]</span><span class="token punctuation">;</span>                slow<span class="token operator">++</span><span class="token punctuation">;</span>                fast<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> slow<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="leetcode-283-移动零"><a href="#leetcode-283-移动零" class="headerlink" title="leetcode 283. 移动零"></a><a href="https://leetcode-cn.com/problems/move-zeroes/">leetcode 283. 移动零</a></h2><p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p><p><strong>示例:</strong></p><pre class="line-numbers language-none"><code class="language-none">输入: [0,1,0,3,12]输出: [1,3,12,0,0]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>说明</strong>:</p><ol><li>必须在原数组上操作，不能拷贝额外的数组。</li><li>尽量减少操作次数。</li></ol><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>利用 26，27的双指针解法，将非0元素移到数组前面，记录<code>fast</code>遍历时<code>0</code>的个数 <code>count</code>，最后在数组的最后 count 个数设置为0。</p><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">moveZeroes</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> slow <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> fast <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>fast <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>fast<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                fast<span class="token operator">++</span><span class="token punctuation">;</span>                count<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                nums<span class="token punctuation">[</span>slow<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>fast<span class="token punctuation">]</span><span class="token punctuation">;</span>                fast<span class="token operator">++</span><span class="token punctuation">;</span>                slow<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span> count <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> count<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            nums<span class="token punctuation">[</span>nums<span class="token punctuation">.</span>length <span class="token operator">-</span> count<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="leetcode-977-有序数组的平方"><a href="#leetcode-977-有序数组的平方" class="headerlink" title="leetcode 977. 有序数组的平方"></a><a href="https://leetcode-cn.com/problems/squares-of-a-sorted-array/">leetcode 977. 有序数组的平方</a></h2><p>给你一个按 <strong>非递减顺序</strong> 排序的整数数组 <code>nums</code>，返回 <strong>每个数字的平方</strong> 组成的新数组，要求也按 <strong>非递减顺序</strong> 排序。</p><p><strong>示例 1：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：nums &#x3D; [-4,-1,0,3,10]输出：[0,1,9,16,100]解释：平方后，数组变为 [16,1,0,9,100]排序后，数组变为 [0,1,9,16,100]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例 2：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：nums &#x3D; [-7,-3,2,3,11]输出：[4,9,9,49,121]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 104</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li><li><code>nums</code> 已按 <strong>非递减顺序</strong> 排序</li></ul><p><strong>进阶：</strong></p><ul><li>请你设计时间复杂度为 <code>O(n)</code> 的算法解决本问题</li></ul><h3 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h3><p>最先想到的肯定就是直接遍历数组的每个值平方，然后排序美滋滋</p><h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">class Solution &#123;    public int[] sortedSquares(int[] nums) &#123;        for(int i &#x3D; 0; i &lt; nums.length; i++) &#123;            nums[i] &#x3D; nums[i] * nums[i];        &#125;        Arrays.sort(nums);        return nums;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>Arrays.sort(nums)</code>底层对基本数据类型排序使用的是快速排序，我们回顾一下快速排序，平均时间复杂度是<code>O(NlogN)</code>，最坏情况下是<code>O(N^2)</code></p><p>因此我们需要对<strong>解法一</strong>进行优化</p><h3 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h3><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>题目是<code>非递减数组</code>，所以可知数组的最外边是最大的，越在中心越小。</p><p>此时可以考虑双指针法了，i指向起始位置，j指向终止位置。</p><p>定义一个新数组result，和A数组一样的大小，让k指向result数组终止位置。</p><p>如果<code>A[i] * A[i] &lt; A[j] * A[j]</code> 那么<code>result[k--] = A[j] * A[j];</code> 。</p><p>如果<code>A[i] * A[i] &gt;= A[j] * A[j]</code> 那么<code>result[k--] = A[i] * A[i];</code> 。</p><p>具体步骤如下动图所示（参考<a href="https://www.programmercarl.com/0977.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9.html#%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95">代码随想录</a>）：</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/977.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9.gif" alt="977.有序数组的平方"></p><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">sortedSquares</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> j <span class="token operator">=</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment">//新数组从后往前，从大到小的放置元素</span>        <span class="token keyword">int</span> k <span class="token operator">=</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">*</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">*</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                res<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">*</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                i<span class="token operator">++</span><span class="token punctuation">;</span>                k<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                res<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">*</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                j<span class="token operator">--</span><span class="token punctuation">;</span>                k<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Sorting algorithrm I</title>
      <link href="/2021/12/29/Sorting-algorithrm/"/>
      <url>/2021/12/29/Sorting-algorithrm/</url>
      
        <content type="html"><![CDATA[<p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/sort.png" alt="sort"></p><h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>​    冒泡排序是一种简单的交换类排序方法，它是通过对相邻数据元素进行交换，逐步将待排序序列变成有序序列的过程。</p><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a><strong>算法思想</strong></h3><p>反复扫描待排序序列，再扫描的过程中顺次比较相邻两个元素的大小，逆序就交换位置。</p><p>以升序为例，在第一趟冒泡排序中，从第一个记录开始，扫描整个待排序序列，若相邻的两个元素逆序，则交换位置。</p><p>在扫描在过程中，不断地将两个相邻记录中关键字大的记录向后移动，最后<strong>必然将待排序列中最大的换到序列的末尾。</strong></p><p>然后进行第二趟冒泡排序，对前n -1个元素进行同样的操作，其结果是使次大的元素被放在第 n - 1个位置上。</p><p>然后进行第三趟冒泡排序，对前n - 2个元素进行同样的操作，其结果是使第三大的元素被放在第 n - 2个位置上。</p><p>如此反复，知道剩下一个最小的元素。</p><p>如果<strong>在某一趟冒泡排序过程中，没有发现一个逆序，说明已经有序，则可以直接结束整个排序</strong>。所以<strong>冒泡排序最多进行 n -1 趟</strong>。（只剩最后一个不用再进行排序，因为已经比它大的已经全在它的右边排好了，所以最多 n - 1趟）</p><h3 id="动图演示："><a href="#动图演示：" class="headerlink" title="动图演示："></a>动图演示：</h3><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/bubbleSort.gif" alt="bubbleSort"></p><h3 id="最好情况"><a href="#最好情况" class="headerlink" title="最好情况"></a>最好情况</h3><p>当输入的数据已经是<strong>正序</strong>时（都已经是正序了，我还要你冒泡排序有何用啊）。</p><h3 id="最坏情况"><a href="#最坏情况" class="headerlink" title="最坏情况"></a>最坏情况</h3><p>当输入的数据是<strong>逆序</strong>时（写一个 for 循环反序输出数据不就行了，干嘛要用你冒泡排序呢，我是闲的吗）。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token class-name">JZoffer</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span></span><span class="token class-name">Array</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Arrays</span><span class="token punctuation">;</span><span class="token comment">/** * @author ykangli * @version 1.0 * @date 2021/12/29 12:55 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BubbleSort</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">45</span><span class="token punctuation">,</span> <span class="token number">34</span><span class="token punctuation">,</span> <span class="token number">23</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">32</span><span class="token punctuation">,</span> <span class="token number">98</span><span class="token punctuation">,</span> <span class="token number">61</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> ints <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BubbleSort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">bubbleSort</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> anInt <span class="token operator">:</span> ints<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>anInt<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> sourceArray<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//对 arr 进行拷贝，不改变原数组</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>sourceArray<span class="token punctuation">,</span> sourceArray<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//最多排 n - 1趟</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">//设置一个flag，当在一趟序列遍历中元素没有发生交换，则证明该序列已经有序，结束整个冒泡排序</span>            <span class="token keyword">boolean</span> flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">int</span> temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                    arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                    arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>                    flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>flag<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> arr<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><ul><li><p>时间复杂度：O(N^2)</p></li><li><p>空间复杂度：O(1)</p></li><li><p>冒泡排序是<strong>稳定</strong>的排序</p></li></ul><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h3 id="算法改进要点"><a href="#算法改进要点" class="headerlink" title="算法改进要点"></a>算法改进要点</h3><p>冒泡排序在扫描过程中只对相邻两个元素进行比较，因此互换相邻元素只能消除一个逆序。如果能通过两个（不相邻）元素的交换，相处待排序序列中的多个逆序，则会大大加快排序的速度。</p><p>快速排序中的一次交换可能消除多个逆序。</p><h3 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h3><p>从待排序记录序列中选取一个元素（通常选取第一个元素）为<strong>枢轴</strong>，其关键字设为 pivot，然后将其余关键字小于 pivot的记录移到前面，而将关键字大于或等于 pivot的记录移到后面，结果将待排序记录序列分成两个子表，最后将关键字为 pivot的记录插到其分界线的位置处。将这个过程称为一趟快速排序。通过一次划分后，就以关键字为 pivot的记录来为界，将待排序序列分成了两个子表，且前面子表中所有记录的关键字均小于 pivot ，而后面子表中的所有记录的关键字均大于或等于pivot。对分割后的子表继续按上述原则进行分割，直到所有子表的表长不超过1为止，此时待排序记录序列就变成了一个有序表。</p><h3 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h3><p>假设待划分序列为 r[ low ], r[ low +1 ], … r[ high ] 。首先将基准记录 r[ low ]移至<strong>变量 pivot</strong> 中．使 r [ low ］相当于空单元，然后反复进行如下两个扫描过程，<strong>直到 low 和 high 相遇</strong>。</p><p>high 从右向左扫描，直到r [high] &lt; pivot时，将 r [ high］移至空单元元 r [ Iow ]处，此时 r[ high ]相当于空单元。<br>low 从左向右扫描，直到 r [low]  ≥ pivot时，将 r [ low ］移至空单元 r [ high ]，此时 r [l ow ］相当于空单元.<br>当 low 和 high 相遇时，r[ low ]或 r [ high ] 相当于空单元，且 r[ low ］<strong>左边所有记录的关键字均小于基准记录的关键字</strong>，而 r [ low ]<strong>右边所有记录的关键字均大于或等于基准记录的关键字</strong>。最后将基准记录移至r[ low ］中就完成一次划分过程。对于 r [ low ］左边的子表和   r [ low］右边的子表可采用同样的方法进行进一步划分。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">QuickSort</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">45</span><span class="token punctuation">,</span> <span class="token number">34</span><span class="token punctuation">,</span> <span class="token number">23</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">32</span><span class="token punctuation">,</span> <span class="token number">98</span><span class="token punctuation">,</span> <span class="token number">61</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">QuickSort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">quickSort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">:</span> a<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">void</span> <span class="token function">quickSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> r<span class="token punctuation">,</span> <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;</span> high<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">//调用一趟快速排序算法，以枢纽pivot为界划分为两个子表</span>            <span class="token keyword">int</span> pivot <span class="token operator">=</span> <span class="token function">quickPass</span><span class="token punctuation">(</span>r<span class="token punctuation">,</span> low<span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//递归对左子表进行快速排序</span>            <span class="token function">quickSort</span><span class="token punctuation">(</span>r<span class="token punctuation">,</span> low<span class="token punctuation">,</span> pivot <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//递归对右子表进行快速排序</span>            <span class="token function">quickSort</span><span class="token punctuation">(</span>r<span class="token punctuation">,</span> pivot <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 一趟快速排序算法，返回调整后基准数的位置     */</span>    <span class="token keyword">int</span> <span class="token function">quickPass</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> r<span class="token punctuation">,</span> <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//选择第一个元素为基准数</span>        <span class="token comment">//有的书上是以中间的数作为基准数的，要实现这个方便非常方便，直接将中间的数和第一个数进行交换就可以了。</span>        <span class="token keyword">int</span> pivot <span class="token operator">=</span> r<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;</span> high<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;</span> high <span class="token operator">&amp;&amp;</span> r<span class="token punctuation">[</span>high<span class="token punctuation">]</span> <span class="token operator">>=</span> pivot<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                high<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;</span> high<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                r<span class="token punctuation">[</span>low<span class="token punctuation">]</span> <span class="token operator">=</span> r<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token punctuation">;</span>                low<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;</span> high <span class="token operator">&amp;&amp;</span> r<span class="token punctuation">[</span>low<span class="token punctuation">]</span> <span class="token operator">&lt;</span> pivot<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                low<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;</span> high<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                r<span class="token punctuation">[</span>high<span class="token punctuation">]</span> <span class="token operator">=</span> r<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token punctuation">;</span>                high<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        r<span class="token punctuation">[</span>low<span class="token punctuation">]</span> <span class="token operator">=</span> pivot<span class="token punctuation">;</span>        <span class="token keyword">return</span> low<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="最好情况-1"><a href="#最好情况-1" class="headerlink" title="最好情况"></a>最好情况</h3><p>每趟将序列一分两半，正好在表中间，将表分成两个大小相等的子表，为<code>O(NlogN)</code></p><h3 id="最坏情况-1"><a href="#最坏情况-1" class="headerlink" title="最坏情况"></a>最坏情况</h3><p>已经排好序。</p><p>第一趟经过n - 1 次比较，第一次记录定在原位置，左部子表为空表，右部子表为 n - 1 个记录，第二趟对第一趟排序后的右子表经过 n - 2 次比较，第二个记录定在原位置，左部子表为空表，右部子表为 n - 2个记录 …… 共需经过 n(n - 1) / 2次比较，所以时间复杂度<code>O(N^2)</code></p><h3 id="算法分析-1"><a href="#算法分析-1" class="headerlink" title="算法分析"></a>算法分析</h3><ul><li>时间复杂度：*快速排序的最坏运行情况是 **O(n²)*<em>，比如说已排好序的数列。但它的平摊期望时间是 O(nlogn)，且 O(nlogn) 记号中隐含的常数因子很小，比复杂度稳定等于 O(nlogn) 的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。</em></li><li>空间复杂度：快速排序递归算法的执行过程对应一颗二叉树，理想情况下是一颗完全二叉树。平均情况下空间复杂度<strong>O(logN)</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Sliding Window</title>
      <link href="/2021/12/28/Sliding-Window/"/>
      <url>/2021/12/28/Sliding-Window/</url>
      
        <content type="html"><![CDATA[<h1 id="滑动窗口的相关题型"><a href="#滑动窗口的相关题型" class="headerlink" title="滑动窗口的相关题型"></a>滑动窗口的相关题型</h1><h2 id="leetcode-1-两数之和"><a href="#leetcode-1-两数之和" class="headerlink" title="leetcode 1. 两数之和"></a><a href="https://leetcode-cn.com/problems/two-sum/">leetcode 1. 两数之和</a></h2><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p><p>示例 1：</p><pre class="line-numbers language-none"><code class="language-none">输入：nums &#x3D; [2,7,11,15], target &#x3D; 9输出：[0,1]解释：因为 nums[0] + nums[1] &#x3D;&#x3D; 9 ，返回 [0, 1] 。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>示例 2：</p><pre class="line-numbers language-none"><code class="language-none">输入：nums &#x3D; [3,2,4], target &#x3D; 6输出：[1,2]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>示例 3：</p><pre class="line-numbers language-none"><code class="language-none">输入：nums &#x3D; [3,3], target &#x3D; 6输出：[0,1]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>提示：</p><ul><li><p>2 &lt;= nums.length &lt;= 104</p></li><li><p>-109 &lt;= nums[i] &lt;= 109</p></li><li><p>-109 &lt;= target &lt;= 109</p></li><li><p>只会存在一个有效答案</p></li></ul><p>进阶：你可以想出一个时间复杂度小于 O(n2) 的算法吗？</p><h3 id="暴力解法："><a href="#暴力解法：" class="headerlink" title="暴力解法："></a>暴力解法：</h3><h4 id="思路分析："><a href="#思路分析：" class="headerlink" title="思路分析："></a>思路分析：</h4><p>枚举数组中的每一个数 <code>x</code>，寻找数组中是否存在 <code>target - x</code>。</p><p>当我们使用遍历整个数组的方式寻找 <code>target - x</code> 时，需要注意到每一个位于 <code>x</code> 之前的元素都已经和 <code>x</code> 匹配过，因此不需要再进行匹配，所以我们只需要在 <code>x</code> 后面的元素中寻找 <code>target - x</code>。</p><p>代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">twoSum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> right <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> difference <span class="token operator">=</span> target <span class="token operator">-</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            right <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>right <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>difference <span class="token operator">==</span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    result<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>                    result<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> right<span class="token punctuation">;</span>                    <span class="token keyword">return</span> result<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                right<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li><p>时间复杂度：O(N^2)，其中 N 是数组中的元素数量。最坏情况下数组中任意两个数都要被匹配一次。</p></li><li><p>空间复杂度：O(1)。</p></li></ul><h3 id="哈希表解法："><a href="#哈希表解法：" class="headerlink" title="哈希表解法："></a>哈希表解法：</h3><h4 id="思路分析：-1"><a href="#思路分析：-1" class="headerlink" title="思路分析："></a>思路分析：</h4><p>暴力解法时间复杂度较高的原因是寻找 target - x 的时间复杂度过高。因此，我们需要一种更优秀的方法，能够快速寻找数组中是否存在目标元素。如果存在，我们需要找出它的索引。</p><p>我们可以利用HashMap，如果哈希表中无该元素，就将每遍历到的元素加入哈希表。比如：当 nums = [2, 3, 4, 5, 6, 7]， target = 9。</p><p>最多当遍历到 7 ，哈希表中已经存入 2，可以 O(1)地寻找 <code>target - x</code>。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">twoSum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">></span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> right <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> difference <span class="token operator">=</span> target <span class="token operator">-</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>difference<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                result<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>                result<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>difference<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> result<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li><p>时间复杂度：O(N)，其中 N 是数组中的元素数量。对于每一个元素 x，我们可以 O(1) 地寻找 target - x。</p></li><li><p>空间复杂度：O(N)，其中 N 是数组中的元素数量。主要为哈希表的开销。</p></li></ul><h2 id="leetcode-15-三数之和"><a href="#leetcode-15-三数之和" class="headerlink" title="leetcode 15. 三数之和"></a><a href="https://leetcode-cn.com/problems/3sum/">leetcode 15. 三数之和</a></h2><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。</p><p>注意：答案中不可以包含重复的三元组。</p><p>示例 1：</p><pre class="line-numbers language-none"><code class="language-none">输入：nums &#x3D; [-1,0,1,2,-1,-4]输出：[[-1,-1,2],[-1,0,1]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>示例 2：</p><pre class="line-numbers language-none"><code class="language-none">输入：nums &#x3D; []输出：[]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>示例 3：</p><pre class="line-numbers language-none"><code class="language-none">输入：nums &#x3D; [0]输出：[]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>提示：</p><ul><li><code>0 &lt;= nums.length &lt;= 3000</code></li><li><code>-105 &lt;= nums[i] &lt;= 105</code></li></ul><h3 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析:"></a>思路分析:</h3><p>如果我们直接使用三重循环枚举三元组，会得到 O(N^3)个满足题目要求的三元组（其中 N是数组的长度）**时间复杂度至少为 O(N^3)**。在这之后，我们还需要使用哈希表进行去重操作，得到不包含重复三元组的最终答案，又消耗了大量的空间。这个做法的时间复杂度和空间复杂度都很高，因此我们要换一种思路来考虑这个问题。</p><p>拿这个 nums 数组来举例，首先将数组排序，然后有一层for循环，k 从下标0的地方开始，同时定一个下标 i = k+1 的位置上，定义下标 j 在数组结尾的位置上(j = nums.length - 1)。</p><p>依然还是在数组中找到 abc 使得a + b +c =0，我们这里相当于 a = nums[k] ,b = nums[i] ,c = nums[j]。</p><p>接下来如何移动left 和right呢， 如果nums[i] + nums[left] + nums[right] &gt; 0 就说明 此时三数之和大了，因为数组是排序后了，所以right下标就应该向左移动，这样才能让三数之和小一些。</p><p>如果 nums[i] + nums[left] + nums[right] &lt; 0 说明 此时 三数之和小了，i 就向右移动，才能让三数之和大一些，直到 i 与 j 相遇为止。</p><h3 id="双指针法思路"><a href="#双指针法思路" class="headerlink" title="双指针法思路"></a>双指针法思路</h3><p> 固定 3个指针中最左（最小）数字的指针 k，双指针 i，j 分设在数组索引 (k, len(nums)) 两端，通过双指针交替向中间移动，记录对于每个固定指针 k 的所有满足 nums[k] + nums[i] + nums[j] == 0 的 i,j 组合：</p><ol><li><p>当 nums[k] &gt; 0 时直接break跳出：因为 nums[j]  &gt;=  nums[i]  &gt;=  nums[k]  &gt; 0，即 3个数字都大于 0，则三数之和必然无法等于 0，结束循环。</p></li><li><p>当 k &gt; 0且nums[k] == nums[k - 1]时即跳过此元素nums[k]：因为<strong>已经将 nums[k - 1] 的所有组合加入到结果中</strong>，本次双指针搜索只会得到重复组合。</p></li><li><p>i，j 分设在数组索引  (k, len(nums)) 两端，当i &lt; j时循环计算s = nums[k] + nums[i] + nums[j]，并按照以下规则执行双指针移动：</p><ul><li><p>当s &lt; 0时，说明nums[i] 太小，i 右移；</p></li><li><p>当s &gt; 0时，说明nums[j] 太大，j 左移；</p></li><li><p>当s == 0时，记录组合[k, i, j]至 res，<strong>执行i += 1和j -= 1</strong>，并跳过所有重复的nums[i] 和 nums[j]，防止记录到重复组合。</p></li></ul></li></ol><p>其实第二个和第三个数就是<strong>滑动窗口</strong>。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span> <span class="token function">threeSum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>nums <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> nums<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> res<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">//k进行去重  注意去重条件    nums[k] == nums[k + 1]是错误的！！！！</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>k <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">int</span> i <span class="token operator">=</span> k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> j <span class="token operator">=</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">int</span> sum <span class="token operator">=</span> nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>sum <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    i<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>sum <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    j<span class="token operator">--</span><span class="token punctuation">;</span>                           <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                    res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">//i,j同时减小，过程中去除重复的i,j   </span>                   <span class="token comment">//注意++i效率更高，++i是直接对于原对象进行自增，不用生成临时变量</span>                    <span class="token comment">//而且不需要最后再进行一次 i++ 到不重复的位置去</span>                    <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span><span class="token operator">++</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token punctuation">&#125;</span>                    <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span><span class="token operator">--</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token punctuation">&#125;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>++i 和 i++<strong>两者参与运算时的区别就是：</strong></p><ol><li>a=i++ , a 返回原来的值a=i,i=i+1;<br>a=++i , a 返回加1后的值,a=i+1,i=i+1。<br>也就是<strong>i++是先赋值，然后再自增；++i是先自增，后赋值。</strong></li><li>第二个区别就是： i++ 不能作为左值，而++i可以。</li></ol><p><strong>两者效率在某些情况下仍有不同！</strong></p><p>当我们考虑自定义类的时候，就不一样了。</p><p>i++是先用临时对象保存原来的对象，然后对原对象自增，再返回临时对象，不能作为左值；**++i是直接对于原对象进行自增**，然后返回原对象的引用，可以作为左值。</p><p>由于要生成临时对象，i++需要调用两次拷贝构造函数与析构函数（将原对象赋给临时对象一次，临时对象以值传递方式返回一次）；</p><p><strong>++i由于不用生成临时变量</strong>，且以引用方式返回，故没有构造与析构的开销，<strong>效率更高</strong>。</p><p>所以在使用类等自定义类型的时候，应尽量使用++i。</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20211230163506590.png" alt="image-20211230163506590"></p><h2 id="leetcode-18-四数之和"><a href="#leetcode-18-四数之和" class="headerlink" title="leetcode 18. 四数之和"></a><a href="https://leetcode-cn.com/problems/4sum/">leetcode 18. 四数之和</a></h2><p>给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）：</p><ul><li><p>0 &lt;= a, b, c, d &lt; n</p></li><li><p>a、b、c 和 d <strong>互不相同</strong></p></li><li><p>nums[a] + nums[b] + nums[c] + nums[d] == target</p></li></ul><p>你可以按 <strong>任意顺序</strong> 返回答案 。</p><p>示例 1：</p><pre class="line-numbers language-none"><code class="language-none">输入：nums &#x3D; [1,0,-1,0,-2,2], target &#x3D; 0输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>示例 2：</p><pre class="line-numbers language-none"><code class="language-none">输入：nums &#x3D; [2,2,2,2,2], target &#x3D; 8输出：[[2,2,2,2]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>提示：</p><ul><li>1 &lt;= nums.length &lt;= 200</li><li>-109 &lt;= nums[i] &lt;= 109</li><li>-109 &lt;= target &lt;= 109</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>暴力解法为O（N^4），数组排序后，最里面两层利用滑动窗口，可将时间复杂度将为0(N ^ 3)</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span> <span class="token function">fourSum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>nums <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> nums<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> res<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> m <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> m <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> m<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">//不能用这里的去重，因为target是任意值</span>            <span class="token comment">//if(nums[m] > target) &#123;</span>            <span class="token comment">//    break;</span>            <span class="token comment">//&#125;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>m <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>m<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> n <span class="token operator">=</span> m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> n <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> n<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">//不能用这里的去重，因为target是任意值</span>                <span class="token comment">//例： nums[m] == -3, nums[n] == -2 ,target = -6</span>                <span class="token comment">// if(nums[m] + nums[n] > target) &#123;</span>                <span class="token comment">//     break;</span>                <span class="token comment">// &#125;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">></span> m <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">continue</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token keyword">int</span> i <span class="token operator">=</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token keyword">int</span> j <span class="token operator">=</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">int</span> sum <span class="token operator">=</span> nums<span class="token punctuation">[</span>m<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span><span class="token punctuation">(</span>sum <span class="token operator">&lt;</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        i<span class="token operator">++</span><span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>sum <span class="token operator">></span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        j<span class="token operator">--</span><span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                        res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>m<span class="token punctuation">]</span> <span class="token punctuation">,</span> nums<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token punctuation">,</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment">//去重</span>                        <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span><span class="token operator">++</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        <span class="token punctuation">&#125;</span>                        <span class="token comment">//去重</span>                        <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span><span class="token operator">--</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        <span class="token punctuation">&#125;</span>                    <span class="token punctuation">&#125;</span>                 <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="leetcode-3-无重复字符的最长子串"><a href="#leetcode-3-无重复字符的最长子串" class="headerlink" title="leetcode 3. 无重复字符的最长子串"></a><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">leetcode 3. 无重复字符的最长子串</a></h2><p>给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。</p><p>示例 1:</p><pre class="line-numbers language-none"><code class="language-none">输入: s &#x3D; &quot;abcabcbb&quot;输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>示例 2:</p><pre class="line-numbers language-none"><code class="language-none">输入: s &#x3D; &quot;bbbbb&quot;输出: 1解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>示例 3:</p><pre class="line-numbers language-none"><code class="language-none">输入: s &#x3D; &quot;pwwkew&quot;输出: 3解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>示例 4:</p><pre class="line-numbers language-none"><code class="language-none">输入: s &#x3D; &quot;&quot;输出: 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>提示：</strong></p><ul><li><code>0 &lt;= s.length &lt;= 5 * 104</code></li><li><code>s</code> 由英文字母、数字、符号和空格组成</li></ul><h3 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">lengthOfLongestSubstring</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> s <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Character</span><span class="token punctuation">,</span> <span class="token class-name">Character</span><span class="token punctuation">></span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>j <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">,</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                j<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            res <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> j <span class="token operator">-</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="滑动窗口解法"><a href="#滑动窗口解法" class="headerlink" title="滑动窗口解法"></a>滑动窗口解法</h3><p>思想：</p><p>暴力解法时间复杂度是O(N^2)，使用滑动窗口可遍历一次数组完成，使得时间复杂度将为O（N）</p><p>滑动窗口的右边界不断的右移，只要没有重复的字符，就持续向右扩大窗口边界。一旦出现了重复字符，就需要缩小左边界，直到重复的字符移出了左边界，然后继续移动滑动窗口的右边界。以此类推，每次移动需要计算当前长度，并判断是否需要更新最大长度，最终最大的值就是题目中的所求。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">lengthOfLongestSubstring</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> s <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> right <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>          <span class="token comment">//set用来存储当前无重复字串都有哪些唯一的字符</span>        <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Character</span><span class="token punctuation">></span></span> set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> left <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> left<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">//每次left移动位置，都要去除set中原left位置对应的元素，因为set中始终存储的是当前不重复字串</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>left <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                set<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>left <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">//只要没有重复的字符，就持续向右扩大窗口边界</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>right <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> len <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>set<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>right <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                right<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token comment">//向set中添加</span>                set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            result <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span> right <span class="token operator">-</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">lengthOfLongestSubstring</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> right <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Character</span><span class="token punctuation">></span></span> set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> length <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>right <span class="token operator">&lt;</span> length<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">//只要没有重复的字符，就持续向右扩大窗口边界</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>set<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                result <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span> right <span class="token operator">-</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                right<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">//一旦出现了重复字符，就需要缩小左边界，直到重复的字符移出了左边界</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>right <span class="token operator">&lt;</span> length <span class="token operator">&amp;&amp;</span> set<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                set<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                left<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="leetcode-209-长度最小的子数组"><a href="#leetcode-209-长度最小的子数组" class="headerlink" title="leetcode 209. 长度最小的子数组"></a><a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/">leetcode 209. 长度最小的子数组</a></h2><p>给定一个含有 <code>n</code> 个正整数的数组和一个正整数 <code>target</code> <strong>。</strong></p><p>找出该数组中满足其和 <code>≥ target</code> 的长度最小的 <strong>连续子数组</strong> <code>[numsl, numsl+1, ..., numsr-1, numsr]</code> ，并返回其长度<strong>。</strong>如果不存在符合条件的子数组，返回 <code>0</code> 。</p><p><strong>示例 1：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：target &#x3D; 7, nums &#x3D; [2,3,1,2,4,3]输出：2解释：子数组 [4,3] 是该条件下的长度最小的子数组。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>示例 2：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：target &#x3D; 4, nums &#x3D; [1,4,4]输出：1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>示例 3：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：target &#x3D; 11, nums &#x3D; [1,1,1,1,1,1,1,1]输出：0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= target &lt;= 109</code></li><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>1 &lt;= nums[i] &lt;= 105</code></li></ul><p><strong>进阶：</strong></p><ul><li>如果你已经实现 <code>O(n)</code> 时间复杂度的解法, 请尝试设计一个 <code>O(n log(n))</code> 时间复杂度的解法。</li></ul><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>子数组想到是否能利用<code>滑动窗口</code> ？？？</p><p>这一题的解题思路是用滑动窗口。在滑动窗口 [i,j]之间不断往后移动，如果总和小于 s，就扩大右边界 j，不断加入右边的值，直到 sum &gt; s，之后再缩小 i 的左边界，不断缩小直到 sum &lt; s，这时候右边界又可以往右移动。以此类推。</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">minSubArrayLen</span><span class="token punctuation">(</span><span class="token keyword">int</span> target<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>        <span class="token comment">//扩大窗口</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> right <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> right <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> right<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            sum <span class="token operator">+=</span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token comment">//缩小窗口</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>sum <span class="token operator">>=</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                result <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span> right <span class="token operator">-</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                sum <span class="token operator">-=</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>                left<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>         <span class="token punctuation">&#125;</span>        <span class="token comment">//有无找到</span>        <span class="token keyword">return</span> result <span class="token operator">==</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MAX_VALUE <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> result<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Palindromic substring</title>
      <link href="/2021/12/26/palindromic-substring/"/>
      <url>/2021/12/26/palindromic-substring/</url>
      
        <content type="html"><![CDATA[<p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/980081ebc17e7bbd499001644140ba4.jpg" alt="2021年12月26日，毛主席诞辰128周年。西安疫情严重，西北大学学子真情流露，在操场雪地上写下众多标语，流露出对毛主席的怀念之情以及对战胜疫情回家过年的期盼。"></p><h1 id="回文串相关题目"><a href="#回文串相关题目" class="headerlink" title="回文串相关题目"></a>回文串相关题目</h1><h2 id="leecode-234-回文链表"><a href="#leecode-234-回文链表" class="headerlink" title="leecode 234. 回文链表"></a>leecode 234. 回文链表</h2><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/03/pal1linked-list.jpg" alt="img"></p><pre class="line-numbers language-none"><code class="language-none">输入：head &#x3D; [1,2,2,1]输出：true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/03/pal2linked-list.jpg" alt="img"></p><pre class="line-numbers language-none"><code class="language-none">输入：head &#x3D; [1,2]输出：false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>进阶：</strong>你能否用 <code>O(n)</code> 时间复杂度和 <code>O(1)</code> 空间复杂度解决此题？</p><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>找到链表<strong>后半部分开始的节点</strong>，反转后半部分链表。</p><h3 id="找链表中点："><a href="#找链表中点：" class="headerlink" title="找链表中点："></a>找链表中点：</h3><ul><li>链表节点数为奇数，快指针 fast 指向最后一个节点时，慢指针 slow的位置就是中点。</li><li>链表节点数为偶数，快指针 fast 指向倒数第二个节点，慢指针 slow的位置就是链表<strong>前半部分结束的节点</strong>。</li></ul><p>注意<strong>循环条件</strong>：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">while</span><span class="token punctuation">(</span>fast<span class="token punctuation">.</span>next <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>找链表中点的算法 ——&gt; <strong>快慢指针</strong></p><p>代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">middleNode</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span> head<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">ListNode</span> slow <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token class-name">ListNode</span> fast <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>fast <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> fast<span class="token punctuation">.</span>next <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>        <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/1.png" alt="1" style="zoom: 50%;"><p>由上图可知：</p><p>如果是奇数，链表中点就是 slow</p><p>如果是偶数，链表中点就是slow.next</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * Definition for singly-linked list. * public class ListNode &#123; *     int val; *     ListNode next; *     ListNode() &#123;&#125; *     ListNode(int val) &#123; this.val = val; &#125; *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isPalindrome</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span> head<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">ListNode</span> slow <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token class-name">ListNode</span> fast <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>fast<span class="token punctuation">.</span>next <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token class-name">ListNode</span> lastHalfReversed <span class="token operator">=</span>  <span class="token function">reverseRecursion</span><span class="token punctuation">(</span>slow<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>lastHalfReversed <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>val <span class="token operator">!=</span> lastHalfReversed<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            head <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            lastHalfReversed <span class="token operator">=</span> lastHalfReversed<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">public</span> <span class="token class-name">ListNode</span> <span class="token function">reverseRecursion</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span> head<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> head<span class="token punctuation">.</span>next <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> head<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token class-name">ListNode</span> newNode <span class="token operator">=</span> <span class="token function">reverseRecursion</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>        head<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>        head<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> newNode<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度：O(n)</strong>    其中 n 指的是链表的大小。</li><li><strong>空间复杂度：O(1)</strong>    我们只会修改原本链表中节点的指向，而在堆栈上的堆栈帧不超过 O(1)。</li></ul><h2 id="leetcode-647-回文子串"><a href="#leetcode-647-回文子串" class="headerlink" title="leetcode 647 . 回文子串"></a>leetcode 647 . 回文子串</h2><p>给你一个字符串 s ，请你统计并返回这个字符串中 回文子串 的数目。</p><p>回文字符串 是正着读和倒过来读一样的字符串。</p><p>子字符串 是字符串中的由连续字符组成的一个序列。</p><p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p><p><strong>示例 1：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：s &#x3D; &quot;abc&quot;输出：3解释：三个回文子串: &quot;a&quot;, &quot;b&quot;, &quot;c&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>示例 2：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：s &#x3D; &quot;aaa&quot;输出：6解释：6个回文子串: &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;aa&quot;, &quot;aa&quot;, &quot;aaa&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 1000</code></li><li><code>s</code> 由小写英文字母组成</li></ul><h3 id="暴力解法："><a href="#暴力解法：" class="headerlink" title="暴力解法："></a>暴力解法：</h3><p>判断所有字串是否为回文串，存储最长的回文子串</p><p>代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//判断字符串是不是 回文串  对称位置的关系  i &lt;------> len - i - 1</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isPalindromic</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">!=</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>len <span class="token operator">-</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">longestPalindrome</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token class-name">String</span> subStr <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isPalindromic</span><span class="token punctuation">(</span>subStr<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> subStr<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> longest<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    num<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> num<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>时间复杂度：</strong></p><p>用<br>$$<br>O(N^2)<br>$$<br>的时间枚举出所有的字串，然后判断字符串是否为回文串的算法 isPalindromic（）时间复杂度为 O(N)，所以暴力解法的时间复杂度为<br>$$<br>O(N^3)<br>$$</p><h3 id="中心扩展法："><a href="#中心扩展法：" class="headerlink" title="中心扩展法："></a><strong>中心扩展法：</strong></h3><h4 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a><strong>思路：</strong></h4><p>枚举出所有的子串（看所有的字串是不是回文串）又有另一种的思路：枚举每一个<strong>可能的回文中心</strong>，然后用两个指针分别向左右两边拓展，当两个指针指向的元素相同的时候就拓展，否则停止拓展。</p><p>偶数的子串(通过偶数的所有子串，找出偶数的回文子串)不能通过单个向两边扩展得到，比如 ababa中的字串 abab无法通过任何一个字符向两边扩展得到。</p><p>所以中心点不能只有单个字符构成，还要包括两个字符，比如上面这个子串 <code>abab</code>，就可以由中心点 <code>ba</code> 扩展一次得到。</p><h4 id="分析结论："><a href="#分析结论：" class="headerlink" title="分析结论："></a>分析结论：</h4><p>所以最终的中心点有 <code>2 * len - 1</code> 个，分别是 <code>len</code> 个单字符和 <code>len - 1</code> 个双字符。</p><p>如果上面看不太懂的话，还可以看看下面几个问题：</p><ul><li>为什么有 2 * len - 1 个中心点？<ul><li>aba 有5个中心点，分别是 a、b、c、ab、ba</li><li>abba 有7个中心点，分别是 a、b、b、a、ab、bb、ba</li></ul></li><li>什么是中心点？<ul><li>中心点即 left 指针和 right 指针初始化指向的地方，可能是一个也可能是两个</li></ul></li><li>为什么不可能是三个或者更多？<ul><li>因为 3 个可以由 1 个扩展一次得到，4 个可以由两个扩展一次得到</li></ul></li></ul><p>再次强调：如果回文长度是奇数，那么回文中心是一个字符；如果回文长度是偶数，那么中心是两个字符。</p><p>我们不妨写一组出来观察观察，假设 n = 4（abba），我们可以把可能的回文中心列出来：</p><table><thead><tr><th align="center">编号(0 ~ 2 n - 1)</th><th align="center">回文中心</th><th align="center">回文中心左起始位置</th><th align="center">回文中心右起始位置</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">a</td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center">1</td><td align="center">ab</td><td align="center">0</td><td align="center">1</td></tr><tr><td align="center">2</td><td align="center">b</td><td align="center">1</td><td align="center">1</td></tr><tr><td align="center">3</td><td align="center">bb</td><td align="center">1</td><td align="center">2</td></tr><tr><td align="center">4</td><td align="center">b</td><td align="center">2</td><td align="center">2</td></tr><tr><td align="center">5</td><td align="center">ba</td><td align="center">2</td><td align="center">3</td></tr><tr><td align="center">6</td><td align="center">a</td><td align="center">3</td><td align="center">3</td></tr></tbody></table><p>单字符中心：n 个</p><p>双字符中心： n - 1 个</p><h4 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">countSubstrings</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//回文字串最少是 s.length() -----> 也就是单个字符的个数</span>        <span class="token keyword">int</span> substrings <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment">//以单个字符为中心的情况（也就是回文子串长度是奇数的情况） n种情况</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> left <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token keyword">int</span> right <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token comment">//注意left和right的取值范围</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>left <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> right <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span> <span class="token operator">==</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                substrings<span class="token operator">++</span><span class="token punctuation">;</span>                left<span class="token operator">--</span><span class="token punctuation">;</span>                right<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>         <span class="token punctuation">&#125;</span>        <span class="token comment">//以双字符为中心的情况（也就是回文字串长度是偶数的情况） n - 1种情况 </span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> left <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token keyword">int</span> right <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>left <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> right <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span> <span class="token operator">==</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                substrings<span class="token operator">++</span><span class="token punctuation">;</span>                left<span class="token operator">--</span><span class="token punctuation">;</span>                right<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>         <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> substrings<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a><strong>复杂度分析</strong></h4><ul><li>时间复杂度：O(n^2)</li><li>空间复杂度：O(1)</li></ul><h2 id="leetcode-5-最长回文子串"><a href="#leetcode-5-最长回文子串" class="headerlink" title="leetcode 5. 最长回文子串"></a>leetcode 5. 最长回文子串</h2><h3 id="暴力解法：-1"><a href="#暴力解法：-1" class="headerlink" title="暴力解法："></a>暴力解法：</h3><h4 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//判断字符串是不是 回文串  对称位置的关系  i &lt;------> len - i - 1</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isPalindromic</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">!=</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>len <span class="token operator">-</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">longestPalindrome</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">String</span> longest <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token class-name">String</span> subStr <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isPalindromic</span><span class="token punctuation">(</span>subStr<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> subStr<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> longest<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    longest <span class="token operator">=</span> subStr<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> longest<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度:"></a>时间复杂度:</h4><p>用O(N^2)的时间枚举出所有的字串，然后判断字符串是否为回文串的算法 isPalindromic（）时间复杂度为 O(N)，所以暴力解法的时间复杂度为O(N^3)</p><h3 id="中心扩展法：-1"><a href="#中心扩展法：-1" class="headerlink" title="中心扩展法："></a>中心扩展法：</h3><p>同leetcode 645</p><h4 id="代码：-3"><a href="#代码：-3" class="headerlink" title="代码："></a>代码：</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">longestPalindrome</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>s <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">int</span> longest <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> longestStr <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>        <span class="token comment">//以单个字符为中心的情况（也就是回文子串长度是奇数的情况） n种情况</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// left = right 的时候，此时回文中心是一个字符，回文串的长度是奇数</span>            <span class="token keyword">int</span> left <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token keyword">int</span> right <span class="token operator">=</span> left<span class="token punctuation">;</span>            <span class="token comment">//注意left和right的取值范围</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>left <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> right <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span> <span class="token operator">==</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">int</span> subStrLen <span class="token operator">=</span> right <span class="token operator">-</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>subStrLen <span class="token operator">></span> longest<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    longest <span class="token operator">=</span> subStrLen<span class="token punctuation">;</span>                    longestStr <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> right <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                left<span class="token operator">--</span><span class="token punctuation">;</span>                right<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>         <span class="token punctuation">&#125;</span>        <span class="token comment">//以双字符为中心的情况（也就是回文字串长度是偶数的情况） n - 1种情况 </span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// right = left + 1 的时候，此时回文中心是一个空隙，回文串的长度是偶数</span>            <span class="token keyword">int</span> left <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token keyword">int</span> right <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>left <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> right <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span> <span class="token operator">==</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">int</span> subStrLen <span class="token operator">=</span> right <span class="token operator">-</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>subStrLen <span class="token operator">></span> longest<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    longest <span class="token operator">=</span> subStrLen<span class="token punctuation">;</span>                    longestStr <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> right <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                left<span class="token operator">--</span><span class="token punctuation">;</span>                right<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>         <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> longestStr<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li><p>时间复杂度：O(n^2)，其中 n是字符串的长度。长度为 1和 2的回文中心分别有 n和 n−1 个，每个回文中心最多会向外扩展 O(n)次。</p></li><li><p>空间复杂度：O(1)</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Fighting COVID-19</title>
      <link href="/2021/12/25/Fighting-COVID-19/"/>
      <url>/2021/12/25/Fighting-COVID-19/</url>
      
        <content type="html"><![CDATA[<p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20211225194728.jpg" alt="微信图片_20211225194728"></p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20211225194749.jpg" alt="微信图片_20211225194749"></p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20211225194836.jpg" alt="微信图片_20211225194836"></p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20211225210532848.png" alt="image-20211225210532848"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>刷题 12/24</title>
      <link href="/2021/12/24/%E5%89%91%E6%8C%87offer-03/"/>
      <url>/2021/12/24/%E5%89%91%E6%8C%87offer-03/</url>
      
        <content type="html"><![CDATA[<h2 id="剑指offer-03-数组中重复的数字"><a href="#剑指offer-03-数组中重复的数字" class="headerlink" title="剑指offer 03. 数组中重复的数字"></a>剑指offer 03. 数组中重复的数字</h2><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20211224095946844.png"></p><h3 id="一-遍历暴力解法-利用HashSet"><a href="#一-遍历暴力解法-利用HashSet" class="headerlink" title="一.遍历暴力解法 ( 利用HashSet )"></a>一.遍历暴力解法 ( 利用HashSet )</h3><p>利用HashSet, 每遍历一个就去Set集合中查询，如果有就说明前面已经存在；若没有将其存入Set。 </p><p>代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findRepeatNumber</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>set<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">return</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>          <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>notes</strong>： 牢记<code>HashSet</code>的两个函数</p><ol><li><strong>add( )</strong>                  如果Set集合中存在该元素，则返回 false</li><li><strong>contains ( )</strong>         如果Set集合中存在该元素，则返回 false</li></ol><ul><li><p><strong>时间复杂度 O(N)：</strong> 遍历数组使用 O(N) ，HashSet 添加与查找元素皆为 O(1)。</p></li><li><p><strong>空间复杂度 O(N)：</strong> HashSet 占用 O(N)  大小的额外空间。</p></li></ul><h3 id="二-原地交换"><a href="#二-原地交换" class="headerlink" title="二. 原地交换"></a>二. 原地交换</h3><p>实际中，可能要求降低空间复杂度。那我们就不能新建 HashSet，利用Set集合的唯一性来实现。那我们就得想，有没有办法仅仅使用当前的数组 nums[ ]来模拟Set。</p><p>我们仔细观察该题目，发现 ——-&gt;  <code>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内</code></p><p>可遍历数组并通过交换操作，<strong>使元素与索引值 一 一对应</strong>（即 nums[i] = inums[i]=i ）。因而，就能通过索引映射对应的值，起到与Set等价的作用。</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20211224104020538.png" alt="image-20211224104020538"></p><p>遍历中，第一次遇到数字 xx 时，将其交换至索引 xx 处；而当第二次遇到数字 xx 时，一定有 nums[x] = xnums[x]=x ，此时即可得到一组重复数字。</p><p><strong>算法步骤：</strong></p><p>一、遍历数组 nums[ ]：</p><ul><li>若 nums[i] == i， 说明元素与索引值对应，继续下一个位置。</li><li>若 nums[nums[i]] == nums[i]， 说明 索引nums[i]处和索引 i 处的元素值都是 nums[i]，找到重复的值，那么返回 nusm[i].</li><li>否则，交换 索引 i 处和 索引 nums[i] 处的元素值，也就是把 元素nums[i], 放到索引 nums[i]处。使得元素值与索引对应。</li></ul><p>二、 遍历完成未找到，返回-1 （本题有重复元素，一定能找到）</p><p>代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findRepeatNumber</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">//元素与索引值对应，继续下一个位置</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                i<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">//找到重复的值 </span>            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">return</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">//交换元素位置，使得元素值与索引对应</span>            <span class="token keyword">int</span> temp <span class="token operator">=</span>  nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>temp<span class="token punctuation">]</span><span class="token punctuation">;</span>            nums<span class="token punctuation">[</span>temp<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><strong>时间复杂度 O(N):</strong>    遍历数组使用<em>O</em>(<em>N</em>) ，每轮遍历的判断和交换操作使用<em>O</em>(1) 。</p></li><li><p><strong>空间复杂度 O(1) ：</strong> 使用常数复杂度的额外空间。</p></li></ul><h3 id="要求时间复杂度O-1-的话，怎么实现？？？？？？？"><a href="#要求时间复杂度O-1-的话，怎么实现？？？？？？？" class="headerlink" title="要求时间复杂度O(1) 的话，怎么实现？？？？？？？"></a>要求时间复杂度O(1) 的话，怎么实现？？？？？？？</h3><h2 id="剑指-Offer-30-包含min函数的栈"><a href="#剑指-Offer-30-包含min函数的栈" class="headerlink" title="剑指 Offer 30. 包含min函数的栈"></a>剑指 Offer 30. 包含min函数的栈</h2><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20211224110825312.png" alt="image-20211224110825312"><h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p>普通栈的 <code>push()</code> 和 <code>pop()</code> 函数的复杂度为 <em>O</em>(1) ；而获取栈最小值 <code>min()</code> 函数需要遍历整个栈，复杂度为 <em>O</em>(<em>N</em>) 。</p><h3 id="难点："><a href="#难点：" class="headerlink" title="难点："></a>难点：</h3><p>那么本题要解决的就是 <strong>将 <code>min()</code> 函数复杂度降为 <em>O</em>(1) ，可通过建立辅助栈实现</strong>。</p><h3 id="具体操作："><a href="#具体操作：" class="headerlink" title="具体操作："></a>具体操作：</h3><ul><li><strong>数据栈 A</strong>：  栈 A用于存储所有元素，保证入栈 push() 函数、出栈 pop() 函数、获取栈顶 top() 函数的正常逻辑。</li><li><strong>辅助栈 B</strong> ： 栈 B中存储栈 A中所有 非严格降序（相等也行） 的元素，则栈 A 中的最小元素始终对应栈 B的栈顶元素，即 min() 函数只需返回栈 B 的栈顶元素即可，可达到min（）的时间复杂度为O(N)的目的。</li></ul><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">MinStack</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//A保存所有元素，B保存非严格单调递减的元素（为了使得B栈顶就是最小值，时间复杂度为O（1））</span>    <span class="token class-name">Deque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> <span class="token class-name">A</span><span class="token punctuation">,</span> <span class="token class-name">B</span><span class="token punctuation">;</span>    <span class="token comment">/** initialize your data structure here. */</span>    <span class="token keyword">public</span> <span class="token class-name">MinStack</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name"><span class="token namespace">this<span class="token punctuation">.</span></span>A</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name"><span class="token namespace">this<span class="token punctuation">.</span></span>B</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">A</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token class-name">B</span><span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token class-name">B</span><span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">>=</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">B</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token class-name">A</span><span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">B</span><span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">B</span><span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token class-name">A</span><span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token class-name">A</span><span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">min</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token class-name">B</span><span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">/** * Your MinStack object will be instantiated and called as such: * MinStack obj = new MinStack(); * obj.push(x); * obj.pop(); * int param_3 = obj.top(); * int param_4 = obj.min(); */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="复杂度分析："><a href="#复杂度分析：" class="headerlink" title="复杂度分析："></a>复杂度分析：</h3><ul><li><strong>时间复杂度 O(1) ：</strong> push( ), pop( ), top( ), min( ) 四个函数的时间复杂度均为常数级别。</li><li><strong>空间复杂度 O(N) ：</strong> 当共有 N 个待入栈元素时，辅助栈 BB 最差情况下存储 N 个元素，使用 O(N） 额外空间。</li></ul><h2 id="剑指offer-10-II-青蛙跳台的问题"><a href="#剑指offer-10-II-青蛙跳台的问题" class="headerlink" title="剑指offer 10 - II. 青蛙跳台的问题"></a>剑指offer 10 - II. 青蛙跳台的问题</h2><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20211224170310559.png" alt="image-20211224170310559" style="zoom:80%;"><h3 id="递归三部曲："><a href="#递归三部曲：" class="headerlink" title="递归三部曲："></a>递归三部曲：</h3><ol><li><p><strong>找base case</strong>，也就是<strong>找整个递归的终止条件：递归应该在什么时候结束？</strong></p></li><li><p><strong>找返回值</strong>：应该给上一级返回什么信息？</p></li><li><p><strong>本级递归应该做什么：</strong>在这一级递归中，应该完成什么任务？</p></li></ol><p>一般想清楚<strong>本级递归应该做什么</strong>就能解决递归！</p><p>在本题中，设跳上 n级台阶有 f(n)种跳法。在所有跳法中，青蛙的最后一步只有两种情况： <strong>跳上 1 级或 2 级台阶</strong>。</p><p>所以本级递归应该完成 f(n) = f(n -1) + f(n - 2) ，就是把两种情况的各自有多少种情况加起来。</p><h3 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//map用来记忆算过的f（n）,加快递归速度，不用去重复递归计算</span>    <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">></span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">numWays</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment">//base case</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">||</span> n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">//本级递归种要做的事情</span>        result <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token function">numWays</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span>  <span class="token operator">+</span> <span class="token function">numWays</span><span class="token punctuation">(</span>n <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">1000000007</span><span class="token punctuation">;</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="leetcode-24-两两交换链表中的结点"><a href="#leetcode-24-两两交换链表中的结点" class="headerlink" title="leetcode 24. 两两交换链表中的结点"></a>leetcode 24. 两两交换链表中的结点</h2><p><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/">https://leetcode-cn.com/problems/swap-nodes-in-pairs/</a></p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20211224201958367.png" alt="image-20211224201958367"></p><p>这种链表中的k个一组交换 —–&gt; 递归   相似的还有<code> leetcode 25. K个一组反转链表</code> <a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/">https://leetcode-cn.com/problems/reverse-nodes-in-k-group/</a></p><p><strong>base case</strong>: 只有一个节点或为空</p><p><strong>本级递归要做的事情</strong>：</p><p>head， head.next， swapPairs（head.next.next）这三个节点中，将head和head.next交换</p><h3 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * Definition for singly-linked list. * public class ListNode &#123; *     int val; *     ListNode next; *     ListNode() &#123;&#125; *     ListNode(int val) &#123; this.val = val; &#125; *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">ListNode</span> <span class="token function">swapPairs</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span> head<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//base case</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> head<span class="token punctuation">.</span>next <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> head<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">//本级递归</span>        <span class="token class-name">ListNode</span> second <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        head<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">swapPairs</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>        second<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">return</span> second<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hexo + Github + TecentCloud + PicGo + AliCloud OSS 搭建个人博客</title>
      <link href="/2021/12/21/Build_A_Blog/"/>
      <url>/2021/12/21/Build_A_Blog/</url>
      
        <content type="html"><![CDATA[<p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/blog.png" alt="blog"></p>]]></content>
      
      
      <categories>
          
          <category> tech </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World(Hexo Docs)</title>
      <link href="/2021/12/21/hello-world/"/>
      <url>/2021/12/21/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.Quick Start</p><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> tech </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>事务基础知识</title>
      <link href="/2021/01/14/%E4%BA%8B%E5%8A%A1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2021/01/14/%E4%BA%8B%E5%8A%A1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="事务基础知识"><a href="#事务基础知识" class="headerlink" title="事务基础知识"></a>事务基础知识</h1><h2 id="1-数据库事务概述"><a href="#1-数据库事务概述" class="headerlink" title="1.数据库事务概述"></a>1.数据库事务概述</h2><h3 id="1-1-存储引擎支持情况"><a href="#1-1-存储引擎支持情况" class="headerlink" title="1.1 存储引擎支持情况"></a>1.1 存储引擎支持情况</h3><p><code>SHOW ENGINES</code> 命令来查看当前 MySQL 支持的存储引擎都有哪些，以及这些存储引擎是否支持事务。  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220114114705699.png" alt="image-20220114114705699"></p><p>能看出在 MySQL 中，只有<code>InnoDB</code> 是支持事务的。  </p><h3 id="1-2-基本概念"><a href="#1-2-基本概念" class="headerlink" title="1.2 基本概念"></a>1.2 基本概念</h3><p><strong>事务</strong>：一组逻辑操作单元，使数据从一种状态变换到另一种状态。</p><p><strong>事务处理的原则</strong>：保证所有事务都作为 一个工作单元 来执行，即使出现了故障，都不能改变这种执行方式。当在一个事务中执行多个操作时，要么所有的事务都被提交( commit )，那么这些修改就 永久 地保存下来；要么数据库管理系统将 放弃 所作的所有 修改 ，整个事务回滚( rollback )到最初状态。  </p><h3 id="1-3-事务的ACID特性"><a href="#1-3-事务的ACID特性" class="headerlink" title="1.3 事务的ACID特性"></a>1.3 事务的ACID特性</h3><ul><li><strong>原子性（atomicity）：</strong></li></ul><p>原子性是指事务是一个不可分割的工作单位，要么全部提交，要么全部失败回滚。</p><ul><li><strong>一致性（consistency）：</strong></li></ul><p>（国内很多网站上对一致性的阐述有误，具体你可以参考 Wikipedia 对<code>Consistency</code>的阐述）根据定义，一致性是指事务执行前后，数据从一个 合法性状态 变换到另外一个 合法性状态 。这种状态是 语义上 的而不是语法上的，跟具体的业务有关。</p><p>那什么是合法的数据状态呢？满足 预定的约束 的状态就叫做合法的状态。通俗一点，这状态是由你自己来定义的（比如满足现实世界中的约束）。满足这个状态，数据就是一致的，不满足这个状态，数据就是不一致的！如果事务中的某个操作失败了，系统就会自动撤销当前正在执行的事务，返回到事务操作之前的状态。</p><ul><li><strong>隔离型（isolation）：</strong></li></ul><p>事务的隔离性是指一个事务的执行 <strong>不能被其他事务干扰</strong> ，即一个事务内部的操作及使用的数据对 <strong>并发</strong> 的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</p><p>如果无法保证隔离性会怎么样？假设A账户有200元，B账户0元。A账户往B账户转账两次，每次金额为50<br>元，分别在两个事务中执行。如果无法保证隔离性，会出现下面的情形：  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">UPDATE</span> accounts <span class="token keyword">SET</span> money <span class="token operator">=</span> money <span class="token operator">-</span> <span class="token number">50</span> <span class="token keyword">WHERE</span> NAME <span class="token operator">=</span> <span class="token string">'AA'</span><span class="token punctuation">;</span><span class="token keyword">UPDATE</span> accounts <span class="token keyword">SET</span> money <span class="token operator">=</span> money <span class="token operator">+</span> <span class="token number">50</span> <span class="token keyword">WHERE</span> NAME <span class="token operator">=</span> <span class="token string">'BB'</span><span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220114115057584.png" alt="image-20220114115057584"></p><ul><li><strong>持久性（durability）：</strong></li></ul><p>持久性是指一个事务一旦被提交，它对数据库中数据的改变就是 <strong>永久性</strong>的 ，接下来的其他操作和数据库故障不应该对其有任何影响。</p><p>持久性是通过 <strong>事务日志</strong> 来保证的。日志包括了 <code>重做日志</code> 和 <code>回滚日志</code> 。当我们通过事务对数据进行修改的时候，首先会将数据库的变化信息记录到重做日志中，然后再对数据库中对应的行进行修改。这样做的好处是，即使数据库系统崩溃，数据库重启后也能找到没有更新到数据库系统中的重做日志，重新执行，从而使事务具有持久性。  </p><h3 id="1-4-事务的状态"><a href="#1-4-事务的状态" class="headerlink" title="1.4 事务的状态"></a>1.4 事务的状态</h3><p>我们现在知道 <strong>事务</strong> 是一个抽象的概念，它其实对应着一个或多个数据库操作，MySQL根据这些操作所执行的不同阶段把 <strong>事务</strong> 大致划分成几个状态：</p><ul><li><strong>活动的（active）</strong></li></ul><p>事务对应的数据库操作正在执行过程中时，我们就说该事务处在 <strong>活动的</strong> 状态。</p><ul><li><strong>部分提交的（partially committed）</strong></li></ul><p>当事务中的最后一个操作执行完成，但由于操作都在内存中执行，所造成的影响并 <strong>没有刷新到磁盘</strong>时，我们就说该事务处在 <strong>部分提交</strong>的 状态。</p><ul><li><strong>失败的（failed）</strong></li></ul><p>当事务处在 <strong>活动的</strong> 或者 部分提交的 状态时，可能遇到了某些错误（数据库自身的错误、操作系统错误或者直接断电等）而无法继续执行，或者人为的停止当前事务的执行，我们就说该事务处在 <strong>失败的</strong> 状态。  </p><ul><li><strong>中止的（aborted）</strong></li></ul><p>如果事务执行了一部分而变为 <strong>失败的</strong> 状态，那么就需要把已经修改的事务中的操作还原到事务执行前的状态。换句话说，就是要撤销失败事务对当前数据库造成的影响。我们把这个撤销的过程称之为 <strong>回滚</strong> 。当 回滚 操作执行完毕时，也就是数据库恢复到了执行事务之前的状态，我们就说该事务处在了 <strong>中止的</strong> 状态。<br>举例：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">UPDATE</span> accounts <span class="token keyword">SET</span> money <span class="token operator">=</span> money <span class="token operator">-</span> <span class="token number">50</span> <span class="token keyword">WHERE</span> NAME <span class="token operator">=</span> <span class="token string">'AA'</span><span class="token punctuation">;</span><span class="token keyword">UPDATE</span> accounts <span class="token keyword">SET</span> money <span class="token operator">=</span> money <span class="token operator">+</span> <span class="token number">50</span> <span class="token keyword">WHERE</span> NAME <span class="token operator">=</span> <span class="token string">'BB'</span><span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><strong>提交的（committed）</strong></li></ul><p>当一个处在 <strong>部分提交的</strong> 状态的事务将修改过的数据都 <strong>同步到磁盘</strong> 上之后，我们就可以说该事务处在了 <strong>提交的</strong> 状态。</p><p>一个基本的状态转换图如下所示：  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220114115758371.png" alt="image-20220114115758371"></p><h2 id="2-如何使用事务"><a href="#2-如何使用事务" class="headerlink" title="2. 如何使用事务"></a>2. 如何使用事务</h2><p>使用事务有两种方式，分别为 <strong>显式事务</strong> 和 <strong>隐式事务</strong> 。</p><h3 id="2-1-显式事务"><a href="#2-1-显式事务" class="headerlink" title="2.1 显式事务"></a>2.1 显式事务</h3><p><strong>步骤1</strong>： <code>START TRANSACTION </code>或者 <code>BEGIN</code> ，作用是显式开启一个事务。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">BEGIN</span><span class="token punctuation">;</span><span class="token comment">#或者</span>mysql<span class="token operator">></span> <span class="token keyword">START</span> <span class="token keyword">TRANSACTION</span><span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p> <code>START TRANSACTION</code> 语句相较于 <code>BEGIN</code> 特别之处在于，后边能跟随几个 <strong>修饰符</strong> ：</p><p>① <code>READ ONLY</code> ：标识当前事务是一个 <strong>只读事务</strong> ，也就是属于该事务的数据库操作只能读取数据，而不能修改数据。</p><p>② <code>READ WRITE</code> ：标识当前事务是一个 <strong>读写事务</strong> ，也就是属于该事务的数据库操作既可以读取数据，也可以修改数据。</p><p>③ <code>WITH CONSISTENT SNAPSHOT</code> ：启动一致性读。</p><p><strong>步骤2</strong>：一系列事务中的操作（主要是DML，不含DDL）</p><p><strong>步骤3</strong>：提交事务 或 中止事务（即回滚事务）  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># 提交事务。当提交事务后，对数据库的修改是永久性的。</span>mysql<span class="token operator">></span> <span class="token keyword">COMMIT</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># 回滚事务。即撤销正在进行的所有没有提交的修改</span>mysql<span class="token operator">></span> <span class="token keyword">ROLLBACK</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># 将事务回滚到某个保存点。</span>mysql<span class="token operator">></span> <span class="token keyword">ROLLBACK</span> <span class="token keyword">TO</span> <span class="token punctuation">[</span><span class="token keyword">SAVEPOINT</span><span class="token punctuation">]</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="2-2-隐式事务"><a href="#2-2-隐式事务" class="headerlink" title="2.2 隐式事务"></a>2.2 隐式事务</h3><p>MySQL中有一个系统变量 <code>autocommit</code> ：</p><pre class="line-numbers language-none"><code class="language-none">mysql&gt; SHOW VARIABLES LIKE &#39;autocommit&#39;;+---------------+-------+| Variable_name | Value |+---------------+-------+| autocommit | ON |+---------------+-------+1 row in set (0.01 sec)  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当然，如果我们想关闭这种 <strong>自动提交</strong> 的功能，可以使用下边两种方法之一：</p><ul><li><p>显式的的使用 <code>START TRANSACTION</code> 或者<code>BEGIN</code>语句开启一个事务。这样<strong>在本次事务提交或者回滚前会暂时关闭掉自动提交的功能</strong>。</p></li><li><p>把系统变量 <code>autocommit </code>的值设置为 <code>OFF</code> ，就像这样：</p></li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SET</span> autocommit <span class="token operator">=</span> <span class="token keyword">OFF</span><span class="token punctuation">;</span><span class="token comment">#或</span><span class="token keyword">SET</span> autocommit <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="2-3-隐式提交数据的情况"><a href="#2-3-隐式提交数据的情况" class="headerlink" title="2.3 隐式提交数据的情况"></a>2.3 隐式提交数据的情况</h3><ul><li><p>数据定义语言（Data definition language，缩写为：DDL）</p></li><li><p>隐式使用或修改mysql数据库中的表</p></li><li><p>事务控制或关于锁定的语句</p></li></ul><p>​    ① 当我们在一个事务还没提交或者回滚时就又使用 START TRANSACTION 或者 BEGIN 语句开启了另一个事务时，会 隐式的提交 上一个事务。即：</p><p>​    ② 当前的 autocommit 系统变量的值为 OFF ，我们手动把它调为 ON 时，也会 隐式的提交 前边语句所属的事务。</p><p>​    ③ 使用 LOCK TABLES 、 UNLOCK TABLES 等关于锁定的语句也会 隐式的提交 前边语句所属的事务。</p><ul><li>加载数据的语句</li><li>关于MySQL复制的一些语句</li><li>其它的一些语句</li></ul><h3 id="2-4-使用举例1：提交与回滚"><a href="#2-4-使用举例1：提交与回滚" class="headerlink" title="2.4 使用举例1：提交与回滚"></a>2.4 使用举例1：提交与回滚</h3><p>我们看下在 MySQL 的默认状态下，下面这个事务最后的处理结果是什么。</p><p><strong>情况1</strong>：  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token keyword">user</span><span class="token punctuation">(</span>name <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span><span class="token punctuation">;</span><span class="token keyword">BEGIN</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token keyword">user</span> <span class="token keyword">SELECT</span> <span class="token string">'张三'</span><span class="token punctuation">;</span><span class="token keyword">COMMIT</span><span class="token punctuation">;</span><span class="token keyword">BEGIN</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token keyword">user</span> <span class="token keyword">SELECT</span> <span class="token string">'李四'</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token keyword">user</span> <span class="token keyword">SELECT</span> <span class="token string">'李四'</span><span class="token punctuation">;</span><span class="token keyword">ROLLBACK</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> <span class="token keyword">user</span><span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果（1 行数据）：  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">commit</span><span class="token punctuation">;</span>Query OK<span class="token punctuation">,</span> <span class="token number">0</span> <span class="token keyword">rows</span> affected <span class="token punctuation">(</span><span class="token number">0.00</span> 秒<span class="token punctuation">)</span>mysql<span class="token operator">></span> <span class="token keyword">BEGIN</span><span class="token punctuation">;</span>Query OK<span class="token punctuation">,</span> <span class="token number">0</span> <span class="token keyword">rows</span> affected <span class="token punctuation">(</span><span class="token number">0.00</span> 秒<span class="token punctuation">)</span>mysql<span class="token operator">></span> <span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token keyword">user</span> <span class="token keyword">SELECT</span> <span class="token string">'李四'</span><span class="token punctuation">;</span>Query OK<span class="token punctuation">,</span> <span class="token number">1</span> <span class="token keyword">rows</span> affected <span class="token punctuation">(</span><span class="token number">0.00</span> 秒<span class="token punctuation">)</span>mysql<span class="token operator">></span> <span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token keyword">user</span> <span class="token keyword">SELECT</span> <span class="token string">'李四'</span><span class="token punctuation">;</span><span class="token keyword">Duplicate</span> entry <span class="token string">'李四'</span> <span class="token keyword">for</span> <span class="token keyword">key</span> <span class="token string">'user.PRIMARY'</span>mysql<span class="token operator">></span> <span class="token keyword">ROLLBACK</span><span class="token punctuation">;</span>Query OK<span class="token punctuation">,</span> <span class="token number">0</span> <span class="token keyword">rows</span> affected <span class="token punctuation">(</span><span class="token number">0.01</span> 秒<span class="token punctuation">)</span>mysql<span class="token operator">></span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">user</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">--------+</span><span class="token operator">|</span> name   <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">--------+</span><span class="token operator">|</span> 张三    <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">--------+</span><span class="token number">1</span> 行于数据集 <span class="token punctuation">(</span><span class="token number">0.01</span> 秒<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>情况2</strong>：  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token keyword">user</span> <span class="token punctuation">(</span>name <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span><span class="token punctuation">;</span><span class="token keyword">BEGIN</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token keyword">user</span> <span class="token keyword">SELECT</span> <span class="token string">'张三'</span><span class="token punctuation">;</span><span class="token keyword">COMMIT</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token keyword">user</span> <span class="token keyword">SELECT</span> <span class="token string">'李四'</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token keyword">user</span> <span class="token keyword">SELECT</span> <span class="token string">'李四'</span><span class="token punctuation">;</span><span class="token keyword">ROLLBACK</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果（2 行数据）：  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> <span class="token keyword">user</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">--------+</span><span class="token operator">|</span> name   <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">--------+</span><span class="token operator">|</span>  张三   <span class="token operator">|</span> <span class="token operator">|</span>  李四   <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">--------+</span><span class="token number">2</span> 行于数据集 <span class="token punctuation">(</span><span class="token number">0.01</span> 秒<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>情况3</strong>：  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token keyword">user</span><span class="token punctuation">(</span>name <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span><span class="token punctuation">;</span><span class="token keyword">SET</span> @<span class="token variable">@completion_type</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">BEGIN</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token keyword">user</span> <span class="token keyword">SELECT</span> <span class="token string">'张三'</span><span class="token punctuation">;</span><span class="token keyword">COMMIT</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token keyword">user</span> <span class="token keyword">SELECT</span> <span class="token string">'李四'</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token keyword">user</span> <span class="token keyword">SELECT</span> <span class="token string">'李四'</span><span class="token punctuation">;</span><span class="token keyword">ROLLBACK</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> <span class="token keyword">user</span><span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果（1 行数据）：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> <span class="token keyword">user</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">--------+</span><span class="token operator">|</span> name   <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">--------+</span><span class="token operator">|</span> 张三    <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">--------+</span><span class="token number">1</span> 行于数据集 <span class="token punctuation">(</span><span class="token number">0.01</span> 秒<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注</strong>：</p><p>当我们设置 <code> autocommit=0</code> 时，不论是否采用 START TRANSACTION 或者 BEGIN 的方式来开启事务，都需要用 <code>COMMIT </code>进行提交，让事务生效，使用 <code>ROLLBACK</code> 对事务进行回滚。</p><p>当我们设置 <code>autocommit=1</code> 时，每条 SQL 语句都会自动进行提交。 不过这时，如果你采用<code>START TRANSACTION</code>或者 <code>BEGIN</code> 的方式来显式地开启事务，那么这个事务只有在 COMMIT 时才会生效，在 <code>ROLLBACK </code>时才会回滚。  </p><h2 id="3-事务隔离级别"><a href="#3-事务隔离级别" class="headerlink" title="3. 事务隔离级别"></a>3. 事务隔离级别</h2><p>MySQL是一个<code>客户端／服务器</code> 架构的软件，对于同一个服务器来说，可以有若干个客户端与之连接，每个客户端与服务器连接上之后，就可以称为一个会话（ <strong>Session</strong> ）。每个客户端都可以在自己的会话中向服务器发出请求语句，一个请求语句可能是某个事务的一部分，也就是<strong>对于服务器来说可能同时处理多个事务</strong>。事务有 <code>隔离性</code>的特性，理论上在某个事务 对某个数据进行访问 时，其他事务应该进行 排<br>队 ，当该事务提交之后，其他事务才可以继续访问这个数据。但是这样对 <strong>性能影响</strong>太大 ，我们既想保持事务的隔离性，又想让服务器在处理访问同一数据的多个事务时 <code>性能尽量高些</code> ，那就看二者如何权衡取舍了。</p><h3 id="3-1-数据准备"><a href="#3-1-数据准备" class="headerlink" title="3.1 数据准备"></a>3.1 数据准备</h3><p>我们需要创建一个表：  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> student <span class="token punctuation">(</span>studentno <span class="token keyword">INT</span><span class="token punctuation">,</span>name <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">,</span>class <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>studentno<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">Engine</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8<span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后向这个表里插入一条数据：  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> student <span class="token keyword">VALUES</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'小谷'</span><span class="token punctuation">,</span> <span class="token string">'1班'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>现在表里的数据就是这样的：  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> student<span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">-----------+--------+-------+</span><span class="token operator">|</span> studentno <span class="token operator">|</span> name   <span class="token operator">|</span> class <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">-----------+--------+-------+ </span><span class="token operator">|</span>         <span class="token number">1</span> <span class="token operator">|</span> 小谷    <span class="token operator">|</span> <span class="token number">1</span>班   <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">-----------+--------+-------+</span><span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-2-数据并发问题"><a href="#3-2-数据并发问题" class="headerlink" title="3.2 数据并发问题"></a>3.2 数据并发问题</h3><p>针对事务的隔离性和并发性，我们怎么做取舍呢？先看一下访问相同数据的事务在 <strong>不保证串行执行</strong> （也就是不保证执行完一个再执行另一个）的情况下可能会出现哪些问题：  </p><p><strong>1. 脏写（ Dirty Write ）</strong></p><p>对于两个事务 Session A、Session B，如果事务Session A <strong>修改了</strong> 另一个 <strong>未提交</strong> 事务Session B <strong>修改过</strong> 的数据，那就意味着发生了 <strong>脏写</strong></p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220114123217362.png" alt="image-20220114123217362"></p><p>Session A和Session B各开启了一个事务，Session B中的事务先将 studentno 列为1的记录的name列更新为’李四’，然后Session A中的事务接着又把这条 studentno 列为1的记录的name列更新为’张三’。如果之后Session B中的事务进行了回滚，那么Session A中的更新也将不复存在，这种现象就称之为脏写。这时Session A中的事务就没有效果了，明明把数据更新了，最后也提交事务了，最后看到的数据什么变化也没有。这里大家对事务的隔离级比较了解的话，会发现默认隔离级别下，上面 sessionA 中的更新语句会处于等待状态，这里只是跟大家说明一下会出现这样现象。</p><p><strong>2. 脏读（ Dirty Read ）</strong></p><p>对于两个事务 Session A、Session B，Session A <strong>读取</strong> 了已经被 Session B <strong>更新</strong> 但还 没有被提交 的字段。之后若 Session B <strong>回滚</strong>,Session A 读取 的内容就是 <strong>临时且无效</strong> 的。</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220114123457085.png" alt="image-20220114123457085"></p><p>Session A和Session B各开启了一个事务，Session B中的事务先将studentno列为1的记录的name列更新为’张三’，然后Session A中的事务再去查询这条studentno为1的记录，如果读到列name的值为’张三’，而Session B中的事务稍后进行了回滚，那么Session A中的事务相当于读到了一个不存在的数据，这种现象就称之为 <strong>脏读</strong> 。</p><p><strong>3. 不可重复读（ Non-Repeatable Read ）</strong></p><p>对于两个事务Session A、Session B，Session A <strong>读取</strong> 了一个字段，然后 Session B <strong>更新</strong> 了该字段。 之后Session A 再次读取 同一个字段， <strong>值就不同</strong> 了。那就意味着发生了不可重复读。</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220114123733312.png" alt="image-20220114123733312"></p><p>我们在Session B中提交了几个 <strong>隐式事务</strong> （注意是隐式事务，意味着语句结束事务就提交了），这些事务都修改了studentno列为1的记录的列name的值，每次事务提交之后，如果Session A中的事务都可以查看到最新的值，这种现象也被称之为 <strong>不可重复读</strong> 。</p><p><strong>4. 幻读（ Phantom ）</strong></p><p>对于两个事务Session A、Session B, Session A 从一个表中 <strong>读取</strong> 了一个字段, 然后 Session B 在该表中 <strong>插入</strong> 了一些新的行。 之后, 如果 Session A 再次读取 <strong>同一个表</strong>, 就会多出几行。那就意味着发生了幻读。</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220114123846351.png" alt="image-20220114123846351"></p><p>Session A中的事务先根据条件 studentno &gt; 0这个条件查询表student，得到了name列值为’张三’的记录；之后Session B中提交了一个 <strong>隐式事务</strong> ，该事务向表student中插入了一条新记录；之后Session A中的事务再根据相同的条件 studentno &gt; 0查询表student，得到的结果集中包含Session B中的事务新插入的那条记录，这种现象也被称之为 <strong>幻读</strong> 。我们把新插入的那些记录称之为 <strong>幻影记录</strong> 。</p><h3 id="3-3-SQL中的四种隔离级别"><a href="#3-3-SQL中的四种隔离级别" class="headerlink" title="3.3 SQL中的四种隔离级别"></a>3.3 SQL中的四种隔离级别</h3><p>上面介绍了几种并发事务执行过程中可能遇到的一些问题，这些问题有轻重缓急之分，我们给这些问题按照严重性来排一下序：</p><pre class="line-numbers language-none"><code class="language-none">脏写 &gt; 脏读 &gt; 不可重复读 &gt; 幻读  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们愿意舍弃一部分隔离性来换取一部分性能在这里就体现在：设立一些隔离级别，隔离级别越低，并发问题发生的就越多。 SQL标准 中设立了<strong>4个 隔离级别</strong> ：</p><ul><li><strong>READ UNCOMMITTED</strong> ：<strong>读未提交</strong>，在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。不能避免脏读、不可重复读、幻读。</li><li><strong>READ COMMITTED</strong> ：<strong>读已提交</strong>，它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。<strong>可以避免脏读</strong>，但不可重复读、幻读问题仍然存在。</li><li><strong>REPEATABLE READ</strong> ：<strong>可重复读</strong>，事务A在读到一条数据之后，此时事务B对该数据进行了修改并提交，那么事务A再读该数据，读到的还是原来的内容。可以避免脏读、不可重复读，但幻读问题仍然存在。这是<strong>MySQL的默认隔离级别</strong>。</li></ul><p><strong>可重复读应用场景</strong>：假设你在管理一个个人银行账户表。一个表存了账户余额，一个表存了账单明细。到了月底你要做数据校对，也就是判断上个月的余额和当前余额的差额，是否与本月的账单明细一致。你一定希望在校对过程中，即使有用户发生了一笔新的交易，也不影响你的校对结果。</p><ul><li><strong>SERIALIZABLE</strong> ：<strong>可串行化</strong>，顾名思义是<strong>对于同一行记录，“写”会加“写锁”，“读”会加“读锁”</strong>。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。确保事务可以从一个表中读取相同的行。在这个事务持续期间，禁止其他事务对该表执行插入、更新和删除操作。所有的并发问题都可以避免，但性能十分低下。能避免脏读、不可重复读和幻读。</li></ul><p><strong>SQL标准</strong> 中规定，针对不同的隔离级别，并发事务可以发生不同严重程度的问题，具体情况如下：  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220114124428542.png" alt="image-20220114124428542"></p><p><strong>脏写</strong> 怎么没涉及到？因为脏写这个问题太严重了，<strong>不论是哪种隔离级别，都不允许脏写的情况发生</strong>。</p><p>不同的隔离级别有不同的现象，并有不同的锁和并发机制，隔离级别越高，数据库的并发性能就越差，4种事务隔离级别与并发性能的关系如下：  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220114124452423.png" alt="image-20220114124452423"></p><h3 id="3-4-MySQL支持的四种隔离级别"><a href="#3-4-MySQL支持的四种隔离级别" class="headerlink" title="3.4 MySQL支持的四种隔离级别"></a>3.4 MySQL支持的四种隔离级别</h3><p><strong>MySQL的默认隔离级别为REPEATABLE READ</strong>，我们可以手动修改一下事务的隔离级别。  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># 查看隔离级别，MySQL 5.7.20的版本之前：</span>mysql<span class="token operator">></span> <span class="token keyword">SHOW</span> VARIABLES <span class="token operator">LIKE</span> <span class="token string">'tx_isolation'</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">---------------+-----------------+</span><span class="token operator">|</span> Variable_name <span class="token operator">|</span> <span class="token keyword">Value</span>           <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">---------------+-----------------+ </span><span class="token operator">|</span> tx_isolation  <span class="token operator">|</span> <span class="token keyword">REPEATABLE</span><span class="token operator">-</span><span class="token keyword">READ</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">---------------+-----------------+</span><span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span><span class="token comment"># MySQL 5.7.20版本之后，引入transaction_isolation来替换tx_isolation</span><span class="token comment"># 查看隔离级别，MySQL 5.7.20的版本及之后：</span>mysql<span class="token operator">></span> <span class="token keyword">SHOW</span> VARIABLES <span class="token operator">LIKE</span> <span class="token string">'transaction_isolation'</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">-----------------------+-----------------+</span><span class="token operator">|</span> Variable_name <span class="token operator">|</span> <span class="token keyword">Value</span> <span class="token operator">|</span>                 <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">-----------------------+-----------------+</span><span class="token operator">|</span> transaction_isolation <span class="token operator">|</span> <span class="token keyword">REPEATABLE</span><span class="token operator">-</span><span class="token keyword">READ</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">-----------------------+-----------------+</span><span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.02</span> sec<span class="token punctuation">)</span><span class="token comment">#或者不同MySQL版本中都可以使用的：</span><span class="token keyword">SELECT</span> @<span class="token variable">@transaction_isolation</span><span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-5-如何设置事务的隔离级别"><a href="#3-5-如何设置事务的隔离级别" class="headerlink" title="3.5 如何设置事务的隔离级别"></a>3.5 如何设置事务的隔离级别</h3><p>通过下面的语句修改事务的隔离级别：  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SET</span> <span class="token punctuation">[</span><span class="token keyword">GLOBAL</span><span class="token operator">|</span><span class="token keyword">SESSION</span><span class="token punctuation">]</span> <span class="token keyword">TRANSACTION</span> <span class="token keyword">ISOLATION</span> <span class="token keyword">LEVEL</span> 隔离级别<span class="token punctuation">;</span><span class="token comment">#其中，隔离级别格式：</span><span class="token operator">></span> <span class="token keyword">READ</span> <span class="token keyword">UNCOMMITTED</span><span class="token operator">></span> <span class="token keyword">READ</span> <span class="token keyword">COMMITTED</span><span class="token operator">></span> <span class="token keyword">REPEATABLE</span> <span class="token keyword">READ</span><span class="token operator">></span> <span class="token keyword">SERIALIZABLE</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>或者：  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SET</span> <span class="token punctuation">[</span><span class="token keyword">GLOBAL</span><span class="token operator">|</span><span class="token keyword">SESSION</span><span class="token punctuation">]</span> TRANSACTION_ISOLATION <span class="token operator">=</span> <span class="token string">'隔离级别'</span><span class="token comment">#其中，隔离级别格式：</span><span class="token operator">></span> <span class="token keyword">READ</span><span class="token operator">-</span><span class="token keyword">UNCOMMITTED</span><span class="token operator">></span> <span class="token keyword">READ</span><span class="token operator">-</span><span class="token keyword">COMMITTED</span><span class="token operator">></span> <span class="token keyword">REPEATABLE</span><span class="token operator">-</span><span class="token keyword">READ</span><span class="token operator">></span> <span class="token keyword">SERIALIZABLE</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>关于设置时使用GLOBAL或SESSION的影响：</strong>  </p><ul><li>使用 <code>GLOBAL</code> 关键字（在全局范围影响）：  </li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SET</span> <span class="token keyword">GLOBAL</span> <span class="token keyword">TRANSACTION</span> <span class="token keyword">ISOLATION</span> <span class="token keyword">LEVEL</span> <span class="token keyword">SERIALIZABLE</span><span class="token punctuation">;</span><span class="token comment">#或</span><span class="token keyword">SET</span> <span class="token keyword">GLOBAL</span> TRANSACTION_ISOLATION <span class="token operator">=</span> <span class="token string">'SERIALIZABLE'</span><span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>使用 <code>SESSION </code>关键字（在会话范围影响）:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SET</span> <span class="token keyword">SESSION</span> <span class="token keyword">TRANSACTION</span> <span class="token keyword">ISOLATION</span> <span class="token keyword">LEVEL</span> <span class="token keyword">SERIALIZABLE</span><span class="token punctuation">;</span><span class="token comment">#或</span><span class="token keyword">SET</span> <span class="token keyword">SESSION</span> TRANSACTION_ISOLATION <span class="token operator">=</span> <span class="token string">'SERIALIZABLE'</span><span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>则：</p><ul><li><strong>对当前会话的所有后续的事务有效</strong></li><li>如果在事务之间执行，则对后续的事务有效该语句可以在已经开启的事务中间</li><li>行，但不会影响当前正在执行的事务  </li></ul><h3 id="3-6-不同隔离级别举例"><a href="#3-6-不同隔离级别举例" class="headerlink" title="3.6 不同隔离级别举例"></a>3.6 不同隔离级别举例</h3><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220114140424937.png" alt="image-20220114140424937"></p><p><strong>演示1. 读未提交之脏读</strong><br>例一：</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220114135908854.png" alt="image-20220114135908854"></p><p>例二：</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220114135928302.png" alt="image-20220114135928302"></p><p><strong>演示2：读已提交</strong>  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220114135945107.png" alt="image-20220114135945107"></p><p>虽然已经解决脏读，但仍会发生不可重复读的情况。</p><p><strong>演示3. 可重复读</strong></p><p>设置隔离级别为可重复读，事务的执行流程如下：  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220114135954500.png" alt="image-20220114135954500"></p><p><strong>演示4：幻读</strong>  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220114140102345.png" alt="image-20220114140102345"></p><h2 id="面试造火箭计划！！！"><a href="#面试造火箭计划！！！" class="headerlink" title="面试造火箭计划！！！"></a>面试造火箭计划！！！</h2><p><strong>1.事务的概念是什么?</strong></p><p>事务是对数据库中数据操作的保证数据逻辑一致的最小操作单位。</p><p><strong>2.mysql的事务隔离级别读未提交, 读已提交, 可重复读, 串行各是什么意思?</strong></p><p>读未提交：一个事务读取到了其他事务未提交的操作。</p><p>读已提交：一个事务读取到了其他事务已经提交的操作。</p><p>可重复读：一个事务从它开始到结束整个生命周期中，所能读取到的数据内容和它启动的时候所能读到的数据内容是相同的。不会出现在事务运行的整个过程中，不同的时间点读取到的数据不一样的情况。</p><p>串行化：所有的事务都进行排队执行，事务之间不存才并发的情况。读有读锁，写有写锁。读、读之间不影响，读、写和写、写之间互相排斥，当遇到排斥的情况后，后发生的事务需要等待先发生的事务执行完成后才可以执行。</p><p><strong>3.读已提交, 可重复读是怎么通过视图构建实现的?</strong></p><p>读已提交：会在事务中的每一个SQL语句执行的时候都为对应的SQL创建一个一致性视图。此时这个SQL能读取到已经提交的事务对数据的操作。</p><p>可重复读：会在事务启动的时候，为整个事务创建一个一致性视图，这个视图会贯穿到这个事务执行结束。在整个事务执行过程中，都使用这个视图中的数据作为一致性读的依据。</p><p><strong>4.可重复读的使用场景举例?</strong></p><p>对账的时候：假设你在管理一个个人银行账户表。一个表存了账户余额，一个表存了账单明细。到了月底你要做数据校对，也就是判断上个月的余额和当前余额的差额，是否与本月的账单明细一致。你一定希望在校对过程中，即使有用户发生了一笔新的交易，也不影响你的校对结果。</p><p>库管盘货</p><p><strong>5.事务隔离是怎么通过read-view(读视图)实现的?</strong></p><p>每一行数有多个版本，当我们要去读取数据的时候，要判断这个数据的版本号，对当前事务而言，是否可见，如果不可见，则要根据undolog计算得到上一个版本。如果上一个版本也不符合要求，则要找到再上一个版本，<br>直到找到对应正确的数据版本。</p><p><strong>6.并发版本控制(MCVV)的概念是什么, 是怎么实现的?</strong></p><p><strong>7.使用长事务的弊病? 为什么使用常事务可能拖垮整个库?</strong></p><p>长事务导致表空间持续增长，即便是事务提交或者回滚后，回滚表空间被是否后，表空间大小仍然不会被缩小。</p><p>长事务的存在导致锁发生冲突或等待的几率大大增加。</p><p>如果某个应用有发生锁等待后尝试重新建立连接的机制，那么在发生锁等待或冲突的时候，应用就会不断地发起新的连接，导致MySQL的连接数被占用爆满。MySQL不能在提供连接服务，就挂掉了。</p><p><strong>8.事务的启动方式有哪几种?</strong></p><p>begin;–一致性读的视图不会马上创建，而是在执行begin后面的第一个操作innodb表的SQL语句时生成。这个SQL可以是</p><p>select,update,delete,insert。事务ID也是此时被分配的</p><p>start transaction;–和begin的功能效果一样。</p><p>start transaciton with consistent snapshot;–该语句执行后，会马上创建一致性读的视图。这个是它和begin的区别。事务ID也是此时被</p><p>分配的。</p><p><strong>9.commit work and chain的语法是做什么用的?</strong></p><p>提交上一个事务，并且再开启一个新的事务。它的功能等效于：commit + begin。</p><p><strong>10.怎么查询各个表中的长事务?</strong></p><p>select * from information_schema.innodb_trx;</p><p>这个表中记录了所有正在运行的事务信息，里面有事务的开始时间。可以从这里看出哪些事务运行的时间比较长。</p><p><strong>11.如何避免长事务的出现?</strong></p><p>从数据库方面：</p><ul><li>  a.设置autocommit=1，不要设置为0。</li><li>  b.写脚本监控information_schemal.innodb_trx表中数据内容，发现长事务，kill掉它。</li><li>  c.配置SQL语句所能执行的最大运行时间，如果查过最大运行时间后，中断这个运行事情长的SQL语句。</li><li>  d.设置回滚表空单独存放，便于回收表空间。</li></ul><p>从业务代码方面：</p><ul><li>  a.确认是否使用了autocommit=0的配置，如果有关闭它，然后再业务代码中手动的使用begin;commit来操作。</li><li>  b.检查业务逻辑代码，能拆分为小事务的不要用大事务。</li><li>  c.检查代码，把没有必要的select语句被事务包裹的情况去掉。</li></ul>]]></content>
      
      
      <categories>
          
          <category> database </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
