<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>电脑已有jdk 8，再配置一个jdk 17</title>
      <link href="/2022/01/26/JDK-Configuration/"/>
      <url>/2022/01/26/JDK-Configuration/</url>
      
        <content type="html"><![CDATA[<p>如何安装两个以上版本jdk，并可以自由切换。以jdk1.8和jdk-17为例</p><h2 id="一、目标："><a href="#一、目标：" class="headerlink" title="一、目标："></a>一、目标：</h2><p>现在用的 jdk1.8 做开发，私下里想了解和测试最新版 jdk-17 的特性，所以需要两个(甚至多个)版本的 jdk（以 jdk1.8 和 jdk-17 和为例），而且要做到可以随时切换版本。</p><h2 id="二、当前情况"><a href="#二、当前情况" class="headerlink" title="二、当前情况"></a>二、当前情况</h2><p>目前电脑中已有一个 jdk1.8</p><h2 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h2><ol><li>将 jdk 17 压缩包解压</li><li>打开环境变量，找到系统变量中的<strong>Path</strong></li><li>点击编辑把<code>%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin;</code>复制到变量值的最前面，然后确定</li></ol><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126225728779.png" alt="image-20220126225728779"></p><ol start="4"><li>新建两个JAVA_HOME，值为jdk的路径</li></ol><table><thead><tr><th>变量</th><th>值</th><th>说明</th></tr></thead><tbody><tr><td>JAVA_HOME</td><td>%JAVA_HOME8%</td><td>修改此处变量值中的数字来达到启用所对应的jdk</td></tr><tr><td>JAVA_HOME17</td><td>jdk17路径</td><td>12为我的jdk版本；后面的路径是你自己jdk的主目录</td></tr><tr><td>JAVA_HOME8</td><td>jdk8路径</td><td>8也为我的jdk版本；后面的路径是你自己jdk的主目录</td></tr></tbody></table><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126225556573.png" alt="image-20220126225556573"></p><h3 id="切换jdk"><a href="#切换jdk" class="headerlink" title="切换jdk"></a>切换jdk</h3><p>修改JAVA_HOME变量值中的数字来达到启用所对应的jdk</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126225831540.png" alt="image-20220126225831540"></p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>WIN+R输入cmd打开命令提示符，键入<br><code>java -version</code></p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126225911133.png" alt="image-20220126225911133"></p><p>切换版本后，要打开一个新的cmd进行测试</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126225938216.png" alt="image-20220126225938216"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL事务日志</title>
      <link href="/2022/01/26/MySQL%E4%BA%8B%E5%8A%A1%E6%97%A5%E5%BF%97/"/>
      <url>/2022/01/26/MySQL%E4%BA%8B%E5%8A%A1%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL事务日志"><a href="#MySQL事务日志" class="headerlink" title="MySQL事务日志"></a>MySQL事务日志</h1><p>事务有4种特性：原子性、一致性、隔离性和持久性。那么事务的四种特性到底是基于什么机制实现呢？</p><p>事务的<strong>隔离性</strong>由 <strong>锁机制</strong> 实现。</p><p>而事务的<strong>原子性、一致性和持久性</strong>由事务的 <strong>redo 日志和undo 日志</strong>来保证。</p><ul><li>REDO LOG 称为 <strong>重做日志</strong> ，提供再写入操作，恢复提交事务修改的页操作，用来保证事务的<strong>持久性</strong>。</li><li>UNDO LOG 称为 <strong>回滚日志</strong> ，回滚行记录到某个特定版本，用来保证事务的<strong>原子性、一致性</strong>。</li></ul><p>有人或许会认为UNDO是REDO的逆过程，其实不然。REDO 和 UNDO 都可以视为是一种<strong>恢复操作</strong>，但是:</p><ul><li> <strong>redo log</strong>:    是<strong>存储引擎层(innodb)生成的日志</strong>，记录的是”<strong>物理级别</strong>“上的页修改操作，比如页号xx、偏移量y写入了’zzz’数据。主要为了保证数据的可靠性;</li><li><strong>undo log</strong>:    是存储引擎层(innodb)生成的日志，记录的是<strong>逻辑操作</strong>日志，比如对某一行数据进行了INSERT语句操作，那么undo log就记录一条与之相反的DELETE操作。主要用于<strong>事务的回滚</strong>(undo log记录的是每个修改操作的<strong>逆操作</strong>)和<strong>一致性非锁定读</strong>(undo log回滚行记录到某种特定的版本—MVCC，即多版本并发控制)</li></ul><h2 id="1-redo日志"><a href="#1-redo日志" class="headerlink" title="1. redo日志"></a>1. redo日志</h2><p>InnoDB存储引擎是<strong>以页为单位</strong>来管理存储空间的。在真正访问页面之前，需要把在<strong>磁盘上</strong>的页缓存到内存中的<strong>Buffer Pool</strong>之后才可以访问。所有的变更都必须<strong>先更新缓冲池中的数据</strong>，然后缓冲池中的<strong>脏页</strong>会以一定的频率被刷入磁盘（<strong>checkPoint机制</strong>），通过缓冲池来优化CPu和磁盘之间的鸿沟，这样就可以保证整体的性能不会下降太快。</p><h3 id="1-1-为什么需要REDO日志"><a href="#1-1-为什么需要REDO日志" class="headerlink" title="1.1 为什么需要REDO日志"></a>1.1 为什么需要REDO日志</h3><p>一方面，缓冲池可以帮助我们消除CPU和磁盘之间的鸿沟，checkpoint机制可以保证数据的最终落盘，然而由于checkpoint 并不是每次变更的时候就触发 的，而是<strong>master线程隔一段时间去处理的</strong>。</p><p><strong>所以最坏的情况</strong>就是事务提交后，刚写完缓冲池，还没将数据刷新到磁盘（内存中完成了，但磁盘中未完成），数据库宕机了，那么这段数据就是丢失的，无法恢复。</p><p>另一方面，事务包含 <strong>持久性</strong> 的特性，就是说对于一个已经提交的事务，在事务提交后即使系统发生了崩溃，这个事务对数据库中所做的更改也不能丢失。</p><p>那么如何保证这个持久性呢？ <strong>一个简单的做法</strong> ：在事务提交完成之前把该事务所修改的所有页面都刷新到磁盘，但是这个简单粗暴的做法有些问题：</p><ul><li><strong>修改量与刷新磁盘工作量严重不成比例</strong></li></ul><p>有时候我们仅仅修改了某个页面中的一个字节，但是我们知道在InnoDB中是<strong>以页为单位来进行磁盘IO的</strong>，也就是说我们在该事务提交时<strong>不得不将一个完整的页面从内存中刷新到磁盘</strong>，我们又知道一个页面默认是16KB大小，只修改一个字节就要刷新16KB的数据到磁盘上显然是太小题大做了。</p><ul><li><strong>随机lO刷新较慢</strong></li></ul><p>一个事务可能包含很多语句，即使是一条语句也可能修改许多页面，假如该事务修改的这些页面可能并不相邻，这就意味着在将某个事务修改的Buffer Pool中的页面刷新到磁盘时，需要进行很多的随机IO，随机IO比顺序IO要慢，尤其对于传统的机械硬盘来说。</p><p><strong>另一个解决的思路</strong> ：我们只是想让已经提交了的事务对数据库中数据所做的修改永久生效，即使后来系统崩溃，在重启后也能把这种修改恢复出来。所以我们其实没有必要在每次事务提交时就把该事务在内存中修改过的全部页面刷新到磁盘，只需要把<strong>修改了哪些东西记录一下就好</strong>。比如，某个事务将系统表空间中 第10号 页面中偏移量为 100 处的那个字节的值 1 改成 2 。我们只需要记录一下：将第0号表空间的10号页面的偏移量为100处的值更新为 2 。  </p><p>InnoDB引擎的事务采用了WAL技术（<code>Write-Ahead Logging</code>)，这种技术的思想就是<strong>先写日志，再写磁盘</strong>，<strong>只有日志写入成功，才算事务提交成功</strong>，这里的日志就是<strong>redo log</strong>。当发生宕机且数据未刷到磁盘的时候，可以通过redo log来恢复，保证ACID中的D，这就是redo log的作用。</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126162713847.png" alt="image-20220126162713847"></p><h3 id="1-2-REDO日志的好处、特点"><a href="#1-2-REDO日志的好处、特点" class="headerlink" title="1.2 REDO日志的好处、特点"></a>1.2 REDO日志的好处、特点</h3><p><strong>好处：</strong></p><ul><li>redo日志降低了刷盘频率</li><li>redo日志占用的空间非常小</li></ul><p>存储表空间ID、页号、偏移量以及需要更新的值，所需要的存储空间是很小的，刷盘快。</p><p><strong>特点：</strong></p><ul><li>redo日志是顺序写入磁盘的</li></ul><p>在执行事务的过程中，每执行一条语句，就可能产生若干条redo日志，这些日志是按照<strong>产生的顺序写入磁盘的</strong>，也就是使用顺序lo，效率比随机IO快。</p><ul><li>事务执行过程中，redo log不断记录  </li></ul><p>redo log跟bin log的区别，redo log是<strong>存储引擎层</strong>产生的，而<strong>bin log是数据库层</strong>产生的。假设一个事务，对表做10万行的记录插入，在这个过程中，一直不断的往redo log顺序记录，而bin log不会记录，直到这个事务提交，才会一次写入到bin log文件中。</p><h3 id="1-3-redo的组成"><a href="#1-3-redo的组成" class="headerlink" title="1.3 redo的组成"></a>1.3 redo的组成</h3><p>Redo log可以简单分为以下两个部分：</p><ul><li>重做日志的缓冲 (redo log buffer) ，保存在内存中，是易失的。</li></ul><p>在服务器启动时就向操作系统申请了一大片称之为redo log buffer的<strong>连续内存</strong>空间，翻译成中文就是redo日志缓冲区。这片内存空间被划分成若干个连续的redo log block。一个redo log block占用512字节大小。</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126164247620.png" alt="image-20220126164244593"></p><p><strong>参数设置：innodb_log_buffer_size：</strong>  </p><p>redo log buffer 大小，默认 16M ，最大值是4096M，最小值为1M。 </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">show</span> variables <span class="token operator">like</span> <span class="token string">'%innodb_log_buffer_size%'</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">------------------------+----------+</span><span class="token operator">|</span> Variable_name <span class="token operator">|</span> <span class="token keyword">Value</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">------------------------+----------+</span><span class="token operator">|</span> innodb_log_buffer_size <span class="token operator">|</span> <span class="token number">16777216</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">------------------------+----------+   </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>重做日志文件 (redo log file) ，保存在硬盘中，是持久的。  </li></ul><p>REDO日志文件如图所示，其中的ib_logfile0和ib_logfile1即为REDO日志。</p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126164528296.png" alt="image-20220126164528296" style="zoom:67%;"><h3 id="1-4-redo的整体流程"><a href="#1-4-redo的整体流程" class="headerlink" title="1.4 redo的整体流程"></a>1.4 redo的整体流程</h3><p>以一个更新事务为例，redo log 流转过程，如下图所示：  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126164659436.png" alt="image-20220126164659436"></p><ul><li>第1步：先将原始数据从磁盘中读入内存中来，修改数据的内存拷贝</li><li>第2步：生成一条重做日志并写入redo log buffer，记录的是数据被修改后的值</li><li>第3步：当事务commit时，将redo log buffer中的内容刷新到 redo log file，对 redo log file采用追加写的方式</li><li>第4步：定期将内存中修改的数据刷新到磁盘中  </li></ul><h3 id="1-5-redo-log的刷盘策略"><a href="#1-5-redo-log的刷盘策略" class="headerlink" title="1.5 redo log的刷盘策略"></a>1.5 redo log的刷盘策略</h3><p>redo log的写入并不是直接写入磁盘的，InnoDB引擎会在写redo log的时候先写redo log buffer，之后以 <strong>一定的频率</strong> 刷入到真正的redo log file 中。这里的一定频率怎么看待呢？这就是我们要说的刷盘策略。  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126164801521.png" alt="image-20220126164801521"></p><p>注意，redo log buffer刷盘到redo log file的过程并不是真正的刷到磁盘中去，只是刷入到 <strong>文件系统缓存（page cache）</strong>中去（这是现代<strong>操作系统</strong>为了提高文件写入效率做的一个优化），真正的写入会交给系统自己来决定（比如page cache足够大了）。那么对于InnoDB来说就存在一个问题，如果交给系统来同步，同样如果<strong>操作系统系统宕机</strong>，那么数据也丢失了（虽然整个系统宕机的概率还是比较小的）。<br>针对这种情况，InnoDB给出 innodb_flush_log_at_trx_commit 参数，该参数控制 commit提交事务时，如何将 redo log buffer 中的日志刷新到 redo log file 中。它支持三种策略：  </p><ul><li>设置为0 ：表示每次事务提交时不进行刷盘操作。（系统默认master thread每隔1s进行一次重做日志的同步）</li><li>设置为1 ：表示<strong>每次事务提交时都将进行同步，刷盘操作</strong>（ <strong>默认值</strong> ）</li><li>设置为2 ：表示每次事务提交时都只把 redo log buffer 内容写入 page cache，不进行同步。由os自己决定什么时候同步到磁盘文件。  </li></ul><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126165353406.png" alt="image-20220126165353406"></p><p>另外，InnoDB存储引擎有一个后台线程，每隔1秒，就会把 redo log buffer 中的内容写到文件系统缓存( page cache ) ，然后调用刷盘操作。</p><h3 id="1-6-不同刷盘策略演示"><a href="#1-6-不同刷盘策略演示" class="headerlink" title="1.6 不同刷盘策略演示"></a>1.6 不同刷盘策略演示</h3><h4 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h4><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126165559699.png" alt="image-20220126165559699"></p><p><strong>小结</strong>: <code>innodb_flush_log_at_trx_commit=1</code></p><p>为1时，只要事务提交成功,redo log记录就一定在硬盘里，不会有任何数据丢失。</p><p>如果事务执行期间MySQL挂了或宕机，这部分日志丢了，但是事务并没有提交，所以日志丢了也不会有损失。可以保证ACID的D，数据绝对不会丢失，但是<strong>效率最差</strong>的。</p><p>建议使用默认值，虽然操作系统宕机的概率理论小于数据库宕机的概率，但是一般既然使用了事务，那么数据的安全相对来说更重要些。|</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126170043228.png" alt="image-20220126170043228"></p><p><strong>小结</strong>:  <code>innodb_flush_log_at_trx_commit=2</code></p><p>为2时，只要事务提交成功，redo log buffer中的内容只写入文件系统缓存（ page cache )</p><p>如果仅仅只是MysQL挂了不会有任何数据丢失（page cache不归内存管了），但是<strong>操作系统宕机可能会有1秒数据的丢失</strong>，这种情况下无法满足ACID中的D。但是数值2肯定是效率最高的。</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126170251477.png" alt="image-20220126170251477"></p><p><strong>小结</strong>:  <code> innodb_flush_log_at_trx_commit=0</code> </p><p>为0时，master thread中每1秒进行一次重做日志的fsync操作，因此实例crash最多丢失1秒钟内的事务。(master thread是负责将缓冲池中的数据异步刷新到磁盘，保证数据的一致性)</p><p>数值0的话，是一种折中的做法，它的IO效率理论是高于1的，低于2的，这种策略也有丢失数据的风险，这种情况下也无法满足ACID中的D。</p><h3 id="1-7-写入redo-log-buffer-过程"><a href="#1-7-写入redo-log-buffer-过程" class="headerlink" title="1.7 写入redo log buffer 过程"></a>1.7 写入redo log buffer 过程</h3><h4 id="1-补充概念-Mini-Transaction"><a href="#1-补充概念-Mini-Transaction" class="headerlink" title="1.补充概念: Mini-Transaction"></a>1.补充概念: Mini-Transaction</h4><p>MysQL把对底层页面中的一次原子访问的过程称之为一个<strong>Mini-Transaction</strong>，简称<strong>mtr</strong>，比如，<strong>向某个索引对应的B+树中插入一条记录的过程就是一个Mini-Transaction</strong>。一个所谓的mtr可以包含一组redo日志在进行崩溃恢复时这一组redo日志作为一个不可分割的整体。</p><p>一个事务可以包含若干条语句，每一条语句其实是由若干个mtr组成，每一个mtr又可以包含若干条redo日志，画个图表示它们的关系就是这样:</p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126172158478.png" alt="image-20220126172158478" style="zoom:60%;"><h4 id="2-redo-日志写入log-buffer"><a href="#2-redo-日志写入log-buffer" class="headerlink" title="2. redo 日志写入log buffer"></a>2. redo 日志写入log buffer</h4><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126172413359.png" alt="image-20220126172413359"></p><p>每个mtr都会产生一组redo日志，用示意图来描述一下这些mtr产生的日志情况：  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126172424274.png" alt="image-20220126172424274"></p><p>不同的事务可能是 并发 执行的，所以 T1 、 T2 之间的 mtr 可能是 交替执行 的。  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126172438820.png" alt="image-20220126172438820"></p><h4 id="3-redo-log-block的结构图"><a href="#3-redo-log-block的结构图" class="headerlink" title="3. redo log block的结构图"></a>3. redo log block的结构图</h4><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126172453846.png" alt="image-20220126172453846"></p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126172501143.png" alt="image-20220126172501143"></p><h3 id="1-8-redo-log-file"><a href="#1-8-redo-log-file" class="headerlink" title="1.8 redo log file"></a>1.8 redo log file</h3><h4 id="1-相关参数设置"><a href="#1-相关参数设置" class="headerlink" title="1. 相关参数设置"></a>1. 相关参数设置</h4><ul><li><strong>innodb_log_group_home_dir</strong> ：指定 redo log 文件组所在的路径，默认值为 ./ ，表示在数据库的数据目录下。MySQL的默认数据目录（ var/lib/mysql ）下默认有两个名为 ib_logfile0 和ib_logfile1 的文件，log buffer中的日志默认情况下就是刷新到这两个磁盘文件中。此redo日志文件位置还可以修改。</li><li><strong>innodb_log_files_in_group</strong>：指明redo log file的个数，命名方式如：ib_logfile0，iblogfile1…iblogfilen。默认2个，最大100个。  </li></ul><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126172627228.png" alt="image-20220126172627228"></p><ul><li><strong>innodb_flush_log_at_trx_commit</strong>：控制 redo log 刷新到磁盘的策略，默认为1。</li><li><strong>innodb_log_file_size</strong>：单个 redo log 文件设置大小，默认值为 48M 。最大值为512G，注意最大值指的是整个 redo log 系列文件之和，即（innodb_log_files_in_group * innodb_log_file_size ）不能大于最大值512G。  </li></ul><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126172718213.png" alt="image-20220126172718213"></p><p>根据业务修改其大小，以便容纳较大的事务。编辑my.cnf文件并重启数据库生效，如下所示  </p><pre class="line-numbers language-none"><code class="language-none">[root@localhost ~]# vim &#x2F;etc&#x2F;my.cnfinnodb_log_file_size&#x3D;200M  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="2-日志文件组"><a href="#2-日志文件组" class="headerlink" title="2. 日志文件组"></a>2. 日志文件组</h4><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126172743759.png" alt="image-20220126172743759"></p><p>总共的redo日志文件大小其实就是： <code>innodb_log_file_size × innodb_log_files_in_group </code>。</p><p>采用循环使用的方式向redo日志文件组里写数据的话，会导致后写入的redo日志覆盖掉前边写的redo日志？当然！所以InnoDB的设计者提出了checkpoint的概念。  </p><h4 id="3-checkpoint"><a href="#3-checkpoint" class="headerlink" title="3. checkpoint"></a>3. checkpoint</h4><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126172808119.png" alt="image-20220126172808119"></p><p>如果 write pos 追上 checkpoint ，表示<strong>日志文件组满了</strong>，这时候不能再写入新的 redo log记录，MySQL 得停下来，清空一些记录，把 checkpoint 推进一下。  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126172825343.png" alt="image-20220126172825343"></p><h3 id="1-9-redo-log小结"><a href="#1-9-redo-log小结" class="headerlink" title="1.9 redo log小结"></a>1.9 redo log小结</h3><p>相信大家都知道redo log的作用和它的刷盘时机、存储形式:</p><p>InnoDB的更新操作采用的是<strong>Write Ahead Log</strong>(预先日志持久化)策略，即<strong>先写日志，再写入磁盘</strong>。</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126173138431.png" alt="image-20220126173138431"></p><h2 id="2-Undo日志"><a href="#2-Undo日志" class="headerlink" title="2. Undo日志"></a>2. Undo日志</h2><p><strong>redo log</strong>是事务<strong>持久性</strong>的保证，<strong>undo log</strong>是事务<strong>原子性</strong>的保证。在事务中 <strong>更新数据</strong> 的 <strong>前置操作</strong> 其实是要先写入一个 undo log 。</p><h3 id="2-1-如何理解Undo日志"><a href="#2-1-如何理解Undo日志" class="headerlink" title="2.1 如何理解Undo日志"></a>2.1 如何理解Undo日志</h3><p>事务需要保证 <strong>原子性</strong> ，也就是事务中的操作<strong>要么全部完成，要么什么也不做</strong>。但有时候事务执行到一半会出现一些情况，比如：</p><ul><li>情况一：事务执行过程中可能遇到各种错误，比如 <strong>服务器本身的错误</strong> ， <strong>操作系统错误</strong> ，甚至是突然<strong>断电</strong>导致的错误。</li><li>情况二：程序员可以在事务执行过程中手动输入 <strong>ROLLBACK</strong> 语句结束当前事务的执行。</li></ul><p>以上情况出现，我们需要把数据改回原先的样子，这个过程称之为 <strong>回滚</strong> ，这样就可以造成一个假象：这个事务看起来什么都没做，所以符合 <strong>原子性</strong> 要求。  </p><p>每当我们要对一条记录做改动时(这里的<strong>改动</strong>可以指<strong>INSERT、DELETE、UPDATE</strong>)，都需要”留一手”—-把回滚时所需的东西记下来。比如:</p><ul><li>你<strong>插入一条记录</strong>时，至少要把这条记录的主键值记下来，之后回滚的时候只需要把这个主键值对应的记录删掉就好了。(对于每个INSERT,InnoDB存储引擎会完成一个DELETE)</li><li>你<strong>删除了一条记录</strong>，至少要把这条记录中的内容都记下来，这样之后回滚时再把由这些内容组成的记录插入到表中就好了。(对于每个DELETE,InnoDB存储引擎会执行一个INSERT)</li><li>你<strong>修改了一条记录</strong>，至少要把修改这条记录前的旧值都记录下来，这样之后回滚时再把这条记录更新为旧值就好了。(对于每个UPDATE，InnoDB存储引擎会执行一个相反的UPDATE，将修改前的行放回去)</li></ul><p>MysQL把这些为了回滚而记录的这些内容称之为<strong>撤销日志</strong>或者<strong>回滚日志</strong>(即undo log)。注意，由于查询操作( SELECT）并不会修改任何用户记录，所以<strong>在查询操作执行时，并不需要记录相应的undo日志</strong>。</p><p>此外，undo log <strong>会产生redo log</strong>，也就是undo log的产生会伴随着redo log的产生，这是因为undo log也需要持久性的保护。</p><h3 id="2-2-Undo日志的作用"><a href="#2-2-Undo日志的作用" class="headerlink" title="2.2 Undo日志的作用"></a>2.2 Undo日志的作用</h3><ul><li><strong>作用1：回滚数据</strong></li></ul><p>用户对undo日志可能有误解:undo用于将数据库物理地恢复到执行语句或事务之前的样子。但事实并非如此。undo是逻辑日志，因此只是将数据库逻辑地恢复到原来的样子。所有修改都被逻辑地取消了，但是<strong>数据结构和页本身在回滚之后可能大不相同</strong>。</p><p>这是因为在多用户并发系统中，可能会有数十、数百甚至数千个并发事务。数据库的主要任务就是协调对数据记录的并发访问。比如，一个事务在修改当前一个页中某几条记录，同时还有别的事务在对同一个页中另几条记录进行修改。因此，不能将一个页回滚到事务开始的样子，因为这样会影响其他事务正在进行的工作。</p><ul><li><strong>作用2：MVCC</strong>  </li></ul><p>undo的另一个作用是MVCC，即在InnoDB存储引擎中MIcc的实现是通过undo来完成。当用户读取一行记录时，若该记录已经被其他事务占用，当前事务可以通过undo读取之前的行版本信息，以此实现非锁定读取。</p><h3 id="2-3-undo的存储结构"><a href="#2-3-undo的存储结构" class="headerlink" title="2.3 undo的存储结构"></a>2.3 undo的存储结构</h3><h4 id="1-回滚段与undo页"><a href="#1-回滚段与undo页" class="headerlink" title="1. 回滚段与undo页"></a>1. 回滚段与undo页</h4><p>InnoDB对undo log的管理采用段的方式，也就是 <strong>回滚段（rollback segment）</strong> 。每个回滚段记录了<strong>1024</strong> 个 <strong>undo log segment</strong> ，而在每个undo log segment段中进行 undo页 的申请。</p><ul><li>在 InnoDB1.1版本之前 （不包括1.1版本），只有一个rollback segment，因此支持同时在线的事务限制为 1024 。虽然对绝大多数的应用来说都已经够用。</li><li>从1.1版本开始InnoDB支持最大 <strong>128个rollback segment</strong> ，故其支持同时在线的事务限制提高到了 <strong>128*1024</strong> 。  </li></ul><h4 id="2-回滚段与事务"><a href="#2-回滚段与事务" class="headerlink" title="2. 回滚段与事务"></a>2. 回滚段与事务</h4><ol><li><p>每个事务只会使用一个回滚段，一个回滚段在同一时刻可能会服务于多个事务。</p></li><li><p>当一个事务开始的时候，会制定一个回滚段，在事务进行的过程中，当数据被修改时，原始的数据会被复制到回滚段。</p></li><li><p>在回滚段中，事务会不断填充盘区，直到事务结束或所有的空间被用完。如果当前的盘区不够用，事务会在段中请求扩展下一个盘区，如果所有已分配的盘区都被用完，事务会覆盖最初的盘区或者在回滚段允许的情况下扩展新的盘区来使用。</p></li><li><p>回滚段存在于undo表空间中，在数据库中可以存在多个undo表空间，但同一时刻只能使用一个undo表空间。</p></li><li><p>当事务提交时，InnoDB存储引擎会做以下两件事情：</p><p>将undo log放入列表中，以供之后的purge操作</p><p>判断undo log所在的页是否可以重用，若可以分配给下个事务使用</p></li><li><p> 回滚段中的数据分类  </p></li></ol><h4 id="3-回滚段中的数据分类"><a href="#3-回滚段中的数据分类" class="headerlink" title="3. 回滚段中的数据分类"></a>3. 回滚段中的数据分类</h4><ol><li><strong>未提交的回滚数据(uncommitted undo information)</strong>:该数据所关联的事务并未提交，用于实现读一致性，所以该数据不能被其他事务的数据覆盖。</li><li>**已经提交但未过期的回滚数据(committed undo information):**该数据关联的事务已经提交，但是仍受到undo retention参数的保持时间的影响。</li><li>**事务已经提交并过期的数据(expired undo information)**∶事务已经提交，而且数据保存时间已经超过undo retention参数指定的时间，属于已经过期的数据。当回滚段满了之后，会优先覆盖”事务已经提交并过期的数据”。</li></ol><p>事务提交后并不能马上删除undo log及undo log所在的页。这是因为可能还有其他事务需要通过undo log来得到行记录之前的版本。故事务提交时将undo log放入一个链表中，是否可以最终删除undo log及undo log所在页由purge线程来判断。</p><h3 id="2-4-undo的类型"><a href="#2-4-undo的类型" class="headerlink" title="2.4 undo的类型"></a>2.4 undo的类型</h3><p>在InnoDB存储引擎中，undo log分为：</p><ul><li>insert undo log</li><li>update undo log</li></ul><h3 id="2-5-undo-log的生命周期"><a href="#2-5-undo-log的生命周期" class="headerlink" title="2.5 undo log的生命周期"></a>2.5 undo log的生命周期</h3><h4 id="1-简要生成过程"><a href="#1-简要生成过程" class="headerlink" title="1. 简要生成过程"></a>1. 简要生成过程</h4><p><strong>只有Buffer Pool的流程：</strong>  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126192950145.png" alt="image-20220126192950145"></p><p><strong>有了Redo Log和Undo Log之后：</strong>  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126193014963.png" alt="image-20220126193014963"></p><h4 id="2-详细生成过程"><a href="#2-详细生成过程" class="headerlink" title="2. 详细生成过程"></a>2. 详细生成过程</h4><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126193323589.png" alt="image-20220126193323589"></p><p>当我们执行INSERT时：  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">begin</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token keyword">user</span> <span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">"tom"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126193345615.png" alt="image-20220126193345615"></p><p><strong>当我们执行UPDATE时：</strong>  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126193356469.png" alt="image-20220126193356469"></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">UPDATE</span> <span class="token keyword">user</span> <span class="token keyword">SET</span> id<span class="token operator">=</span><span class="token number">2</span> <span class="token keyword">WHERE</span> id<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126193411418.png" alt="image-20220126193411418"></p><h4 id="3-undo-log是如何回滚的"><a href="#3-undo-log是如何回滚的" class="headerlink" title="3. undo log是如何回滚的"></a>3. undo log是如何回滚的</h4><p>以上面的例子来说，假设执行rollback，那么对应的流程应该是这样：</p><ol><li>通过undo no=3的日志把id=2的数据删除</li><li>通过undo no=2的日志把id=1的数据的deletemark还原成0</li><li>通过undo no=1的日志把id=1的数据的name还原成Tom</li><li>通过undo no=0的日志把id=1的数据删除  </li></ol><h4 id="4-undo-log的删除"><a href="#4-undo-log的删除" class="headerlink" title="4. undo log的删除"></a>4. undo log的删除</h4><ul><li>针对于insert undo log</li></ul><p>因为insert操作的记录，只对事务本身可见，对其他事务不可见。故该undo log可以在事务提交后直接删除，不需要进行purge操作。</p><ul><li>针对于update undo log</li></ul><p>该undo log可能需要提供MVCC机制，因此不能在事务提交时就进行删除。提交时放入undo log链表，等待purge线程进行最后的删除。  </p><h3 id="2-6-小结"><a href="#2-6-小结" class="headerlink" title="2.6 小结"></a>2.6 小结</h3><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220126193510769.png" alt="image-20220126193510769"></p><p><strong>undo log是逻辑日志</strong>，对事务回滚时，只是将数据库<strong>逻辑地恢复到原来的样子</strong>。<br><strong>redo log是物理日志</strong>，记录的是数据页的物理变化，undo log不是redo log的逆过程。  </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>多表查询</title>
      <link href="/2022/01/25/%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2/"/>
      <url>/2022/01/25/%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h1><p>多表查询，也称为关联查询，指两个或更多个表一起完成查询操作。</p><p>前提条件：这些一起查询的表之间是有关系的（一对一、一对多），它们之间一定是有关联字段，这个关联字段可能建立了外键，也可能没有建立外键。比如：员工表和部门表，这两个表依靠“部门编号”进行关联。  </p><h2 id="1-一个案例引发的多表连接"><a href="#1-一个案例引发的多表连接" class="headerlink" title="1.一个案例引发的多表连接"></a>1.一个案例引发的多表连接</h2><h3 id="1-1-案例说明"><a href="#1-1-案例说明" class="headerlink" title="1.1 案例说明"></a>1.1 案例说明</h3><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220125162712644.png" alt="image-20220125162712644"></p><p>从多个表中获取数据：  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220125162742939.png" alt="image-20220125162742939"></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">#案例：查询员工的姓名及其部门名称</span><span class="token keyword">SELECT</span> last_name<span class="token punctuation">,</span> department_name <span class="token keyword">FROM</span> employees<span class="token punctuation">,</span> departments<span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220125162802341.png" alt="image-20220125162802341"></p><p>查询结果：  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220125162830410.png" alt="image-20220125162830410"></p><p><strong>2889 rows in set (0.01 sec)</strong>  </p><p><strong>分析错误情况 ：</strong></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token function">COUNT</span><span class="token punctuation">(</span>employee_id<span class="token punctuation">)</span> <span class="token keyword">FROM</span> employees<span class="token punctuation">;</span><span class="token comment">#输出107行</span><span class="token keyword">SELECT</span> <span class="token function">COUNT</span><span class="token punctuation">(</span>department_id<span class="token punctuation">)</span><span class="token keyword">FROM</span> departments<span class="token punctuation">;</span><span class="token comment">#输出27行</span><span class="token keyword">SELECT</span> <span class="token number">107</span><span class="token operator">*</span><span class="token number">27</span> <span class="token keyword">FROM</span> dual<span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们把上述多表查询中出现的问题称为：笛卡尔积的错误。  </p><h3 id="1-2-笛卡尔积（或交叉连接）的理解"><a href="#1-2-笛卡尔积（或交叉连接）的理解" class="headerlink" title="1.2 笛卡尔积（或交叉连接）的理解"></a>1.2 笛卡尔积（或交叉连接）的理解</h3><p>笛卡尔乘积是一个数学运算。假设我有两个集合 X 和 Y，那么 X 和 Y 的笛卡尔积就是 X 和 Y 的所有可能组合，也就是第一个对象来自于 X，第二个对象来自于 Y 的所有可能。组合的个数即为两个集合中元素个数的乘积数。  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220125162944790.png" alt="image-20220125162944790"></p><p>SQL92中，笛卡尔积也称为 <strong>交叉连接</strong> ，英文是 <strong>CROSS JOIN</strong> 。在 SQL99 中也是使用 CROSS JOIN表示交叉连接。它的作用就是可以把任意表进行连接，即使这两张表不相关。在MySQL中如下情况会出现笛卡尔积：</p><ul><li><p><strong>笛卡尔积的错误会在下面条件下产生：</strong></p><ul><li><p>省略多个表的连接条件（或关联条件）</p></li><li><p>连接条件（或关联条件）无效</p></li><li><p>所有表中的所有行互相连接</p></li></ul></li></ul><p>为了避免笛卡尔积， <strong>可以在 WHERE 加入有效的连接条件</strong>。</p><p>加入连接条件后，查询语法：  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> table1<span class="token punctuation">.</span><span class="token keyword">column</span><span class="token punctuation">,</span> table2<span class="token punctuation">.</span><span class="token keyword">column</span><span class="token keyword">FROM</span> table1<span class="token punctuation">,</span> table2<span class="token keyword">WHERE</span> table1<span class="token punctuation">.</span>column1 <span class="token operator">=</span> table2<span class="token punctuation">.</span>column2<span class="token punctuation">;</span> <span class="token comment">#连接条件  </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>正确写法：  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">#案例：查询员工的姓名及其部门名称</span><span class="token keyword">SELECT</span> last_name<span class="token punctuation">,</span> department_name<span class="token keyword">FROM</span> employees<span class="token punctuation">,</span> departments<span class="token keyword">WHERE</span> employees<span class="token punctuation">.</span>department_id <span class="token operator">=</span> departments<span class="token punctuation">.</span>department_id<span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>在表中有相同列时，在列名之前加上表名前缀。</strong>  <code>从SQL优化的角度，建议多表查询时，每个字段都指明其所在的表。</code></p><h2 id="2-多表查询分类讲解"><a href="#2-多表查询分类讲解" class="headerlink" title="2.多表查询分类讲解"></a>2.多表查询分类讲解</h2><h3 id="分类1：等值连接-vs-非等值连接"><a href="#分类1：等值连接-vs-非等值连接" class="headerlink" title="分类1：等值连接 vs 非等值连接"></a>分类1：等值连接 vs 非等值连接</h3><h4 id="等值连接"><a href="#等值连接" class="headerlink" title="等值连接"></a>等值连接</h4><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220125163431595.png" alt="image-20220125163431595"></p><p>例如上图中，从表<code> EMPLOYEES</code>中的 <code>DEPARTMENT_ID</code>对应表 <code>DEPARTMENTS</code>中的<code>DEPARTMENT_ID</code>， 我们要查询通过两张表中查询某员工的部门名称，那么就是通过两张表的<code>DEPARTMENT_ID</code>来进行连接的。通过两张表中字段确定的值来查询，这样的就叫做<strong>等值连接</strong>。</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220125163915473.png" alt="image-20220125163915473"></p><p><strong>拓展1：区分重复的列名</strong>  </p><ul><li>多个表中有相同列时，必须在列名之前加上表名前缀。</li><li>在不同表中具有相同列名的列可以用 <strong>表名</strong> 加以区分。  </li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> employees<span class="token punctuation">.</span>last_name<span class="token punctuation">,</span> departments<span class="token punctuation">.</span>department_name<span class="token punctuation">,</span>employees<span class="token punctuation">.</span>department_id<span class="token keyword">FROM</span> employees<span class="token punctuation">,</span> departments<span class="token keyword">WHERE</span> employees<span class="token punctuation">.</span>department_id <span class="token operator">=</span> departments<span class="token punctuation">.</span>department_id<span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>拓展2：表的别名</strong>  </p><ul><li>使用别名可以简化查询。</li><li>列名前使用表名前缀可以提高查询效率。  </li><li><strong>需要注意的是</strong>，如果我们使用了表的别名，在查询字段中、过滤条件中就只能使用别名进行代替，不能使用原有的表名，否则就会报错  </li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> e<span class="token punctuation">.</span>employee_id<span class="token punctuation">,</span> e<span class="token punctuation">.</span>last_name<span class="token punctuation">,</span> e<span class="token punctuation">.</span>department_id<span class="token punctuation">,</span>d<span class="token punctuation">.</span>department_id<span class="token punctuation">,</span> d<span class="token punctuation">.</span>location_id<span class="token keyword">FROM</span> employees e <span class="token punctuation">,</span> departments d<span class="token keyword">WHERE</span> e<span class="token punctuation">.</span>department_id <span class="token operator">=</span> d<span class="token punctuation">.</span>department_id<span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>【强制】</strong>对于数据库中表记录的查询和变更，只要涉及多个表，都需要在列名前加表的别名（或表名）进行限定。</p><p><strong>说明</strong> ：对多表进行查询记录、更新记录、删除记录时，如果对操作列没有限定表的别名（或表名），并且操作列在多个表中存在时，就会抛异常。</p><p><strong>正例</strong> ：select t1.name from table_first as t1 , table_second as t2 where t1.id=t2.id;</p><p><strong>反例</strong> ：在某业务中，由于多表关联查询语句没有加表的别名（或表名）的限制，正常运行两年后，最近在 某个表中增加一个同名字段，在预发布环境做数据库变更后，线上查询语句出现出1052 异常：Column ‘name’ in field list is ambiguous。  </p><p><strong>拓展3：连接多个表</strong>  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220125164547569.png" alt="image-20220125164547569"></p><p><strong>总结：连接 n个表,至少需要n-1个连接条件</strong>。比如，连接三个表，至少需要两个连接条件。  </p><h4 id="非等值连接"><a href="#非等值连接" class="headerlink" title="非等值连接"></a>非等值连接</h4><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220125164609522.png" alt="image-20220125164609522"></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> e<span class="token punctuation">.</span>last_name<span class="token punctuation">,</span> e<span class="token punctuation">.</span>salary<span class="token punctuation">,</span> j<span class="token punctuation">.</span>grade_level<span class="token keyword">FROM</span> employees e<span class="token punctuation">,</span> job_grades j<span class="token keyword">WHERE</span> e<span class="token punctuation">.</span>salary <span class="token operator">BETWEEN</span> j<span class="token punctuation">.</span>lowest_sal <span class="token operator">AND</span> j<span class="token punctuation">.</span>highest_sal<span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220125164952009.png" alt="image-20220125164952009"></p><p>例如通过表<code>EMPLOYEES</code>查询该员工所在的工资等级GRA，是利用表<code>EMPLOYEES</code>的<code>SALARY</code>字段的值，看其处于表<code>JOB_GRADES</code>的那个范围，这就是<strong>非等值查询连接</strong>。</p><h3 id="分类2：自连接-vs-非自连接"><a href="#分类2：自连接-vs-非自连接" class="headerlink" title="分类2：自连接 vs 非自连接"></a>分类2：自连接 vs 非自连接</h3><p>之前查询并且连接不同的表，都是<strong>非自连接</strong>。</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220125165056389.png" alt="image-20220125165056389"></p><p>利用一张表<code>EMPLOYEES</code>，使得一行中显示员工的管理者，也就是表自己和自己连接。</p><p>当table1和table2本质上是同一张表，只是<strong>用取别名的方式虚拟成两张表</strong>以代表不同的意义。然后两个表再进行内连接，外连接等查询。  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> employee_id<span class="token punctuation">,</span> department_nameFROMemployees e<span class="token punctuation">,</span>departments d<span class="token keyword">WHERE</span> e<span class="token punctuation">.</span> 'department_id<span class="token punctuation">`</span> <span class="token operator">=</span> d<span class="token punctuation">.</span>department_id<span class="token punctuation">;</span> <span class="token comment">#只有106条记录，表EMPLOYEES中共107条记录</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>因为这是<strong>内连接查询</strong>，只会将符合查询条件的查询出来。（剩余一个员工是最上级，再没有管理者）</p><h3 id="分类3：内连接-vs-外连接"><a href="#分类3：内连接-vs-外连接" class="headerlink" title="分类3：内连接 vs 外连接"></a>分类3：内连接 vs 外连接</h3><p>除了查询满足条件的记录以外，外连接还可以查询某一方<strong>不满足条件的记录</strong> 。</p><ul><li><p><strong>内连接:</strong> 合并具有同一列的两个以上的表的行, 结果集中不包含一个表与另一个表不匹配的行 （<strong>满足匹配条件的查出来，不满足条件的不会查出来</strong>）</p></li><li><p><strong>外连接:</strong> 两个表在连接过程中除了返回满足连接条件的行以外还返回左（或右）表中不满足条件的行 ，这种连接称为左（或右） 外连接。没有匹配的行时, 结果表中相应的列为空(NULL)。(<strong>把不满足条件的也查询出来</strong>)</p><ul><li>如果是<strong>左外连接</strong><code>LEFT JOIN</code>，则连接条件中左边的表也称为 <strong>主表</strong> ，右边的表称为 <strong>从表</strong> 。（左边不满足的查出来）</li></ul><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/img_leftjoin.gif" alt="SQL LEFT JOIN"></p><ul><li>如果是<strong>右外连接</strong><code>RIGHT JOIN</code> ，则连接条件中右边的表也称为 <strong>主表</strong> ，左边的表称为 <strong>从表</strong> 。 （右边不满足的查出来）</li></ul></li></ul><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/img_rightjoin.gif" alt="SQL RIGHT JOIN"></p><ul><li><strong>满外连接</strong> <code>FULL OUTER JOIN </code>关键字<strong>只要左表（table1）和右表（table2）其中一个表中存在匹配</strong>，则返回行。<code>FULL OUTER JOIN </code>关键字结合了<code> LEFT JOIN</code> 和 <code>RIGHT JOIN </code>的结果。</li></ul><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/img_fulljoin.gif" alt="SQL FULL OUTER JOIN"></p><p>SQL92语法实现内连接：见上</p><h3 id="SQL92：使用-创建连接"><a href="#SQL92：使用-创建连接" class="headerlink" title="SQL92：使用(+)创建连接"></a>SQL92：使用(+)创建连接</h3><p>在 SQL92 中采用（+）代表从表所在的位置。即左或右外连接中，(+) 表示哪个是从表。</p><p>Oracle 对 SQL92 支持较好，而 <strong>MySQL 则不支持 SQL92 的外连接</strong>  （！！！！！说了个卵）</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">#左外连接</span><span class="token keyword">SELECT</span> last_name<span class="token punctuation">,</span>department_name<span class="token keyword">FROM</span> employees <span class="token punctuation">,</span>departments<span class="token keyword">WHERE</span> employees<span class="token punctuation">.</span>department_id <span class="token operator">=</span> departments<span class="token punctuation">.</span>department_id<span class="token punctuation">(</span><span class="token operator">+</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">#右外连接</span><span class="token keyword">SELECT</span> last_name<span class="token punctuation">,</span>department_name<span class="token keyword">FROM</span> employees <span class="token punctuation">,</span>departments<span class="token keyword">WHERE</span> employees<span class="token punctuation">.</span>department_id<span class="token punctuation">(</span><span class="token operator">+</span><span class="token punctuation">)</span> <span class="token operator">=</span> departments<span class="token punctuation">.</span>department_id<span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而且在 SQL92 中，只有左外连接和右外连接，没有满（或全）外连接。  </p><p>因此我们要学习SQL99语法实现多表查询 。</p><h2 id="3-SQL99语法实现多表查询"><a href="#3-SQL99语法实现多表查询" class="headerlink" title="3. SQL99语法实现多表查询"></a>3. SQL99语法实现多表查询</h2><p>SQL99语法使用<code>JOIN ... ON</code>的方式实现多表查询，可解决外连接的问题。<strong>MySQL支持SQL99的外连接</strong>。</p><h4 id="3-1-基本语法"><a href="#3-1-基本语法" class="headerlink" title="3.1 基本语法"></a>3.1 基本语法</h4><p><strong>使用<code>JOIN...ON子</code>句创建连接的语法结构：</strong>  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> table1<span class="token punctuation">.</span><span class="token keyword">column</span><span class="token punctuation">,</span> table2<span class="token punctuation">.</span><span class="token keyword">column</span><span class="token punctuation">,</span>table3<span class="token punctuation">.</span><span class="token keyword">column</span><span class="token keyword">FROM</span> table1<span class="token keyword">JOIN</span> table2 <span class="token keyword">ON</span> table1 和 table2 的连接条件<span class="token keyword">JOIN</span> table3 <span class="token keyword">ON</span> table2 和 table3 的连接条件  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>它的嵌套逻辑类似我们使用的 FOR 循环：  </p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">for</span> t1 in table1<span class="token operator">:</span><span class="token keyword">for</span> t2 in table2<span class="token operator">:</span><span class="token keyword">if</span> condition1<span class="token operator">:</span><span class="token keyword">for</span> t3 in table3<span class="token operator">:</span><span class="token keyword">if</span> condition2<span class="token operator">:</span>output t1 <span class="token operator">+</span> t2 <span class="token operator">+</span> t3  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>SQL99 采用的这种嵌套结构非常清爽、层次性更强、可读性更强，即使再多的表进行连接也都清晰可见。如果你采用 SQL92，可读性就会大打折扣。  </p><p><strong>语法说明：</strong></p><ul><li>可以使用 ON 子句指定额外的连接条件。</li><li>这个连接条件是与其它条件分开的。</li><li>ON 子句使语句具有更高的易读性。</li><li>关键字 JOIN、INNER JOIN、CROSS JOIN 的含义是一样的，都表示内连接  </li></ul><h4 id="3-2-内连接-INNER-JOIN-的实现"><a href="#3-2-内连接-INNER-JOIN-的实现" class="headerlink" title="3.2 内连接(INNER JOIN)的实现"></a>3.2 内连接(INNER JOIN)的实现</h4><p><strong>语法：</strong></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> 字段列表<span class="token keyword">FROM</span> A表 <span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> B表<span class="token keyword">ON</span> 关联条件<span class="token keyword">WHERE</span> 等其他子句<span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>例：</p><p>三张表<code>employees</code>,<code>locations</code>,<code>departments</code></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> last_name<span class="token punctuation">,</span> department_name <span class="token keyword">FROM</span> employees e <span class="token keyword">JOIN</span> departments d<span class="token keyword">ON</span> e<span class="token punctuation">.</span>department_id <span class="token operator">=</span> d<span class="token punctuation">.</span>department_id<span class="token keyword">JOIN</span> locations l <span class="token keyword">ON</span> d<span class="token punctuation">.</span>location_id <span class="token operator">=</span> l<span class="token punctuation">.</span>location_id<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-3-外连接-OUTER-JOIN-的实现"><a href="#3-3-外连接-OUTER-JOIN-的实现" class="headerlink" title="3.3 外连接(OUTER JOIN)的实现"></a>3.3 外连接(OUTER JOIN)的实现</h4><h5 id="3-3-1-左外连接-LEFT-OUTER-JOIN"><a href="#3-3-1-左外连接-LEFT-OUTER-JOIN" class="headerlink" title="3.3.1 左外连接(LEFT OUTER JOIN)"></a>3.3.1 左外连接(LEFT OUTER JOIN)</h5><ul><li>语法：</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">#实现查询结果是A</span><span class="token keyword">SELECT</span> 字段列表<span class="token keyword">FROM</span> A表 <span class="token keyword">LEFT</span> <span class="token keyword">JOIN</span><span class="token punctuation">(</span>或 <span class="token keyword">LEFT</span> <span class="token keyword">OUTER</span> <span class="token keyword">JOIN</span><span class="token punctuation">)</span> B表<span class="token keyword">ON</span> 关联条件<span class="token keyword">WHERE</span> 等其他子句<span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>举例：</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> e<span class="token punctuation">.</span>last_name<span class="token punctuation">,</span> e<span class="token punctuation">.</span>department_id<span class="token punctuation">,</span> d<span class="token punctuation">.</span>department_name<span class="token keyword">FROM</span> employees e <span class="token keyword">LEFT</span> <span class="token keyword">OUTER</span> <span class="token keyword">JOIN</span> departments d<span class="token keyword">ON</span> e<span class="token punctuation">.</span>department_id <span class="token operator">=</span> d<span class="token punctuation">.</span>department_id<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220125191635213.png" alt="image-20220125191635213"></p><p>3.3.2 右外连接(RIGHT OUTER JOIN)  </p><ul><li>语法</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> 字段列表<span class="token keyword">FROM</span> A表 <span class="token keyword">RIGHT</span> JOI<span class="token keyword">ON</span> 关联条件<span class="token keyword">WHERE</span> 等其他子句<span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>举例：  </li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> e<span class="token punctuation">.</span>last_name<span class="token punctuation">,</span> e<span class="token punctuation">.</span>department_id<span class="token punctuation">,</span> d<span class="token punctuation">.</span>department_name<span class="token keyword">FROM</span> employees e<span class="token keyword">RIGHT</span> <span class="token keyword">OUTER</span> <span class="token keyword">JOIN</span> departments  d<span class="token keyword">ON</span> e<span class="token punctuation">.</span>department_id <span class="token operator">=</span> d<span class="token punctuation">.</span>department_id<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220125192045048.png" alt="image-20220125192045048"></p><p><strong>需要注意的是</strong>，LEFT JOIN 和 RIGHT JOIN 只存在于 SQL99 及以后的标准中，在 SQL92 中不存在，<br>只能用 (+) 表示。  </p><h5 id="3-3-3-满外连接-FULL-OUTER-JOIN"><a href="#3-3-3-满外连接-FULL-OUTER-JOIN" class="headerlink" title="3.3.3 满外连接(FULL OUTER JOIN)"></a>3.3.3 满外连接(FULL OUTER JOIN)</h5><ul><li>满外连接的结果 = 左右表匹配的数据 + 左表没有匹配到的数据 + 右表没有匹配到的数据。</li><li>SQL99是支持满外连接的。使用<code>FULL JOIN</code> 或 <code>FULL OUTER JOIN</code>来实现。</li><li>需要注意的是，<strong>MySQL不支持</strong><code>FULL JOIN</code>，但是可以用 <code>LEFT JOIN UNION RIGHT JOIN</code>代替  </li></ul><h2 id="4-UNION的使用"><a href="#4-UNION的使用" class="headerlink" title="4.UNION的使用"></a>4.UNION的使用</h2><p><strong>合并查询结果</strong> 利用UNION关键字，可以给出多条SELECT语句，并将它们的结果组合成单个结果集。合并时，两个表对应的列数和数据类型必须相同，并且相互对应。各个SELECT语句之间使用UNION或UNIONALL关键字分隔。</p><p>语法格式：  </p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">SELECT column,... FROM table1UNION [ALL]SELECT column,... FROM table2  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>UNION操作符</strong>  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220125193620957.png" alt="image-20220125193620957"></p><p><code>UNION </code>操作符返回两个查询的结果集的并集，<strong>去除重复记录</strong></p><p><strong>UNION ALL操作符</strong>  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220125193701666.png" alt="image-20220125193701666"></p><p><code>UNION ALL</code>操作符返回两个查询的结果集的并集。对于两个结果集的重复部分，<strong>不去重</strong>。  </p><p><strong>注意：</strong>执行<code>UNION ALL</code>语句时所需要的资源比<code>UNION</code>语句少。如果明确知道合并数据后的结果数据<br>不存在重复数据，或者不需要去除重复的数据，则<strong>尽量使用</strong><code>UNION ALL</code>语句，以提高数据查询的效<br>率。  </p><h2 id="5-7种SQL-JOINS的实现"><a href="#5-7种SQL-JOINS的实现" class="headerlink" title="5.   7种SQL JOINS的实现"></a>5.   7种SQL JOINS的实现</h2><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220125193922411.png" alt="image-20220125193922411" style="zoom:60%;"><p>5.7.1 代码实现</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">#中图：内连接 A∩BSELECT employee_id,last_name,department_nameFROM employees e JOIN departments dON e.&#96;department_id&#96; &#x3D; d.&#96;department_id&#96;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">#左上图：左外连接SELECT employee_id,last_name,department_nameFROM employees e LEFT JOIN departments dON e.&#96;department_id&#96; &#x3D; d.&#96;department_id&#96;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">#右上图：右外连接SELECT employee_id,last_name,department_nameFROM employees e RIGHT JOIN departments dON e.&#96;department_id&#96; &#x3D; d.&#96;department_id&#96;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">#左中图：A - A∩BSELECT employee_id,last_name,department_nameFROM employees e LEFT JOIN departments dON e.&#96;department_id&#96; &#x3D; d.&#96;department_id&#96;WHERE d.&#96;department_id&#96; IS NULL<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">#右中图：B-A∩BSELECT employee_id,last_name,department_nameFROM employees e RIGHT JOIN departments dON e.&#96;department_id&#96; &#x3D; d.&#96;department_id&#96;WHERE e.&#96;department_id&#96; IS NULL  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">#左下图：满外连接</span><span class="token comment">#利用左中图 + 右上图 A∪B</span><span class="token keyword">SELECT</span> employee_id<span class="token punctuation">,</span>last_name<span class="token punctuation">,</span>department_name<span class="token keyword">FROM</span> employees e <span class="token keyword">LEFT</span> <span class="token keyword">JOIN</span> departments d<span class="token keyword">ON</span> e<span class="token punctuation">.</span><span class="token punctuation">`</span>department_id<span class="token punctuation">`</span> <span class="token operator">=</span> d<span class="token punctuation">.</span><span class="token punctuation">`</span>department_id<span class="token punctuation">`</span><span class="token keyword">WHERE</span> d<span class="token punctuation">.</span><span class="token punctuation">`</span>department_id<span class="token punctuation">`</span> <span class="token operator">IS</span> <span class="token boolean">NULL</span><span class="token keyword">UNION</span> <span class="token keyword">ALL</span> <span class="token comment">#没有去重操作，效率高</span><span class="token keyword">SELECT</span> employee_id<span class="token punctuation">,</span>last_name<span class="token punctuation">,</span>department_name<span class="token keyword">FROM</span> employees e <span class="token keyword">RIGHT</span> <span class="token keyword">JOIN</span> departments d<span class="token keyword">ON</span> e<span class="token punctuation">.</span><span class="token punctuation">`</span>department_id<span class="token punctuation">`</span> <span class="token operator">=</span> d<span class="token punctuation">.</span><span class="token punctuation">`</span>department_id<span class="token punctuation">`</span><span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">#右下图</span><span class="token comment">#左中图 + 右中图 A ∪B- A∩B 或者 (A - A∩B) ∪ （B - A∩B）</span><span class="token keyword">SELECT</span> employee_id<span class="token punctuation">,</span>last_name<span class="token punctuation">,</span>department_name<span class="token keyword">FROM</span> employees e <span class="token keyword">LEFT</span> <span class="token keyword">JOIN</span> departments d<span class="token keyword">ON</span> e<span class="token punctuation">.</span><span class="token punctuation">`</span>department_id<span class="token punctuation">`</span> <span class="token operator">=</span> d<span class="token punctuation">.</span><span class="token punctuation">`</span>department_id<span class="token punctuation">`</span><span class="token keyword">WHERE</span> d<span class="token punctuation">.</span><span class="token punctuation">`</span>department_id<span class="token punctuation">`</span> <span class="token operator">IS</span> <span class="token boolean">NULL</span><span class="token keyword">UNION</span> <span class="token keyword">ALL</span><span class="token keyword">SELECT</span> employee_id<span class="token punctuation">,</span>last_name<span class="token punctuation">,</span>department_name<span class="token keyword">FROM</span> employees e <span class="token keyword">RIGHT</span> <span class="token keyword">JOIN</span> departments d<span class="token keyword">ON</span> e<span class="token punctuation">.</span><span class="token punctuation">`</span>department_id<span class="token punctuation">`</span> <span class="token operator">=</span> d<span class="token punctuation">.</span><span class="token punctuation">`</span>department_id<span class="token punctuation">`</span><span class="token keyword">WHERE</span> e<span class="token punctuation">.</span><span class="token punctuation">`</span>department_id<span class="token punctuation">`</span> <span class="token operator">IS</span> <span class="token boolean">NULL</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6-SQL99语法新特性"><a href="#6-SQL99语法新特性" class="headerlink" title="6. SQL99语法新特性"></a>6. SQL99语法新特性</h2><h3 id="6-1-自然连接"><a href="#6-1-自然连接" class="headerlink" title="6.1 自然连接"></a>6.1 自然连接</h3><p>SQL99 在 SQL92 的基础上提供了一些特殊语法，比如 <strong>NATURAL JOIN</strong> 用来表示自然连接。我们可以把自然连接理解为 SQL92 中的等值连接。它会帮你自动查询两张连接表中 <strong>所有相同的字段</strong> ，然后进行 <strong>等值连接</strong> 。  </p><p>在SQL92标准中：  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> employee_id<span class="token punctuation">,</span>last_name<span class="token punctuation">,</span>department_name<span class="token keyword">FROM</span> employees e <span class="token keyword">JOIN</span> departments d<span class="token keyword">ON</span> e<span class="token punctuation">.</span><span class="token punctuation">`</span>department_id<span class="token punctuation">`</span> <span class="token operator">=</span> d<span class="token punctuation">.</span><span class="token punctuation">`</span>department_id<span class="token punctuation">`</span><span class="token operator">AND</span> e<span class="token punctuation">.</span><span class="token punctuation">`</span>manager_id<span class="token punctuation">`</span> <span class="token operator">=</span> d<span class="token punctuation">.</span><span class="token punctuation">`</span>manager_id<span class="token punctuation">`</span><span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在 SQL99 中你可以写成：  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> employee_id<span class="token punctuation">,</span>last_name<span class="token punctuation">,</span>department_name<span class="token keyword">FROM</span> employees e <span class="token keyword">NATURAL</span> <span class="token keyword">JOIN</span> departments d<span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="6-2-USING连接"><a href="#6-2-USING连接" class="headerlink" title="6.2 USING连接"></a>6.2 USING连接</h3><p>当我们进行连接的时候，SQL99还支持使用 <strong>USING</strong> 指定数据表里的 <strong>同名字段</strong> 进行等值连接。但是只能配合JOIN一起使用。比如：  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> employee_id<span class="token punctuation">,</span>last_name<span class="token punctuation">,</span>department_name<span class="token keyword">FROM</span> employees e <span class="token keyword">JOIN</span> departments d<span class="token keyword">USING</span> <span class="token punctuation">(</span>department_id<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>你能看出与自然连接 <code>NATURAL JOIN </code>不同的是，<code>USING </code>指定了具体的相同的字段名称，你需要在<code> USING</code>的括号 () 中填入要指定的同名字段。同时使用 <code>JOIN...USING</code> 可以简化 JOIN ON 的等值连接。它与下面的 SQL 查询结果是相同的：  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> employee_id<span class="token punctuation">,</span>last_name<span class="token punctuation">,</span>department_name<span class="token keyword">FROM</span> employees e <span class="token punctuation">,</span>departments d<span class="token keyword">WHERE</span> e<span class="token punctuation">.</span>department_id <span class="token operator">=</span> d<span class="token punctuation">.</span>department_id<span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="7-章节小结"><a href="#7-章节小结" class="headerlink" title="7. 章节小结"></a>7. 章节小结</h2><p>表连接的约束条件可以有三种方式：<code>WHERE, ON, USING  </code></p><ul><li>WHERE：适用于所有关联查询</li><li>ON ：只能和JOIN一起使用，只能写关联条件。虽然关联条件可以并到WHERE中和其他条件一起写，但分开写可读性更好。</li><li>USING：只能和JOIN一起使用，而且要求两个关联字段在关联表中名称一致，而且只能表示关联字段值相等  </li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">#关联条件</span><span class="token comment">#把关联条件写在where后面</span><span class="token keyword">SELECT</span> last_name<span class="token punctuation">,</span>department_name<span class="token keyword">FROM</span> employees<span class="token punctuation">,</span>departments<span class="token keyword">WHERE</span> employees<span class="token punctuation">.</span>department_id <span class="token operator">=</span> departments<span class="token punctuation">.</span>department_id<span class="token punctuation">;</span><span class="token comment">#把关联条件写在on后面，只能和JOIN一起使用</span><span class="token keyword">SELECT</span> last_name<span class="token punctuation">,</span>department_name<span class="token keyword">FROM</span> employees <span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> departments<span class="token keyword">ON</span> employees<span class="token punctuation">.</span>department_id <span class="token operator">=</span> departments<span class="token punctuation">.</span>department_id<span class="token punctuation">;</span><span class="token keyword">SELECT</span> last_name<span class="token punctuation">,</span>department_name<span class="token keyword">FROM</span> employees <span class="token keyword">CROSS</span> <span class="token keyword">JOIN</span> departments<span class="token keyword">ON</span> employees<span class="token punctuation">.</span>department_id <span class="token operator">=</span> departments<span class="token punctuation">.</span>department_id<span class="token punctuation">;</span><span class="token keyword">SELECT</span> last_name<span class="token punctuation">,</span>department_name<span class="token keyword">FROM</span> employees <span class="token keyword">JOIN</span> departments<span class="token keyword">ON</span> employees<span class="token punctuation">.</span>department_id <span class="token operator">=</span> departments<span class="token punctuation">.</span>department_id<span class="token punctuation">;</span><span class="token comment">#把关联字段写在using()中，只能和JOIN一起使用</span><span class="token comment">#而且两个表中的关联字段必须名称相同，而且只能表示=</span><span class="token comment">#查询员工姓名与基本工资</span><span class="token keyword">SELECT</span> last_name<span class="token punctuation">,</span>job_title<span class="token keyword">FROM</span> employees <span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> jobs <span class="token keyword">USING</span><span class="token punctuation">(</span>job_id<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">#n张表关联，需要n-1个关联条件</span><span class="token comment">#查询员工姓名，基本工资，部门名称</span><span class="token keyword">SELECT</span> last_name<span class="token punctuation">,</span>job_title<span class="token punctuation">,</span>department_name <span class="token keyword">FROM</span> employees<span class="token punctuation">,</span>departments<span class="token punctuation">,</span>jobs<span class="token keyword">WHERE</span> employees<span class="token punctuation">.</span>department_id <span class="token operator">=</span> departments<span class="token punctuation">.</span>department_id<span class="token operator">AND</span> employees<span class="token punctuation">.</span>job_id <span class="token operator">=</span> jobs<span class="token punctuation">.</span>job_id<span class="token punctuation">;</span><span class="token keyword">SELECT</span> last_name<span class="token punctuation">,</span>job_title<span class="token punctuation">,</span>department_name<span class="token keyword">FROM</span> employees <span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> departments <span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> jobs<span class="token keyword">ON</span> employees<span class="token punctuation">.</span>department_id <span class="token operator">=</span> departments<span class="token punctuation">.</span>department_id<span class="token operator">AND</span> employees<span class="token punctuation">.</span>job_id <span class="token operator">=</span> jobs<span class="token punctuation">.</span>job_id<span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意：</strong><br>我们要 <strong>控制连接表的数量</strong> 。多表连接就<strong>相当于嵌套 for 循环一样，非常消耗资源</strong>，会让 SQL 查询性能下降得很严重，因此不要连接不必要的表。在许多 DBMS 中，也都会有最大连接表的限制。  </p><p><strong>【强制】****超过三个表禁止 join</strong>。需要 join 的字段，数据类型保持绝对一致；多表关联查询时， 保证被关联的字段需要有索引。<br>说明：即使双表 join 也要注意表索引、SQL 性能。来源：阿里巴巴《Java开发手册》  </p><h2 id="附录：常用的-SQL-标准有哪些"><a href="#附录：常用的-SQL-标准有哪些" class="headerlink" title="附录：常用的 SQL 标准有哪些"></a>附录：常用的 SQL 标准有哪些</h2><p>在正式开始讲连接表的种类时，我们首先需要知道 SQL 存在不同版本的标准规范，因为不同规范下的表连接操作是有区别的。</p><p>SQL 有两个主要的标准，分别是 SQL92 和 SQL99 。92 和 99 代表了标准提出的时间，SQL92 就是 92 年提出的标准规范。当然除了 SQL92 和 SQL99 以外，还存在 SQL-86、SQL-89、SQL:2003、SQL:2008、SQL:2011 和 SQL:2016 等其他的标准。</p><p>这么多标准，到底该学习哪个呢？<strong>实际上最重要的 SQL 标准就是 SQL92 和 SQL99</strong>。一般来说 SQL92 的形式更简单，但是写的 SQL 语句会比较长，可读性较差。而 <strong>SQL99 相比于 SQL92 来说，语法更加复杂，但可读性更强</strong>。我们从这两个标准发布的页数也能看出，SQL92 的标准有 500 页，而 SQL99 标准超过了1000 页。实际上从 SQL99 之后，很少有人能掌握所有内容，因为确实太多了。就好比我们使用Windows、Linux 和 Office 的时候，很少有人能掌握全部内容一样。我们只需要掌握一些核心的功能，满<br>足日常工作的需求即可。</p><p><strong>SQL92 和 SQL99 是经典的 SQL 标准，也分别叫做 SQL-2 和 SQL-3 标准。</strong>也正是在这两个标准发布之<br>后，SQL 影响力越来越大，甚至超越了数据库领域。现如今 SQL 已经不仅仅是数据库领域的主流语言，<br>还是信息领域中信息处理的主流语言。在图形检索、图像检索以及语音检索中都能看到 SQL 语言的使<br>用。  </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>锁</title>
      <link href="/2022/01/19/%E9%94%81/"/>
      <url>/2022/01/19/%E9%94%81/</url>
      
        <content type="html"><![CDATA[<p>事务的 <strong>隔离性</strong> 由这章讲述的 <strong>锁</strong> 来实现。  </p><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p><strong>锁</strong>是计算机协调多个进程或线程<strong>并发访问某一资源</strong>的机制。在程序开发中会存在多线程同步的问题，当多个线程并发访问某个数据的时候，尤其是针对一些敏感的数据(比如订单、金额等)，我们就需要保证这个数据在任何时刻<strong>最多只有一个线程在访问</strong>，保证数据的<strong>完整性</strong>和一致性。在开发过程中加锁是为了保证数据的一致性，这个思想在数据库领域中同样很重要。</p><p>在数据库中，除传统的计算资源（如CPU、RAM、/O等）的争用以外，数据也是一种供计多用厂共寻的负源。乃保证数据的一致性，需要对<strong>并发操作进行控制</strong>，因此产生了<strong>锁</strong>。同时<strong>锁机制</strong>也为实现MysQL的各个隔离级别提供了保证。<strong>锁冲突</strong>也是影响数据库<strong>并发访问性能</strong>的一个重要因素。所以锁对数据库而言显得尤其重要，也更加复杂。</p><h2 id="2-MySQL并发事务访问相同记录"><a href="#2-MySQL并发事务访问相同记录" class="headerlink" title="2. MySQL并发事务访问相同记录"></a>2. MySQL并发事务访问相同记录</h2><p>并发事务访问相同记录的情况大致可以分为3种：</p><h3 id="2-1-读-读情况"><a href="#2-1-读-读情况" class="headerlink" title="2.1 读-读情况"></a>2.1 读-读情况</h3><p>读-读 情况，即并发事务相继 读取相同的记录 。读取操作本身不会对记录有任何影响，并不会引起什么<br>问题，所以允许这种情况的发生。  </p><p>怎么解决 <strong>脏读 、 不可重复读 、 幻读</strong> 这些问题呢？其实有两种可选的解决方案：  </p><h3 id="2-2-写-写情况"><a href="#2-2-写-写情况" class="headerlink" title="2.2 写-写情况"></a>2.2 写-写情况</h3><p>写-写 情况，即并发事务相继对相同的记录做出改动。</p><p>在这种情况下会发生 <strong>脏写</strong> 的问题，任何一种隔离级别都不允许这种问题的发生。所以在多个未提交事务相继对一条记录做改动时，需要让它们 排队执行 ，这个排队的过程其实是通过 <strong>锁</strong> 来实现的。这个所谓的锁其实是一个 <strong>内存中的结构</strong> ，在事务执行前本来是没有锁的，也就是说一开始是没有 锁结构 和记录进行关联的，如图所示：  </p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220119173930092.png" alt="image-20220119173930092" style="zoom: 50%;"><p>当一个事务想对这条记录做改动时，首先会看看内存中有没有与这条记录关联的 锁结构 ，当没有的时候就会在内存中生成一个 锁结构 与之关联。比如，事务 T1 要对这条记录做改动，就需要生成一个 锁结构与之关联 ：</p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220119173952962.png" alt="image-20220119173952962" style="zoom:50%;"><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220119174002208.png" alt="image-20220119174002208" style="zoom:50%;"><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220119174010815.png" alt="image-20220119174010815" style="zoom:50%;"><p>小结几种说法：</p><ul><li>不加锁</li></ul><p>意思就是不需要在内存中生成对应的 锁结构 ，可以直接执行操作。</p><ul><li>获取锁成功，或者加锁成功</li></ul><p>意思就是在内存中生成了对应的 锁结构 ，而且锁结构的 <code>is_waiting </code>属性为 <code>false</code> ，也就是事务可以继续执行操作。</p><ul><li>获取锁失败，或者加锁失败，或者没有获取到锁</li></ul><p>意思就是在内存中生成了对应的 <strong>锁结构</strong> ，不过锁结构的<code>is_waiting</code>属性为 <strong>true</strong> ，也就是事务需要等待，不可以继续执行操作。  </p><h3 id="2-3-读-写或写-读情况"><a href="#2-3-读-写或写-读情况" class="headerlink" title="2.3 读-写或写-读情况"></a>2.3 读-写或写-读情况</h3><p>读-写 或 写-读 ，即一个事务进行读取操作，另一个进行改动操作。这种情况下可能发生 <strong>脏读 、 不可重复读 、 幻读</strong> 的问题。</p><p>各个数据库厂商对 SQL标准 的支持都可能不一样。比如MySQL在 <strong>REPEATABLE READ</strong> 隔离级别上就已经解决了 <strong>幻读</strong> 问题。  </p><h3 id="2-4-并发问题的解决方案"><a href="#2-4-并发问题的解决方案" class="headerlink" title="2.4 并发问题的解决方案"></a>2.4 并发问题的解决方案</h3><p>怎么解决 脏读 、 不可重复读 、 幻读 这些问题呢？其实有<strong>两种可选的解决方案</strong>：  </p><p><strong>方案一</strong>：读操作利用多版本并发控制（ MVCC ，下章讲解），<strong>写</strong>操作进行 <code>加锁</code> 。  </p><p>所谓的<strong>MVCC</strong>，就是生成一个<strong>ReadView</strong>，通过ReadView找到符合条件的记录版本（历史版本由<strong>undo日志</strong>构建)。查询语句只能<strong>读</strong>到在生成ReadView之前<strong>已提交事务所做的更改</strong>，在生成ReadView之前未提交的事务或者之后才开启的事务所做的更改是看不到的。而<strong>写操作</strong>肯定的是<strong>最新版本的记录</strong>，读记录的历史版本和改动记录的最新版本本身并不冲突，也就是采用MVCC时，<strong>读-写操作并不冲突</strong>。</p><p>普通的SELECT语句在READ COMMITTED和REPEATABLE READ隔离级别下会使用到MVCC读取记录。</p><ul><li>在 <strong>READ COMMITTED</strong> 隔离级别下，一个事务在执行过程中每次执行SELECT操作时都会生成一个ReadView，ReadView的存在本身就保证了 <strong>事务不可以读取到未提交的事务所做的更改</strong> ，也就是避免了脏读现象；</li><li>在 <strong>REPEATABLE READ</strong> 隔离级别下，一个事务在执行过程中只有 <strong>第一次执行SELECT操作</strong> 才会生成一个ReadView，之后的SELECT操作都 <strong>复用</strong> 这个ReadView，这样也就避免了不可重复读和幻读的问题。  </li></ul><p><strong>方案二</strong>：读、写操作都采用 加锁 的方式。  </p><p>如果我们的一些业务场景不允许读取记录的旧版本，而是每次都必须去<strong>读取记录的最新版本</strong>。比如，在银行存款的事务中，你需要先把账户的余额读出来，然后将其加上本次存款的数额，最后再写到数据库中。在将账户余额读取出来后，就不想让别的事务再访问该余额，直到本次存款事务执行完成，其他事务才可以访问账户的余额。这样在读取记录的时候就需要对其进行<strong>加锁</strong>操作，这样也就意味着读操作和写操作也像<strong>写-写操作那样排队执行</strong>。</p><p><strong>脏读</strong>的产生是因为当前事务读取了另一个未提交事务写的一条记录，如果另一个事务在写记录的时候就给这条记录加锁，那么当前事务就无法继续读取该记录了，所以也就不会有脏读问题的产生了。</p><p><strong>不可重复读</strong>的产生是因为当前事务先读取一条记录，另外一个事务对该记录做了改动之后并提交之后，当前事务再次读取时会获得不同的值，如果在当前事务读取记录时就给该记录加锁，那么另一个事务就无法修改该记录，自然也不会发生不可重复读了。</p><p><strong>幻读</strong>问题的产生是因为当前事务读取了一个范围的记录，然后另外的事务向该范围内插入了新记录，当前事务再次读取该范围的记录时发现了新插入的新记录。采用加锁的方式解决幻读问题就有一些麻烦，因为当前事务在第一次读取记录时幻影记录并不存在，所以读取的时候加锁就有点尴尬（因为你并不知道给谁加锁，通过间隙锁和临键锁来解决，详见后面的InnoDB的行锁)。  </p><p><strong>小结对比发现：</strong></p><ul><li>采用 MVCC 方式的话， 读-写 操作彼此并不冲突， 性能更高 。</li><li>采用 加锁 方式的话， 读-写 操作彼此需要 排队执行 ，影响性能。</li></ul><p>一般情况下我们当然愿意采用 <strong>MVCC</strong> 来解决 <strong>读-写</strong> 操作并发执行的问题，但是业务在某些特殊情况下，要求必须采用 <strong>加锁</strong> 的方式执行。下面就讲解下MySQL中不同类别的锁。  </p><h2 id="3-锁的不同角度分类"><a href="#3-锁的不同角度分类" class="headerlink" title="3. 锁的不同角度分类"></a>3. 锁的不同角度分类</h2><p>锁的分类图，如下：  </p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220119173448654.png" alt="image-20220119173448654" style="zoom:40%;"><h3 id="3-1-从数据操作的类型划分：读锁、写锁"><a href="#3-1-从数据操作的类型划分：读锁、写锁" class="headerlink" title="3.1 从数据操作的类型划分：读锁、写锁"></a>3.1 从数据操作的类型划分：读锁、写锁</h3><p>对于数据库中并发事务的读-读情况并不会引起什么问题。对于<strong>写-写、读-写</strong>或<strong>写-读</strong>这些情况可能会引起一些问题，需要使用<strong>MVCC</strong>或者<strong>加锁</strong>的方式来解决它们。在使用加锁的方式解决问题时，由于既要<strong>允许读-读</strong>情况不受影响，又要使<strong>写-写、读-写</strong>或<strong>写-读</strong>情况中的操作<strong>相互阻塞</strong>，所以MySQL实现一个由两种类型的锁组成的锁系统来解决。这两种类型的锁通常被称为<strong>共享锁(Shared Lock，SLock)<strong>和</strong>排他锁(Exclusive Lock，XLock)<strong>，也叫读</strong>锁(readlock)<strong>和</strong>写锁(write lock)</strong> 。</p><ul><li><strong>读锁</strong> ：也称为 <strong>共享锁</strong> 、英文用 <strong>S</strong> 表示。针对同一份数据，多个事务的读操作可以同时进行而<strong>不会互相影响，相互不阻塞</strong>的。</li><li><strong>写锁</strong> ：也称为 <strong>排他锁</strong> 、英文用 <strong>X</strong> 表示。当前写操作没有完成前，它<strong>会阻断其他写锁和读锁</strong>。这样就能确保在给定的时间里，只有一个事务能执行写入，并防止其他用户读取正在写入的同一资源。  </li></ul><p><strong>需要注意的是对于 InnoDB 引擎来说，读锁和写锁可以加在表上，也可以加在行上。</strong>  </p><p>**举例（行级读写锁)**︰如果一个事务T1已经获得了某个行r的读锁，那么此时另外的一个事务T2是可以去获得这个行r的读锁的，因为读取操作并没有改变行r的数据;但是，如果某个事务T3想获得行r的写锁，则它必须等待事务T1、T2释放掉行r上的读锁才行。</p><p>总结:这里的兼容是指对同一张表或记录的锁的兼容性情况。</p><table><thead><tr><th align="center"></th><th align="center">X锁</th><th align="center">S锁</th></tr></thead><tbody><tr><td align="center">X锁</td><td align="center">不兼容</td><td align="center">不兼容</td></tr><tr><td align="center">S锁</td><td align="center">不兼容</td><td align="center"><strong>兼容</strong></td></tr></tbody></table><h4 id="1-锁定读"><a href="#1-锁定读" class="headerlink" title="1.锁定读"></a>1.锁定读</h4><p>在采用<strong>加锁</strong>方式解决<strong>脏读、不可重复读、幻读</strong>这些问题时，读取一条记录时需要获取该记录的S锁，其实是<strong>不严谨的</strong>，有时候需要在读取记录时就获取记录的<strong>X锁</strong>，<strong>来禁止别的事务读写该记录</strong>，为此MysQL提出了两种比较特殊的SELECT语句格式:</p><ul><li>对读取的记录加S锁∶</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">LOCK</span> <span class="token operator">IN</span> <span class="token keyword">SHARE</span> <span class="token keyword">MODE</span><span class="token punctuation">;</span><span class="token comment">#或</span><span class="token keyword">SELECT</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">FOR</span> <span class="token keyword">SHARE</span><span class="token punctuation">;</span><span class="token comment">#(8.0新增语法)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在普通的SELECT语句后边加<code>LOCK IN SHARE MODE</code>，如果当前事务执行了该语句，那么它会为读取到的记录加s锁，这样<strong>允许别的事务继续获取这些记录的S锁(<strong>比方说别的事务也使用<code>SELECT ... LOCK IN SHAREMODE</code>语句来读取这些记录)，但是不能获取这些记录的</strong>X锁</strong>(比如使用<code>SELECT ... FOR UPDATE</code>语句来读取这些记录，或者直接修改这些记录)。如果别的事务想要获取这些记录的<strong>X锁</strong>，那么它们会<strong>阻塞</strong>，<strong>直到当前事务提交之后将这些记录上的S锁释放掉</strong>。</p><ul><li>对读取的记录加X锁︰</li></ul><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">SELECT ... FOR UPDATE; <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在普通的SELECT语句后边加<code>FOR UPDATE</code>，如果当前事务执行了该语句，那么它会为读取到的记录加X锁，这样<strong>既不允许别的事务获取这些记录的S锁(<strong>比方说别的事务使用<code>SELECT ... LOCK IN SHARE MODE</code>语句来读取这些记录)，也不允许获取这些记录的X锁(比如使用<code>SELECT ... FOR UPDATE</code>语句来读取这些记录，或者直接修改这些记录)。如果别的事务想要获取这些记录的S锁或者X锁，那么它们会</strong>阻塞</strong>，<strong>直到当前事务提交之后将这些记录上的X锁释放掉</strong>。</p><p><strong>MySQL 8.0 新特性</strong></p><p>在5.7及之前的版本，<code>SELECT ... FOR UPDATE</code>，如果获取不到锁，会一直等待，直到<code>innodb_lock_wait_timeout</code>超时。在8.0版本中，<code>SELECT ... FOR UPDATE，SELECT...FOR SHARE </code>添加<code>NOWAIT、SKIP LOCKED</code>语法，跳过锁等待，或者跳过锁定。</p><ul><li>通过添加<code>NOWAIT、SKIP LOCKED</code>语法，能够立即返回。如果查询的行已经加锁:</li><li>那么<code>NOWAIT</code>会立即报错返回</li><li>而<code>SKIP LOCKED</code>也会立即返回，只是返回的结果中不包含被锁定的行。</li></ul><h4 id="2-写操作"><a href="#2-写操作" class="headerlink" title="2.写操作"></a>2.写操作</h4><p>平常所用到的写操作无非是 DELETE、UPDATE、INSERT这三种:</p><p><strong>DELETE:</strong></p><p>对一条记录做DELETE操作的过程其实是先在B+树中定位到这条记录的位置，然后获取这条记录的X锁，再执行delete mark操作。我们也可以把这个定位待删除记录在B+树中位置的过程看成是一个获取X锁的锁定读。</p><p><strong>UPDATE</strong>:     在对一条记录做UPDATE操作时分为三种情况:</p><ul><li>情况1:未修改该记录的键值，并且被更新的列占用的存储空间在修改前后未发生变化。则先在B+树中定位到这条记录的位置，然后再获取一下记录的X锁，最后在原记录的位置进行修改操作。我们也可以把这个定位待修改记录在B+树中位置的过程看成是一个获取X锁的锁定读。</li><li>情况2∶未修改该记录的键值，并且至少有一个被更新的列占用的存储空间在修改前后发生变化。则先在B+树中定位到这条记录的位置，然后获取一下记录的X锁，将该记录彻底删除掉(就是把记录彻底移入垃圾链表)，最后再插入一条新记录。这个定位待修改记录在B+树中位置的过程看成是一个获取×锁的锁定读，新插入的记录由INSERT 操作提供的隐式锁进行保护。|</li><li>情况3:修改了该记录的键值，则相当于在原记录上做DELETE操作之后再来一次INSERT操作，加锁操作就需要按照DELETE 和INSERT的规则进行了。</li></ul><p><strong>INSERT :</strong></p><p>一般情况下，新插入一条记录的操作并不加锁，通过一种称之为隐式锁的结构来保护这条新插入的记录在本事务提交前不被别的事务访问。</p><h3 id="3-2-从数据操作的粒度划分：表级锁、页级锁、行锁"><a href="#3-2-从数据操作的粒度划分：表级锁、页级锁、行锁" class="headerlink" title="3.2 从数据操作的粒度划分：表级锁、页级锁、行锁"></a>3.2 从数据操作的粒度划分：表级锁、页级锁、行锁</h3><p>为了尽可能提高数据库的并发度，每次锁定的数据范围越小越好，理论上每次只锁定当前操作的数据的方案会得到最大的并发度，但是管理锁是很耗资源的事情（涉及获取、检查、释放锁等动作)。因此数据库系统需要在<strong>高并发响应</strong>和<strong>系统性能</strong>两方面进行平衡，这样就产生了“**锁粒度（Lock granularity)**”的概念。</p><p>对一条记录加锁影响的也只是这条记录而已，我们就说这个锁的粒度比较细;其实一个事务也可以在<strong>表级别</strong>进行加锁，自然就被称之为<strong>表级锁</strong>或者<strong>表锁</strong>，对一个表加锁影响整个表中的记录，我们就说这个锁的粒度比较粗。锁的粒度主要分为<strong>表级锁、页级锁</strong>和<strong>行锁</strong>。</p><h4 id="1-表锁（Table-Lock）"><a href="#1-表锁（Table-Lock）" class="headerlink" title="1. 表锁（Table Lock）"></a>1. 表锁（Table Lock）</h4><p>该锁会<strong>锁定整张表</strong>，它是MySQL中最基本的锁策略，并<strong>不依赖于存储引擎</strong>(不管你是MySQL的什么存储引擎，对于表锁的策略都是一样的)，并且<strong>表锁是开销最小的策略</strong>（因为粒度比较大)。由于表级锁一次会将整个表锁定，所以可以很好的<strong>避免死锁问题</strong>。当然，锁的粒度大所带来最大的负面影响就是出现锁资源争用的概率也会最高，导致并发率大打折扣。</p><h5 id="①-表级别的S锁、X锁"><a href="#①-表级别的S锁、X锁" class="headerlink" title="① 表级别的S锁、X锁"></a>① 表级别的S锁、X锁</h5><p>在对某个表执行<code>SELECT、INSERT、DELETE、UPDATE</code>语句时，InnoDB存储引擎是不会为这个表添加表级别的 S锁 或者 X锁 的。在对某个表执行一些诸如<code>ALTER TABLE 、 DROP TABLE</code>这类的 <strong>DDL 语句时</strong>，<strong>其他事务对这个表并发执行诸如<code>SELECT、INSERT、DELETE、UPDATE</code>的语句会发生阻塞</strong>。同理，某个事务中对某个表执行<code>SELECT、INSERT、DELETE、UPDATE</code>语句时，在其他会话中对这个表执行 DDL 语句也会发生阻塞。这个过程其实是通过在 <strong>server层</strong> 使用一种称之为 <strong>元数据锁</strong> （英文名： Metadata Locks ，简称 <strong>MDL</strong> ）结构来实现的。</p><p>一般情况下，不会使用InnoDB存储引擎提供的表级别的 S锁 和 X锁 。只会在一些特殊情况下，比方说 崩溃恢复 过程中用到。比如，在系统变量<code> autocommit=0，innodb_table_locks = 1</code> 时， 手动 获取InnoDB存储引擎提供的表t 的 S锁 或者 X锁 可以这么写：</p><ul><li><strong>LOCK TABLES t READ</strong> ：InnoDB存储引擎会对表 t 加表级别的 S锁 。</li><li><strong>LOCK TABLES t WRITE</strong> ：InnoDB存储引擎会对表 t 加表级别的 X锁 。</li></ul><p>不过尽量避免在使用InnoDB存储引擎的表上使用 LOCK TABLES  这样的手动锁表语句，它们并不会提供什么额外的保护，只是会降低并发能力而已。<strong>InnoDB的厉害之处还是实现了更细粒度的行锁</strong> ，关于InnoDB表级别的 S锁 和 X锁 大家了解一下就可以了。</p><p>MySQL的表级锁有两种模式：（以MyISAM表进行操作的演示）  </p><ul><li>表共享读锁（Table Read Lock）</li><li>表独占写锁（Table Write Lock）  </li></ul><table><thead><tr><th>锁类型</th><th>自己可读</th><th>自己可写</th><th>自己可操作其他表</th><th>他人可读</th><th>他人可写</th></tr></thead><tbody><tr><td>读锁</td><td>是</td><td>否</td><td>否</td><td>是</td><td>否，等</td></tr><tr><td>写锁</td><td>是</td><td>是</td><td>否</td><td>否，等</td><td>否，等</td></tr></tbody></table><h5 id="②-意向锁-（intention-lock）"><a href="#②-意向锁-（intention-lock）" class="headerlink" title="② 意向锁 （intention lock）"></a>② 意向锁 （intention lock）</h5><p>InnoDB 支持 <strong>多粒度锁（multiple granularity locking）</strong> ，它允许 <strong>行级锁</strong> 与 <strong>表级锁</strong> 共存，而<strong>意向锁</strong>就是其中的一种 <strong>表锁</strong> 。  </p><p>意向锁分为两种：  </p><p>1、意向锁的存在是<strong>为了协调行锁和表锁的关系</strong>，支持多粒度（表锁与行锁)的锁并存。</p><p>2、意向锁是一种<strong>不与行级锁冲突表级锁</strong>，这一点非常重要。</p><p>3、表明“某个事务正在某些行持有了锁或该事务准备去持有锁”</p><p><strong>意向共享锁（intention shared lock, IS）</strong>：事务有意向对表中的某些行加共享锁（S锁）  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 事务要获取某些行的 S 锁，必须先获得表的 IS 锁。</span><span class="token keyword">SELECT</span> <span class="token keyword">column</span> <span class="token keyword">FROM</span> <span class="token keyword">table</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">LOCK</span> <span class="token operator">IN</span> <span class="token keyword">SHARE</span> <span class="token keyword">MODE</span><span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>意向排他锁（intention exclusive lock, IX）</strong>：事务有意向对表中的某些行加排他锁（X锁）  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 事务要获取某些行的 X 锁，必须先获得表的 IX 锁。</span><span class="token keyword">SELECT</span> <span class="token keyword">column</span> <span class="token keyword">FROM</span> <span class="token keyword">table</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">FOR</span> <span class="token keyword">UPDATE</span><span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>即：意向锁是由存储引擎 <strong>自己维护的</strong> ，用户无法手动操作意向锁，在为数据行加共享 / 排他锁之前，InooDB 会先获取该数据行 <strong>所在数据表的对应意向锁</strong> 。  </p><p><strong>1.意向锁要解决的问题</strong></p><p>现在有两个事务，分别是T1和T2，其中T2试图在该表级别上应用共享或排它锁，如果没有意向锁存在，那么T2就需要去检查各个页或行是否存在锁;如果存在意向锁，那么此时就会受到由T1控制的<strong>表级别意向锁的阻塞</strong>。T2在锁定该表前不必检查各个页或行锁，而只需检查表上的意向锁。简单来说就是<strong>给更大一级别的空间示意里面是否已经上过锁</strong>。</p><p>在数据表的场景中，<strong>如果我们给某一行数据加上了排它锁，数据库会自动给更大一级的空间，比如数据页或数据表加上意向锁，告诉其他人这个数据页或数据表已经有人上过排它锁了</strong>，这样当其他人想要获取数据表排它锁的时候，只需要了解是否有人已经获取了这个数据表的意向排他锁即可。</p><ul><li>如果事务想要获得数据表中某些记录的共享锁，就需要在数据表上<strong>添加意向共享锁。</strong></li><li>如果事务想要获得数据表中某些记录的排他锁，就需要在数据表上<strong>添加意向排他锁</strong>。</li></ul><p>这时，意向锁会告诉其他事务已经有人锁定了表中的某些记录。</p><p>举例:创建表teacher，插入6条数据，事务的隔离级别默认为Repeatable-Read，如下所示。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token string">'teacher`('</span>id<span class="token punctuation">`</span> <span class="token keyword">int</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span><span class="token punctuation">`</span>name <span class="token punctuation">`</span> <span class="token keyword">varchar</span> <span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span><span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span><span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span> <span class="token punctuation">`</span>id <span class="token punctuation">`</span><span class="token punctuation">)</span>）<span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8mb4 <span class="token keyword">COLLATE</span><span class="token operator">=</span>utf8mb4_0900_ai_ci<span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token string">'teacher` VALUES( '</span><span class="token number">1</span> <span class="token string">', '</span>zhangsan <span class="token string">' ),( '</span><span class="token number">2</span><span class="token string">', '</span>lisi <span class="token string">'),( '</span><span class="token number">3</span> <span class="token string">' , '</span>wangwu <span class="token string">' ) ，( '</span><span class="token number">4</span><span class="token string">', '</span>zhaoliu <span class="token string">')，( '</span><span class="token number">5</span><span class="token string">', '</span>songhongkang <span class="token string">' ),( '</span><span class="token number">6</span><span class="token string">', '</span>leifengyang'<span class="token punctuation">)</span><span class="token punctuation">;</span>mysql<span class="token operator">></span> <span class="token keyword">SELECT</span> @<span class="token variable">@transaction_isolation</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">----------------------------+</span><span class="token operator">|</span>  @<span class="token variable">@transaction_isolationl</span>  <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">----------------------------+</span><span class="token operator">|</span>  REAPEATABKE<span class="token operator">-</span><span class="token keyword">READ</span>          <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">----------------------------+</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>假设事务A获取了某一行的排他锁，并未提交，语句如下所示。</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">begin ;SELECT * FROM teacher WHERE id &#x3D; 6 FOR UPDATE;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>事务B想要获取teacher 表的表读锁，语句如下。</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">begin;LOCK TABLES teacher READ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>因为共享锁与排他锁互斥，所以事务B在试图对teacher表加共享锁的时候，必须保证两个条件。</p><ul><li>当前没有其他事务持有teacher表的排他锁</li><li>当前没有其他事务持有teacher表中任意一行的排他锁。</li></ul><p>为了检测是否满足第二个条件，事务B必须在确保teacher表不存在任何排他锁的前提下，去检测表中的每一行是否存在排他锁。很明显这是一个效率很差的做法，但是有了意向锁之后，情况就不一样了。</p><p>意向锁是怎么解决这个问题的呢?首先，我们需要知道意向锁之间的兼容互斥性，如下所示。</p><table><thead><tr><th align="center"></th><th align="center">意向共享锁（IS）</th><th align="center">意向排他锁（IX）</th></tr></thead><tbody><tr><td align="center">意向共享锁（IS）</td><td align="center">兼容</td><td align="center">兼容</td></tr><tr><td align="center">意向排他锁（IX）</td><td align="center">兼容</td><td align="center">兼容</td></tr></tbody></table><p>即<strong>意向锁之间是互相兼容的</strong>，虽然意向锁和自家兄弟互相兼容，但是它<strong>会与普通的排他/共享锁互斥</strong>。</p><table><thead><tr><th align="center"></th><th align="center">意向共享锁（IS）</th><th align="center">意向排他锁（IX）</th></tr></thead><tbody><tr><td align="center">共享锁（S）</td><td align="center">兼容</td><td align="center">互斥</td></tr><tr><td align="center">排他锁（X）</td><td align="center">互斥</td><td align="center">互斥</td></tr></tbody></table><p>注意这里的排他/共享锁指的都是<strong>表锁</strong>，意向锁不会与行级的共享/排他锁互斥。回到刚才teacher表的例子。</p><p>事务A获取了某一行的排他锁，并未提交:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">BEGIN</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> teacher <span class="token keyword">WHERE</span> id <span class="token operator">=</span> <span class="token number">6</span> <span class="token keyword">FOR</span> <span class="token keyword">UPDATE</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>此时teacher表存在两把锁: teacher表上的<strong>意向排他锁</strong>与id为6的<strong>数据行上的排他锁</strong>。事务B想要获取 teacher表的共享锁。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">BEGIN</span><span class="token punctuation">;</span><span class="token keyword">LOCK</span> <span class="token keyword">TABLES</span> teacher <span class="token keyword">READ</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>此时事务B检测事务A持有teacher表的意向排他锁，就可以得知事务A必然持有该表中某些数据行的排他锁，那么事务B对teacher表的加锁请求就会被**排斥（阻塞)**，而无需去检测表中的每一行数据是否存在排他锁。</p><p><strong>意向锁的并发性</strong></p><p>意向锁不会与行级的共享 / 排他锁互斥！正因为如此，<strong>意向锁并不会影响到多个事务对不同数据行加排他锁时的并发性。</strong>（不然我们直接用普通的表锁就行了）</p><p>我们扩展一下上面 teacher表的例子来概括一下意向锁的作用（一条数据从被锁定到被释放的过程中，可能存在多种不同锁，但是这里我们只着重表现意向锁）。</p><p>事务A先获取了某一行的排他锁，并<strong>未提交:</strong></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">BEGIN</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> teacher <span class="token keyword">WHERE</span> id <span class="token operator">=</span> <span class="token number">6</span> <span class="token keyword">FOR</span> <span class="token keyword">UPDATE</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>事务A获取了teacher表上的意向排他锁，事务A获取了id为6的数据行上的排他锁。之后事务B想要获取teacher表的共享锁。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">BEGIN</span><span class="token punctuation">;</span><span class="token keyword">LOCK</span> <span class="token keyword">TABLES</span> teacher <span class="token keyword">READ</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>事务B检测到事务A持有teacher表的意向排他锁。事务B对teacher表的加锁请求被阻塞(排斥)。最后事务C也想获取 teacher表中某一行的排他锁。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">BEGIN</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> teacher <span class="token keyword">WHERE</span> id <span class="token operator">=</span> <span class="token number">5</span> <span class="token keyword">FOR</span> <span class="token keyword">UPDATE</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>事务c申请teacher表的意向排他锁。事务c检测到事务A持有teacher表的意向排他锁。因为<strong>意向锁之间并不互斥</strong>，所以事务c获取到了teacher表的意向排他锁。因为id为<strong>5</strong>的数据行上不存在任何排他锁最终事务C成功获取到了该数据行上的排他锁。</p><p>从上面的案例可以得到如下结论：</p><ol><li>InnoDB 支持 <strong>多粒度锁</strong> ，特定场景下，<strong>行级锁可以与表级锁共存</strong>。</li><li>意向锁之间互不排斥，但除了 IS 与 S 兼容外， <strong>意向锁会与 共享锁 / 排他锁 互斥</strong> 。</li><li>IX，IS是表级锁，不会和行级的X，S锁发生冲突。只会和表级的X，S发生冲突。</li><li>意向锁在保证并发性的前提下，实现了 <strong>行锁和表锁共存</strong> 且 <strong>满足事务隔离性</strong> 的要求。  </li></ol><h5 id="③-自增锁（AUTO-INC锁）"><a href="#③-自增锁（AUTO-INC锁）" class="headerlink" title="③ 自增锁（AUTO-INC锁）"></a>③ 自增锁（AUTO-INC锁）</h5><p>在使用MySQL过程中，我们可以为表的某个列添加 AUTO_INCREMENT 属性。举例：  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span>teacher<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span> <span class="token keyword">int</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span><span class="token punctuation">`</span>name<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span><span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8mb4 <span class="token keyword">COLLATE</span><span class="token operator">=</span>utf8mb4_0900_ai_ci<span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于这个表的id字段声明了AUTO_INCREMENT，意味着在书写插入语句时不需要为其赋值，SQL语句修改<br>如下所示。  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token punctuation">`</span>teacher<span class="token punctuation">`</span> <span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'zhangsan'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'lisi'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上边的插入语句并没有为id列显式赋值，所以系统会自动为它赋上递增的值。</p><p>现在我们看到的上面插入数据只是一种简单的插入模式，所有插入数据的方式总共分为三类，分别是<code>“ Simple inserts ”，“ Bulk inserts ”和“ Mixed-mode inserts ”</code>。  </p><ol><li><strong>“Simple inserts” （简单插入）</strong></li></ol><p>可以 预先确定要插入的行数 （当语句被初始处理时）的语句。包括没有嵌套子查询的单行和多行<br>INSERT…VALUES() 和 REPLACE 语句。比如我们上面举的例子就属于该类插入，已经确定要插入的行<br>数。</p><ol start="2"><li><strong>“Bulk inserts” （批量插入）</strong></li></ol><p>事先不知道要插入的行数 （和所需自动递增值的数量）的语句。比如 INSERT … SELECT ， REPLACE<br>… SELECT 和 LOAD DATA 语句，但不包括纯INSERT。 InnoDB在每处理一行，为AUTO_INCREMENT列<br>分配一个新值。</p><ol start="3"><li><strong>“Mixed-mode inserts” （混合模式插入）</strong></li></ol><p>这些是“Simple inserts”语句但是指定部分新行的自动递增值。例如 <code>INSERT INTO teacher (id,name) VALUES (1,&#39;a&#39;), (NULL,&#39;b&#39;), (5,&#39;c&#39;), (NULL,&#39;d&#39;); </code>只是指定了部分id的值。另一种类型的“混合模式插入”是 <code>INSERT ... ON DUPLICATE KEY UPDATE </code>。  </p><p>innodb_autoinc_lock_mode有三种取值，分别对应与不同锁定模式：  </p><p>（1）innodb_autoinc_lock_mode = 0(“传统”锁定模式)  </p><p>在此锁定模式下，所有类型的insert语句都会获得一个特殊的表级AUTO-INC锁，用于插入具有AUTO_INCREMENT列的表。这种模式其实就如我们上面的例子，即每当执行insert的时候，都会得到一个表级锁(AUTO-INC锁)，使得语句中生成的auto_increment为顺序，且在binlog中重放的时候，可以保证master与slave中数据的auto_increment是相同的。因为是表级锁，当在同一时间多个事务中执行insert的<br>时候，对于AUTO-INC锁的争夺会 <strong>限制并发</strong> 能力 。</p><p>（2）innodb_autoinc_lock_mode = 1(“连续”锁定模式)  </p><p>在 <strong>MySQL 8.0 之前</strong>，<strong>连续锁定模式是 默认 的</strong>。</p><p>在这个模式下，“bulk inserts”仍然使用AUTO-INC表级锁，并保持到语句结束。这适用于所有<code>INSERT ...SELECT，REPLACE ... SELECT和LOAD DATA</code>语句。同一时刻只有一个语句可以持有AUTO-INC锁。</p><p>对于“Simple inserts”（要插入的行数事先已知），则通过在 mutex（轻量锁） 的控制下获得所需数量的自动递增值来避免表级AUTO-INC锁， 它只在分配过程的持续时间内保持，而不是直到语句完成。不使用表级AUTO-INC锁，除非AUTO-INC锁由另一个事务保持。如果另一个事务保持AUTO-INC锁，则“Simple inserts”等待AUTO-INC锁，如同它是一个“bulk inserts”。  </p><p>（3）innodb_autoinc_lock_mode = 2(“交错”锁定模式)  </p><p>从 <strong>MySQL 8.0</strong> 开始，<strong>交错锁模式</strong>是 <strong>默认</strong> 设置。</p><p>在此锁定模式下，自动递增值 保证 在所有并发执行的所有类型的insert语句中是 唯一 且 单调递增 的。但是，由于多个语句可以同时生成数字（即，跨语句交叉编号），<strong>为任何给定语句插入的行生成的值可能不是连续的</strong>。  </p><h5 id="④-元数据锁（MDL锁）"><a href="#④-元数据锁（MDL锁）" class="headerlink" title="④ 元数据锁（MDL锁）"></a>④ 元数据锁（MDL锁）</h5><p>MySQL5.5引入了meta data lock，简称MDL锁，属于表锁范畴。MDL 的作用是，保证读写的正确性。比如，如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个 <strong>表结构做变更</strong> ，增加了一列，那么查询线程拿到的结果跟表结构对不上，肯定是不行的。</p><p>因此，<strong>当对一个表做增删改查操作的时候，加 MDL读锁；当要对表做结构变更操作的时候，加 MDL 写锁</strong>。  </p><p>select name from world where GDP &gt;= ALL(select GDP from world where continent =’Europe’ and population &gt;0);</p>]]></content>
      
      
      <categories>
          
          <category> database </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>索引的创建与设计原则</title>
      <link href="/2022/01/18/%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
      <url>/2022/01/18/%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</url>
      
        <content type="html"><![CDATA[<h1 id="索引的创建与设计原则"><a href="#索引的创建与设计原则" class="headerlink" title="索引的创建与设计原则"></a>索引的创建与设计原则</h1><h2 id="1-索引的声明与使用"><a href="#1-索引的声明与使用" class="headerlink" title="1.索引的声明与使用"></a>1.索引的声明与使用</h2><h3 id="1-1-索引的分类"><a href="#1-1-索引的分类" class="headerlink" title="1.1 索引的分类"></a>1.1 索引的分类</h3><p>MySQL的索引包括普通索引、唯一性索引、全文索引、单列索引、多列索引和空间索引等。</p><ul><li>从 <strong>功能逻辑</strong> 上说，索引主要有 4 种，分别是普通索引、唯一索引、主键索引、全文索引。</li><li>按照 <strong>物理实现方式</strong> ，索引可以分为 2 种：聚簇索引和非聚簇索引。</li><li>按照 作用字段个数 进行划分，分成单列索引和联合索引。  </li></ul><p>1.普通索引</p><p>在创建普通索引时，不附加任何限制条件，只是用于提高查询效率。这类索引可以创建在<strong>任何数据类型</strong>中，其值是否唯一和非空，要由字段本身的完整性约束条件决定。建立索引以后，可以通过索引进行查询。例如，在表student的字段name上建立一个普通索引，查询记录时就可以根据该索引进行查询。</p><p>2.唯一性索引</p><p>使用<strong>UNIQUE参数</strong>可以设置索引为唯一性索引，在创建唯一性索引时，限制该索引的值必须是唯一的，但允许有空值。在一张数据表里<strong>可以有多个唯一索引</strong>。</p><p>例如，在表student的字段email中创建唯一性索引，那么字段email的值就必须是唯一的。通过唯一性索引，可以更快速地确定某条记录。</p><p>3.主键索引</p><p>主键索引就是一种<strong>特殊的唯一性索引</strong>，在唯一索引的基础上增加了不为空的约束，也就是NOT NULL+UNIQUE，<strong>一张表里最多只有一个主键索引</strong>。</p><p><strong>Why?</strong> 这是由主键索引的物理实现方式决定的，因为数据存储在文件中只能按照一种顺序进行存储。</p><p>4.单列索引</p><p>在表中的单个字段上创建索引。单列索引只根据该字段进行索引。单列索引可以是普通索引，也可以是唯一性索引，还可以是全文索引。只要保证该索引只对应一个字段即可。一个表可以有多个单列索引。</p><p>5.多列(组合、联合)索引</p><p>多列索引是在表的多个字段组合上创建一个索引。该索引指向创建时对应的多个字段，可以通过这几个子段进仃查询，但是只有查询条件中使用了这些字段中的第一个字段时才会被使用。例如，在表中的字段id、name和gender上建立一个多列索引idx_id_name_gender，只有在查询条件中使用了字段id时该索引才会被使用。使用组合索引时遵循最左前缀集合。</p><p>6.全文索引</p><p>全文索引(也称全文检索)是目前<strong>搜索引擎</strong>使用的一种关键技术。它能够利用【<strong>分词技术</strong>】等多种算法智能分析出文本文字中关键词的频率和重要性，然后按照一定的算法规则智能地筛选出我们想要的搜索结果。全文索引非常适合大型数据集，对于小的数据集，它的用处比较小。</p><p>使用参数<strong>FULLTEXT</strong>可以设置索引为全文索引。在定义索引的列上支持值的全文查找，允许在这些索引例中插入重复值和空值。全文索引只能创建在<strong>CHAR 、VARCHAR</strong>或TEXT类型及其系列类型的字段上，查<strong>询数据重较大的字符串类型的字段时，使用全文索引可以提高查询速度</strong>。例如，表student的字段information是I庆尖丝，该字段包含了很多文字信息。在字段information上建立全文索引后，可以提高查询字段information的速度。</p><p>全文索引典型的有两种类型:自然语言的全文索引和布尔全文索引。</p><ul><li>自然语言搜索引擎将计算每一个文档对象和查询的相关度。这里，相关度是基于匹配的关键词的个数，以及关键词在文档中出现的次数。<strong>在整个索引中出现次数越少的词语，匹配时的相关度就越高</strong>。相反，非常常见的单词将不会被搜索，如果一个词语的在超过50%的记录中都出现了，那么自然语言的搜索将不会搜索这类词语。</li></ul><p>MysQL数据库从3.23.23版开始支持全文索引，但MySQL5.6.4以前只有<strong>Myisam</strong>支持，5.6.4版本以后<strong>innodb</strong>才支持，但是官方版本不支持<strong>中文分词</strong>，需要第三方分词插件。在5.7.6版本，MySQL内置了ngram全文解析器，用来支持亚洲语种的分词。测试或使用全文索引时，要先看一下自己的MysQL版本、存储引擎和数据类型是否支持全文索引。</p><p>随着大数据时代的到来，关系型数据库应对全文索引的需求已力不从心，逐渐被solr、<strong>ElasticSearch</strong>等专门的搜索引擎所替代。</p><p>7.补充:空间索引</p><p>使用<strong>参数SPATIAL</strong>可以设置索引为<strong>空间索引</strong>。空间索引只能建立在空间数据类型上，这样可以提高系统获取空间数据的效率。MySQL中的空间数据类型包括<strong>GEOMETRY、POINT、LINESTRING和POLYGON</strong>等。目前只有MyISAM存储引擎支持空间检索，而且索引的字段不能为空值。对于初学者来说，这类索引很少会用到</p><p><strong>小结：</strong>不同的存储引擎支持的索引类型也不一样 InnoDB ：支持 B-tree、Full-text 等索引，不支持 Hash索引； MyISAM ： 支持 B-tree、Full-text 等索引，不支持 Hash 索引； Memory ：支持 B-tree、Hash 等索引，不支持 Full-text 索引； NDB ：支持 Hash 索引，不支持 B-tree、Full-text 等索引； Archive ：不支持 B-tree、Hash、Full-text 等索引；  </p><h3 id="1-2-创建索引"><a href="#1-2-创建索引" class="headerlink" title="1.2 创建索引"></a>1.2 创建索引</h3><p>MySQL支持多种方法在单个或多个列上创建索引:在创建表的定义语句<strong>CREATE TABLE</strong>中指定索引列，使用<strong>ALTER TABLE</strong>语句在存在的表上创建索引，或者使用<strong>CREATE INDEX</strong>语句在已存在的表上添加索引。</p><h4 id="1-创建表的时候创建索引"><a href="#1-创建表的时候创建索引" class="headerlink" title="1.创建表的时候创建索引"></a>1.创建表的时候创建索引</h4><p>使用CREATE TABLE创建表时，除了可以定义列的数据类型外，还可以定义主键约束、外键约束或者唯一性约束,而不论创建哪种约束，<strong>在定义约束的同时相当于在指定列上创建了一个索引</strong>。</p><p>举例：  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">#隐式的方式创建索引 在主键约束、外键约束或者唯一性约束的字段上，会自动的添加相关的索引</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> dept<span class="token punctuation">(</span>dept_id <span class="token keyword">INT</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span>dept_name <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> emp<span class="token punctuation">(</span>emp_id <span class="token keyword">INT</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span>emp_name <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token keyword">UNIQUE</span><span class="token punctuation">,</span>dept_id <span class="token keyword">INT</span><span class="token punctuation">,</span><span class="token keyword">CONSTRAINT</span> emp_dept_id_fk <span class="token keyword">FOREIGN</span> <span class="token keyword">KEY</span><span class="token punctuation">(</span>dept_id<span class="token punctuation">)</span> <span class="token keyword">REFERENCES</span> dept<span class="token punctuation">(</span>dept_id<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 但是，如果显式创建表时创建索引的话，基本语法格式如下：  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> table_name <span class="token punctuation">[</span>col_name data_type<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token keyword">UNIQUE</span> <span class="token operator">|</span> FULLTEXT <span class="token operator">|</span> SPATIAL<span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token keyword">INDEX</span> <span class="token operator">|</span> <span class="token keyword">KEY</span><span class="token punctuation">]</span> <span class="token punctuation">[</span>index_name<span class="token punctuation">]</span> <span class="token punctuation">(</span>col_name <span class="token punctuation">[</span>length<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token keyword">ASC</span> <span class="token operator">|</span><span class="token keyword">DESC</span><span class="token punctuation">]</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><strong>UNIQUE 、 FULLTEXT</strong> 和 <strong>SPATIAL</strong> 为可选参数，分别表示唯一索引、全文索引和空间索引；</li><li><strong>INDEX</strong> 与 <strong>KEY</strong> 为同义词，两者的作用相同，用来指定创建索引；</li><li><strong>index_name</strong> 指定索引的名称，为可选参数，如果不指定，那么MySQL默认<strong>col_name为索引名</strong>；</li><li><strong>col_name</strong> 为需要创建索引的字段列，该列必须从数据表中定义的多个列中选择；</li><li><strong>length</strong> 为可选参数，表示索引的长度，只有字符串类型的字段才能指定索引长度；</li><li><strong>ASC 或 DESC</strong> 指定升序或者降序的索引值存储。  </li></ul><p><strong>通过命令查看索引：</strong></p><p>方式一：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SHOW</span> <span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> BOOK<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>方式二：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SHOW</span> <span class="token keyword">INDEX</span> <span class="token keyword">FROM</span> BOOK<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>1.创建普通索引</strong></p><p>在book表中的year_publication字段上建立普通索引，SQL语句如下：  </p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">CREATE TABLE book(book_id INT ,book_name VARCHAR(100),authors VARCHAR(100),info VARCHAR(100) ,comment VARCHAR(100),year_publication YEAR,INDEX(year_publication));  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用EXPLAIN语句查看索引是否正在使用:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">EXPLAIN</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> book <span class="token keyword">WHERE</span> year_publication<span class="token operator">=</span> <span class="token string">'1990'</span> <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>EXPLAIN语句输出结果的各个行我们在下一章讲解。这里主要关注两个字段:</p><ol><li> possible_keys行给出了MySQL在搜索数据记录时可选用的各个索引。</li><li> key行是MySQL实际选用的索引。</li></ol><p>可以看到possible_keys和key的值都为year_publication，查询时使用了索引。</p><p><strong>2.创建唯一索引</strong></p><p>举例：  </p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">CREATE TABLE test1(id INT NOT NULL,name varchar(30) NOT NULL,UNIQUE INDEX uk_idx_id(id));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该语句执行完毕之后，使用SHOW CREATE TABLE查看表结构  :</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">SHOW INDEX FROM test1;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>3.主键索引</strong></p><p>设定为主键后数据库会自动建立索引，innodb为聚簇索引，语法：</p><ul><li><p>随表一起建索引：  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">#隐式的方式创建索引</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> student <span class="token punctuation">(</span>id <span class="token keyword">INT</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token keyword">UNSIGNED</span> <span class="token keyword">AUTO_INCREMENT</span> <span class="token punctuation">,</span>student_no <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">,</span>student_name <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>删除主键索引：  </p></li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> student<span class="token keyword">drop</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>修改主键索引：必须先删除掉(drop)原索引，再新建(add)索引  </p><p><strong>4.创建单列索引</strong>  </p><p>举例：  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> test2<span class="token punctuation">(</span>id <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>name <span class="token keyword">CHAR</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span><span class="token keyword">INDEX</span> single_idx_name<span class="token punctuation">(</span>name<span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该语句执行完毕之后，使用SHOW CREATE TABLE查看表结构：  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SHOW</span> <span class="token keyword">INDEX</span> <span class="token keyword">FROM</span> test2 <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>5.创建组合索引</strong>  </p><p>举例：创建表test3，在表中的id、name和age字段上建立组合索引，SQL语句如下：  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> test3<span class="token punctuation">(</span>id <span class="token keyword">INT</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>name <span class="token keyword">CHAR</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>age <span class="token keyword">INT</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>info <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">INDEX</span> multi_idx<span class="token punctuation">(</span>id<span class="token punctuation">,</span>name<span class="token punctuation">,</span>age<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该语句执行完毕之后，使用SHOW INDEX 查看：  </p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">SHOW INDEX FROM test3 ;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>由结果可以看到，id、name和age字段上已经成功建立了一个名为multi_idx的组合索引。</p><p>组合索引可起几个索引的作用，但是使用时并不是随便查询哪个字段都可以使用索引，而是遵从“最左前缀”。例如，索引可以搜索的字段组合为: (id, name, age) . (id, name)或者id。而(age)或者(name,age)组合不能使用索引查询。</p><p>在test3表中，查询id和name字段，使用EXPLAIN语句查看索引的使用情况:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">EXPLAIN</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> test3 <span class="token keyword">WHERE</span> id<span class="token operator">=</span><span class="token number">1</span> <span class="token operator">AND</span> name<span class="token operator">=</span> <span class="token string">'songhongkang'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以看到，查询id和name字段时，使用了名称为Multildx的索引</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">EXPLAIN</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> test3 <span class="token keyword">WHERE</span> name<span class="token operator">=</span> <span class="token string">'songhongkang'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果查询(name,age)组合或者单独查询name和age字段，会发现结果中possible_keys和key值为NULL（<strong>索引失效</strong>），并没有使用在t3表中创建的索引进行查询。(具体知识点详见 <strong>索引优化与查询优化笔记</strong>)</p><p><strong>6.创建全文索引</strong>  </p><p>FULLTEXT全文索引可以用于全文搜索，并且只为<strong>CHAR、VARCHAR和TEXT</strong>列创建索引。索引总是对整个列进行，不支持局部（前缀)索引。</p><p>举例1：创建表test4，在表中的info字段上建立全文索引，SQL语句如下：  </p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">CREATE TABLE test4(id INT NOT NULL,name CHAR(30) NOT NULL,age INT NOT NULL,info VARCHAR(255),FULLTEXT INDEX futxt_idx_info(info)) ENGINE&#x3D;MyISAM;  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在MySQL5.7及之后版本中可以不指定最后的ENGINE了，因为在此版本中InnoDB支持全文索引。  </p><p>举例2：  </p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">CREATE TABLE articles (id INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,title VARCHAR (200),body TEXT,FULLTEXT index (title, body)) ENGINE &#x3D; INNODB ;  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>创建了一个给title和body字段添加全文索引的表.</p><p>举例3：  </p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">CREATE TABLE &#96;papers&#96; (&#96;id&#96; int(10) unsigned NOT NULL AUTO_INCREMENT,&#96;title&#96; varchar(200) DEFAULT NULL,&#96;content&#96; text,PRIMARY KEY (&#96;id&#96;),FULLTEXT KEY &#96;title&#96; (&#96;title&#96;,&#96;content&#96;)) ENGINE&#x3D;MyISAM DEFAULT CHARSET&#x3D;utf8;  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">SELECT * FROM papers WHERE content LIKE ‘%查询字符串%’;  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>全文索引用match+against方式查询：  </p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">SELECT * FROM papers WHERE MATCH(title,content) AGAINST (‘查询字符串’);  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">注意点:1. 使用全文索引前，搞清楚版本支持情况；2. 全文索引比 like + % 快 N 倍，但是可能存在精度问题；3. 如果需要全文索引的是大量数据，建议先添加数据，再创建索引。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>7.创建空间索引</strong>  </p><p>空间索引创建中，要求空间类型的字段必须为 非空 。</p><p>举例：创建表test5，在空间类型为GEOMETRY的字段上创建空间索引，SQL语句如下：  </p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">CREATE TABLE test5(geo GEOMETRY NOT NULL,SPATIAL INDEX spa_idx_geo(geo)) ENGINE&#x3D;MyISAM;  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-在已经存在的表上创建索引"><a href="#2-在已经存在的表上创建索引" class="headerlink" title="2.在已经存在的表上创建索引"></a>2.在已经存在的表上创建索引</h4><p>在已经存在的表中创建索引可以使用<strong>ALTER TABLE</strong>语句或者<strong>CREATE INDEX</strong>语句  </p><p><strong>1.使用ALTER TABLE ADD语句创建索引</strong> </p><p>ALTER TABLE语句创建索引的基本语法如下：  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> table_name <span class="token keyword">ADD</span> <span class="token punctuation">[</span><span class="token keyword">UNIQUE</span> <span class="token operator">|</span> FULLTEXT <span class="token operator">|</span> SPATIAL<span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token keyword">INDEX</span> <span class="token operator">|</span> <span class="token keyword">KEY</span><span class="token punctuation">]</span><span class="token punctuation">[</span>index_name<span class="token punctuation">]</span> <span class="token punctuation">(</span>col_name<span class="token punctuation">[</span>length<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token keyword">ASC</span> <span class="token operator">|</span> <span class="token keyword">DESC</span><span class="token punctuation">]</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>2.使用CREATE INDEX创建索引</strong> </p><p>CREATE INDEX语句可以在已经存在的表上添加索引，在MySQL中，<strong>CREATE INDEX</strong>被映射到一个<strong>ALTER TABLE</strong>语句上，基本语法结构为：  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token punctuation">[</span><span class="token keyword">UNIQUE</span> <span class="token operator">|</span> FULLTEXT <span class="token operator">|</span> SPATIAL<span class="token punctuation">]</span> <span class="token keyword">INDEX</span> index_name<span class="token keyword">ON</span> table_name <span class="token punctuation">(</span>col_name<span class="token punctuation">[</span>length<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token keyword">ASC</span> <span class="token operator">|</span> <span class="token keyword">DESC</span><span class="token punctuation">]</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="1-3-删除索引"><a href="#1-3-删除索引" class="headerlink" title="1.3 删除索引"></a>1.3 删除索引</h3><ol><li><strong>使用ALTER TABLE删除索引</strong>  </li></ol><p>ALTER TABLE删除索引的基本语法格式如下：  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> table_name <span class="token keyword">DROP</span> <span class="token keyword">INDEX</span> index_name<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>提示</strong>        添加<strong>AUTO_INCERMENT</strong>约束字段的唯一索引<strong>不能被删除</strong>  </p><ol start="2"><li><strong>使用DROP INDEX语句删除索引</strong> </li></ol><p>DROP INDEX删除索引的基本语法格式如下：  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">DROP</span> <span class="token keyword">INDEX</span> index_name <span class="token keyword">ON</span> table_name<span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>提示</strong>     </p><p>删除表中的列时，如果要删除的列为索引的组成部分，则该列也会从索引中删除。如果组成索引的所有列都被删除，则整个索引将被删除。</p><h2 id="2-MySQL8-0索引新特性"><a href="#2-MySQL8-0索引新特性" class="headerlink" title="2. MySQL8.0索引新特性"></a>2. MySQL8.0索引新特性</h2><h3 id="2-1-支持降序索引"><a href="#2-1-支持降序索引" class="headerlink" title="2.1 支持降序索引"></a>2.1 支持降序索引</h3><p>降序索引以降序存储键值。虽然在语法上，从MysQL 4版本开始就已经支持降序索引的语法了但实际上该DESC定义是被忽略的，直到MysQL 8.x版本才开始真正支持降序索引（仅限于InnoDB存储引擎)。</p><p>MySQL在<strong>8.0版本之前创建的仍然是升序索引，使用时进行反向扫描，这大大降低了数据库的效率</strong>。在某些场景下，降序索引意义重大。例如，如果一个查询，需要对多个列进行排序，且顺序要求不一致，那么使用降序索引将会避免数据库使用额外的文件排序操作，从而提高性能。</p><p>举例：分别在MySQL 5.7版本和MySQL 8.0版本中创建数据表ts1，结果如下：  </p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">CREATE TABLE ts1(a int,b int,index idx_a_b(a,b desc));  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在MySQL 5.7版本中查看数据表ts1的结构，结果如下  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220119112409791.png" alt="image-20220119112409791"></p><p>从结果可以看出，索引仍然是默认的升序。在MySQL 8.0版本中查看数据表ts1的结构，结果如下：  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220119113035239.png" alt="image-20220119113035239"></p><p>从结果可以看出，索引已经是降序了。下面继续测试降序索引在执行计划中的表现。</p><p>分别在MySQL 5.7版本和MySQL 8.0版本的数据表ts1中插入800条随机数据，执行语句如下：  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">DELIMITER</span> <span class="token comment">//</span><span class="token keyword">CREATE</span> <span class="token keyword">PROCEDURE</span> ts_insert<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">BEGIN</span><span class="token keyword">DECLARE</span> i <span class="token keyword">INT</span> <span class="token keyword">DEFAULT</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">WHILE</span> i <span class="token operator">&lt;</span> <span class="token number">800</span><span class="token keyword">DO</span><span class="token keyword">insert</span> <span class="token keyword">into</span> ts1 <span class="token keyword">select</span> rand<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">80000</span><span class="token punctuation">,</span>rand<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">80000</span><span class="token punctuation">;</span><span class="token keyword">SET</span> i <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">END</span> <span class="token keyword">WHILE</span><span class="token punctuation">;</span><span class="token keyword">commit</span><span class="token punctuation">;</span><span class="token keyword">END</span> <span class="token comment">//</span><span class="token keyword">DELIMITER</span> <span class="token punctuation">;</span>\#调用  <span class="token keyword">CALL</span> ts_insert<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在MySQL 5.7版本中查看数据表ts1的执行计划，结果如下：  </p><pre class="line-numbers language-none"><code class="language-none">EXPLAIN SELECT * FROM ts1 ORDER BY a,b DESC LIMIT 5;  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>从结果可以看出，执行计划中扫描数为799，而且使用了Using filesort。</p><pre class="line-numbers language-none"><code class="language-none">提示 Using filesort是MySQL中一种速度比较慢的外部排序，能避免是最好的。多数情况下，管理员可以通过优化索引来尽量避免出现Using filesort，从而提高数据库执行速度。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在MySQL 8.0版本中查看数据表ts1的执行计划。从结果可以看出，执行计划中扫描数为5，而且没有使用Using filesort。</p><pre class="line-numbers language-none"><code class="language-none">注意 降序索引只对查询中特定的排序顺序有效，如果使用不当，反而查询效率更低。例如，上述查询排序条件改为order by a desc, b desc，MySQL 5.7的执行计划要明显好于MySQL 8.0。将排序条件修改为order by a desc, b desc后，下面来对比不同版本中执行计划的效果。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> 在MySQL 5.7版本中查看数据表ts1的执行计划，结果如下：  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">EXPLAIN</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> ts1 <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> a <span class="token keyword">DESC</span><span class="token punctuation">,</span>b <span class="token keyword">DESC</span> <span class="token keyword">LIMIT</span> <span class="token number">5</span><span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在MySQL 8.0版本中查看数据表ts1的执行计划。从结果可以看出，修改后MySQL 5.7的执行计划要明显好于MySQL 8.0。  </p><h3 id="2-2-隐藏索引"><a href="#2-2-隐藏索引" class="headerlink" title="2.2 隐藏索引"></a>2.2 隐藏索引</h3><p>在MySQL 5.7版本及之前，只能通过显式的方式删除索引。此时，如果发现删除索引后出现错误，又只能通过显式创建索引的方式将删除的索引创建回来。如果数据表中的数据量非常大，或者数据表本身比较大，这种操作就会消耗系统过多的资源，操作成本非常高。</p><p>从MySQL 8.x开始支持 <strong>隐藏索引</strong>（invisible indexes） ，只需要将待删除的索引设置为隐藏索引，使查询优化器不再使用这个索引（即使使用force index（强制使用索引），优化器也不会使用该索引），确认将索引设置为隐藏索引后系统不受任何响应，就可以彻底删除索引。 <strong>这种通过先将索引设置为隐藏索引，再删除索引的方式就是软删除</strong> 。  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220119113551533.png" alt="image-20220119113551533"></p><p>索引默认是可见的，在使用<strong>CREATE TABLE，CREATE INDEX</strong>或者ALTERTABLE等语句时可以通过VISIBLE或者INVISIBLE 关键词设置索引的可见性。</p><ol><li><strong>创建表时直接创建</strong> </li></ol><p>在MySQL中创建隐藏索引通过SQL语句INVISIBLE来实现，其语法形式如下：  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> tablename<span class="token punctuation">(</span>propname1 type1<span class="token punctuation">[</span>CONSTRAINT1<span class="token punctuation">]</span><span class="token punctuation">,</span>propname2 type2<span class="token punctuation">[</span>CONSTRAINT2<span class="token punctuation">]</span><span class="token punctuation">,</span>……propnamen typen<span class="token punctuation">,</span><span class="token keyword">INDEX</span> <span class="token punctuation">[</span>indexname<span class="token punctuation">]</span><span class="token punctuation">(</span>propname1 <span class="token punctuation">[</span><span class="token punctuation">(</span>length<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span> INVISIBLE<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220119114052830.png" alt="image-20220119114052830"></p><p>上述语句比普通索引多了一个关键字INVISIBLE，用来标记索引为不可见索引。  </p><ol start="2"><li><strong>在已经存在的表上创建</strong>  </li></ol><p>可以为已经存在的表设置隐藏索引，其语法形式如下：  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">INDEX</span> indexname<span class="token keyword">ON</span> tablename<span class="token punctuation">(</span>propname<span class="token punctuation">[</span><span class="token punctuation">(</span>length<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span> INVISIBLE<span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220119114207883.png" alt="image-20220119114207883"></p><ol start="3"><li><strong>通过ALTER TABLE语句创建</strong>  </li></ol><p>语法形式如下：  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> tablename<span class="token keyword">ADD</span> <span class="token keyword">INDEX</span> indexname <span class="token punctuation">(</span>propname <span class="token punctuation">[</span><span class="token punctuation">(</span>length<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span> INVISIBLE<span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol start="4"><li><p><strong>切换索引可见状态</strong></p><p> 已存在的索引可通过如下语句切换可见状态：  </p></li></ol><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> tablename <span class="token keyword">ALTER</span> <span class="token keyword">INDEX</span> index_name INVISIBLE<span class="token punctuation">;</span> <span class="token comment">#切换成隐藏索引</span><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> tablename <span class="token keyword">ALTER</span> <span class="token keyword">INDEX</span> index_name VISIBLE<span class="token punctuation">;</span> <span class="token comment">#切换成非隐藏索引  </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果将index_cname索引切换成可见状态，通过explain查看执行计划，发现优化器选择了index_cname索引。  </p><pre class="line-numbers language-none"><code class="language-none">注意 当索引被隐藏时，它的内容仍然是和正常索引一样实时更新的。如果一个索引需要长期被隐藏，那么可以将其删除，因为索引的存在会影响插入、更新和删除的性能。  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="3-索引的设计原则"><a href="#3-索引的设计原则" class="headerlink" title="3.索引的设计原则"></a>3.索引的设计原则</h2><h3 id="3-1-数据准备"><a href="#3-1-数据准备" class="headerlink" title="3.1 数据准备"></a>3.1 数据准备</h3><p>第1步：创建数据库、创建表  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">DATABASE</span> atguigudb1<span class="token punctuation">;</span><span class="token keyword">USE</span> atguigudb1<span class="token punctuation">;</span><span class="token comment">#1.创建学生表和课程表</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span>student_info<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span> <span class="token keyword">INT</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span><span class="token punctuation">`</span>student_id<span class="token punctuation">`</span> <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token punctuation">,</span><span class="token punctuation">`</span>name<span class="token punctuation">`</span> <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span><span class="token punctuation">`</span>course_id<span class="token punctuation">`</span> <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token punctuation">,</span><span class="token punctuation">`</span>class_id<span class="token punctuation">`</span> <span class="token keyword">INT</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span><span class="token punctuation">`</span>create_time<span class="token punctuation">`</span> <span class="token keyword">DATETIME</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CURRENT_TIMESTAMP</span> <span class="token keyword">ON</span> <span class="token keyword">UPDATE</span> <span class="token keyword">CURRENT_TIMESTAMP</span><span class="token punctuation">,</span><span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">INNODB</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token operator">=</span><span class="token number">1</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8<span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span>course<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span> <span class="token keyword">INT</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span><span class="token punctuation">`</span>course_id<span class="token punctuation">`</span> <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token punctuation">,</span><span class="token punctuation">`</span>course_name<span class="token punctuation">`</span> <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">40</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span><span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">INNODB</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token operator">=</span><span class="token number">1</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8<span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第2步：创建模拟数据必需的存储函数  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">#函数1：创建随机产生字符串函数</span><span class="token keyword">DELIMITER</span> <span class="token comment">//</span><span class="token keyword">CREATE</span> <span class="token keyword">FUNCTION</span> rand_string<span class="token punctuation">(</span>n <span class="token keyword">INT</span><span class="token punctuation">)</span><span class="token keyword">RETURNS</span> <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span> <span class="token comment">#该函数会返回一个字符串</span><span class="token keyword">BEGIN</span><span class="token keyword">DECLARE</span> chars_str <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span><span class="token string">'abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ'</span><span class="token punctuation">;</span><span class="token keyword">DECLARE</span> return_str <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token string">''</span><span class="token punctuation">;</span><span class="token keyword">DECLARE</span> i <span class="token keyword">INT</span> <span class="token keyword">DEFAULT</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">WHILE</span> i <span class="token operator">&lt;</span> n <span class="token keyword">DO</span><span class="token keyword">SET</span> return_str <span class="token operator">=</span>CONCAT<span class="token punctuation">(</span>return_str<span class="token punctuation">,</span>SUBSTRING<span class="token punctuation">(</span>chars_str<span class="token punctuation">,</span>FLOOR<span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">+</span>RAND<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">52</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">SET</span> i <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">END</span> <span class="token keyword">WHILE</span><span class="token punctuation">;</span><span class="token keyword">RETURN</span> return_str<span class="token punctuation">;</span><span class="token keyword">END</span> <span class="token comment">//</span><span class="token keyword">DELIMITER</span> <span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">#函数2：创建随机数函数</span><span class="token keyword">DELIMITER</span> <span class="token comment">//</span><span class="token keyword">CREATE</span> <span class="token keyword">FUNCTION</span> rand_num <span class="token punctuation">(</span>from_num <span class="token keyword">INT</span> <span class="token punctuation">,</span>to_num <span class="token keyword">INT</span><span class="token punctuation">)</span> <span class="token keyword">RETURNS</span> <span class="token keyword">INT</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span><span class="token keyword">BEGIN</span><span class="token keyword">DECLARE</span> i <span class="token keyword">INT</span> <span class="token keyword">DEFAULT</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">SET</span> i <span class="token operator">=</span> FLOOR<span class="token punctuation">(</span>from_num <span class="token operator">+</span>RAND<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">(</span>to_num <span class="token operator">-</span> from_num<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">;</span><span class="token keyword">RETURN</span> i<span class="token punctuation">;</span><span class="token keyword">END</span> <span class="token comment">//</span><span class="token keyword">DELIMITER</span> <span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>创建函数，假如报错：</p><p>由于开启过慢查询日志bin-log, 我们就必须为我们的function指定一个参数。</p><p>主从复制，主机会将写操作记录在bin-log日志中。从机读取bin-log日志，执行语句来同步数据。如果使用函数来操作数据，会导致从机和主键操作时间不一致。所以，默认情况下，<strong>mysql不开启创建函数设置</strong>。</p><p>查看mysql是否允许创建函数：</p><pre class="line-numbers language-none"><code class="language-none">show variables like &#39;log_bin_trust_function_creators&#39;;  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>命令开启：允许创建函数设置：</p><pre class="line-numbers language-none"><code class="language-none">set global log_bin_trust_function_creators&#x3D;1; # 不加global只是当前窗口有效。 <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> mysqld重启，上述参数又会消失。永久方法：</p><p>windows下：my.ini[mysqld]加上：</p><pre class="line-numbers language-none"><code class="language-none">log_bin_trust_function_creators&#x3D;1  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>linux下：/etc/my.cnf下my.cnf[mysqld]加上：</p><pre class="line-numbers language-none"><code class="language-none">log_bin_trust_function_creators&#x3D;1  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>第3步：创建插入模拟数据的存储过程</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL"># 存储过程1：创建插入课程表存储过程DELIMITER &#x2F;&#x2F;CREATE PROCEDURE insert_course( max_num INT )BEGINDECLARE i INT DEFAULT 0;    SET autocommit &#x3D; 0; #设置手动提交事务    REPEAT #循环    SET i &#x3D; i + 1; #赋值    INSERT INTO course (course_id, course_name ) VALUES    (rand_num(10000,10100),rand_string(6));    UNTIL i &#x3D; max_num    END REPEAT;    COMMIT; #提交事务END &#x2F;&#x2F;DELIMITER ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL"># 存储过程2：创建插入学生信息表存储过程DELIMITER &#x2F;&#x2F;CREATE PROCEDURE insert_stu( max_num INT )BEGINDECLARE i INT DEFAULT 0;    SET autocommit &#x3D; 0;  #设置手动提交事务     REPEAT #循环      SET i &#x3D; i + 1; #赋值    INSERT INTO student_info (course_id, class_id ,student_id ,NAME ) VALUES    (rand_num(10000,10100),rand_num(10000,10200),rand_num(1,200000),rand_string(6));    UNTIL i &#x3D; max_num    END REPEAT;    COMMIT; #提交事务END &#x2F;&#x2F;DELIMITER ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第4步：调用存储过程  </p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">CALL insert_course(100);CALL insert_stu(1000000);  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="3-2-哪些情况适合创建索引"><a href="#3-2-哪些情况适合创建索引" class="headerlink" title="3.2 哪些情况适合创建索引"></a>3.2 哪些情况适合创建索引</h3><p>索引本身可以起到约束的作用，比如唯一索引、主键索引都是可以起到唯一性约束的，因此在我们的数据表中,如果某个字段是唯一性的，就可以直接创建唯一性索引，或者主键索引。这样可以更快速地通过该索引来确定某条记录。</p><p>例如，学生表中学号是具有唯一性的字段，为该字段建立唯一性索引可以很快确定某个学生的信息，如果使用姓名的话，可能存在同名现象，从而降低查询速度。</p><h4 id="1-字段的数值有唯一性的限制"><a href="#1-字段的数值有唯一性的限制" class="headerlink" title="1.字段的数值有唯一性的限制"></a>1.字段的数值有唯一性的限制</h4><pre class="line-numbers language-none"><code class="language-none">业务上具有唯一特性的字段，即使是组合字段，也必须建成唯一索引。（来源：Alibaba）说明：不要以为唯一索引影响了 insert 速度，这个速度损耗可以忽略，但提高查找速度是明显的。  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="2-频繁作为-WHERE-查询条件的字段"><a href="#2-频繁作为-WHERE-查询条件的字段" class="headerlink" title="2. 频繁作为 WHERE 查询条件的字段"></a>2. 频繁作为 WHERE 查询条件的字段</h4><p>某个字段在SELECT语句的 WHERE 条件中经常被使用到，那么就需要给这个字段创建索引了。尤其是在数据量大的情况下，创建普通索引就可以大幅提升数据查询的效率。</p><p>比如student_info数据表（含100万条数据），假设我们想要查询 student_id=123110 的用户信息。  </p><h4 id="3-经常-GROUP-BY-和-ORDER-BY-的列"><a href="#3-经常-GROUP-BY-和-ORDER-BY-的列" class="headerlink" title="3.    经常 GROUP BY 和 ORDER BY 的列"></a>3.    经常 GROUP BY 和 ORDER BY 的列</h4><p>索引就是让数据按照某种顺序进行存储或检索，因此当我们使用 GROUP BY 对数据进行分组查询，或者使用 ORDER BY 对数据进行排序的时候，就需要 <strong>对分组或者排序的字段进行索引</strong> 。如果待排序的列有多个，那么可以在这些列上建立 组合索引 。  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220119121104654.png" alt="image-20220119121104654"></p><p>说明:多个单列索引在多条件查询时只会生效一个索引(MySQL会选择其中一个限制最严格的作为索引)，所以在多条件联合查询的时候最好创建联合索引。接着，我们创建联合索引(student_id, create_time)，查询时间为0.22s，效率提升了很多。</p><p>如果我们创建联合索引的顺序为(create_time, student_id)呢?运行时间为2.164s，因为在进行SELECT查询的时候，<strong>先进行GROUP BY，再对数据进行ORDER BY的操作</strong>，所以按照(student_id, create_time)这个联合索引的顺序效率是最高的。</p><h4 id="4-UPDATE、DELETE-的-WHERE-条件列"><a href="#4-UPDATE、DELETE-的-WHERE-条件列" class="headerlink" title="4. UPDATE、DELETE 的 WHERE 条件列"></a>4. UPDATE、DELETE 的 WHERE 条件列</h4><p>对数据按照某个条件进行查询后再进行 UPDATE 或 DELETE 的操作，如果对 WHERE 字段创建了索引，就能大幅提升效率。原理是因为我们需要先根据 WHERE 条件列检索出来这条记录，然后再对它进行更新或删除。<strong>如果进行更新的时候，更新的字段是非索引字段，提升的效率会更明显，这是因为非索引字段更新不需要对索引进行维护</strong>。  </p><h4 id="5-DISTINCT-字段需要创建索引"><a href="#5-DISTINCT-字段需要创建索引" class="headerlink" title="5. DISTINCT 字段需要创建索引"></a>5. DISTINCT 字段需要创建索引</h4><p>有时候我们需要对某个字段进行去重，使用 DISTINCT，那么对这个字段创建索引，也会提升查询效率。比如，我们想要查询课程表中不同的 student_id 都有哪些，如果我们没有对 student_id 创建索引，执行SQL 语句：  </p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">SELECT DISTINCT(student_id) FROM &#96;student_info&#96;;  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>运行结果（600637 条记录，运行时间 0.683s ）</p><p>如果我们对 student_id 创建索引，再执行 SQL 语句：  </p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">SELECT DISTINCT(student_id) FROM &#96;student_info&#96;;  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>运行结果（600637 条记录，运行时间 0.010s ）：</p><p>你能看到 SQL 查询效率有了提升，同时显示出来的 student_id 还是按照 <strong>递增的顺序</strong> 进行展示的。这是因为索引会对数据按照某种顺序进行排序，所以在去重的时候也会快很多。  </p><h4 id="6-多表-JOIN-连接操作时，创建索引注意事项"><a href="#6-多表-JOIN-连接操作时，创建索引注意事项" class="headerlink" title="6. 多表 JOIN 连接操作时，创建索引注意事项"></a>6. 多表 JOIN 连接操作时，创建索引注意事项</h4><p>首先， <strong>连接表的数量尽量不要超过 3 张</strong> ，因为每增加一张表就相当于增加了一次嵌套的循环，数量级增长会非常快，严重影响查询的效率。</p><p>其次， <strong>对 WHERE 条件创建索引</strong> ，因为 WHERE 才是对数据条件的过滤。如果在数据量非常大的情况下，没有 WHERE 条件过滤是非常可怕的。</p><p>最后， <strong>对用于连接的字段创建索引</strong> ，并且该字段在多张表中的 <strong>类型必须一致</strong> 。比如 course_id 在student_info 表和 course 表中都为 int(11) 类型，而不能一个为 int 另一个为 varchar 类型。  </p><p>举个例子，如果我们只对 student_id 创建索引，执行 SQL 语句：  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> course_id<span class="token punctuation">,</span> name<span class="token punctuation">,</span> student_info<span class="token punctuation">.</span>student_id<span class="token punctuation">,</span> course_name<span class="token keyword">FROM</span> student_info <span class="token keyword">JOIN</span> course<span class="token keyword">ON</span> student_info<span class="token punctuation">.</span>course_id <span class="token operator">=</span> course<span class="token punctuation">.</span>course_id<span class="token keyword">WHERE</span> name <span class="token operator">=</span> <span class="token string">'462eed7ac6e791292a79'</span><span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果（1 条数据，运行时间 0.189s ）：</p><p>这里我们对 name 创建索引，再执行上面的 SQL 语句，运行时间为 0.002s 。  </p><h4 id="7-使用列的类型小的创建索引"><a href="#7-使用列的类型小的创建索引" class="headerlink" title="7. 使用列的类型小的创建索引"></a>7. 使用列的类型小的创建索引</h4><p>我们这里所说的<strong>类型大小</strong>指的就是该类型表示的<strong>数据范围的大小</strong>。</p><p>我们在定义表结构的时候要显式的指定列的类型，以整数类型为例，有<strong>TINYINT、MEDIUMINTINT 、BIGINT</strong>等，它们占用的存储空间依次递增，能表示的整数范围当然也是依次递增。如果我们想要对某个整数列建立索引的话，<strong>在表示的整数范围允许的情况下，尽量让索引列使用较小的类型</strong>，比如我们能使用<strong>INT</strong>就不要使用BIGINT，能使用<strong>MEDIUMINT</strong>就不要使用<strong>INT</strong>。这是因为:</p><p><strong>BINGINT:</strong>    从 <strong>-2^63</strong> (-9223372036854775808) 到 <strong>2^63-1</strong> (9223372036854775807) 的整型数据（所有数字），无符号的范围是0到</p><p>18446744073709551615。一位为 <strong>8</strong> 个字节。</p><p><strong>INT :</strong>     <strong>-2^31 (-2,147,483,648) 到 2^31 – 1 (2,147,483,647)</strong> 的整型数据（所有数字），存储大小为<strong>4</strong>个字节；</p><p><strong>MEDIUMINT:</strong>    一个中等大小整数，有符号的范围是**-8388608到8388607<strong>，无符号的范围是0到16777215。 一位大小为</strong>3**个字节。</p><p><strong>SMALLINT:</strong>    一个小整数。有符号的范围是**-2^15 (-32,768) 到 2^15 - 1 (32,767)** 的整型数据，无符号的范围是<strong>0到65535</strong>。一位大小为 <strong>2</strong> 个字节。</p><p><strong>TINYINT:</strong>     带符号的范围是**-128到127<strong>，无符号的范围是</strong>0到255**。</p><ul><li>数据类型越小，在查询时进行的比较操作越快。</li><li>数据类型越小，索引占用的存储空间就越少，<strong>在一个数据页内就可以放下更多的记录</strong>，从而<strong>减少磁盘I/0带来的性能损耗</strong>，也就意味着可以把更多的数据页缓存在内存中，从而加快读写效率。</li></ul><p>这个建议对于表的<strong>主键来说更加适用</strong>，因为不仅是聚簇索引中会存储主键值，其他所有的<strong>二级索引的节点处都会存储一份记录的主键值</strong>，如果主键使用更小的数据类型，也就意味着节省更多的存储空间和更高效的IO。</p><h4 id="8-使用字符串前缀创建索引"><a href="#8-使用字符串前缀创建索引" class="headerlink" title="8. 使用字符串前缀创建索引"></a>8. 使用字符串前缀创建索引</h4><p>假设我们的字符串很长，那存储一个字符串就需要占用很大的存储空间。在我们需要为这个字符串列建立索引时，那就意味着在对应的B+树中有这么两个问题:</p><ul><li>B+树索引中的记录需要把该列的完整字符串存储起来，更费时。而且<strong>字符串越长，在索引中占用的存储空间越大</strong>。</li><li>如果B+树索引中索引列存储的字符串很长，那在做字符串<strong>比较时会占用更多的时间</strong>。</li></ul><p>我们可以通过截取字段的前面一部分内容建立索引，这个就叫<strong>前缀索引</strong>。这样在查找记录时虽然不能精确的定位到记录的位置，但是能定位到相应前缀所在的位置，然后根据前缀相同的记录的主键值回表查询完整的字符串值。既<strong>节约空间</strong>，又<strong>减少了字符串的比较时间</strong>，还大体能解决排序的问题。</p><p>例如，TEXT和BLOG类型的字段，进行全文检索会很浪费时间，如果只检索字段前面的若干字符，这样可以提高检索速度。</p><p>创建一张商户表，因为地址字段比较长，在地址字段上建立前缀索引  </p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">create table shop(address varchar(120) not null);alter table shop add index(address(12));  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>问题是，截取多少呢？截取得多了，达不到节省索引存储空间的目的；截取得少了，重复内容太多，字段的散列度(选择性)会降低。怎么<strong>计算不同的长度的选择性呢</strong>？  </p><p>先看一下字段在全部数据中的选择度：  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token keyword">distinct</span> address<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">from</span> shop<span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>通过不同长度去计算，与全表的选择性对比：  </p><p>公式：  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token function">count</span><span class="token punctuation">(</span><span class="token keyword">distinct</span> <span class="token keyword">left</span><span class="token punctuation">(</span>列名<span class="token punctuation">,</span> 索引长度<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>例如：  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token keyword">distinct</span> <span class="token keyword">left</span><span class="token punctuation">(</span>address<span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">as</span> sub10<span class="token punctuation">,</span> <span class="token comment">-- 截取前10个字符的选择度</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token keyword">distinct</span> <span class="token keyword">left</span><span class="token punctuation">(</span>address<span class="token punctuation">,</span><span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">as</span> sub11<span class="token punctuation">,</span> <span class="token comment">-- 截取前15个字符的选择度</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token keyword">distinct</span> <span class="token keyword">left</span><span class="token punctuation">(</span>address<span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">as</span> sub12<span class="token punctuation">,</span> <span class="token comment">-- 截取前20个字符的选择度</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token keyword">distinct</span> <span class="token keyword">left</span><span class="token punctuation">(</span>address<span class="token punctuation">,</span><span class="token number">25</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">as</span> sub13 <span class="token comment">-- 截取前25个字符的选择度</span><span class="token keyword">from</span> shop<span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>越接近 1 越好！！</p><p><strong>引申另一个问题：索引列前缀对排序的影响</strong></p><p>如果使用了索引列前缀，比方说前边只把address列的前12个字符放到了二级索引中，下边这个查询可能就有点儿尴尬了:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> shop <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> addressLIMIT <span class="token number">12</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>因为二级索引中不包含完整的address列信息，所以无法对前12个字符相同，后边的字符不同的记录进行排序，也就是使用索引列前缀的方式<strong>无法支持使用索引排序</strong>，只能使用<strong>文件排序</strong>。</p><p><strong>拓展：Alibaba《Java开发手册》</strong></p><p>【 强制 】在 varchar 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据实际文本<br>区分度决定索引长度。</p><p>说明：索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为 20 的索引，区分度会 <strong>高达</strong><br><strong>90% 以上</strong> ，可以使用<code> count(distinct left(列名, 索引长度)) / count(*)</code>的区分度来确定。  </p><h4 id="9-区分度高-散列性高-的列适合作为索引"><a href="#9-区分度高-散列性高-的列适合作为索引" class="headerlink" title="9. 区分度高(散列性高)的列适合作为索引"></a>9. 区分度高(散列性高)的列适合作为索引</h4><p><strong>列的基数</strong>指的是<strong>某一列中不重复数据的个数</strong>，比方说某个列包含值2，5，8，2，5，8，2，5，8，虽然有9条记录，但该列的基数却是3。也就是说，<strong>在记录行数一定的情况下，列的基数越大，该列中的值越分散;列的基数越小，该列中的值越集中</strong>。这个列的基数指标非常重要，直接影响我们是否能有效的利用索引。最好为列的基数大的列建立索引，为基数太小列的建立索引效果可能不好。</p><p>可以使用公式 <code>select count(distinct a)/count(*) from t1</code>计算区分度，越接近1越好。一般超过33%就算是比较高效的索引了。</p><p>拓展:联合索引把区分度高(散列性高)的列放在前面。</p><h4 id="10-使用最频繁的列放到联合索引的左侧"><a href="#10-使用最频繁的列放到联合索引的左侧" class="headerlink" title="10. 使用最频繁的列放到联合索引的左侧"></a>10. 使用最频繁的列放到联合索引的左侧</h4><p>这样也可以较少的建立一些索引。同时，由于”最左前缀原则”，可以增加联合索引的使用率。  </p><h4 id="11-在多个字段都要创建索引的情况下，联合索引优于单值索引"><a href="#11-在多个字段都要创建索引的情况下，联合索引优于单值索引" class="headerlink" title="11. 在多个字段都要创建索引的情况下，联合索引优于单值索引"></a>11. 在多个字段都要创建索引的情况下，联合索引优于单值索引</h4><h3 id="3-3限制索引的数目"><a href="#3-3限制索引的数目" class="headerlink" title="3.3限制索引的数目"></a>3.3限制索引的数目</h3><h3 id="3-4-哪些情况不适合创建索引"><a href="#3-4-哪些情况不适合创建索引" class="headerlink" title="3.4 哪些情况不适合创建索引"></a>3.4 哪些情况不适合创建索引</h3><h4 id="1-在where中使用不到的字段，不要设置索引"><a href="#1-在where中使用不到的字段，不要设置索引" class="headerlink" title="1. 在where中使用不到的字段，不要设置索引"></a>1. 在where中使用不到的字段，不要设置索引</h4><h4 id="2-数据量小的表最好不要使用索引"><a href="#2-数据量小的表最好不要使用索引" class="headerlink" title="2. 数据量小的表最好不要使用索引"></a>2. 数据量小的表最好不要使用索引</h4><p>结论：在数据表中的数据行数比较少的情况下，比如不到 <strong>1000</strong> 行，是不需要创建索引的。</p><h4 id="3-有大量重复数据的列上不要建立索引"><a href="#3-有大量重复数据的列上不要建立索引" class="headerlink" title="3. 有大量重复数据的列上不要建立索引"></a>3. 有大量重复数据的列上不要建立索引</h4><p> 举例1：要在 100 万行数据中查找其中的 50 万行（比如性别为男的数据），一旦创建了索引，你需要先访问 50 万次索引，然后再访问 50 万次数据表，这样加起来的开销比不使用索引可能还要大。</p><p>举例2：假设有一个学生表，学生总数为 100 万人，男性只有 10 个人，也就是占总人口的 10 万分之 1。学生表 student_gender 结构如下。其中数据表中的 student_gender 字段取值为 0 或 1，0 代表女性，1 代表男性。  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> student_gender<span class="token punctuation">(</span>student_id <span class="token keyword">INT</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>student_name <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>student_gender <span class="token keyword">TINYINT</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span><span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">(</span>student_id<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">ENGINE</span> <span class="token operator">=</span> <span class="token keyword">INNODB</span><span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果我们要筛选出这个学生表中的男性，可以使用：  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> student_gender <span class="token keyword">WHERE</span> student_gender <span class="token operator">=</span> <span class="token number">1</span> <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结论：当数据重复度大，比如 高于 10% 的时候，也不需要对这个字段使用索引。  </p><h4 id="4-避免对经常更新的表创建过多的索引"><a href="#4-避免对经常更新的表创建过多的索引" class="headerlink" title="4. 避免对经常更新的表创建过多的索引"></a>4. 避免对经常更新的表创建过多的索引</h4><h4 id="5-不建议用无序的值作为索引"><a href="#5-不建议用无序的值作为索引" class="headerlink" title="5. 不建议用无序的值作为索引"></a>5. 不建议用无序的值作为索引</h4><p>例如身份证、UUID(在索引比较时需要转为ASCII，并且插入时可能造成页分裂)、MD5、HASH、无序长字符串等。  </p><h4 id="6-删除不再使用或者很少使用的索引"><a href="#6-删除不再使用或者很少使用的索引" class="headerlink" title="6. 删除不再使用或者很少使用的索引"></a>6. 删除不再使用或者很少使用的索引</h4><h4 id="7-不要定义冗余或重复的索引"><a href="#7-不要定义冗余或重复的索引" class="headerlink" title="7. 不要定义冗余或重复的索引"></a>7. 不要定义冗余或重复的索引</h4><p><strong>① 冗余索引</strong>  </p><p>举例：建表语句如下  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> person_info<span class="token punctuation">(</span>id <span class="token keyword">INT</span> <span class="token keyword">UNSIGNED</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span>name <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>birthday <span class="token keyword">DATE</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>phone_number <span class="token keyword">CHAR</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>country <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span><span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">KEY</span> idx_name_birthday_phone_number <span class="token punctuation">(</span>name<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span> birthday<span class="token punctuation">,</span> phone_number<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">KEY</span> idx_name <span class="token punctuation">(</span>name<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们知道，通过<code> idx_name_birthday_phone_number (联合索引)</code> 索引就可以对<code>name</code>列进行快速搜索，再创建一个专门针对<code>name</code>列的索引就算是一个 <strong>冗余索引</strong> ，维护这个索引只会增加维护的成本，并不会对搜索有什么好处。  </p><p><strong>② 重复索引</strong>  </p><p>另一种情况，我们可能会对某个列 <strong>重复建立索引</strong> ，比方说这样：  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> repeat_index_demo <span class="token punctuation">(</span>col1 <span class="token keyword">INT</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">,</span>col2 <span class="token keyword">INT</span><span class="token punctuation">,</span><span class="token keyword">UNIQUE</span> uk_idx_c1 <span class="token punctuation">(</span>col1<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">INDEX</span> idx_c1 <span class="token punctuation">(</span>col1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们看到，col1 既是主键、又给它定义为一个唯一索引，还给它定义了一个普通索引，可是主键本身就会生成聚簇索引，所以定义的唯一索引和普通索引是重复的，这种情况要避免。  </p>]]></content>
      
      
      <categories>
          
          <category> database </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>索引</title>
      <link href="/2022/01/15/%E7%B4%A2%E5%BC%95/"/>
      <url>/2022/01/15/%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<h1 id="1-为什么使用索引"><a href="#1-为什么使用索引" class="headerlink" title="1.为什么使用索引"></a>1.为什么使用索引</h1><p>索引是存储引擎用于快速找到数据记录的一种数据结构，就好比一本教课书的目录部分，通过目录中找到对应文章的页码，便可快速定位到需要的文章。MySQL中也是一样的道理，进行数据查找时，首先查查询条件是否命中某条索引，符合则<strong>通过索引查找</strong>相关数据，如果不符合则需要<strong>全表扫描</strong>，即需要一条一条地查找记录，直到找到与条件符合的记录。</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220115100536189.png" alt="image-20220115100536189"></p><p>如上图所示，数据库没有索引的情况下，数据 <strong>分布在硬盘不同的位置上面</strong>，读取数据时，摆臂需要前后摆动查找数据，这样操作非常消耗时间。如果数据 <strong>顺序摆放</strong>，那么也需要从1到6行按顺序读取，这样就相当于进行了6次I0操作，<strong>依旧非常耗时</strong>。如果我们不借助任何索引结构帮助我们快速定位数据的话，我们查找Col2=89这条记录，就要逐行去查找、去比较。从Col 2= 34开始，进行比较，发现不是，继续下一行。我们当前的表只有不到10行数据，但如果表很大的话，有<strong>上千万条数据</strong>，就意味着要做很多很多次磁盘I/0才能找到。现在要查找Col 2=89这条记录。CPu必须先去磁盘查找这条记录，找到之后加载到内存，再对数据进行处理。这个过程最耗时间的就是磁盘I/o(涉及到磁盘的旋转时间（速度较快)、磁头的寻道时间(速度慢、费时))</p><p>假如给数据使用 **二叉树 **这样的数据结构进行存储，如下图所示</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220115101032427.png" alt="image-20220115101032427"></p><p>对字段Col2添加了索引，就相当于在硬盘上为Col 2维护了一个索引的数据结构，即这个 <strong>二叉搜索树</strong>。二叉搜索树的每个结点存储的是<strong>（K，V)结构</strong>，key是Col2，value是该key 所在行的文件指针(地址)。比如:该二叉搜索树的根节点就是: <strong>(34,0x07）</strong>。现在对Col2添加了索引，这时再去查找Col 2=89这条记录的时候会先去查找该二叉搜索树（二叉树的遍历查找)。读34到内存，89&gt;34; 继续右侧数据，读89到内存，89 == 89; 找到数据返回。找到之后就根据当前结点的value快速定位到要查找的记录对应的地址。我们可以发现只需要<strong>查找两次</strong>就可以定位到记录的地址，查询速度就提高了。</p><p>这就是我们为什么要建索引，目的就是为了<strong>减少磁盘I/0的次数</strong>，加快查询速率。</p><h1 id="2-索引及其优缺点"><a href="#2-索引及其优缺点" class="headerlink" title="2.索引及其优缺点"></a>2.索引及其优缺点</h1><p>MySQL官方对索引的定义为：<strong>索引（Index）是帮助MySQL高效获取数据的数据结构</strong>。  </p><p><strong>索引的本质</strong>：<strong>索引是数据结构</strong>。你可以简单理解为“排好序的快速查找数据结构”，满足特定查找算法。这些数据结构以某种方式指向数据， 这样就可以在这些数据结构的基础上实现 <strong>高级查找算法</strong> 。  </p><p><strong>索引是在存储引擎中实现</strong>的，因此每种存储引擎的索引不一定完全相同，并且每种存储引擎不一定支持所有索引类型。同时，存储引擎可以定义每个表的<strong>最大索引数</strong>和<strong>最大索引长度</strong>。所有存储引擎支持每个表至少<strong>16</strong>个索引，总索引长度至少为256字节。有些存储引擎支持更多的索引数和更大的索引长度。|</p><h2 id="2-1-优点"><a href="#2-1-优点" class="headerlink" title="2.1 优点"></a>2.1 优点</h2><p>（1）类似大学图书馆建书目索引，提高数据检索的效率，降低 <strong>数据库的IO成本</strong> ，这也是创建索引最主要的原因。 </p><p>（2）通过创建唯一索引，可以保证数据库表中每一行 <strong>数据的唯一性</strong> 。 </p><p>（3）在实现数据的参考完整性方面，可以 <strong>加速表和表之间的连接</strong> 。换句话说，对于有依赖关系的子表和父表联合查询时，可以提高查询速度。 </p><p>（4）在使用分组和排序子句进行数据查询时，可以显著 <strong>减少查询中分组和排序的时间</strong> ，降低了CPU的消耗。  </p><h2 id="2-2-缺点"><a href="#2-2-缺点" class="headerlink" title="2.2 缺点"></a>2.2 缺点</h2><p>增加索引也有许多不利的方面，主要表现在如下几个方面： </p><p>（1）创建索引和维护索引要 <strong>耗费时间</strong> ，并且随着数据量的增加，所耗费的时间也会增加。 </p><p>（2）索引需要占 <strong>磁盘空间</strong> ，除了数据表占数据空间之外，每一个索引还要占一定的物理空间， <strong>存储在磁盘上</strong> ，如果有大量的索引，索引文件就可能比数据文件更快达到最大文件尺寸。 </p><p>（3）虽然索引大大提高了查询速度，同时却会 <strong>降低更新表的速度</strong> 。当对表<br>中的数据进行增加、删除和修改的时候，索引也要动态地维护，这样就降低了数据的维护速度。因此，选择使用索引时，需要综合考虑索引的优点和缺点。  </p><p>因此，选择使用索引时，需要综合考虑索引的优点和缺点。  </p><p>提示:<br>索引可以提高查询的速度，但是会影响插入记录的速度。这种情况下，最好的办法是先删除表中的索引，然后插入数据，插入完成后再创建索引。</p><h1 id="3-InnoDB中索引的推演"><a href="#3-InnoDB中索引的推演" class="headerlink" title="3.InnoDB中索引的推演"></a>3.InnoDB中索引的推演</h1><h2 id="3-1-索引之前的查找"><a href="#3-1-索引之前的查找" class="headerlink" title="3.1 索引之前的查找"></a>3.1 索引之前的查找</h2><p>先来看一个精确匹配的例子：  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token punctuation">[</span>列名列表<span class="token punctuation">]</span> <span class="token keyword">FROM</span> 表名 <span class="token keyword">WHERE</span> 列名 <span class="token operator">=</span> xxx<span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>1.<strong>在一个页中的查找</strong></p><p>假设目前表中的记录比较少，所有的记录都可以被存放到一个页中，在查找记录的时候可以根据搜索条件的不同分为两种情况:</p><ul><li><strong>以主键为搜索条件</strong></li></ul><p>​    可以在页目录中使用<strong>二分法</strong>快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录。</p><ul><li><strong>以其他列作为搜索条件</strong></li></ul><p>​    因为在数据页中并没有对非主键列建立所谓的页目录，所以我们无法通过<strong>二分法</strong>快速定位相应的槽。这种情况下只能从<strong>最小记录</strong>开始<strong>依次遍历</strong>单链表中的每条记录，然后对比每条记录是不是符合搜索条件。很显然，这种查找的效率是非常低的。</p><p>2.<strong>在很多页中查找</strong></p><p>大部分情况下我们表中存放的记录都是非常多的，需要好多的数据页来存储这些记录。在很多页中查找记录的话可以分为两个步骤:</p><p>​    1.定位到记录所在的页。</p><p>​    2.从所在的页内中查找相应的记录。</p><p>在没有索引的情况下，不论是根据主键列或者其他列的值进行查找，由于我们<strong>并不能快速的定位到记录所在的页</strong>，所以只能 <strong>从第一个页</strong> 沿着 <strong>双向链表</strong> 一直往下找，在每一个页中根据我们上面的查找方式去查找指定的记录。因为要遍历所有的数据页，所以这种方式显然是 <strong>超级耗时</strong> 的。如果一个表有一亿条记录呢？此时 <strong>索引</strong> 应运而生。  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220115102738099.png" alt="image-20220115102738099"></p><h2 id="3-2-设计索引"><a href="#3-2-设计索引" class="headerlink" title="3.2 设计索引"></a>3.2 设计索引</h2><p>建一个表：  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> index_demo<span class="token punctuation">(</span>    <span class="token operator">-</span><span class="token operator">></span>c1 <span class="token keyword">INT</span><span class="token punctuation">,</span>     <span class="token operator">-</span><span class="token operator">></span>c2 <span class="token keyword">INT</span><span class="token punctuation">,</span>    <span class="token operator">-</span><span class="token operator">></span>c3 <span class="token keyword">CHAR</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token operator">-</span><span class="token operator">></span><span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">(</span>c1<span class="token punctuation">)</span> <span class="token operator">|</span>    <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">)</span> ROW_FORMAT <span class="token operator">=</span> Compact<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个新建的 <strong>index_demo</strong> 表中有2个INT类型的列，1个CHAR(1)类型的列，而且我们规定了c1列为主键，这个表使用 <strong>Compact</strong> 行格式来实际存储记录的。这里我们简化了index_demo表的行格式示意图：  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220115103558132.png" alt="image-20220115103558132"></p><p>我们只在示意图里展示记录的这几个部分：</p><ul><li><strong>record_type</strong> ：记录头信息的一项属性，表示记录的类型， 0 表示普通记录、 2 表示最小记录、 3 表示最大记录、 1 暂时还没用过，下面讲。</li><li>next_record ：记录头信息的一项属性，表示下一条地址相对于本条记录的地址偏移量，我们用箭头来表明下一条记录是谁。</li><li><strong>各个列的值</strong> ：这里只记录在 index_demo 表中的三个列，分别是 c1 、 c2 和 c3 。</li><li><strong>其他信息</strong> ：除了上述3种信息以外的所有信息，包括其他隐藏列的值以及记录的额外信息。将记录格式示意图的其他信息项暂时去掉并把它竖起来的效果就是这样：</li></ul><p>将记录格式示意图的其他信息项暂时去掉并把它竖起来的效果就是这样：  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220115103713866.png" alt="image-20220115103713866"></p><p>把一些记录放到页里的示意图就是：  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220115103726133.png" alt="image-20220115103726133"></p><h3 id="1-一个简单的索引设计方案"><a href="#1-一个简单的索引设计方案" class="headerlink" title="1. 一个简单的索引设计方案"></a>1. 一个简单的索引设计方案</h3><p>我们在根据某个搜索条件查找一些记录时为什么要遍历所有的数据页呢？因为各个页中的记录并没有规律，我们并不知道我们的搜索条件匹配哪些页中的记录，所以不得不依次遍历所有的数据页。所以如果我们 <strong>想快速的定位到需要查找的记录在哪些数据页</strong> 中该咋办？我们可以为快速定位记录所在的数据页而 <strong>建立一个目录</strong> ，建这个目录必须完成下边这些事  </p><ul><li>下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值。  </li></ul><p>假设:每个数据页最多能存放3条记录(实际上一个数据页非常大，可以存放下好多记录)。有了这个假设之后我们向index_demo表插入3条记录:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> index_demo <span class="token keyword">VALUES</span><span class="token punctuation">(</span><span class="token number">1</span>，<span class="token number">4</span>，<span class="token string">'u'</span><span class="token punctuation">)</span>，<span class="token punctuation">(</span><span class="token number">3</span>， <span class="token number">9</span>，<span class="token string">'d'</span><span class="token punctuation">)</span>，<span class="token punctuation">(</span><span class="token number">5</span> <span class="token number">3</span>， <span class="token string">'y'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Query oK<span class="token punctuation">,</span><span class="token number">3</span> <span class="token keyword">rows</span> affected <span class="token punctuation">(</span><span class="token number">0.01</span> sec<span class="token punctuation">)</span>Records : <span class="token number">3</span> Duplicates: <span class="token number">0</span> <span class="token keyword">warnings</span> : <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>那么这些记录已经按照主键值的大小串联成一个单向链表了，如图所示：</p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220115104243828.png" alt="image-20220115104243828" style="zoom:67%;"><p>从图中可以看出来, <strong>index_demo</strong>表中的3条记录都被插入到了编号为10的数据页中了。此时我们再来插入一条记录:</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">mysql&gt; INSERT INTO index_demo VALUES(4,4,&#39;a&#39;);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> <img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220115104413616.png" alt="image-20220115104413616"></p><p>注意，新分配的<strong>数据页编号</strong>可能并不是连续的。它们只是通过维护着上一个页和下一个页的编号而建立了<strong>链表</strong>关系。另外，<strong>页10</strong>中用户记录最大的主键值是5，而<strong>页28</strong>中有一条记录的主键值是4，因为<strong>5 &gt;4</strong>，所以这就不符合下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值的要求，所以在插入主键值为4的记录的时候需要伴随着一次<strong>记录移动</strong>，也就是把主键值为5的记录移动到页28中，然后再把主键值为4的记录插入到页10中，这个过程的示意图如下:</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220115104730152.png" alt="image-20220115104730152"></p><p>这个过程表明了在对页中的记录进行增删改操作的过程中，我们必须通过一些诸如记录移动的操作来始终保证这个状态一直成立:下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值。这个过程我们称为<strong>页分裂</strong>。</p><ul><li>给所有的页建立一个目录项  </li></ul><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220115105020632.png" alt="image-20220115105020632"></p><p>所以我们为上边几个页做好的目录就像这样子：  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220115104858560.png" alt="image-20220115104858560"></p><p>以 页28 为例，它对应 目录项2 ，这个目录项中包含着该页的页号 28 以及该页中用户记录的最小主键值 5 。我们只需要把几个目录项在物理存储器上连续存储（比如：数组），就可以实现根据主键值快速查找某条记录的功能了。比如：查找主键值为 20 的记录，具体查找过程分两步：</p><ol><li><p>先从<strong>目录项</strong>中根据 二分法 快速确定出主键值为 20 的记录在 目录项3 中（因为 12 &lt; 20 &lt;209 ），它对应的页是 页9 。</p></li><li><p>再根据前边说的在页中查找记录的方式去 页9 中定位具体的记录。</p></li></ol><p>至此，针对数据页做的简易目录就搞定了。这个目录有一个别名，称为 <strong>索引</strong> 。  </p><h3 id="2-InnoDB中的索引方案"><a href="#2-InnoDB中的索引方案" class="headerlink" title="2.InnoDB中的索引方案"></a>2.InnoDB中的索引方案</h3><p><strong>① 迭代1次：目录项纪录的页</strong>  </p><p>我们把前边使用到的目录项放到数据页中的样子就是这样：  </p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220117111135749.png" alt="image-20220117111135749" style="zoom: 67%;"><p>从图中可以看出来，我们新分配了一个编号为30的页来专门存储目录项记录。这里再次强调 目录项记录和普通的 用户记录 的不同点：  </p><ul><li><strong>目录项记录</strong> 的<code> record_type</code> 值是 <strong>1</strong>，而 普通用户记录 的<code> record_type</code> 值是 <strong>0</strong>。</li><li>目录项记录只有 <strong>主键值和页的编号</strong> 两个列，而普通的用户记录的列是用户自己定义的，可能包含** <strong>很</strong><br>多列** ，另外还有<code>InnoDB</code>自己添加的隐藏列。</li><li>了解：记录头信息里还有一个叫 min_rec_mask 的属性，只有在存储 目录项记录 的页中的主键值<br>最小的 目录项记录 的 min_rec_mask 值为 1 ，其他别的记录的 min_rec_mask 值都是 0 。  </li></ul><p>相同点：两者用的是一样的数据页，都会为主键值生成 Page Directory （页目录），从而在按照主键值进行查找时可以使用 <strong>二分法</strong> 来加快查询速度。  </p><p>现在以查找主键为 20 的记录为例，根据某个主键值去查找记录的步骤就可以大致拆分成下边两步：  </p><ol><li>先到存储 <strong>目录项记录</strong> 的页，也就是页30中通过 <strong>二分法</strong> 快速定位到对应目录项，因为 12 &lt; 20 &lt; 209 ，所以定位到对应的记录所在的页就是页 <strong>9</strong>。</li><li>再到存储用户记录的页9中根据 <strong>二分法</strong> 快速定位到主键值为 20 的用户记录  </li></ol><p><strong>② 迭代2次：多个目录项纪录的页</strong>  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220117111536071.png" alt="image-20220117111536071"></p><p>从图中可以看出，我们插入了一条主键值为320的用户记录之后需要两个新的数据页：</p><ul><li>为存储该用户记录而新生成了 页31 。</li><li>因为原先存储目录项记录的 页30的容量已满 （我们前边假设只能存储4条目录项记录），所以不得<br>不需要一个新的 页32 来存放 页31 对应的目录项。  </li></ul><p>现在因为存储目录项记录的页不止一个，所以如果我们想根据主键值查找一条用户记录大致需要3个步<br>骤，以查找主键值为 20 的记录为例：  </p><ul><li><ol><li>确定 <strong>目录项记录页</strong><br>我们现在的存储目录项记录的页有两个，即 页30 和 页32 ，又因为页30表示的目录项的主键值的范围是 [1, 320) ，页32表示的目录项的主键值不小于 <strong>320</strong> ，所以主键值为 <strong>20</strong> 的记录对应的目录项记录在 页30 中。</li></ol></li><li><ol start="2"><li>通过目录项记录页 <strong>确定用户记录真实所在的页 。</strong><br>在一个存储 <strong>目录项记录</strong> 的页中通过主键值定位一条目录项记录的方式说过了。</li></ol></li><li><ol start="3"><li>在真实存储用户记录的页中定位到具体的记录。  </li></ol></li></ul><p><strong>③ 迭代3次：目录项记录页的目录页</strong>  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220117111848240.png" alt="image-20220117111848240"></p><p>如图，我们生成了一个存储更高级目录项的 <strong>页33</strong> ，这个页中的两条记录分别代表页30和页32，如果用户记录的主键值在 <strong>[1, 320)</strong> 之间，则到页30中查找更详细的目录项记录，如果主键值 不小于320 的话，就到页32中查找更详细的目录项记录。</p><p>我们可以用下边这个图来描述它：  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220117111947930.png" alt="image-20220117111947930"></p><p>这个数据结构，它的名称是 <strong>B+树</strong>  。</p><p><strong>④ B+Tree</strong>  </p><p>一个B+树的节点其实可以分成好多层，规定最下边的那层，也就是存放我们用户记录的那层为第 0 层，之后依次往上加。之前我们做了一个非常极端的假设：存放用户记录的页 最多存放3条记录 ，存放目录项记录的页 最多存放4条记录 。其实真实环境中一个页存放的记录数量是非常大的，假设所有存放用户记录的叶子节点代表的数据页可以存放 100条用户记录 ，所有存放目录项记录的内节点代表的数据页可以存放 1000条目录项记录 ，那么：  </p><ul><li>如果B+树只有1层，也就是只有1个用于存放用户记录的节点，最多能存放 100 条记录  </li><li>如果B+树有2层，最多能存放 1000×100=10,0000 条记录。</li><li>如果B+树有3层，最多能存放 1000×1000×100=1,0000,0000 条记录。</li><li>如果B+树有4层，最多能存放 1000×1000×1000×100=1000,0000,0000 条记录。相当多的记<br>录！！！  </li></ul><p>你的表里能存放 100000000000 条记录吗？所以一般情况下，我们 <strong>用到的B+树都不会超过4层</strong> ，那我们<br>通过主键值去查找某条记录<strong>最多只需要做4个页面内的查找</strong>（查找3个目录项页和一个用户记录页），又<br>因为在每个页面内有所谓的 Page Directory （页目录），所以在页面内也可以通过 <strong>二分法</strong> 实现快速<br>定位记录 。</p><h2 id="3-3-常见索引概念"><a href="#3-3-常见索引概念" class="headerlink" title="3.3 常见索引概念"></a>3.3 常见索引概念</h2><p>索引按照物理实现方式，索引可以分为 2 种：聚簇（聚集）和非聚簇（非聚集）索引。我们也把非聚集</p><p>索引称为二级索引或者辅助索引。  </p><h3 id="1-聚簇索引"><a href="#1-聚簇索引" class="headerlink" title="1.聚簇索引"></a>1.聚簇索引</h3><p><strong>索引即数据，数据即索引。</strong></p><p>特点：</p><ol><li>使用记录<strong>主键值</strong>的大小进行记录和页的排序，这包括三个方面的含义：</li></ol><ul><li>页内 的记录是按照主键的大小顺序排成一个 <strong>单向链表</strong> 。</li><li>各个存放 <strong>用户记录的页</strong> 也是根据页中用户记录的主键大小顺序排成一个 双向链表 。</li><li>存放 <strong>目录项记录的页</strong> 分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个 <strong>双向链表</strong> 。</li></ul><ol start="2"><li>B+树的 叶子节点 存储的是完整的用户记录。</li></ol><p>所谓完整的用户记录，就是指这个记录中存储了所有列的值（包括隐藏列）。  </p><p><strong>优点：</strong></p><ul><li>数据访问更快 ，因为<strong>聚簇索引将索引和数据保存在同一个B+树中</strong>，因此从聚簇索引中获取数据比非聚簇索引更快</li><li>聚簇索引对于<strong>主键的 排序查找 和 范围查找 速度非常快</strong></li><li>按照聚簇索引排列顺序，查询显示一定范围数据的时候，由于数据都是紧密相连，数据库不用从多个数据块中提取数据，所以 <strong>节省了大量的io操作</strong> 。  </li></ul><p>缺点：</p><ul><li><strong>插入速度严重依赖于插入顺序</strong> ，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们<strong>一般都会定义一个自增的ID列为主键</strong></li><li><strong>更新主键的代价很高</strong> ，因为将会导致被更新的行移动。因此，对于InnoDB表，我们<strong>一般定义主键为不可更新</strong></li><li>二级索引访问需要两次索引查找 ，第一次找到主键值，第二次根据主键值找到行数据  </li></ul><h3 id="2-二级索引（辅助索引、非聚簇索引）"><a href="#2-二级索引（辅助索引、非聚簇索引）" class="headerlink" title="2. 二级索引（辅助索引、非聚簇索引）"></a>2. 二级索引（辅助索引、非聚簇索引）</h3><p>上边介绍的<strong>聚簇索引</strong>只能在<strong>搜索条件是主键值时</strong>才能发挥作用，因为B+树中的数据都是按照主键进行排序的。那如果我们想以别的列作为搜索条件该怎么办呢? 肯定不能是从头到尾沿着链表依次遍历记录一遍</p><p>答案:我们可以<strong>多建几棵B+树</strong>，不同的B+树中的数据采用不同的排序规则。比方说我们用 <strong>c2</strong> 列的大小作为数据页、页中记录的排序规则，再建一棵B+树，效果如下图所示:</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220117112703079.png" alt="image-20220117112703079"></p><p>这个B+树与上边介绍的聚簇索引有几处不同：  </p><ul><li><p>使用记录c2列的大小进行记录和页的排序，这包括三个方面的含义:</p><ul><li><p>页内的记录是按照c2列的大小顺序排成一个<strong>单向链表</strong>。</p></li><li><p>各个存放用户记录的页也是根据页中记录的c2列大小顺序排成一个<strong>双向链表</strong>。</p></li><li><p>存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的c2列大小顺序排成一个<strong>双向链表</strong>。</p></li></ul></li><li><p>B+树的叶子节点存储的并不是完整的用户记录，而只是<strong>c2列+主键</strong>这两个列的值。</p></li><li><p>目录项记录中不再是<strong>主键+页号</strong>的搭配，而变成了<strong>c2列+页号</strong>的搭配。</p></li></ul><p>所以如果我们现在想通过c2列的值查找某些记录的话就可以使用我们刚刚建好的这个B+树了。以查找c2列的值为 <strong>4</strong> 的记录为例，查找过程如下:</p><p>1.确定<strong>目录项记录页</strong></p><p>根据<strong>根页面</strong>，也就是页44，可以快速定位到<strong>目录项记录</strong>所在的页为页42(因为2&lt;4&lt;9 )。</p><p>2．通过<strong>目录项记录</strong>页确定用户记录真实所在的页。</p><p>在页42中可以快速定位到实际存储用户记录的页，但是由于c2列并没有唯一性约束，所以c2列值为4的记录可能分布在多个数据页中，又因为2&lt; 4≤4，所以确定实际存储用户记录的页在页34和页35中。</p><p>3．在真实存储用户记录的页中定位到具体的记录。</p><p>到页34和页35中定位到具体的记录。</p><p>4、但是这个B+树的叶子节点中的记录只存储了<strong>c2</strong>和c1(也就是<strong>主键</strong>）两个列，所以我们<strong>必须再根据主键值去聚簇索引中再查找</strong>一遍完整的用户记录。</p><p><strong>概念</strong>：<strong>回表</strong> 我们根据这个以c2列大小排序的B+树只能确定我们要查找记录的主键值，所以如果我们想根据c2列的值查找到完整的用户记录的话，仍然需要到 <strong>聚簇索引</strong> 中再查一遍，这个过程称为 <strong>回表</strong> 。也就是根据c2列的值查询一条完整的用户记录需要使用到<code> 2 棵 B+树</code>！   </p><p><strong>问题</strong>：为什么我们还需要一次 <strong>回表</strong> 操作呢？直接把完整的用户记录放到二级索引的叶子节点不OK吗？  </p><p><strong>答</strong>：如果把完整的用户记录放到叶子节点是可以不用回表。但是<strong>太占地方了</strong>，相当于每建立一棵B+树都需要把所有的用户记录再都拷贝一遍，这就有点太浪费存储空间了。</p><p>因为这种按照非主键列建立的B+树需要一次回表操作才可以定位到完整的用户记录，所以这种B+树也被称为<strong>二级索引</strong>(英文名secondary index)，或者辅助索引。由于我们使用的是c2列的大小作为B+树的排序规则，所以我们也称这个B+树是为c2列建立的索引。</p><p>非聚簇索引的存在不影响数据在聚簇索引中的组织，所以<strong>一张表可以有多个非聚簇索引</strong>。</p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220118102446241.png" alt="image-20220118102446241" style="zoom:40%;"><h3 id="3-联合索引"><a href="#3-联合索引" class="headerlink" title="3. 联合索引"></a>3. 联合索引</h3><p>我们也可以同时以多个列的大小作为排序规则，也就是同时为多个列建立索引，比方说我们想让B+树按照 c2和c3列 的大小进行排序，这个包含两层含义：</p><ul><li>先把各个记录和页按照c2列进行排序。</li><li>在记录的c2列相同的情况下，采用c3列进行排序</li></ul><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220118102859128.png" alt="image-20220118102859128"></p><p>注意一点，以<strong>c2和c3列的大小为排序规则</strong>建立的B+树称为 <strong>联合索引</strong> ，本质上也是一个<strong>二级索引</strong>。它的意思与分别为c2和c3列分别建立索引的表述是不同的，不同点如下：</p><p>建立 <strong>联合索引</strong> 只会建立如上图一样的1棵B+树。</p><p>为c2和c3列分别建立索引会分别以c2和c3列的大小为排序规则建立2棵B+树。  </p><h2 id="3-4-InnoDB-的B-树索引的注意事项"><a href="#3-4-InnoDB-的B-树索引的注意事项" class="headerlink" title="3.4 InnoDB 的B+树索引的注意事项"></a>3.4 InnoDB 的B+树索引的注意事项</h2><h3 id="1-根页面位置万年不动"><a href="#1-根页面位置万年不动" class="headerlink" title="1. 根页面位置万年不动"></a>1. 根页面位置万年不动</h3><p>我们前边介绍B+树索引的时候，为了大家理解上的方便，先把存储用户记录的叶子节点都画出来，然后接着画存储目录项记录的内节点，实际上B+树的形成过程是这样的:</p><ul><li>每当为某个表创建一个B+树索引(聚簇索引不是人为创建的，默认就有）的时候，都会为这个索引创建一个<br><strong>根节点</strong>页面。最开始表中没有数据的时候，每个B+树索引对应的根节点中既没有用户记录，也没有目录项记录。</li><li>随后向表中插入用户记录时，先把用户记录存储到这个根节点中。</li><li>当根节点中的可用空间用完时继续插入记录，此时会将根节点中的所有记录<strong>复制到一个新分配的页</strong>，比如页a中，然后对这个新页进行页分裂的操作，得到另一个新页，比如页b。这时新插入的记录根据键值（也就是聚簇索引中的主键值，二级索引中对应的索引列的值)的大小就会被分配到页a或者页b中，而<strong>根节点便升级为存储目录项记录的页</strong>。</li></ul><p>这个过程特别注意的是:一个B+树索引的根节点自诞生之日起，便不会再移动。这样只要我们对某个表建立一个索引，那么它的根节点的页号便会被记录到某个地方，然后凡是InnoDB存储引擎需要用到这个索引的时候，都会从那个固定的地方取出根节点的页号，从而来访问这个索引。</p><h3 id="2-内节点中目录项记录的唯一性"><a href="#2-内节点中目录项记录的唯一性" class="headerlink" title="2. 内节点中目录项记录的唯一性"></a>2. 内节点中目录项记录的唯一性</h3><p>我们知道B+树索引的内节点中目录项记录的内容是索引列＋页号的搭配，但是这个搭配对于二级索引来说有点儿不严谨。还拿<code>index_demo</code>表为例，假设这个表中的数据是这样的:</p><table><thead><tr><th align="center">c1</th><th align="center">c2</th><th align="center">c3</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">1</td><td align="center">‘u’</td></tr><tr><td align="center">3</td><td align="center">1</td><td align="center">‘d’</td></tr><tr><td align="center">5</td><td align="center">1</td><td align="center">‘y’</td></tr><tr><td align="center">7</td><td align="center">1</td><td align="center">‘a’</td></tr></tbody></table><p>如果二级索引中目录项记录的内容只是索引列＋页号的搭配的话，那么为c2列建立索引后的B+树应该长这样:</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220118104232145.png" alt="image-20220118104232145"></p><p>如果我们想新插入一行记录，其中c1、c2、c3的值分别是:9、1、 ‘c’，那么在修改这个为c2列建立的二级索引对应的B+树时便碰到驽个大问题:由于贝3.中仔储的日以的C的值也是1，那我们这条新插入的记录两条目录项记录对应的c2列的值都是1，而我们新插入的这条记录的c2列的值也是1，那我们这条新插入的记录到底应该放到页4中，还是应该放到页5中啊?答案是:对不起，懵了。</p><p>为了让新插入记录能找到自己在那个页里，我们<strong>需要保证在B+树的同一层内节点的目录项记录除页号这个字段以外是唯一的</strong>。所以对于二级索引的内节点的目录项记录的内容实际上是由三个部分构成的:</p><ul><li>索引列的值</li><li>主键值</li><li>页号</li></ul><p>也就是我们把主键值也添加到二级索引内节点中的目录项记录了，这样就能保证B+树每一层节点中各条目录项记录除页号这个字段外是唯一的，所以我们为c2列建立二级索引后的示意图实际上应该是这样子的:</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220118104430530.png" alt="image-20220118104430530"></p><p>这样我们再插入记录<code>(9，1，&#39;c&#39;)</code>时，由于页3中存储的目录项记录是由<code>c2列＋主键＋页号</code>的值构成的，可以先把新记录的c2列的值和页3中各目录项记录的c2列的值作比较，如果c2列的值相同的话，可以接着比较主键值，因为B+树同一层中不同目录项记录的<strong>c2列＋主键</strong>的值肯定是不一样的，所以最后肯定能定位<strong>唯一的一条目录项记录</strong>，在本例中最后确定新记录应该被插入到页<strong>5</strong>中。</p><h3 id="3-一个页面最少存储2条记录"><a href="#3-一个页面最少存储2条记录" class="headerlink" title="3. 一个页面最少存储2条记录"></a>3. 一个页面最少存储2条记录</h3><p>一个B+树只需要很少的层级就可以轻松存储数亿条记录，查询速度相当不错!这是因为B+树本质上就是一个大的多层级目录，每经过一个目录时都会过滤掉许多无效的子目录，直到最后访问到存储真实数据的目录。那如果一个大的目录中只存放一个子目录是个啥效果呢?那就是目录层级非常非常非常多，而且最后的那个存放真实数据的目录中只能存放一条记录。费了半天劲只能存放一条真实的用户记录?<strong>所以InnoDB的一个数据页至少可以存放两条记录</strong>。</p><h1 id="4-MyISAM中的索引方案"><a href="#4-MyISAM中的索引方案" class="headerlink" title="4. MyISAM中的索引方案"></a>4. MyISAM中的索引方案</h1><p>B树索引适用存储引擎如表所示：  </p><table><thead><tr><th align="center">索引 / 存储引擎</th><th align="center">MyISAM</th><th align="center">InnoDB</th><th align="center">Memory</th></tr></thead><tbody><tr><td align="center">B-Tree索引</td><td align="center">支持</td><td align="center">支持</td><td align="center">支持</td></tr></tbody></table><p>即使多个存储引擎支持同一种类型的索引，但是他们的实现原理也是不同的。Innodb和MyISAM默认的索引是Btree索引；而Memory默认的索引是<strong>Hash索引</strong>。</p><p>MyISAM引擎使用 B+Tree 作为索引结构，叶子节点的data域存放的是 <strong>数据记录的地址</strong> 。</p><h3 id="4-2-MyISAM索引的原理"><a href="#4-2-MyISAM索引的原理" class="headerlink" title="4.2 MyISAM索引的原理"></a>4.2 MyISAM索引的原理</h3><p>下图是MyISAM索引的原理图。  </p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220118111201081.png" alt="image-20220118111201081" style="zoom:45%;"><p>如果我们在Col2上建立一个二级索引，则此索引的结构如下图所示：  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220118111212222.png" alt="image-20220118111212222"></p><h3 id="4-3-MyISAM-与-InnoDB对比"><a href="#4-3-MyISAM-与-InnoDB对比" class="headerlink" title="4.3 MyISAM 与 InnoDB对比"></a>4.3 MyISAM 与 InnoDB对比</h3><p>MyISAM的索引方式都是“非聚簇”的，与InnoDB包含1个聚簇索引是不同的。小结两种引擎中索引的区别：</p><p>① 在InnoDB存储引擎中，我们只需要根据主键值对 <strong>聚簇索引</strong> 进行一次查找就能找到对应的记录，而在MyISAM 中却需要进行一次 <strong>回表</strong> 操作，意味着MyISAM中建立的索引相当于全部都是 <strong>二级索引</strong> 。</p><p>② <code>InnoDB</code>的数据文件<strong>本身就是索引文件</strong>，<strong>而MyISAM索引文件和数据文件是 分离的</strong> ，索引文件仅保存<strong>数据记录的地址</strong>。</p><p>③ InnoDB的非聚簇索引data域存储相应记录 <strong>主键的值</strong> ，而MyISAM索引记录的是 地址 。换句话说，InnoDB的所有非聚簇索引都引用主键作为data域。</p><p>④ MyISAM的回表操作是十分 快速 的，因为是拿着地址偏移量直接到文件中取数据的，反观InnoDB是通过<strong>获取主键之后</strong>再去聚簇索引里找记录，虽然说也不慢，但还是比不上直接用地址去访问。</p><p>⑤ InnoDB要求表 <strong>必须有主键</strong> （ MyISAM可以没有 ）。如果没有显式指定，则MySQL系统会自动选择一个可以非空且唯一标识数据记录的列作为主键。如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整型。  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220118111349480.png" alt="image-20220118111349480"></p><h1 id="5-索引的代价"><a href="#5-索引的代价" class="headerlink" title="5. 索引的代价"></a>5. 索引的代价</h1><p>索引是个好东西，可不能乱建，它在空间和时间上都会有消耗：  </p><ul><li><strong>空间上的代价</strong></li></ul><p>每建立一个索引都要为它建立一棵B+树，每一棵B+树的每一个节点都是一个数据页，一个页默认会占用 16KB 的存储空间，一棵很大的B+树由许多数据页组成，那就是很大的一片存储空间。</p><ul><li><strong>时间上的代价</strong></li></ul><p>每次对表中的数据进行 <strong>增、删、改</strong> 操作时，都需要去修改各个B+树索引。而且我们讲过，B+树每层节点都是按照索引列的值 <strong>从小到大的顺序排序</strong> 而组成了 <strong>双向链表</strong> 。不论是叶子节点中的记录，还是内节点中的记录（也就是不论是用户记录还是目录项记录）都是按照索引列的值从小到大的顺序而形成了一个单向链表。而增、删、改操作可能会对节点和记录的排序造成破坏，所以存储引擎需要额外的时间进行一些 <strong>记录移位 ， 页面分裂 、 页面回收</strong> 等操作来维护好节点和记录的排序。如果我们建了许多索引，每个索引对应的B+树都要进行相关的维护操作，会给性能拖后腿。  </p><h1 id="6-MySQL数据结构选择的合理性"><a href="#6-MySQL数据结构选择的合理性" class="headerlink" title="6.MySQL数据结构选择的合理性"></a>6.MySQL数据结构选择的合理性</h1><h2 id="6-1-全表遍历"><a href="#6-1-全表遍历" class="headerlink" title="6.1 全表遍历"></a>6.1 全表遍历</h2><h2 id="6-2-Hash结构"><a href="#6-2-Hash结构" class="headerlink" title="6.2 Hash结构"></a>6.2 Hash结构</h2><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220118111726111.png" alt="image-20220118111726111"></p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220118111731791.png" alt="image-20220118111731791"></p><p>上图中哈希函数h有可能将两个不同的关键字映射到相同的位置，这叫做 碰撞 ，在数据库中一般采用 <strong>链接法</strong> 来解决。在链接法中，将散列到同一槽位的元素放在一个链表中，如下图所示：  </p><h3 id="Hash结构效率高，那为什么索引结构要设计成树型呢"><a href="#Hash结构效率高，那为什么索引结构要设计成树型呢" class="headerlink" title="Hash结构效率高，那为什么索引结构要设计成树型呢?"></a>Hash结构效率高，那为什么索引结构要设计成树型呢?</h3><p>原因1: Hash索引仅能满足(=) (&lt;&gt;) 和 IN查询(<strong>等值判断</strong>)。如果进行<strong>范围查询</strong>，哈希型的索引，时间复杂度会退化为<strong>o(n)</strong>; 而树型的 “有序” 特性，依然能够保持O(log2N)的高效率。</p><p>原因2: Hash索引还有一个缺陷，数据的存储是<strong>没有顺序</strong>的，在ORDER BY的情况下，使用Hash索引还需要对数据重新排序。</p><p>原因3:对于联合索引的情况，Hash值是将联合索引键合并后一起来计算的，无法对单独的一个键或者几个索引键进行查询。</p><p>原因4:∶对于等值查询来说，通常Hash索引的效率更高，不过也存在一种情况，就是<strong>索引列的重复值如果很多，效率就会降低</strong>。这是因为遇到<strong>Hash冲突</strong>时，需要遍历桶中的<strong>行指针</strong>来进行比较，找到查询的关键字，非常耗时。所以，Hash索引通常不会用到重复值多的列上，比如列为性别、年龄的情况等。</p><p>Hash索引适用存储引擎如表所示：  </p><table><thead><tr><th>索引 / 存储引擎</th><th>MyISAM</th><th>InnoDB</th><th>Memory</th></tr></thead><tbody><tr><td>HASH索引</td><td>不支持</td><td>不支持</td><td>支持</td></tr></tbody></table><p>Hash索引的适用性：<br>Hash 索引存在着很多限制，相比之下在数据库中B+树索引的使用面会更广，不过也有一些场景采用Hash索引效率更高，比如在键值型(Key-Value)数据库中，<strong>Redis存储的核心就是Hash表</strong>。</p><p>MySQL中的Memory存储引|擎支持Hash存储，如果我们需要用到查询的临时表时，就可以选择Memory存储引擎，把某个字段设置为Hash索引，比如字符串类型的字段，进行Hash计算之后长度可以缩短到几个字节。当字段的重复度低，而且经常需要进行<strong>等值查询</strong>的时候，采用Hash索引是个不错的选择。</p><p>另外，InnoDB本身不支持 Hash索引，但是提供<strong>自适应Hash索引</strong>(Adaptive Hash Index)。什么情况下才会使用自适应Hash索引呢? 如果某个数据经常被访问，当满足一定条件的时候，就会将这个数据页的地址存放到Hash表中。这样下次查询的时候，就可以直接找到这个页面的所在位置。这样让B+树也具备了Hash 索引的优点。</p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220118111831329.png" alt="image-20220118111831329" style="zoom:30%;"><p>采用自适应 Hash 索引目的是<strong>方便根据 SQL 的查询条件加速定位到叶子节点</strong>，特别是当 B+ 树比较深的时候，通过自适应 Hash 索引可以明显提高数据的检索效率。</p><p>我们可以通过<code> innodb_adaptive_hash_index</code> 变量来查看是否开启了自适应 Hash，比如：  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">show</span> variables <span class="token operator">like</span> <span class="token string">'%adaptive_hash_index'</span><span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220118112043877.png" alt="image-20220118112043877"></p><h2 id="6-3-二叉搜索树"><a href="#6-3-二叉搜索树" class="headerlink" title="6.3 二叉搜索树"></a>6.3 二叉搜索树</h2><p>如果我们利用二叉树作为索引结构，那么磁盘的IO次数和索引树的高度是相关的 。</p><p>1.二叉搜索树的特点</p><ul><li>一个节点只能有两个子节点，也就是一个节点度不能超过2</li><li>左子节点 <code>&lt;</code> 本节点;右子节点 <code>&gt;=</code> 本节点，比我大的向右，比我小的向左</li></ul><p>2.查找规则我们先来看下最基础的二叉搜索树(Binary Search Tree)，搜索某个节点和插入节点的规则一样，我们假设搜索插入的数值为key:</p><ul><li>1.如果key大于根节点，则在右子树中进行查找;</li><li>2如果key 小于根节点，则在左子树中进行查找;</li><li>3.如果 key等于根节点，也就是找到了这个节点，返回根节点即可。</li></ul><p>举个例子，我们对数列(34，22，89，5，23，77，91）创造出来的二分查找树如下图所示:</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220118113202984.png" alt="image-20220118113202984"></p><p>但是存在特殊的情况，就是有时候二叉树的深度非常大。比如我们给出的数据顺序是<code>(5,22,23,34,77,89,91)</code>，创造出来的二分搜索树如下图所示:│</p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220118113325362.png" alt="image-20220118113325362" style="zoom:80%;"><p>上面第二棵树也属于二分查找树，但是性能上已经退化成了一条链表，查找数据的时间复杂度变成了0(n)。你能看出来第一个树的深度是3，也就是说最多只需3次比较，就可以找到节点，而第二个树的深度是7，最多需要7次比较才能找到节点。</p><p>为了提高查询效率，就需要<strong>减少磁盘IO数</strong>。为了减少磁盘lo的次数，就需要尽量<strong>降低树的高度</strong>。需要把原来“瘦高”的树结构变的“矮胖”，树的每层的分叉越多越好。</p><h2 id="6-4-AVL树"><a href="#6-4-AVL树" class="headerlink" title="6.4 AVL树"></a>6.4 AVL树</h2><p>为了解决上面二叉查找树退化成链表的问题，人们提出了<strong>平衡二叉搜索树</strong>(Balanced Binary Tree)，又称为AVL树(有别于AVL算法)，它在二叉搜索树的基础上增加了约束，具有以下性质:</p><p><strong>它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</strong></p><p>这里说一下，常见的平衡二叉树有很多种，包括了<strong>平衡二叉搜索树、红黑树、数堆、伸展树</strong>。平衡二叉搜索树是最早提出来的自平衡二叉搜索树，当我们提到平衡二叉树时一般指的就是平衡二叉搜索树。事实上，第一棵树就属于平衡二叉搜索树，搜索时间复杂度就是**0(log2n)**。</p><p>数据查询的时间主要依赖于磁盘I/O的次数，如果我们采用二叉树的形式，即使通过平衡二叉搜索树进行了改进，树的深度也是 o(log2n)，当n 比较大时，深度也是比较高的，比如下图的情况:</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220118113703965.png" alt="image-20220118113703965"></p><p>每访问一次节点就需要进行一次磁盘 I/0操作，对于上面的树来说，我们需要进行5次I/0操作虽然平衡二叉树的效率高，但是树的深度也同样高，这就意味着磁盘I/o操作次数多，会影响整体数据查询的效率。，对于上面的树来说，我们需要进行5次I/0操作虽然平衡二叉树的效率高，但是树的深度也同样高，这就意味着磁盘I/o操作次数多，会影响整体数据查询的效率。</p><p>针对同样的数据，如果我们把二叉树改成 <strong>M 叉树</strong> （M&gt;2）呢？当 M=3 时，同样的 31 个节点可以由下面的三叉树来进行存储：  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220118113631329.png" alt="image-20220118113631329"></p><p>你能看到此时树的高度降低了，当数据量N大的时候，以及树的分叉数M大的时候，M叉树的高度会远小于二叉树的高度(M&gt;2)。所以，我们需要把<strong>树从“瘦高”变“矮胖”</strong>。</p><h2 id="6-5-B-Tree"><a href="#6-5-B-Tree" class="headerlink" title="6.5 B-Tree"></a>6.5 B-Tree</h2><p>B 树的结构如下图所示：  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220118114836279.png" alt="image-20220118114836279"></p><p>B树作为多路平衡查找树，它的每一个节点最多可以包括M个子节点，<strong>M称为 B树的阶</strong>。每个磁盘块中包括了<strong>关键字</strong>和<strong>子节点的指针</strong>。如果一个磁盘块中包括了×个关键字，那么指针数就是x+1。对于一个10o阶的B树来说，如果有3层的话最多可以存储约100万的索引数据。对于大量的索引数据来说，采用B树的结构是非常适合的，因为树的高度要远小于二叉树的高度。一个 M 阶的 B 树（M&gt;2）有以下的特性：</p><ol><li><p>根节点的儿子数的范围是 [2,M]。</p></li><li><p>每个中间节点包含 k-1 个关键字和 k 个孩子，孩子的数量 = 关键字的数量 +1，k 的取值范围为[ceil(M/2), M]。</p></li><li><p>叶子节点包括 k-1 个关键字（叶子节点没有孩子），k 的取值范围为 [ceil(M/2), M]。</p></li><li><p>假设中间节点节点的关键字为：Key[1], Key[2], …, Key[k-1]，且关键字按照升序排序，即 Key[i]&lt;Key[i+1]。此时 k-1 个关键字相当于划分了 k 个范围，也就是对应着 k 个指针，即为：P[1], P[2], …,P[k]，其中 P[1] 指向关键字小于 Key[1] 的子树，P[i] 指向关键字属于 (Key[i-1], Key[i]) 的子树，P[k]指向关键字大于 Key[k-1] 的子树。</p></li><li><p>所有叶子节点位于同一层。</p></li></ol><p>上面那张图所表示的 B 树就是一棵 3 阶的 B 树。我们可以看下磁盘块 2，里面的关键字为（8，12），它有 3 个孩子 (3，5)，(9，10) 和 (13，15)，你能看到 (3，5) 小于 8，(9，10) 在 8 和 12 之间，而 (13，15)大于 12，刚好符合刚才我们给出的特征。  </p><p>然后我们来看下如何用 B 树进行查找。假设我们想要 <strong>查找的关键字是 9</strong> ，那么步骤可以分为以下几步：</p><ol><li>我们与根节点的关键字 (17，35）进行比较，9 小于 17 那么得到指针 P1；</li><li>按照指针 P1 找到磁盘块 2，关键字为（8，12），因为 9 在 8 和 12 之间，所以我们得到指针 P2；</li><li>按照指针 P2 找到磁盘块 6，关键字为（9，10），然后我们找到了关键字 9。</li></ol><p>你能看出来在 B 树的搜索过程中，我们比较的次数并不少，但如果把数据读取出来然后在内存中进行比较，这个时间就是可以忽略不计的。而读取磁盘块本身需要进行 I/O 操作，消耗的时间比在内存中进行比较所需要的时间要多，是数据查找用时的重要因素。 <strong>B 树相比于平衡二叉树来说磁盘 I/O 操作要少</strong> ，在数据查询中比平衡二叉树效率要高。所以 <strong>只要树的高度足够低，IO次数足够少，就可以提高查询性能</strong> 。  </p><p><strong>小结:</strong></p><ol><li>B树在插入和删除节点的时候如果导致树不平衡，就通过自动调整节点的位置来保持树的自平衡。</li><li>关键字集合分布在整棵树中,即**叶子节点和非叶子节点都存放数据 **(如8这个非叶子节点就会存放数据)。搜索有可能在非叶子节点结束.</li><li>其搜索性能等价于在关键字全集内做一次二分查找。</li></ol><p><strong>再举例1：</strong>  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220118115030993.png" alt="image-20220118115030993"></p><h2 id="6-6-B-Tree"><a href="#6-6-B-Tree" class="headerlink" title="6.6 B+Tree"></a>6.6 B+Tree</h2><p>B+树也是一种多路搜索树，<strong>基于B树做出了改进</strong>，主流的DBMS都支持B+树的索引方式，比如MySQL。相比于B-Tree，B+Tree适合文件索引系统。</p><p>MySQL官网说明：  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220118115713457.png" alt="image-20220118115713457"></p><p><strong>B+ 树和 B 树的差异：</strong></p><ol><li>有 k 个孩子的节点就有 k 个关键字。也就是孩子数量 = 关键字数，而 B 树中，孩子数量 = 关键字数+1。</li><li>非叶子节点的关键字也会同时存在在子节点中，并且是在子节点中所有关键字的最大（或最小）。</li><li>非叶子节点仅用于索引，不保存数据记录，跟记录有关的信息都放在叶子节点中。而 B 树中， <strong>非叶子节点既保存索引，也保存数据记录</strong> 。</li><li>所有关键字都在叶子节点出现，叶子节点构成一个有序链表，而且叶子节点本身按照关键字的大小从小到大顺序链接。</li></ol><pre class="line-numbers language-none"><code class="language-none">B 树和 B+ 树都可以作为索引的数据结构，在 MySQL 中采用的是 B+ 树。但B树和B+树各有自己的应用场景，不能说B+树完全比B树好，反之亦然  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>整个过程一共进行了3次I/O操作，看起来B+树和B树的查询过程差不多，但是B+树和B树有个根本的差异在于，<strong>B+树的中间节点并不直接存储数据</strong>。这样的好处都有什么呢?</p><p>首先，B+树查询效率更稳定。因为B+树每次只有访问到叶子节点才能找到对应的数据，而在B树中，非叶子节点也会存储数据，这样就会造成查询效率不稳定的情况，有时候访问到了非叶子节点就可以找到关键字，而有时需要访问到叶子节点才能找到关键字。</p><p>其次，B+树的查询效率更高。这是因为通常B+树比B树更矮胖(阶数更大，深度更低)，查询所需要的磁盘I/o也会更少。同样的磁盘页大小，B+树可以存储更多的节点关键字。</p><p>不仅是对单个关键字的查询上，<strong>在查询范围上，B+树的效率也比B树高。</strong>这是因为所有关键字都出现在B+树的叶子节点中，叶子节点之间会有指针，数据又是递增的，这使得我们范围查找可以通过指针连接查找。而在B树中则需要通过中序遍历才能完成查询范围的查找，效率要低很多。</p><h1 id="面试造火箭计划！！！"><a href="#面试造火箭计划！！！" class="headerlink" title="面试造火箭计划！！！"></a>面试造火箭计划！！！</h1><p><strong>思考题：为了减少IO，索引树会一次性加载吗？</strong></p><p>1、数据库索引是存储在磁盘上的，如果数据量很大，必然导致索引的大小也会很大，超过几个G。<br>2、当我们利用索引查询时候，是不可能将全部几个G的索引都加载进内存的，我们能做的只能是:逐一加载每一个磁盘页，因为磁盘页对应着索引树的节点。</p><p><strong>思考题：B+树的存储能力如何？为何说一般查找行记录，最多只需1~3次磁盘IO</strong></p><p>InnoDB存储引擎中页的大小为1<strong>6KB</strong>，一般表的主键类型为INT(占用4个字节)或BIGINT(占用8个字节)，指针类型也一般为4或8个字节，也就是说一个页(B+Tree中的一个节点)中大概存储16KB/(8B+8B)=<strong>1K个键值</strong>(因为是估值，为方便计算，这里的K取值为10^3。也就是说一个深度为3的B+Tree索引可以维护10^3<em>10^3</em>10^3= <strong>10亿条记录</strong>。(这里假定一个数据页也存储10^3条行记录数据了)</p><p>实际情况中每个节点可能不能填充满，因此在数据库中，<strong>B+Tree 的高度一般都在2~4层</strong>。MySQL的InnoDB存储引擎在设计时是将根<strong>节点常驻内存的</strong>，也就是说查找某一键值的行记录时最多只需要<strong>1~3次</strong>磁盘1/o操作。</p><p><strong>思考题：为什么说B+树比B-树更适合实际应用中操作系统的文件索引和数据库索引？</strong></p><p>1、B+树的磁盘读写代价更低</p><p>B+树的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。</p><p>2、B+树的查询效率更加稳定</p><p>由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</p><p><strong>思考题：Hash 索引与 B+ 树索引的区别</strong></p><p>我们之前讲到过B+树索引的结构，Hash索引结构和B+树的不同，因此在索引使用上也会有差别</p><p>1、Hash索引<strong>不能进行范围查询，而B+树可以</strong>。这是因为Hash索引指向的数据是无序的，而B+树的叶子节点是个有序的链表。</p><p>2、Hash索引<strong>不支持联合索引的最左侧原则</strong>(即联合索引的部分索引无法使用)，而B+树可以。对于联合索引来说，Hash索引在计算Hash值的时候是将索引键合并后再一起计算Hash值，所以不会针对每个索引单独计算 Hash值。因此如果用到联合索引的一个或者几个索引时，联合索引无法被利用。</p><p>3、Hash索引<strong>不支持ORDER BY排序</strong>，因为Hash索引指向的数据是无序的，因此无法起到排序优化的作用，而<strong>B+树索引数据是有序的</strong>，可以起到对该字段ORDER BY排序优化的作用。同理，我们也<strong>无法用Hash索引进行模糊查询</strong>，而B+树使用LIKE进行模糊查询的时候，LIKE后面后模糊查询（比如%结尾）的话就可以起到优化的作用。</p><p>4.InnoDB不支持哈希索引。</p><p><strong>思考题：Hash 索引与 B+ 树索引是在建索引的时候手动指定的吗？</strong>  </p><p>如果使用的是MysQL的话，我们需要了解MySQL的存储引擎都支持哪些索引结构，如下图所示（参考来源https:/dev.mysql.com/doc/refman/8.0/en/create-index.html)。如果是其他的DBMS，可以参考相关的DBMS文档。</p><p><img src="/2022/01/15/%E7%B4%A2%E5%BC%95/01/15/%E7%B4%A2%E5%BC%95/Users/Li\AppData\Roaming\Typora\typora-user-images\image-20220118120907649.png" alt="image-20220118120907649"></p><p>你能看到，针对 <strong>InnoDB和MyISAM</strong>存储引擎，都会<strong>默认采用B+树索引，无法使用 Hash索引</strong>。InnoDB提供的<strong>自适应Hash是不需要手动指定的</strong>。如果是Memory/Heap和NDB存储引擎，是可以进行选择Hash索引的。</p>]]></content>
      
      
      <categories>
          
          <category> database </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>02 | 日志系统：一条SQL更新语句是如何执行的？（数据库使用InnoDB恢复原理）</title>
      <link href="/2022/01/13/%E4%B8%A4%E4%B8%AA%E9%87%8D%E8%A6%81%E6%97%A5%E5%BF%97%E5%8F%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D/"/>
      <url>/2022/01/13/%E4%B8%A4%E4%B8%AA%E9%87%8D%E8%A6%81%E6%97%A5%E5%BF%97%E5%8F%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="两个重要日志及数据库恢复"><a href="#两个重要日志及数据库恢复" class="headerlink" title="两个重要日志及数据库恢复"></a>两个重要日志及数据库恢复</h1><p>一条更新语句的执行流程又是怎样的呢？</p><p>之前你可能经常听 DBA 同事说，MySQL 可以恢复到半个月内任意一秒的状态，惊叹的同时，你是不是心中也会不免会好奇，这是怎样做到的呢？</p><p>我们还是从一个表的一条更新语句说起，下面是这个表的创建语句，这个表有一个主键 ID 和一个整型字段 age：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">create</span> <span class="token keyword">table</span> T<span class="token punctuation">(</span>ID <span class="token keyword">int</span> <span class="token keyword">primary</span> <span class="token keyword">key</span><span class="token punctuation">,</span> age <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果要将 ID=2 这一行的值加 1，SQL 语句就会这么写：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">update</span> T <span class="token keyword">set</span> age<span class="token operator">=</span>age<span class="token operator">+</span><span class="token number">1</span> <span class="token keyword">where</span> ID<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>前面我有跟你介绍过 SQL 语句基本的执行链路，这里我再把那张图拿过来，你也可以先简单看看这个图回顾下。首先，可以确定的说，查询语句的那一套流程，更新语句也是同样会走一遍。</p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/0d2070e8f84c4801adbfa03bda1f98d9.png" alt="MySQL 的逻辑架构图" style="zoom:33%;"><p>执行语句前要先连接数据库，这是连接器的工作。</p><p>前面我们说过，在一个表上有更新的时候，跟这个表有关的查询缓存会失效，所以这条语句就会把表 T 上所有缓存结果都清空。这也就是我们一般不建议使用查询缓存的原因。</p><p>接下来，分析器会通过词法和语法解析知道这是一条更新语句。优化器决定要使用 ID 这个索引。然后，执行器负责具体执行，找到这一行，然后更新。</p><p>与查询流程不一样的是，更新流程还涉及两个重要的日志模块，它们正是我们今天要讨论的主角：<code>redo log（重做日志）</code>和<code> binlog（归档日志）</code>。</p><h2 id="重要的日志模块：redo-log"><a href="#重要的日志模块：redo-log" class="headerlink" title="重要的日志模块：redo log"></a>重要的日志模块：redo log</h2><p>不知道你还记不记得《孔乙己》这篇文章，酒店掌柜有一个粉板，专门用来记录客人的赊账记录。如果赊账的人不多，那么他可以把顾客名和账目写在板上。但如果赊账的人多了，粉板总会有记不下的时候，这个时候掌柜一定还有一个专门记录赊账的账本。</p><p>如果有人要赊账或者还账的话，掌柜一般有两种做法：</p><ul><li>一种做法是直接把账本翻出来，把这次赊的账加上去或者扣除掉；</li><li>另一种做法是先在粉板上记下这次的账，等打烊以后再把账本翻出来核算。</li></ul><p>在生意红火柜台很忙时，掌柜一定会选择后者，因为前者操作实在是太麻烦了。首先，你得找到这个人的赊账总额那条记录。你想想，密密麻麻几十页，掌柜要找到那个名字，可能还得带上老花镜慢慢找，找到之后再拿出算盘计算，最后再将结果写回到账本上。</p><p>这整个过程想想都麻烦。相比之下，还是先在粉板上记一下方便。你想想，如果掌柜没有粉板的帮助，每次记账都得翻账本，效率是不是低得让人难以忍受？</p><p>同样，在 MySQL 里也有这个问题，如果每一次的更新操作都需要写进磁盘，然后磁盘也要找到对应的那条记录，然后再更新，整个过程 IO 成本、查找成本都很高。为了解决这个问题，MySQL 的设计者就用了类似酒店掌柜粉板的思路来提升更新效率。</p><p>而粉板和账本配合的整个过程，其实就是 MySQL 里经常说到的 <code>WAL 技术</code>，WAL 的全称是 <code>Write-Ahead Logging</code>，它的关键点就是<strong>先写日志，再写磁盘</strong>，也就是先写粉板，等不忙的时候再写账本。</p><p>具体来说，当有一条记录需要更新的时候，<code>InnoDB </code>引擎就会<strong>先把记录写到 redo log</strong>（粉板）里面，<strong>并更新内存</strong>，这个时候更新就算完成了。同时，<code>InnoDB </code>引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做，这就像打烊以后掌柜做的事。</p><p>如果今天赊账的不多，掌柜可以等打烊后再整理。但如果某天赊账的特别多，粉板写满了，又怎么办呢？这个时候掌柜只好放下手中的活儿，把粉板中的一部分赊账记录更新到账本中，然后把这些记录从粉板上擦掉，为记新账腾出空间。</p><p>与此类似，<strong>InnoDB 的 redo log 是固定大小的</strong>，比如可以配置为一组 4 个文件，每个文件的大小是 1GB，那么这块“粉板”总共就可以记录 4GB 的操作。从头开始写，写到末尾就又回到开头<strong>循环写</strong>，如下面这个图所示。</p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/16a7950217b3f0f4ed02db5db59562a7.png" alt style="zoom: 67%;"><p><strong>write pos</strong> 是当前记录的位置，一边写一边后移，写到第 3 号文件末尾后就回到 0 号文件开头。<strong>checkpoint</strong> 是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。</p><p>write pos 和 checkpoint 之间的是“粉板”上还空着的部分，可以用来记录新的操作。如果 write pos 追上 checkpoint，表示“粉板”满了，这时候不能再执行新的更新，得停下来先擦掉一些记录，把 checkpoint 推进一下。</p><p>有了 redo log，<code>InnoDB</code> 就<strong>可以保证即使数据库发生异常重启，之前提交的记录都不会丢失</strong>，这个能力称为 <strong>crash-safe</strong>。</p><p>要理解 crash-safe 这个概念，可以想想我们前面赊账记录的例子。只要赊账记录记在了粉板上或写在了账本上，之后即使掌柜忘记了，比如突然停业几天，恢复生意后依然可以通过账本和粉板上的数据明确赊账账目。</p><h2 id="重要的日志模块：binlog"><a href="#重要的日志模块：binlog" class="headerlink" title="重要的日志模块：binlog"></a>重要的日志模块：binlog</h2><p>前面我们讲过，MySQL 整体来看，其实就有两块：一块是 Server 层，它主要做的是 MySQL 功能层面的事情；还有一块是引擎层，负责存储相关的具体事宜。上面我们聊到的粉板 <strong>redo log 是 <code>InnoDB </code>引擎特有的日志</strong>，而 Server 层也有自己的日志，称为 <code>binlog</code>（归档日志）。</p><p>为什么会有两份日志呢？</p><p>因为最开始 MySQL 里并没有<code>InnoDB</code>引擎。MySQL 自带的引擎是 <code>MyISAM</code>，但是<code>MyISAM</code>没有 crash-safe 的能力，<code>binlog </code>日志只能用于归档。而<code>InnoDB</code>是另一个公司以插件形式引入 MySQL 的，既然只依靠 <code>binlog </code>是没有 crash-safe 能力的，所以 <code>InnoDB</code> 使用另外一套日志系统——也就是 <strong>redo log 来实现 crash-safe 能力</strong>。</p><h2 id="redo-log-和-binlog的区别"><a href="#redo-log-和-binlog的区别" class="headerlink" title="redo log 和 binlog的区别"></a>redo log 和 binlog的区别</h2><p>两种日志有以下三点不同。</p><ol><li>redo log 是 InnoDB 引擎特有的；<strong>binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用</strong>。redo log 是<strong>物理日志</strong>，记录的是“在某个数据页上做了什么修改”；</li><li>binlog 是<strong>逻辑日志</strong>，记录的是这个语句的原始逻辑，比如“给 ID=2 这一行的 age字段加 1 ”。<strong>redo log 是循环写的，空间固定会用完</strong>；</li><li>binlog 是可以<strong>追加写</strong>入的。“追加写”是指 binlog 文件写到一定大小后会切换到下一个，<strong>并不会覆盖以前的日志</strong>。</li></ol><h2 id="update-语句的执行流程"><a href="#update-语句的执行流程" class="headerlink" title="update 语句的执行流程"></a><strong>update 语句的执行流程</strong></h2><h3 id="update-语句执行流程图"><a href="#update-语句执行流程图" class="headerlink" title="update 语句执行流程图"></a><strong>update 语句执行流程图</strong></h3><p>图中浅色框表示是在 InnoDB 内部执行的，深色框表示是在执行器中执行的。</p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/2e5bff4910ec189fe1ee6e2ecc7b4bbe.png" alt="update 语句的执行流程图" style="zoom:67%;"><h3 id="update-语句执行步骤"><a href="#update-语句执行步骤" class="headerlink" title="update 语句执行步骤"></a>update 语句执行步骤</h3><ol><li><p>执行器：找存储引擎取到 id = 2 这一行记录</p></li><li><p>存储引擎：根据主键索引树找到这一行，如果 id = 2 这一行所在的数据页本来就在内存池（Buffer Pool）中，就直接返回给执行器；否则，需要先从磁盘读入内存池，然后再返回</p></li><li><p><a href="https://www.zhihu.com/search?q=%E6%89%A7%E8%A1%8C%E5%99%A8&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2280710259%7D">执行器</a>：拿到存储引擎返回的行记录，把 age 字段加上 1，得到一行新的记录，然后再调用存储引擎的接口写入这行新记录</p></li><li><p>存储引擎：将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 <code>prepare</code> 状态。然后告知执行器执行完成了，随时可以提交事务</p><p>注意:不要把这里的提交事务和我们 sql 语句中的提交事务 commit 命令搞混了哈，我们这里说的提交事务，指的是事务提交过程中的一个小步骤，也是最后一步。当这个步骤执行完成后，commit 命令就执行成功了。</p></li><li><p>执行器：生成这个操作的 bin log，并把 bin log 写入磁盘</p></li><li><p>执行器：调用存储引擎的提交事务接口</p></li><li><p>存储引擎：把刚刚写入的 redo log 状态改成提交（<code>commit</code>）状态，更新完成</p></li></ol><p>请格外注意和理解为什么将<code>redo log</code>的写入拆成了<strong>两个步骤</strong>：<code>prepare </code>和 <code>commit</code>，这就是**”两阶段提交”**。</p><p>为什么这样设计就能<strong>实现数据库崩溃后还能恢复数据</strong>呢？</p><h2 id="为什么说-redo-log-具有崩溃恢复的能力"><a href="#为什么说-redo-log-具有崩溃恢复的能力" class="headerlink" title="为什么说 redo log 具有崩溃恢复的能力"></a>为什么说 redo log 具有崩溃恢复的能力</h2><p>redo log 和 bin log 的一个很大的区别就是，一个是<strong>循环写</strong>，一个是追加写。也就是说 <strong>redo log 只会记录未刷入磁盘的日志</strong>，已经刷入磁盘的数据都会从 redo log 这个有限大小的日志文件里删除。</p><p>而 bin log 是追加日志，<strong>保存的是全量的日志</strong>。这就会导致一个问题，那就是没有标志能让 InnoDB 从 bin log 中判断哪些数据已经刷入磁盘了，哪些数据还没有。</p><p>举个例子，bin log 记录了两条日志：</p><pre class="line-numbers language-none"><code class="language-none">记录 1：给 id &#x3D; 1 这一行的 age 字段加 1记录 2：给 id &#x3D; 1 这一行的 age 字段加 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>假设在记录 1 刷盘后，记录 2 未刷盘时，数据库崩溃。重启后，只通过 bin log 数据库是无法判断这两条记录哪条已经写入磁盘，哪条没有写入磁盘，不管是两条都恢复至内存，还是都不恢复，对 id = 1 这行数据来说，都是不对的。</p><p>但 redo log 不一样，只要刷入磁盘的数据，都会从 redo log 中被抹掉，数据库重启后，直接把 redo log 中的数据都恢复至内存就可以了。</p><p>这就是为什么说 <strong>redo log 具有崩溃恢复的能力，而 bin log 不具备</strong>。</p><h2 id="崩溃恢复时的判断规则"><a href="#崩溃恢复时的判断规则" class="headerlink" title="崩溃恢复时的判断规则"></a>崩溃恢复时的判断规则</h2><p>根据两阶段提交，<strong>崩溃恢复时的判断规则</strong>是这样的：</p><ol><li>如果 redo log 里面的事务是完整的，也就是已经有了 commit 标识，则直接提交</li><li>如果 redo log 里面的事务处于 prepare 状态，则判断对应的事务 binlog 是否存在并完整</li></ol><ul><li>a. 如果 binlog 存在并完整，则提交事务；</li><li>b. 否则，回滚事务。</li></ul><h3 id="数据库崩溃例一"><a href="#数据库崩溃例一" class="headerlink" title="数据库崩溃例一"></a>数据库崩溃例一</h3><p>如下图所示，假设数据库在<strong>写入 redo log(prepare) 阶段之后、写入 binlog 之前</strong>，发生了崩溃，此时 redo log 里面的事务处于 prepare 状态，binlog 还没写（对应 2b），所以崩溃的时候，这个事务会回滚。</p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/v2-a26e4c7c6d2e1c89ed9c2296798e7899_720w.jpg" alt="img" style="zoom: 67%;"><p>原因：</p><p>此时 redo log 里面的事务处于 prepare 状态，binlog 还没写，之后从库进行同步的时候，无法执行这个操作，但是实际上主库已经完成了这个操作，所以为了主备一致，MySQL 崩溃时会在主库上回滚这个事务。并且，由于 binlog 还没写，所以也就不会传到备库，从而避免主备不一致的情况。</p><h3 id="数据库崩溃例二"><a href="#数据库崩溃例二" class="headerlink" title="数据库崩溃例二"></a>数据库崩溃例二</h3><p>如果数据库在写入 binlog 之后，redo log 状态修改为 commit 前发生崩溃，此时 redo log 里面的事务仍然是 prepare 状态，binlog 存在并完整（对应 2a），所以即使在这个时刻数据库崩溃了，事务仍然会被正常提交。</p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/v2-94ec46b4b750cdf6bd913b5d9eedcb53_720w.jpg" alt="img" style="zoom:67%;"><p>原因：</p><p>因为 binlog 已经写入成功了，这样之后就会被从库同步过去，但是实际上主库并没有完成这个操作，所以为了主备一致，在<a href="https://www.zhihu.com/search?q=%E4%B8%BB%E5%BA%93&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2280710259%7D">主库</a>上需要提交这个事务。</p><h2 id="redo-log-两阶段提交的必要性"><a href="#redo-log-两阶段提交的必要性" class="headerlink" title="redo log 两阶段提交的必要性"></a>redo log <strong>两阶段提交的必要性</strong></h2><p>可不可以先 redo log 写完，再写 bin log 或者反过来？</p><h3 id="1）对于先写完-redo-log-后写-bin-log-的情况："><a href="#1）对于先写完-redo-log-后写-bin-log-的情况：" class="headerlink" title="1）对于先写完 redo log 后写 bin log 的情况："></a>1）对于先写完 redo log 后写 bin log 的情况：</h3><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/v2-b690e860bdb751e57e14af362ba16647_720w.jpg" alt="img" style="zoom:67%;"><p>假设在 <strong>redo log 写完，binlog 还没有写完</strong>的时候，MySQL 进程异常重启。由于我们前面说过的，redo log 写完之后，系统即使崩溃，仍然能够把数据恢复回来，所以恢复后这一行 age 的值是 1。但是由于 binlog 没写完就 crash 了，这时候 binlog 里面就没有记录这个语句。</p><p>因此，之后备份日志的时候，存起来的 binlog 里面就没有这条语句。然后你会发现，如果需要用这个 binlog 来恢复临时库的话，由于这个语句的 binlog 丢失，这个临时库就会少了这一次更新，恢复出来的这一行 c 的值就是 0，与原库的值不同。</p><h3 id="2）对于先写完-binlog-后写-redo-log-的情况："><a href="#2）对于先写完-binlog-后写-redo-log-的情况：" class="headerlink" title="2）对于先写完 binlog 后写 redo log 的情况："></a>2）对于先写完 binlog 后写 redo log 的情况：</h3><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/v2-df3f63c6451613af1dcc4324677f1e4f_720w.jpg" alt="img" style="zoom:67%;"><p>如果在 binlog 写完之后 crash，由于 redo log 还没写，崩溃恢复以后这个事务无效，所以这一行 c 的值是 0。但是 binlog 里面已经记录了“把 c 从 0 改成 1”这个日志。所以，在之后用 binlog 来恢复的时候就多了一个事务出来，恢复出来的这一行 c 的值就是 1，与原库的值不同。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Bin log 用于记录了完整的逻辑记录，所有的逻辑记录在 bin log 里都能找到，所以在备份恢复时，是以 bin log 为基础，通过其记录的完整逻辑操作，备份出一个和原库完整的数据。</p><h2 id="面试造火箭计划！！！"><a href="#面试造火箭计划！！！" class="headerlink" title="面试造火箭计划！！！"></a>面试造火箭计划！！！</h2><ol><li><p>redo log的概念是什么? 为什么会存在.</p><p>答： redo log是重做日志。主要用于MySQL异常重启后的一种数据恢复手段，确保了数据的一致性。归根到底是MySQL为了实现WAL机制的一种手段。因为MySQL进行更新操作，为了能够快速响应，所以采用了异步写回磁盘的技术，写入内存后就返回。但是会存在crash后内存数据丢失的隐患，而redo log具备crash safe能力。</p></li><li><p>什么是<code>WAL(write-ahead log)</code>机制, 好处是什么.</p><p>答： WAL机制是<strong>先写日志，再写磁盘</strong>。也就是MySQL更新操作后在真正把数据写入到磁盘前先记录日志。好处是不用每一次操作都实时把数据写盘，就算crash后也可以通过redo log重放恢复，所以能够实现快速响应SQL语句。</p></li><li><p>redo log 为什么可以保证crash safe机制.</p><p>答： 因为redo log是每次更新操作完成后，就一定会写入的，如果写入失败，这说明此次操作失败，事务也不可能提交。redo log内部结构是基于页的，记录了这个页的字段值变化，只要crash后读取redo log进行重放就可以恢复数据。（因为redo log是循环写的，如果满了InnoDB就会执行真正写盘）</p></li><li><p>binlog的概念是什么, 起到什么作用, 可以做crash safe吗?</p><p>答：  bin log是归档日志，属于MySQL Server层的日志。可以起到全量备份的作用。当需要恢复数据时，可以取出某个时间范围内的bin log进行重放恢复。但是bin log不可以做crash safe，因为crash之前，bin log可能没有写入完全MySQL就挂了。所以需要配合redo log才可以进行crash safe。</p></li><li><p>binlog 和 redolog的不同点有哪些?</p><p>答案：参考上面笔记。</p></li><li><p>物理一致性和逻辑一直性各应该怎么理解?</p><p>答: binlog 是逻辑日志，可以给别的数据库，别的引擎使用，已经大家都讲得通这个“逻辑”；redolog是物理日志，就只有“我”自己能用，别人没有共享我的“物理格式”</p></li><li><p>执行器和innoDB在执行update语句时候的流程是什么样的?</p><p>答案：参考上面笔记。</p></li><li><p>如果数据库误操作, 如何执行数据恢复?</p><p>答：数据库在某一天误操作，就可以找到距离误操作最近的时间节点前的bin log，重放到临时数据库里，然后选择当天误删的数据恢复到线上数据库。</p></li><li><p>什么是两阶段提交, 为什么需要两阶段提交, 两阶段提交怎么保证数据库中两份日志间的逻辑一致性(什么叫逻辑一致性)?</p><p>答案：参考上面笔记。</p></li><li><p>如果不是两阶段提交, 先写redo log和先写bin log两种情况各会遇到什么问题?</p><p>答案：参考上面笔记。</p></li></ol><h2 id="一些名词"><a href="#一些名词" class="headerlink" title="一些名词"></a>一些名词</h2><p>数据页 ：MySQL的记录是以“页”为单位存取的，默认大小16K。也就是说，你要访问磁盘中一个记录，不会只读这个记录，而会把它所在的16K数据一起读入内存</p>]]></content>
      
      
      <categories>
          
          <category> database </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>01 | 基础架构：一条SQL查询语句是如何执行的？</title>
      <link href="/2022/01/12/%E4%B8%80%E6%9D%A1SQL%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/"/>
      <url>/2022/01/12/%E4%B8%80%E6%9D%A1SQL%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/</url>
      
        <content type="html"><![CDATA[<h1 id="基础架构：一条SQL查询语句是如何执行的？"><a href="#基础架构：一条SQL查询语句是如何执行的？" class="headerlink" title="基础架构：一条SQL查询语句是如何执行的？"></a>基础架构：一条SQL查询语句是如何执行的？</h1><p>下面我给出的是 <strong>MySQL 的基本架构示意图</strong>，从中你可以清楚地看到 SQL 语句在 MySQL 的各个功能模块中的执行过程。</p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/0d2070e8f84c4801adbfa03bda1f98d9.png" alt="img" style="zoom: 33%;"><p>大体来说，MySQL 可以分为 <code>Server 层</code>和<code>存储引擎层</code>两部分。</p><p><strong>Server 层</strong>包括连接器、查询缓存、分析器、优化器、执行器等，涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），<strong>所有跨存储引擎的功能都在这一层实现</strong>，比如存储过程、触发器、视图等。</p><p><strong>存储引擎层</strong>负责<code>数据的存储和提取</code>。其架构模式是<strong>插件式</strong>的，支持 InnoDB、MyISAM、Memory 等多个存储引擎。现在最常用的存储引擎是 InnoDB（支持事务），它从 MySQL 5.5.5 版本开始成为了默认存储引擎。</p><p>从图中不难看出，<strong>不同的存储引擎共用一个 Server 层</strong>，也就是从连接器到执行器的部分。</p><h2 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h2><p>第一步，你会先连接到这个数据库上，这时候接待你的就是连接器。连接器负责跟客户端建立连接、获取权限、维持和管理连接。连接命令一般是这么写的：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql <span class="token operator">-</span>h$ip <span class="token operator">-</span>P$port <span class="token operator">-</span>u$<span class="token keyword">user</span> <span class="token operator">-</span>p<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>输完命令之后，你就需要在交互对话里面输入密码。</p><p>连接完成后，如果你没有后续的动作，这个连接就处于空闲状态，你可以在<code>show processlist</code>命令中看到它。文本中这个图是 <code>show processlist </code>的结果，其中的 Command 列显示为“Sleep”的这一行，就表示现在系统里面有一个空闲连接。</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/f2da4aa3a672d48ec05df97b9f992fed.png" alt="img"></p><p>客户端如果太长时间没动静，连接器就会自动将它断开。这个时间是由参数 <code>wait_timeout </code>控制的，默认值是 8 小时。</p><p>数据库里面，长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。</p><p>建立连接的过程通常是比较复杂的，<strong>尽量减少建立连接的动作，也就是尽量使用长连接。</strong></p><p>但是全部使用长连接后，你可能会发现，有些时候 MySQL 占用内存涨得特别快，这是因为 MySQL 在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候才释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉（OOM），从现象看就是 MySQL 异常重启了。</p><p>怎么解决这个问题呢？你可以考虑以下两种方案。</p><ol><li>定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。</li><li>如果你用的是 <code>MySQL 5.7 </code>或更新版本，可以在每次执行一个比较大的操作后，通过执行<code>mysql_reset_connection</code>来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。</li></ol><h2 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h2><p>连接建立完成后，你就可以执行 <code>select</code> 语句了。执行逻辑就会来到第二步：查询缓存。</p><p>MySQL 拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。之前执行过的语句及其结果可能会以 key-value 对的形式，被直接缓存在内存中。key 是查询的语句，value 是查询的结果。如果你的查询能够直接在这个缓存中找到 key，那么这个 value 就会被直接返回给客户端。如果语句不在查询缓存中，就会继续后面的执行阶段。执行完成后，执行结果会被存入查询缓存中。你可以看到，如果查询命中缓存，MySQL 不需要执行后面的复杂操作，就可以直接返回结果，这个效率会很高。</p><p>缺点：</p><p>查询缓存的失效非常频繁，<strong>只要有对一个表的更新，这个表上所有的查询缓存都会被清空</strong>。因此很可能你费劲地把结果存起来，还没使用呢，就被一个更新全清空了。对于更新压力大的数据库来说，查询缓存的命中率会非常低。除非你的业务就是有一张静态表，很长时间才会更新一次。比如，一个系统配置表，那这张表上的查询才适合使用查询缓存。</p><p><strong>MySQL 8.0 版本直接将查询缓存的整块功能删掉了，也就是说 8.0 开始彻底没有这个功能了。</strong></p><h2 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h2><p>如果没有命中查询缓存，就要开始真正执行语句了。首先，MySQL 需要知道你要做什么，因此需要对 SQL 语句做解析。</p><p>分析器先会做“词法分析”。你输入的是由多个字符串和空格组成的一条 SQL 语句，MySQL 需要识别出里面的字符串分别是什么，代表什么。</p><p>MySQL 从你输入的”select”这个关键字识别出来，这是一个查询语句。它也要把字符串“T”识别成“表名 T”，把字符串“ID”识别成“列 ID”。</p><p>做完了这些识别以后，就要做“语法分析”。根据词法分析的结果，语法分析器会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法。</p><p>如果你的语句不对，就会收到<code>“You have an error in your SQL syntax”</code>的错误提醒，比如下面这个语句 select 少打了开头的字母“s”。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">></span> elect <span class="token operator">*</span> <span class="token keyword">from</span> t <span class="token keyword">where</span> ID<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>ERROR <span class="token number">1064</span> <span class="token punctuation">(</span><span class="token number">42000</span><span class="token punctuation">)</span>: You have an error <span class="token operator">in</span> your <span class="token keyword">SQL</span> syntax<span class="token punctuation">;</span> <span class="token keyword">check</span> the manual that corresponds <span class="token keyword">to</span> your MySQL server version <span class="token keyword">for</span> the <span class="token keyword">right</span> syntax <span class="token keyword">to</span> <span class="token keyword">use</span> near <span class="token string">'elect * from t where ID=1'</span> at line <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>一般语法错误会<strong>提示第一个出现错误的位置</strong>，所以你要关注的是紧接<code>“use near”</code>的内容。</p><h2 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h2><p>经过了分析器，MySQL 就知道你要做什么了。在开始执行之前，还要先经过优化器的处理。</p><p>优化器是在表里面有多个索引的时候，<strong>决定使用哪个索引</strong>；或者在一个语句有多表关联（join）的时候，<strong>决定各个表的连接顺序</strong>。比如你执行下面这样的语句，这个语句是执行两个表的 join：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t1 <span class="token keyword">join</span> t2 <span class="token keyword">using</span><span class="token punctuation">(</span>ID<span class="token punctuation">)</span> <span class="token keyword">where</span> t1<span class="token punctuation">.</span>c<span class="token operator">=</span><span class="token number">10</span> <span class="token operator">and</span> t2<span class="token punctuation">.</span>d<span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>既可以先从表 t1 里面取出 c=10 的记录的 ID 值，再根据 ID 值关联到表 t2，再判断 t2 里面 d 的值是否等于 20。</p><p>也可以先从表 t2 里面取出 d=20 的记录的 ID 值，再根据 ID 值关联到 t1，再判断 t1 里面 c 的值是否等于 10。</p><p>这两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪一个方案。优化器阶段完成后，这个语句的执行方案就确定下来了，然后进入执行器阶段。</p><h2 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h2><p>MySQL 通过分析器知道了你要做什么，通过优化器知道了该怎么做，于是就进入了执行器阶段，开始执行语句。</p><p>开始执行的时候，要先判断一下你对这个表 T 有没有执行查询的权限，如果没有，就会返回没有权限的错误，如下所示 (在工程实现上，如果命中查询缓存，会在查询缓存返回结果的时候，做权限验证。查询也会在优化器之前调用 precheck 验证权限)。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> T <span class="token keyword">where</span> ID<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">;</span>ERROR <span class="token number">1142</span> <span class="token punctuation">(</span><span class="token number">42000</span><span class="token punctuation">)</span>: <span class="token keyword">SELECT</span> command denied <span class="token keyword">to</span> <span class="token keyword">user</span> <span class="token string">'b'</span><span class="token variable">@'localhost'</span> <span class="token keyword">for</span> <span class="token keyword">table</span> <span class="token string">'T'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口。</p><p>比如我们这个例子中的表 T 中，ID 字段没有索引，那么执行器的执行流程是这样的：</p><p>调用 InnoDB 引擎接口取这个表的第一行，判断 ID 值是不是 10，如果不是则跳过，如果是则将这行存在结果集中；</p><p>调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。</p><p>执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。</p><p>至此，这个语句就执行完成了。</p><p>对于有索引的表，执行的逻辑也差不多。第一次调用的是“取满足条件的第一行”这个接口，之后循环取“满足条件的下一行”这个接口，这些接口都是引擎中已经定义好的。</p><p>你会在数据库的慢查询日志中看到一个<code>rows_examined</code>的字段，表示这个语句执行过程中扫描了多少行。这个值就是在执行器每次调用引擎获取数据行的时候累加的。</p><p>在有些场景下，执行器调用一次，在引擎内部则扫描了多行，因此<strong>引擎扫描行数跟 rows_examined 并不是完全相同的</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> database </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Spiral Matrix</title>
      <link href="/2022/01/11/Spiral-Matrix/"/>
      <url>/2022/01/11/Spiral-Matrix/</url>
      
        <content type="html"><![CDATA[<h2 id="54-螺旋矩阵"><a href="#54-螺旋矩阵" class="headerlink" title="54. 螺旋矩阵"></a><a href="https://leetcode-cn.com/problems/spiral-matrix/">54. 螺旋矩阵</a></h2><p>给你一个 <code>m</code> 行 <code>n</code> 列的矩阵 <code>matrix</code> ，请按照 <strong>顺时针螺旋顺序</strong> ，返回矩阵中的所有元素。</p><p><strong>Example 1:</strong></p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220111194853048.png" alt="image-20220111194853048"></p><pre class="line-numbers language-none"><code class="language-none">Input: matrix &#x3D; [[1,2,3],[4,5,6],[7,8,9]]Output: [1,2,3,6,9,8,7,4,5]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>Example 2:</strong></p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220111195003770.png" alt="image-20220111195003770"></p><pre class="line-numbers language-none"><code class="language-none">Input: matrix &#x3D; [[1,2,3,4],[5,6,7,8],[9,10,11,12]]Output: [1,2,3,4,8,12,11,10,9,5,6,7]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>提示:</strong></p><ul><li><code>m == matrix.length</code></li><li><code>n == matrix[i].length</code></li><li><code>1 &lt;= m, n &lt;= 10</code></li><li><code>-100 &lt;= matrix[i][j] &lt;= 100</code></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>参考<code>[59. 螺旋矩阵 II]</code>，模拟顺时针顺序，依次将数字填入结果链表<code>result</code>中</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> <span class="token function">spiralOrder</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> matrix<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> matrix<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span> top <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> bottom <span class="token operator">=</span> m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> right <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> m <span class="token operator">*</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">//从左到右</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> left<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> right<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                result<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>top<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> m <span class="token operator">*</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">return</span> result<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>            top<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token comment">//从上往下</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> top<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> bottom<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                result<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> m <span class="token operator">*</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">return</span> result<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>            right<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token comment">//从右往左</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> right<span class="token punctuation">;</span> i <span class="token operator">>=</span> left<span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                result<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>bottom<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> m <span class="token operator">*</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">return</span> result<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>            bottom<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token comment">//从下往后上</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> bottom<span class="token punctuation">;</span> i <span class="token operator">>=</span> top<span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                result<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> m <span class="token operator">*</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">return</span> result<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>            left<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="59-螺旋矩阵-II"><a href="#59-螺旋矩阵-II" class="headerlink" title="59. 螺旋矩阵 II"></a><a href="https://leetcode-cn.com/problems/spiral-matrix-ii/">59. 螺旋矩阵 II</a></h2><p>给你一个正整数 <code>n</code> ，生成一个包含 <code>1</code> 到 <code>n2</code> 所有元素，且元素按顺时针顺序螺旋排列的 <code>n x n</code> 正方形矩阵 <code>matrix</code> 。</p><p><strong>示例 1：</strong></p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220111194853048.png" alt="image-20220111194853048"></p><pre class="line-numbers language-none"><code class="language-none">输入：n &#x3D; 3输出：[[1,2,3],[8,9,4],[7,6,5]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>示例 2：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：n &#x3D; 1输出：[[1]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 20</code></li></ul><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ul><li><p>生成一个 <code>n × n </code>空矩阵 mat，随后模拟整个向内环绕的填入过程：</p><ol><li>定义当前左右上下边界<code> l,r,t,b</code>，初始值 num = 1，迭代终止值 <code>tar = n * n</code>；</li><li>当 <code>num &lt;= tar</code> 时，始终按照 从左到右 从上到下 从右到左 从下到上 填入顺序循环，每次填入后：<ul><li>执行 num += 1：得到下一个需要填入的数字；</li><li>更新边界：例如从左到右填完后，上边界 t += 1，相当于上边界向内缩 1。</li></ul></li><li>使用<code>num &lt;= tar</code>而不是<code>l &lt; r || t &lt; b</code>作为迭代条件，是为了解决当n为奇数时，矩阵中心数字无法在迭代过程中被填充的问题。</li></ol></li><li><p>最终返回 mat 即可。</p></li></ul><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/ccff416fa39887c938d36fec8e490e1861813d3bba7836eda941426f13420759-Picture1.png" alt="Picture1.png" style="zoom:67%;"><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">generateMatrix</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> top <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> bottom <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> right <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>         <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> target <span class="token operator">=</span> n <span class="token operator">*</span> n<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>num <span class="token operator">&lt;=</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">//从左到右</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> left<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> right<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                result<span class="token punctuation">[</span>top<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> num<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            top<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token comment">//从上往下</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> top<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> bottom<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                result<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">=</span> num<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            right<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token comment">//从右往左</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> right<span class="token punctuation">;</span> i <span class="token operator">>=</span> left<span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                result<span class="token punctuation">[</span>bottom<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> num<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            bottom<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token comment">//从下往后上</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> bottom<span class="token punctuation">;</span> i <span class="token operator">>=</span> top<span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                result<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">=</span> num<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            left<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="剑指-Offer-29-顺时针打印矩阵"><a href="#剑指-Offer-29-顺时针打印矩阵" class="headerlink" title="剑指 Offer 29. 顺时针打印矩阵"></a><a href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/">剑指 Offer 29. 顺时针打印矩阵</a></h2><p>难度简单335</p><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p><p><strong>示例 1：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：matrix &#x3D; [[1,2,3],[4,5,6],[7,8,9]]输出：[1,2,3,6,9,8,7,4,5]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>示例 2：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：matrix &#x3D; [[1,2,3,4],[5,6,7,8],[9,10,11,12]]输出：[1,2,3,4,8,12,11,10,9,5,6,7]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>限制：</strong></p><ul><li><code>0 &lt;= matrix.length &lt;= 100</code></li><li><code>0 &lt;= matrix[i].length &lt;= 100</code></li></ul><p>注意：本题与主站 54 题相同：<a href="https://leetcode-cn.com/problems/spiral-matrix/">https://leetcode-cn.com/problems/spiral-matrix/</a></p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数组中的双指针相关题目</title>
      <link href="/2022/01/10/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E5%8F%8C%E6%8C%87%E9%92%88%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/"/>
      <url>/2022/01/10/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E5%8F%8C%E6%8C%87%E9%92%88%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="数组中的双指针"><a href="#数组中的双指针" class="headerlink" title="数组中的双指针"></a>数组中的双指针</h1><h2 id="leetcode-26-删除有序数组中的重复项"><a href="#leetcode-26-删除有序数组中的重复项" class="headerlink" title="leetcode 26. 删除有序数组中的重复项"></a><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/">leetcode 26. 删除有序数组中的重复项</a></h2><p>给你一个有序数组 <code>nums</code> ，请你**<a href="http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95"> 原地</a>** 删除重复出现的元素，使每个元素 <strong>只出现一次</strong> ，返回删除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在 <strong><a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地 </a>修改输入数组</strong> 并在使用 O(1) 额外空间的条件下完成。</p><p><strong>说明:</strong></p><p>为什么返回数值是整数，但输出的答案是数组呢?</p><p>请注意，输入数组是以<strong>「引用」</strong>方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下:</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝int len &#x3D; removeDuplicates(nums);&#x2F;&#x2F; 在函数里修改输入数组对于调用者是可见的。&#x2F;&#x2F; 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。for (int i &#x3D; 0; i &lt; len; i++) &#123;    print(nums[i]);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例 1：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：nums &#x3D; [1,1,2]输出：2, nums &#x3D; [1,2]解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>示例 2：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：nums &#x3D; [0,0,1,1,1,2,2,3,3,4]输出：5, nums &#x3D; [0,1,2,3,4]解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>提示：</strong></p><ul><li><code>0 &lt;= nums.length &lt;= 3 * 104</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li><li><code>nums</code> 已按升序排列</li></ul><h3 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h3><p>数组一旦创建，就不能改变其长度，因此题目的“删除”其实是把不重复的放在前面。</p><p>题目要求不使用额外的数组，那么就在原数组上修改。</p><p>使用双指针 <code>slow</code> 和 <code>fast</code>  ，<code>slow</code>指针用来标记下一个不重复元素应该存储的位置，<code>fast</code>指针用来遍历数组。</p><h3 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h3><ol><li><p>当数组为空时，则返回 0 ；</p></li><li><p>当数组长度 &gt; 0时， 不管有没有重复元素，至少有一个不重复的元素，nums[0]一定是最后结果数组中的。因此我们从nums[1]开始遍历。设置 slow = 1, fast = 1</p></li><li><p><code>fast</code> 指针遍历数组</p><ul><li><p>当 nums[fast] == nums[fast - 1]时，说明当前fast元素已经重复，那么 fast指针继续后移（slow不动）；</p><p>当 nums[fast]  != nums[fast - 1]时，说明当前fast元素与之前不重复，将其放入<code>slow</code>的位置，<code>slow</code>和<code>fast</code>均后移。</p><p>牢记<code>slow</code>表示下一个不重复元素要放置的位置！！！！</p></li></ul></li><li><p>不重复数组长度为 <code>slow</code></p></li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">removeDuplicates</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">int</span> slow <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> fast <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>fast <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// nums[fast] == nums[fast - 1]时，说明当前fast元素已经重复，那么 fast指针继续后移（slow不动）</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>fast<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>fast <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                fast<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                 <span class="token comment">// 当 nums[fast]  != nums[fast - 1]时，说明当前fast元素与之前不重复，</span>                <span class="token comment">// 将其放入`slow`的位置，`slow`和`fast`均后移</span>                nums<span class="token punctuation">[</span>slow<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>fast<span class="token punctuation">]</span><span class="token punctuation">;</span>                slow<span class="token operator">++</span><span class="token punctuation">;</span>                fast<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> slow<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><p>时间复杂度： 由于利用双指针只遍历一次数组，所以时间复杂度为<code>O(N)</code></p><p>空间复杂度：为创建新数组，只是创建slow，fast指针，所以空间复杂度为<code>O(1)</code></p><h2 id="leetcode-27-移除元素"><a href="#leetcode-27-移除元素" class="headerlink" title="leetcode 27. 移除元素"></a><a href="https://leetcode-cn.com/problems/remove-element/">leetcode 27. 移除元素</a></h2><p>给你一个数组 <code>nums</code> 和一个值 <code>val</code>，你需要 <strong><a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a></strong> 移除所有数值等于 <code>val</code> 的元素，并返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须仅使用 <code>O(1)</code> 额外空间并 <strong><a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地 </a>修改输入数组</strong>。</p><p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p><p><strong>说明:</strong></p><p>为什么返回数值是整数，但输出的答案是数组呢?</p><p>请注意，输入数组是以<strong>「引用」</strong>方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下:</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝int len &#x3D; removeElement(nums, val);&#x2F;&#x2F; 在函数里修改输入数组对于调用者是可见的。&#x2F;&#x2F; 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。for (int i &#x3D; 0; i &lt; len; i++) &#123;    print(nums[i]);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例 1：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：nums &#x3D; [3,2,2,3], val &#x3D; 3输出：2, nums &#x3D; [2,2]解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums &#x3D; [2,2,3,3] 或 nums &#x3D; [2,2,0,0]，也会被视作正确答案。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>示例 2：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：nums &#x3D; [0,1,2,2,3,0,4,2], val &#x3D; 2输出：5, nums &#x3D; [0,1,4,0,3]解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>提示：</strong></p><ul><li><code>0 &lt;= nums.length &lt;= 100</code></li><li><code>0 &lt;= nums[i] &lt;= 50</code></li><li><code>0 &lt;= val &lt;= 100</code></li></ul><h3 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h3><p>这道题和第 27 题很像。这道题和第 283 题，第 27 题基本一致，283 题是删除 0，27 题是删除指定元素，这一题是删除重复元素，实质是一样的。</p><p>这里数组的删除并不是真的删除，只是将不需移除的元素放在数组前面。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">removeElement</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> slow <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> fast <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>fast <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>fast<span class="token punctuation">]</span> <span class="token operator">==</span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                fast<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                nums<span class="token punctuation">[</span>slow<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>fast<span class="token punctuation">]</span><span class="token punctuation">;</span>                slow<span class="token operator">++</span><span class="token punctuation">;</span>                fast<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> slow<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="leetcode-283-移动零"><a href="#leetcode-283-移动零" class="headerlink" title="leetcode 283. 移动零"></a><a href="https://leetcode-cn.com/problems/move-zeroes/">leetcode 283. 移动零</a></h2><p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p><p><strong>示例:</strong></p><pre class="line-numbers language-none"><code class="language-none">输入: [0,1,0,3,12]输出: [1,3,12,0,0]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>说明</strong>:</p><ol><li>必须在原数组上操作，不能拷贝额外的数组。</li><li>尽量减少操作次数。</li></ol><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>利用 26，27的双指针解法，将非0元素移到数组前面，记录<code>fast</code>遍历时<code>0</code>的个数 <code>count</code>，最后在数组的最后 count 个数设置为0。</p><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">moveZeroes</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> slow <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> fast <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>fast <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>fast<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                fast<span class="token operator">++</span><span class="token punctuation">;</span>                count<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                nums<span class="token punctuation">[</span>slow<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>fast<span class="token punctuation">]</span><span class="token punctuation">;</span>                fast<span class="token operator">++</span><span class="token punctuation">;</span>                slow<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span> count <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> count<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            nums<span class="token punctuation">[</span>nums<span class="token punctuation">.</span>length <span class="token operator">-</span> count<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="leetcode-977-有序数组的平方"><a href="#leetcode-977-有序数组的平方" class="headerlink" title="leetcode 977. 有序数组的平方"></a><a href="https://leetcode-cn.com/problems/squares-of-a-sorted-array/">leetcode 977. 有序数组的平方</a></h2><p>给你一个按 <strong>非递减顺序</strong> 排序的整数数组 <code>nums</code>，返回 <strong>每个数字的平方</strong> 组成的新数组，要求也按 <strong>非递减顺序</strong> 排序。</p><p><strong>示例 1：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：nums &#x3D; [-4,-1,0,3,10]输出：[0,1,9,16,100]解释：平方后，数组变为 [16,1,0,9,100]排序后，数组变为 [0,1,9,16,100]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例 2：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：nums &#x3D; [-7,-3,2,3,11]输出：[4,9,9,49,121]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 104</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li><li><code>nums</code> 已按 <strong>非递减顺序</strong> 排序</li></ul><p><strong>进阶：</strong></p><ul><li>请你设计时间复杂度为 <code>O(n)</code> 的算法解决本问题</li></ul><h3 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h3><p>最先想到的肯定就是直接遍历数组的每个值平方，然后排序美滋滋</p><h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">class Solution &#123;    public int[] sortedSquares(int[] nums) &#123;        for(int i &#x3D; 0; i &lt; nums.length; i++) &#123;            nums[i] &#x3D; nums[i] * nums[i];        &#125;        Arrays.sort(nums);        return nums;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>Arrays.sort(nums)</code>底层对基本数据类型排序使用的是快速排序，我们回顾一下快速排序，平均时间复杂度是<code>O(NlogN)</code>，最坏情况下是<code>O(N^2)</code></p><p>因此我们需要对<strong>解法一</strong>进行优化</p><h3 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h3><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>题目是<code>非递减数组</code>，所以可知数组的最外边是最大的，越在中心越小。</p><p>此时可以考虑双指针法了，i指向起始位置，j指向终止位置。</p><p>定义一个新数组result，和A数组一样的大小，让k指向result数组终止位置。</p><p>如果<code>A[i] * A[i] &lt; A[j] * A[j]</code> 那么<code>result[k--] = A[j] * A[j];</code> 。</p><p>如果<code>A[i] * A[i] &gt;= A[j] * A[j]</code> 那么<code>result[k--] = A[i] * A[i];</code> 。</p><p>具体步骤如下动图所示（参考<a href="https://www.programmercarl.com/0977.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9.html#%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95">代码随想录</a>）：</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/977.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9.gif" alt="977.有序数组的平方"></p><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">sortedSquares</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> j <span class="token operator">=</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment">//新数组从后往前，从大到小的放置元素</span>        <span class="token keyword">int</span> k <span class="token operator">=</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">*</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">*</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                res<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">*</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                i<span class="token operator">++</span><span class="token punctuation">;</span>                k<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                res<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">*</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                j<span class="token operator">--</span><span class="token punctuation">;</span>                k<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Sorting algorithrm I</title>
      <link href="/2021/12/29/Sorting-algorithrm/"/>
      <url>/2021/12/29/Sorting-algorithrm/</url>
      
        <content type="html"><![CDATA[<p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/sort.png" alt="sort"></p><h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>​    冒泡排序是一种简单的交换类排序方法，它是通过对相邻数据元素进行交换，逐步将待排序序列变成有序序列的过程。</p><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a><strong>算法思想</strong></h3><p>反复扫描待排序序列，再扫描的过程中顺次比较相邻两个元素的大小，逆序就交换位置。</p><p>以升序为例，在第一趟冒泡排序中，从第一个记录开始，扫描整个待排序序列，若相邻的两个元素逆序，则交换位置。</p><p>在扫描在过程中，不断地将两个相邻记录中关键字大的记录向后移动，最后<strong>必然将待排序列中最大的换到序列的末尾。</strong></p><p>然后进行第二趟冒泡排序，对前n -1个元素进行同样的操作，其结果是使次大的元素被放在第 n - 1个位置上。</p><p>然后进行第三趟冒泡排序，对前n - 2个元素进行同样的操作，其结果是使第三大的元素被放在第 n - 2个位置上。</p><p>如此反复，知道剩下一个最小的元素。</p><p>如果<strong>在某一趟冒泡排序过程中，没有发现一个逆序，说明已经有序，则可以直接结束整个排序</strong>。所以<strong>冒泡排序最多进行 n -1 趟</strong>。（只剩最后一个不用再进行排序，因为已经比它大的已经全在它的右边排好了，所以最多 n - 1趟）</p><h3 id="动图演示："><a href="#动图演示：" class="headerlink" title="动图演示："></a>动图演示：</h3><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/bubbleSort.gif" alt="bubbleSort"></p><h3 id="最好情况"><a href="#最好情况" class="headerlink" title="最好情况"></a>最好情况</h3><p>当输入的数据已经是<strong>正序</strong>时（都已经是正序了，我还要你冒泡排序有何用啊）。</p><h3 id="最坏情况"><a href="#最坏情况" class="headerlink" title="最坏情况"></a>最坏情况</h3><p>当输入的数据是<strong>逆序</strong>时（写一个 for 循环反序输出数据不就行了，干嘛要用你冒泡排序呢，我是闲的吗）。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token class-name">JZoffer</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span></span><span class="token class-name">Array</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Arrays</span><span class="token punctuation">;</span><span class="token comment">/** * @author ykangli * @version 1.0 * @date 2021/12/29 12:55 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BubbleSort</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">45</span><span class="token punctuation">,</span> <span class="token number">34</span><span class="token punctuation">,</span> <span class="token number">23</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">32</span><span class="token punctuation">,</span> <span class="token number">98</span><span class="token punctuation">,</span> <span class="token number">61</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> ints <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BubbleSort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">bubbleSort</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> anInt <span class="token operator">:</span> ints<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>anInt<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> sourceArray<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//对 arr 进行拷贝，不改变原数组</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>sourceArray<span class="token punctuation">,</span> sourceArray<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//最多排 n - 1趟</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">//设置一个flag，当在一趟序列遍历中元素没有发生交换，则证明该序列已经有序，结束整个冒泡排序</span>            <span class="token keyword">boolean</span> flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">int</span> temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                    arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                    arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>                    flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>flag<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> arr<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><ul><li><p>时间复杂度：O(N^2)</p></li><li><p>空间复杂度：O(1)</p></li><li><p>冒泡排序是<strong>稳定</strong>的排序</p></li></ul><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h3 id="算法改进要点"><a href="#算法改进要点" class="headerlink" title="算法改进要点"></a>算法改进要点</h3><p>冒泡排序在扫描过程中只对相邻两个元素进行比较，因此互换相邻元素只能消除一个逆序。如果能通过两个（不相邻）元素的交换，相处待排序序列中的多个逆序，则会大大加快排序的速度。</p><p>快速排序中的一次交换可能消除多个逆序。</p><h3 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h3><p>从待排序记录序列中选取一个元素（通常选取第一个元素）为<strong>枢轴</strong>，其关键字设为 pivot，然后将其余关键字小于 pivot的记录移到前面，而将关键字大于或等于 pivot的记录移到后面，结果将待排序记录序列分成两个子表，最后将关键字为 pivot的记录插到其分界线的位置处。将这个过程称为一趟快速排序。通过一次划分后，就以关键字为 pivot的记录来为界，将待排序序列分成了两个子表，且前面子表中所有记录的关键字均小于 pivot ，而后面子表中的所有记录的关键字均大于或等于pivot。对分割后的子表继续按上述原则进行分割，直到所有子表的表长不超过1为止，此时待排序记录序列就变成了一个有序表。</p><h3 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h3><p>假设待划分序列为 r[ low ], r[ low +1 ], … r[ high ] 。首先将基准记录 r[ low ]移至<strong>变量 pivot</strong> 中．使 r [ low ］相当于空单元，然后反复进行如下两个扫描过程，<strong>直到 low 和 high 相遇</strong>。</p><p>high 从右向左扫描，直到r [high] &lt; pivot时，将 r [ high］移至空单元元 r [ Iow ]处，此时 r[ high ]相当于空单元。<br>low 从左向右扫描，直到 r [low]  ≥ pivot时，将 r [ low ］移至空单元 r [ high ]，此时 r [l ow ］相当于空单元.<br>当 low 和 high 相遇时，r[ low ]或 r [ high ] 相当于空单元，且 r[ low ］<strong>左边所有记录的关键字均小于基准记录的关键字</strong>，而 r [ low ]<strong>右边所有记录的关键字均大于或等于基准记录的关键字</strong>。最后将基准记录移至r[ low ］中就完成一次划分过程。对于 r [ low ］左边的子表和   r [ low］右边的子表可采用同样的方法进行进一步划分。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">QuickSort</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">45</span><span class="token punctuation">,</span> <span class="token number">34</span><span class="token punctuation">,</span> <span class="token number">23</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">32</span><span class="token punctuation">,</span> <span class="token number">98</span><span class="token punctuation">,</span> <span class="token number">61</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">QuickSort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">quickSort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">:</span> a<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">void</span> <span class="token function">quickSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> r<span class="token punctuation">,</span> <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;</span> high<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">//调用一趟快速排序算法，以枢纽pivot为界划分为两个子表</span>            <span class="token keyword">int</span> pivot <span class="token operator">=</span> <span class="token function">quickPass</span><span class="token punctuation">(</span>r<span class="token punctuation">,</span> low<span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//递归对左子表进行快速排序</span>            <span class="token function">quickSort</span><span class="token punctuation">(</span>r<span class="token punctuation">,</span> low<span class="token punctuation">,</span> pivot <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//递归对右子表进行快速排序</span>            <span class="token function">quickSort</span><span class="token punctuation">(</span>r<span class="token punctuation">,</span> pivot <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 一趟快速排序算法，返回调整后基准数的位置     */</span>    <span class="token keyword">int</span> <span class="token function">quickPass</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> r<span class="token punctuation">,</span> <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//选择第一个元素为基准数</span>        <span class="token comment">//有的书上是以中间的数作为基准数的，要实现这个方便非常方便，直接将中间的数和第一个数进行交换就可以了。</span>        <span class="token keyword">int</span> pivot <span class="token operator">=</span> r<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;</span> high<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;</span> high <span class="token operator">&amp;&amp;</span> r<span class="token punctuation">[</span>high<span class="token punctuation">]</span> <span class="token operator">>=</span> pivot<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                high<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;</span> high<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                r<span class="token punctuation">[</span>low<span class="token punctuation">]</span> <span class="token operator">=</span> r<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token punctuation">;</span>                low<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;</span> high <span class="token operator">&amp;&amp;</span> r<span class="token punctuation">[</span>low<span class="token punctuation">]</span> <span class="token operator">&lt;</span> pivot<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                low<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;</span> high<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                r<span class="token punctuation">[</span>high<span class="token punctuation">]</span> <span class="token operator">=</span> r<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token punctuation">;</span>                high<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        r<span class="token punctuation">[</span>low<span class="token punctuation">]</span> <span class="token operator">=</span> pivot<span class="token punctuation">;</span>        <span class="token keyword">return</span> low<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="最好情况-1"><a href="#最好情况-1" class="headerlink" title="最好情况"></a>最好情况</h3><p>每趟将序列一分两半，正好在表中间，将表分成两个大小相等的子表，为<code>O(NlogN)</code></p><h3 id="最坏情况-1"><a href="#最坏情况-1" class="headerlink" title="最坏情况"></a>最坏情况</h3><p>已经排好序。</p><p>第一趟经过n - 1 次比较，第一次记录定在原位置，左部子表为空表，右部子表为 n - 1 个记录，第二趟对第一趟排序后的右子表经过 n - 2 次比较，第二个记录定在原位置，左部子表为空表，右部子表为 n - 2个记录 …… 共需经过 n(n - 1) / 2次比较，所以时间复杂度<code>O(N^2)</code></p><h3 id="算法分析-1"><a href="#算法分析-1" class="headerlink" title="算法分析"></a>算法分析</h3><ul><li>时间复杂度：*快速排序的最坏运行情况是 **O(n²)*<em>，比如说已排好序的数列。但它的平摊期望时间是 O(nlogn)，且 O(nlogn) 记号中隐含的常数因子很小，比复杂度稳定等于 O(nlogn) 的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。</em></li><li>空间复杂度：快速排序递归算法的执行过程对应一颗二叉树，理想情况下是一颗完全二叉树。平均情况下空间复杂度<strong>O(logN)</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Sliding Window</title>
      <link href="/2021/12/28/Sliding-Window/"/>
      <url>/2021/12/28/Sliding-Window/</url>
      
        <content type="html"><![CDATA[<h1 id="滑动窗口的相关题型"><a href="#滑动窗口的相关题型" class="headerlink" title="滑动窗口的相关题型"></a>滑动窗口的相关题型</h1><h2 id="leetcode-1-两数之和"><a href="#leetcode-1-两数之和" class="headerlink" title="leetcode 1. 两数之和"></a><a href="https://leetcode-cn.com/problems/two-sum/">leetcode 1. 两数之和</a></h2><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p><p>示例 1：</p><pre class="line-numbers language-none"><code class="language-none">输入：nums &#x3D; [2,7,11,15], target &#x3D; 9输出：[0,1]解释：因为 nums[0] + nums[1] &#x3D;&#x3D; 9 ，返回 [0, 1] 。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>示例 2：</p><pre class="line-numbers language-none"><code class="language-none">输入：nums &#x3D; [3,2,4], target &#x3D; 6输出：[1,2]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>示例 3：</p><pre class="line-numbers language-none"><code class="language-none">输入：nums &#x3D; [3,3], target &#x3D; 6输出：[0,1]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>提示：</p><ul><li><p>2 &lt;= nums.length &lt;= 104</p></li><li><p>-109 &lt;= nums[i] &lt;= 109</p></li><li><p>-109 &lt;= target &lt;= 109</p></li><li><p>只会存在一个有效答案</p></li></ul><p>进阶：你可以想出一个时间复杂度小于 O(n2) 的算法吗？</p><h3 id="暴力解法："><a href="#暴力解法：" class="headerlink" title="暴力解法："></a>暴力解法：</h3><h4 id="思路分析："><a href="#思路分析：" class="headerlink" title="思路分析："></a>思路分析：</h4><p>枚举数组中的每一个数 <code>x</code>，寻找数组中是否存在 <code>target - x</code>。</p><p>当我们使用遍历整个数组的方式寻找 <code>target - x</code> 时，需要注意到每一个位于 <code>x</code> 之前的元素都已经和 <code>x</code> 匹配过，因此不需要再进行匹配，所以我们只需要在 <code>x</code> 后面的元素中寻找 <code>target - x</code>。</p><p>代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">twoSum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> right <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> difference <span class="token operator">=</span> target <span class="token operator">-</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            right <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>right <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>difference <span class="token operator">==</span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    result<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>                    result<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> right<span class="token punctuation">;</span>                    <span class="token keyword">return</span> result<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                right<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li><p>时间复杂度：O(N^2)，其中 N 是数组中的元素数量。最坏情况下数组中任意两个数都要被匹配一次。</p></li><li><p>空间复杂度：O(1)。</p></li></ul><h3 id="哈希表解法："><a href="#哈希表解法：" class="headerlink" title="哈希表解法："></a>哈希表解法：</h3><h4 id="思路分析：-1"><a href="#思路分析：-1" class="headerlink" title="思路分析："></a>思路分析：</h4><p>暴力解法时间复杂度较高的原因是寻找 target - x 的时间复杂度过高。因此，我们需要一种更优秀的方法，能够快速寻找数组中是否存在目标元素。如果存在，我们需要找出它的索引。</p><p>我们可以利用HashMap，如果哈希表中无该元素，就将每遍历到的元素加入哈希表。比如：当 nums = [2, 3, 4, 5, 6, 7]， target = 9。</p><p>最多当遍历到 7 ，哈希表中已经存入 2，可以 O(1)地寻找 <code>target - x</code>。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">twoSum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">></span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> right <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> difference <span class="token operator">=</span> target <span class="token operator">-</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>difference<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                result<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>                result<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>difference<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> result<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li><p>时间复杂度：O(N)，其中 N 是数组中的元素数量。对于每一个元素 x，我们可以 O(1) 地寻找 target - x。</p></li><li><p>空间复杂度：O(N)，其中 N 是数组中的元素数量。主要为哈希表的开销。</p></li></ul><h2 id="leetcode-15-三数之和"><a href="#leetcode-15-三数之和" class="headerlink" title="leetcode 15. 三数之和"></a><a href="https://leetcode-cn.com/problems/3sum/">leetcode 15. 三数之和</a></h2><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。</p><p>注意：答案中不可以包含重复的三元组。</p><p>示例 1：</p><pre class="line-numbers language-none"><code class="language-none">输入：nums &#x3D; [-1,0,1,2,-1,-4]输出：[[-1,-1,2],[-1,0,1]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>示例 2：</p><pre class="line-numbers language-none"><code class="language-none">输入：nums &#x3D; []输出：[]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>示例 3：</p><pre class="line-numbers language-none"><code class="language-none">输入：nums &#x3D; [0]输出：[]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>提示：</p><ul><li><code>0 &lt;= nums.length &lt;= 3000</code></li><li><code>-105 &lt;= nums[i] &lt;= 105</code></li></ul><h3 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析:"></a>思路分析:</h3><p>如果我们直接使用三重循环枚举三元组，会得到 O(N^3)个满足题目要求的三元组（其中 N是数组的长度）**时间复杂度至少为 O(N^3)**。在这之后，我们还需要使用哈希表进行去重操作，得到不包含重复三元组的最终答案，又消耗了大量的空间。这个做法的时间复杂度和空间复杂度都很高，因此我们要换一种思路来考虑这个问题。</p><p>拿这个 nums 数组来举例，首先将数组排序，然后有一层for循环，k 从下标0的地方开始，同时定一个下标 i = k+1 的位置上，定义下标 j 在数组结尾的位置上(j = nums.length - 1)。</p><p>依然还是在数组中找到 abc 使得a + b +c =0，我们这里相当于 a = nums[k] ,b = nums[i] ,c = nums[j]。</p><p>接下来如何移动left 和right呢， 如果nums[i] + nums[left] + nums[right] &gt; 0 就说明 此时三数之和大了，因为数组是排序后了，所以right下标就应该向左移动，这样才能让三数之和小一些。</p><p>如果 nums[i] + nums[left] + nums[right] &lt; 0 说明 此时 三数之和小了，i 就向右移动，才能让三数之和大一些，直到 i 与 j 相遇为止。</p><h3 id="双指针法思路"><a href="#双指针法思路" class="headerlink" title="双指针法思路"></a>双指针法思路</h3><p> 固定 3个指针中最左（最小）数字的指针 k，双指针 i，j 分设在数组索引 (k, len(nums)) 两端，通过双指针交替向中间移动，记录对于每个固定指针 k 的所有满足 nums[k] + nums[i] + nums[j] == 0 的 i,j 组合：</p><ol><li><p>当 nums[k] &gt; 0 时直接break跳出：因为 nums[j]  &gt;=  nums[i]  &gt;=  nums[k]  &gt; 0，即 3个数字都大于 0，则三数之和必然无法等于 0，结束循环。</p></li><li><p>当 k &gt; 0且nums[k] == nums[k - 1]时即跳过此元素nums[k]：因为<strong>已经将 nums[k - 1] 的所有组合加入到结果中</strong>，本次双指针搜索只会得到重复组合。</p></li><li><p>i，j 分设在数组索引  (k, len(nums)) 两端，当i &lt; j时循环计算s = nums[k] + nums[i] + nums[j]，并按照以下规则执行双指针移动：</p><ul><li><p>当s &lt; 0时，说明nums[i] 太小，i 右移；</p></li><li><p>当s &gt; 0时，说明nums[j] 太大，j 左移；</p></li><li><p>当s == 0时，记录组合[k, i, j]至 res，<strong>执行i += 1和j -= 1</strong>，并跳过所有重复的nums[i] 和 nums[j]，防止记录到重复组合。</p></li></ul></li></ol><p>其实第二个和第三个数就是<strong>滑动窗口</strong>。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span> <span class="token function">threeSum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>nums <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> nums<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> res<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">//k进行去重  注意去重条件    nums[k] == nums[k + 1]是错误的！！！！</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>k <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">int</span> i <span class="token operator">=</span> k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> j <span class="token operator">=</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">int</span> sum <span class="token operator">=</span> nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>sum <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    i<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>sum <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    j<span class="token operator">--</span><span class="token punctuation">;</span>                           <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                    res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">//i,j同时减小，过程中去除重复的i,j   </span>                   <span class="token comment">//注意++i效率更高，++i是直接对于原对象进行自增，不用生成临时变量</span>                    <span class="token comment">//而且不需要最后再进行一次 i++ 到不重复的位置去</span>                    <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span><span class="token operator">++</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token punctuation">&#125;</span>                    <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span><span class="token operator">--</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token punctuation">&#125;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>++i 和 i++<strong>两者参与运算时的区别就是：</strong></p><ol><li>a=i++ , a 返回原来的值a=i,i=i+1;<br>a=++i , a 返回加1后的值,a=i+1,i=i+1。<br>也就是<strong>i++是先赋值，然后再自增；++i是先自增，后赋值。</strong></li><li>第二个区别就是： i++ 不能作为左值，而++i可以。</li></ol><p><strong>两者效率在某些情况下仍有不同！</strong></p><p>当我们考虑自定义类的时候，就不一样了。</p><p>i++是先用临时对象保存原来的对象，然后对原对象自增，再返回临时对象，不能作为左值；**++i是直接对于原对象进行自增**，然后返回原对象的引用，可以作为左值。</p><p>由于要生成临时对象，i++需要调用两次拷贝构造函数与析构函数（将原对象赋给临时对象一次，临时对象以值传递方式返回一次）；</p><p><strong>++i由于不用生成临时变量</strong>，且以引用方式返回，故没有构造与析构的开销，<strong>效率更高</strong>。</p><p>所以在使用类等自定义类型的时候，应尽量使用++i。</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20211230163506590.png" alt="image-20211230163506590"></p><h2 id="leetcode-18-四数之和"><a href="#leetcode-18-四数之和" class="headerlink" title="leetcode 18. 四数之和"></a><a href="https://leetcode-cn.com/problems/4sum/">leetcode 18. 四数之和</a></h2><p>给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）：</p><ul><li><p>0 &lt;= a, b, c, d &lt; n</p></li><li><p>a、b、c 和 d <strong>互不相同</strong></p></li><li><p>nums[a] + nums[b] + nums[c] + nums[d] == target</p></li></ul><p>你可以按 <strong>任意顺序</strong> 返回答案 。</p><p>示例 1：</p><pre class="line-numbers language-none"><code class="language-none">输入：nums &#x3D; [1,0,-1,0,-2,2], target &#x3D; 0输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>示例 2：</p><pre class="line-numbers language-none"><code class="language-none">输入：nums &#x3D; [2,2,2,2,2], target &#x3D; 8输出：[[2,2,2,2]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>提示：</p><ul><li>1 &lt;= nums.length &lt;= 200</li><li>-109 &lt;= nums[i] &lt;= 109</li><li>-109 &lt;= target &lt;= 109</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>暴力解法为O（N^4），数组排序后，最里面两层利用滑动窗口，可将时间复杂度将为0(N ^ 3)</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span> <span class="token function">fourSum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>nums <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> nums<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> res<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> m <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> m <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> m<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">//不能用这里的去重，因为target是任意值</span>            <span class="token comment">//if(nums[m] > target) &#123;</span>            <span class="token comment">//    break;</span>            <span class="token comment">//&#125;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>m <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>m<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> n <span class="token operator">=</span> m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> n <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> n<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">//不能用这里的去重，因为target是任意值</span>                <span class="token comment">//例： nums[m] == -3, nums[n] == -2 ,target = -6</span>                <span class="token comment">// if(nums[m] + nums[n] > target) &#123;</span>                <span class="token comment">//     break;</span>                <span class="token comment">// &#125;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">></span> m <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">continue</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token keyword">int</span> i <span class="token operator">=</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token keyword">int</span> j <span class="token operator">=</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">int</span> sum <span class="token operator">=</span> nums<span class="token punctuation">[</span>m<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span><span class="token punctuation">(</span>sum <span class="token operator">&lt;</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        i<span class="token operator">++</span><span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>sum <span class="token operator">></span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        j<span class="token operator">--</span><span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                        res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>m<span class="token punctuation">]</span> <span class="token punctuation">,</span> nums<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token punctuation">,</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment">//去重</span>                        <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span><span class="token operator">++</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        <span class="token punctuation">&#125;</span>                        <span class="token comment">//去重</span>                        <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span><span class="token operator">--</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        <span class="token punctuation">&#125;</span>                    <span class="token punctuation">&#125;</span>                 <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="leetcode-3-无重复字符的最长子串"><a href="#leetcode-3-无重复字符的最长子串" class="headerlink" title="leetcode 3. 无重复字符的最长子串"></a><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">leetcode 3. 无重复字符的最长子串</a></h2><p>给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。</p><p>示例 1:</p><pre class="line-numbers language-none"><code class="language-none">输入: s &#x3D; &quot;abcabcbb&quot;输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>示例 2:</p><pre class="line-numbers language-none"><code class="language-none">输入: s &#x3D; &quot;bbbbb&quot;输出: 1解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>示例 3:</p><pre class="line-numbers language-none"><code class="language-none">输入: s &#x3D; &quot;pwwkew&quot;输出: 3解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>示例 4:</p><pre class="line-numbers language-none"><code class="language-none">输入: s &#x3D; &quot;&quot;输出: 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>提示：</strong></p><ul><li><code>0 &lt;= s.length &lt;= 5 * 104</code></li><li><code>s</code> 由英文字母、数字、符号和空格组成</li></ul><h3 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">lengthOfLongestSubstring</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> s <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Character</span><span class="token punctuation">,</span> <span class="token class-name">Character</span><span class="token punctuation">></span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>j <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">,</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                j<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            res <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> j <span class="token operator">-</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="滑动窗口解法"><a href="#滑动窗口解法" class="headerlink" title="滑动窗口解法"></a>滑动窗口解法</h3><p>思想：</p><p>暴力解法时间复杂度是O(N^2)，使用滑动窗口可遍历一次数组完成，使得时间复杂度将为O（N）</p><p>滑动窗口的右边界不断的右移，只要没有重复的字符，就持续向右扩大窗口边界。一旦出现了重复字符，就需要缩小左边界，直到重复的字符移出了左边界，然后继续移动滑动窗口的右边界。以此类推，每次移动需要计算当前长度，并判断是否需要更新最大长度，最终最大的值就是题目中的所求。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">lengthOfLongestSubstring</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> s <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> right <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>          <span class="token comment">//set用来存储当前无重复字串都有哪些唯一的字符</span>        <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Character</span><span class="token punctuation">></span></span> set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> left <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> left<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">//每次left移动位置，都要去除set中原left位置对应的元素，因为set中始终存储的是当前不重复字串</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>left <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                set<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>left <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">//只要没有重复的字符，就持续向右扩大窗口边界</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>right <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> len <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>set<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>right <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                right<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token comment">//向set中添加</span>                set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            result <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span> right <span class="token operator">-</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">lengthOfLongestSubstring</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> right <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Character</span><span class="token punctuation">></span></span> set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> length <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>right <span class="token operator">&lt;</span> length<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">//只要没有重复的字符，就持续向右扩大窗口边界</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>set<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                result <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span> right <span class="token operator">-</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                right<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">//一旦出现了重复字符，就需要缩小左边界，直到重复的字符移出了左边界</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>right <span class="token operator">&lt;</span> length <span class="token operator">&amp;&amp;</span> set<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                set<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                left<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="leetcode-209-长度最小的子数组"><a href="#leetcode-209-长度最小的子数组" class="headerlink" title="leetcode 209. 长度最小的子数组"></a><a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/">leetcode 209. 长度最小的子数组</a></h2><p>给定一个含有 <code>n</code> 个正整数的数组和一个正整数 <code>target</code> <strong>。</strong></p><p>找出该数组中满足其和 <code>≥ target</code> 的长度最小的 <strong>连续子数组</strong> <code>[numsl, numsl+1, ..., numsr-1, numsr]</code> ，并返回其长度<strong>。</strong>如果不存在符合条件的子数组，返回 <code>0</code> 。</p><p><strong>示例 1：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：target &#x3D; 7, nums &#x3D; [2,3,1,2,4,3]输出：2解释：子数组 [4,3] 是该条件下的长度最小的子数组。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>示例 2：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：target &#x3D; 4, nums &#x3D; [1,4,4]输出：1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>示例 3：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：target &#x3D; 11, nums &#x3D; [1,1,1,1,1,1,1,1]输出：0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= target &lt;= 109</code></li><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>1 &lt;= nums[i] &lt;= 105</code></li></ul><p><strong>进阶：</strong></p><ul><li>如果你已经实现 <code>O(n)</code> 时间复杂度的解法, 请尝试设计一个 <code>O(n log(n))</code> 时间复杂度的解法。</li></ul><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>子数组想到是否能利用<code>滑动窗口</code> ？？？</p><p>这一题的解题思路是用滑动窗口。在滑动窗口 [i,j]之间不断往后移动，如果总和小于 s，就扩大右边界 j，不断加入右边的值，直到 sum &gt; s，之后再缩小 i 的左边界，不断缩小直到 sum &lt; s，这时候右边界又可以往右移动。以此类推。</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">minSubArrayLen</span><span class="token punctuation">(</span><span class="token keyword">int</span> target<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>        <span class="token comment">//扩大窗口</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> right <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> right <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> right<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            sum <span class="token operator">+=</span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token comment">//缩小窗口</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>sum <span class="token operator">>=</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                result <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span> right <span class="token operator">-</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                sum <span class="token operator">-=</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>                left<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>         <span class="token punctuation">&#125;</span>        <span class="token comment">//有无找到</span>        <span class="token keyword">return</span> result <span class="token operator">==</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MAX_VALUE <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> result<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Palindromic substring</title>
      <link href="/2021/12/26/palindromic-substring/"/>
      <url>/2021/12/26/palindromic-substring/</url>
      
        <content type="html"><![CDATA[<p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/980081ebc17e7bbd499001644140ba4.jpg" alt="2021年12月26日，毛主席诞辰128周年。西安疫情严重，西北大学学子真情流露，在操场雪地上写下众多标语，流露出对毛主席的怀念之情以及对战胜疫情回家过年的期盼。"></p><h1 id="回文串相关题目"><a href="#回文串相关题目" class="headerlink" title="回文串相关题目"></a>回文串相关题目</h1><h2 id="leecode-234-回文链表"><a href="#leecode-234-回文链表" class="headerlink" title="leecode 234. 回文链表"></a>leecode 234. 回文链表</h2><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/03/pal1linked-list.jpg" alt="img"></p><pre class="line-numbers language-none"><code class="language-none">输入：head &#x3D; [1,2,2,1]输出：true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/03/pal2linked-list.jpg" alt="img"></p><pre class="line-numbers language-none"><code class="language-none">输入：head &#x3D; [1,2]输出：false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>进阶：</strong>你能否用 <code>O(n)</code> 时间复杂度和 <code>O(1)</code> 空间复杂度解决此题？</p><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>找到链表<strong>后半部分开始的节点</strong>，反转后半部分链表。</p><h3 id="找链表中点："><a href="#找链表中点：" class="headerlink" title="找链表中点："></a>找链表中点：</h3><ul><li>链表节点数为奇数，快指针 fast 指向最后一个节点时，慢指针 slow的位置就是中点。</li><li>链表节点数为偶数，快指针 fast 指向倒数第二个节点，慢指针 slow的位置就是链表<strong>前半部分结束的节点</strong>。</li></ul><p>注意<strong>循环条件</strong>：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">while</span><span class="token punctuation">(</span>fast<span class="token punctuation">.</span>next <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>找链表中点的算法 ——&gt; <strong>快慢指针</strong></p><p>代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">middleNode</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span> head<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">ListNode</span> slow <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token class-name">ListNode</span> fast <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>fast <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> fast<span class="token punctuation">.</span>next <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>        <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/1.png" alt="1" style="zoom: 50%;"><p>由上图可知：</p><p>如果是奇数，链表中点就是 slow</p><p>如果是偶数，链表中点就是slow.next</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * Definition for singly-linked list. * public class ListNode &#123; *     int val; *     ListNode next; *     ListNode() &#123;&#125; *     ListNode(int val) &#123; this.val = val; &#125; *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isPalindrome</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span> head<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">ListNode</span> slow <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token class-name">ListNode</span> fast <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>fast<span class="token punctuation">.</span>next <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token class-name">ListNode</span> lastHalfReversed <span class="token operator">=</span>  <span class="token function">reverseRecursion</span><span class="token punctuation">(</span>slow<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>lastHalfReversed <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>val <span class="token operator">!=</span> lastHalfReversed<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            head <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            lastHalfReversed <span class="token operator">=</span> lastHalfReversed<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">public</span> <span class="token class-name">ListNode</span> <span class="token function">reverseRecursion</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span> head<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> head<span class="token punctuation">.</span>next <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> head<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token class-name">ListNode</span> newNode <span class="token operator">=</span> <span class="token function">reverseRecursion</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>        head<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>        head<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> newNode<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度：O(n)</strong>    其中 n 指的是链表的大小。</li><li><strong>空间复杂度：O(1)</strong>    我们只会修改原本链表中节点的指向，而在堆栈上的堆栈帧不超过 O(1)。</li></ul><h2 id="leetcode-647-回文子串"><a href="#leetcode-647-回文子串" class="headerlink" title="leetcode 647 . 回文子串"></a>leetcode 647 . 回文子串</h2><p>给你一个字符串 s ，请你统计并返回这个字符串中 回文子串 的数目。</p><p>回文字符串 是正着读和倒过来读一样的字符串。</p><p>子字符串 是字符串中的由连续字符组成的一个序列。</p><p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p><p><strong>示例 1：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：s &#x3D; &quot;abc&quot;输出：3解释：三个回文子串: &quot;a&quot;, &quot;b&quot;, &quot;c&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>示例 2：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：s &#x3D; &quot;aaa&quot;输出：6解释：6个回文子串: &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;aa&quot;, &quot;aa&quot;, &quot;aaa&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 1000</code></li><li><code>s</code> 由小写英文字母组成</li></ul><h3 id="暴力解法："><a href="#暴力解法：" class="headerlink" title="暴力解法："></a>暴力解法：</h3><p>判断所有字串是否为回文串，存储最长的回文子串</p><p>代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//判断字符串是不是 回文串  对称位置的关系  i &lt;------> len - i - 1</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isPalindromic</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">!=</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>len <span class="token operator">-</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">longestPalindrome</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token class-name">String</span> subStr <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isPalindromic</span><span class="token punctuation">(</span>subStr<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> subStr<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> longest<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    num<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> num<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>时间复杂度：</strong></p><p>用<br>$$<br>O(N^2)<br>$$<br>的时间枚举出所有的字串，然后判断字符串是否为回文串的算法 isPalindromic（）时间复杂度为 O(N)，所以暴力解法的时间复杂度为<br>$$<br>O(N^3)<br>$$</p><h3 id="中心扩展法："><a href="#中心扩展法：" class="headerlink" title="中心扩展法："></a><strong>中心扩展法：</strong></h3><h4 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a><strong>思路：</strong></h4><p>枚举出所有的子串（看所有的字串是不是回文串）又有另一种的思路：枚举每一个<strong>可能的回文中心</strong>，然后用两个指针分别向左右两边拓展，当两个指针指向的元素相同的时候就拓展，否则停止拓展。</p><p>偶数的子串(通过偶数的所有子串，找出偶数的回文子串)不能通过单个向两边扩展得到，比如 ababa中的字串 abab无法通过任何一个字符向两边扩展得到。</p><p>所以中心点不能只有单个字符构成，还要包括两个字符，比如上面这个子串 <code>abab</code>，就可以由中心点 <code>ba</code> 扩展一次得到。</p><h4 id="分析结论："><a href="#分析结论：" class="headerlink" title="分析结论："></a>分析结论：</h4><p>所以最终的中心点有 <code>2 * len - 1</code> 个，分别是 <code>len</code> 个单字符和 <code>len - 1</code> 个双字符。</p><p>如果上面看不太懂的话，还可以看看下面几个问题：</p><ul><li>为什么有 2 * len - 1 个中心点？<ul><li>aba 有5个中心点，分别是 a、b、c、ab、ba</li><li>abba 有7个中心点，分别是 a、b、b、a、ab、bb、ba</li></ul></li><li>什么是中心点？<ul><li>中心点即 left 指针和 right 指针初始化指向的地方，可能是一个也可能是两个</li></ul></li><li>为什么不可能是三个或者更多？<ul><li>因为 3 个可以由 1 个扩展一次得到，4 个可以由两个扩展一次得到</li></ul></li></ul><p>再次强调：如果回文长度是奇数，那么回文中心是一个字符；如果回文长度是偶数，那么中心是两个字符。</p><p>我们不妨写一组出来观察观察，假设 n = 4（abba），我们可以把可能的回文中心列出来：</p><table><thead><tr><th align="center">编号(0 ~ 2 n - 1)</th><th align="center">回文中心</th><th align="center">回文中心左起始位置</th><th align="center">回文中心右起始位置</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">a</td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center">1</td><td align="center">ab</td><td align="center">0</td><td align="center">1</td></tr><tr><td align="center">2</td><td align="center">b</td><td align="center">1</td><td align="center">1</td></tr><tr><td align="center">3</td><td align="center">bb</td><td align="center">1</td><td align="center">2</td></tr><tr><td align="center">4</td><td align="center">b</td><td align="center">2</td><td align="center">2</td></tr><tr><td align="center">5</td><td align="center">ba</td><td align="center">2</td><td align="center">3</td></tr><tr><td align="center">6</td><td align="center">a</td><td align="center">3</td><td align="center">3</td></tr></tbody></table><p>单字符中心：n 个</p><p>双字符中心： n - 1 个</p><h4 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">countSubstrings</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//回文字串最少是 s.length() -----> 也就是单个字符的个数</span>        <span class="token keyword">int</span> substrings <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment">//以单个字符为中心的情况（也就是回文子串长度是奇数的情况） n种情况</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> left <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token keyword">int</span> right <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token comment">//注意left和right的取值范围</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>left <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> right <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span> <span class="token operator">==</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                substrings<span class="token operator">++</span><span class="token punctuation">;</span>                left<span class="token operator">--</span><span class="token punctuation">;</span>                right<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>         <span class="token punctuation">&#125;</span>        <span class="token comment">//以双字符为中心的情况（也就是回文字串长度是偶数的情况） n - 1种情况 </span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> left <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token keyword">int</span> right <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>left <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> right <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span> <span class="token operator">==</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                substrings<span class="token operator">++</span><span class="token punctuation">;</span>                left<span class="token operator">--</span><span class="token punctuation">;</span>                right<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>         <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> substrings<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a><strong>复杂度分析</strong></h4><ul><li>时间复杂度：O(n^2)</li><li>空间复杂度：O(1)</li></ul><h2 id="leetcode-5-最长回文子串"><a href="#leetcode-5-最长回文子串" class="headerlink" title="leetcode 5. 最长回文子串"></a>leetcode 5. 最长回文子串</h2><h3 id="暴力解法：-1"><a href="#暴力解法：-1" class="headerlink" title="暴力解法："></a>暴力解法：</h3><h4 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//判断字符串是不是 回文串  对称位置的关系  i &lt;------> len - i - 1</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isPalindromic</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">!=</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>len <span class="token operator">-</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">longestPalindrome</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">String</span> longest <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token class-name">String</span> subStr <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isPalindromic</span><span class="token punctuation">(</span>subStr<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> subStr<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> longest<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    longest <span class="token operator">=</span> subStr<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> longest<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度:"></a>时间复杂度:</h4><p>用O(N^2)的时间枚举出所有的字串，然后判断字符串是否为回文串的算法 isPalindromic（）时间复杂度为 O(N)，所以暴力解法的时间复杂度为O(N^3)</p><h3 id="中心扩展法：-1"><a href="#中心扩展法：-1" class="headerlink" title="中心扩展法："></a>中心扩展法：</h3><p>同leetcode 645</p><h4 id="代码：-3"><a href="#代码：-3" class="headerlink" title="代码："></a>代码：</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">longestPalindrome</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>s <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">int</span> longest <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> longestStr <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>        <span class="token comment">//以单个字符为中心的情况（也就是回文子串长度是奇数的情况） n种情况</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// left = right 的时候，此时回文中心是一个字符，回文串的长度是奇数</span>            <span class="token keyword">int</span> left <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token keyword">int</span> right <span class="token operator">=</span> left<span class="token punctuation">;</span>            <span class="token comment">//注意left和right的取值范围</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>left <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> right <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span> <span class="token operator">==</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">int</span> subStrLen <span class="token operator">=</span> right <span class="token operator">-</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>subStrLen <span class="token operator">></span> longest<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    longest <span class="token operator">=</span> subStrLen<span class="token punctuation">;</span>                    longestStr <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> right <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                left<span class="token operator">--</span><span class="token punctuation">;</span>                right<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>         <span class="token punctuation">&#125;</span>        <span class="token comment">//以双字符为中心的情况（也就是回文字串长度是偶数的情况） n - 1种情况 </span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// right = left + 1 的时候，此时回文中心是一个空隙，回文串的长度是偶数</span>            <span class="token keyword">int</span> left <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token keyword">int</span> right <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>left <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> right <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span> <span class="token operator">==</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">int</span> subStrLen <span class="token operator">=</span> right <span class="token operator">-</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>subStrLen <span class="token operator">></span> longest<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    longest <span class="token operator">=</span> subStrLen<span class="token punctuation">;</span>                    longestStr <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> right <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                left<span class="token operator">--</span><span class="token punctuation">;</span>                right<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>         <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> longestStr<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li><p>时间复杂度：O(n^2)，其中 n是字符串的长度。长度为 1和 2的回文中心分别有 n和 n−1 个，每个回文中心最多会向外扩展 O(n)次。</p></li><li><p>空间复杂度：O(1)</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Fighting COVID-19</title>
      <link href="/2021/12/25/Fighting-COVID-19/"/>
      <url>/2021/12/25/Fighting-COVID-19/</url>
      
        <content type="html"><![CDATA[<p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20211225194728.jpg" alt="微信图片_20211225194728"></p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20211225194749.jpg" alt="微信图片_20211225194749"></p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20211225194836.jpg" alt="微信图片_20211225194836"></p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20211225210532848.png" alt="image-20211225210532848"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>刷题 12/24</title>
      <link href="/2021/12/24/%E5%89%91%E6%8C%87offer-03/"/>
      <url>/2021/12/24/%E5%89%91%E6%8C%87offer-03/</url>
      
        <content type="html"><![CDATA[<h2 id="剑指offer-03-数组中重复的数字"><a href="#剑指offer-03-数组中重复的数字" class="headerlink" title="剑指offer 03. 数组中重复的数字"></a>剑指offer 03. 数组中重复的数字</h2><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20211224095946844.png"></p><h3 id="一-遍历暴力解法-利用HashSet"><a href="#一-遍历暴力解法-利用HashSet" class="headerlink" title="一.遍历暴力解法 ( 利用HashSet )"></a>一.遍历暴力解法 ( 利用HashSet )</h3><p>利用HashSet, 每遍历一个就去Set集合中查询，如果有就说明前面已经存在；若没有将其存入Set。 </p><p>代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findRepeatNumber</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>set<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">return</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>          <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>notes</strong>： 牢记<code>HashSet</code>的两个函数</p><ol><li><strong>add( )</strong>                  如果Set集合中存在该元素，则返回 false</li><li><strong>contains ( )</strong>         如果Set集合中存在该元素，则返回 false</li></ol><ul><li><p><strong>时间复杂度 O(N)：</strong> 遍历数组使用 O(N) ，HashSet 添加与查找元素皆为 O(1)。</p></li><li><p><strong>空间复杂度 O(N)：</strong> HashSet 占用 O(N)  大小的额外空间。</p></li></ul><h3 id="二-原地交换"><a href="#二-原地交换" class="headerlink" title="二. 原地交换"></a>二. 原地交换</h3><p>实际中，可能要求降低空间复杂度。那我们就不能新建 HashSet，利用Set集合的唯一性来实现。那我们就得想，有没有办法仅仅使用当前的数组 nums[ ]来模拟Set。</p><p>我们仔细观察该题目，发现 ——-&gt;  <code>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内</code></p><p>可遍历数组并通过交换操作，<strong>使元素与索引值 一 一对应</strong>（即 nums[i] = inums[i]=i ）。因而，就能通过索引映射对应的值，起到与Set等价的作用。</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20211224104020538.png" alt="image-20211224104020538"></p><p>遍历中，第一次遇到数字 xx 时，将其交换至索引 xx 处；而当第二次遇到数字 xx 时，一定有 nums[x] = xnums[x]=x ，此时即可得到一组重复数字。</p><p><strong>算法步骤：</strong></p><p>一、遍历数组 nums[ ]：</p><ul><li>若 nums[i] == i， 说明元素与索引值对应，继续下一个位置。</li><li>若 nums[nums[i]] == nums[i]， 说明 索引nums[i]处和索引 i 处的元素值都是 nums[i]，找到重复的值，那么返回 nusm[i].</li><li>否则，交换 索引 i 处和 索引 nums[i] 处的元素值，也就是把 元素nums[i], 放到索引 nums[i]处。使得元素值与索引对应。</li></ul><p>二、 遍历完成未找到，返回-1 （本题有重复元素，一定能找到）</p><p>代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findRepeatNumber</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">//元素与索引值对应，继续下一个位置</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                i<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">//找到重复的值 </span>            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">return</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">//交换元素位置，使得元素值与索引对应</span>            <span class="token keyword">int</span> temp <span class="token operator">=</span>  nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>temp<span class="token punctuation">]</span><span class="token punctuation">;</span>            nums<span class="token punctuation">[</span>temp<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><strong>时间复杂度 O(N):</strong>    遍历数组使用<em>O</em>(<em>N</em>) ，每轮遍历的判断和交换操作使用<em>O</em>(1) 。</p></li><li><p><strong>空间复杂度 O(1) ：</strong> 使用常数复杂度的额外空间。</p></li></ul><h3 id="要求时间复杂度O-1-的话，怎么实现？？？？？？？"><a href="#要求时间复杂度O-1-的话，怎么实现？？？？？？？" class="headerlink" title="要求时间复杂度O(1) 的话，怎么实现？？？？？？？"></a>要求时间复杂度O(1) 的话，怎么实现？？？？？？？</h3><h2 id="剑指-Offer-30-包含min函数的栈"><a href="#剑指-Offer-30-包含min函数的栈" class="headerlink" title="剑指 Offer 30. 包含min函数的栈"></a>剑指 Offer 30. 包含min函数的栈</h2><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20211224110825312.png" alt="image-20211224110825312"><h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p>普通栈的 <code>push()</code> 和 <code>pop()</code> 函数的复杂度为 <em>O</em>(1) ；而获取栈最小值 <code>min()</code> 函数需要遍历整个栈，复杂度为 <em>O</em>(<em>N</em>) 。</p><h3 id="难点："><a href="#难点：" class="headerlink" title="难点："></a>难点：</h3><p>那么本题要解决的就是 <strong>将 <code>min()</code> 函数复杂度降为 <em>O</em>(1) ，可通过建立辅助栈实现</strong>。</p><h3 id="具体操作："><a href="#具体操作：" class="headerlink" title="具体操作："></a>具体操作：</h3><ul><li><strong>数据栈 A</strong>：  栈 A用于存储所有元素，保证入栈 push() 函数、出栈 pop() 函数、获取栈顶 top() 函数的正常逻辑。</li><li><strong>辅助栈 B</strong> ： 栈 B中存储栈 A中所有 非严格降序（相等也行） 的元素，则栈 A 中的最小元素始终对应栈 B的栈顶元素，即 min() 函数只需返回栈 B 的栈顶元素即可，可达到min（）的时间复杂度为O(N)的目的。</li></ul><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">MinStack</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//A保存所有元素，B保存非严格单调递减的元素（为了使得B栈顶就是最小值，时间复杂度为O（1））</span>    <span class="token class-name">Deque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> <span class="token class-name">A</span><span class="token punctuation">,</span> <span class="token class-name">B</span><span class="token punctuation">;</span>    <span class="token comment">/** initialize your data structure here. */</span>    <span class="token keyword">public</span> <span class="token class-name">MinStack</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name"><span class="token namespace">this<span class="token punctuation">.</span></span>A</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name"><span class="token namespace">this<span class="token punctuation">.</span></span>B</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">A</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token class-name">B</span><span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token class-name">B</span><span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">>=</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">B</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token class-name">A</span><span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">B</span><span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">B</span><span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token class-name">A</span><span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token class-name">A</span><span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">min</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token class-name">B</span><span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">/** * Your MinStack object will be instantiated and called as such: * MinStack obj = new MinStack(); * obj.push(x); * obj.pop(); * int param_3 = obj.top(); * int param_4 = obj.min(); */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="复杂度分析："><a href="#复杂度分析：" class="headerlink" title="复杂度分析："></a>复杂度分析：</h3><ul><li><strong>时间复杂度 O(1) ：</strong> push( ), pop( ), top( ), min( ) 四个函数的时间复杂度均为常数级别。</li><li><strong>空间复杂度 O(N) ：</strong> 当共有 N 个待入栈元素时，辅助栈 BB 最差情况下存储 N 个元素，使用 O(N） 额外空间。</li></ul><h2 id="剑指offer-10-II-青蛙跳台的问题"><a href="#剑指offer-10-II-青蛙跳台的问题" class="headerlink" title="剑指offer 10 - II. 青蛙跳台的问题"></a>剑指offer 10 - II. 青蛙跳台的问题</h2><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20211224170310559.png" alt="image-20211224170310559" style="zoom:80%;"><h3 id="递归三部曲："><a href="#递归三部曲：" class="headerlink" title="递归三部曲："></a>递归三部曲：</h3><ol><li><p><strong>找base case</strong>，也就是<strong>找整个递归的终止条件：递归应该在什么时候结束？</strong></p></li><li><p><strong>找返回值</strong>：应该给上一级返回什么信息？</p></li><li><p><strong>本级递归应该做什么：</strong>在这一级递归中，应该完成什么任务？</p></li></ol><p>一般想清楚<strong>本级递归应该做什么</strong>就能解决递归！</p><p>在本题中，设跳上 n级台阶有 f(n)种跳法。在所有跳法中，青蛙的最后一步只有两种情况： <strong>跳上 1 级或 2 级台阶</strong>。</p><p>所以本级递归应该完成 f(n) = f(n -1) + f(n - 2) ，就是把两种情况的各自有多少种情况加起来。</p><h3 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//map用来记忆算过的f（n）,加快递归速度，不用去重复递归计算</span>    <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">></span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">numWays</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment">//base case</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">||</span> n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">//本级递归种要做的事情</span>        result <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token function">numWays</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span>  <span class="token operator">+</span> <span class="token function">numWays</span><span class="token punctuation">(</span>n <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">1000000007</span><span class="token punctuation">;</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="leetcode-24-两两交换链表中的结点"><a href="#leetcode-24-两两交换链表中的结点" class="headerlink" title="leetcode 24. 两两交换链表中的结点"></a>leetcode 24. 两两交换链表中的结点</h2><p><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/">https://leetcode-cn.com/problems/swap-nodes-in-pairs/</a></p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20211224201958367.png" alt="image-20211224201958367"></p><p>这种链表中的k个一组交换 —–&gt; 递归   相似的还有<code> leetcode 25. K个一组反转链表</code> <a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/">https://leetcode-cn.com/problems/reverse-nodes-in-k-group/</a></p><p><strong>base case</strong>: 只有一个节点或为空</p><p><strong>本级递归要做的事情</strong>：</p><p>head， head.next， swapPairs（head.next.next）这三个节点中，将head和head.next交换</p><h3 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * Definition for singly-linked list. * public class ListNode &#123; *     int val; *     ListNode next; *     ListNode() &#123;&#125; *     ListNode(int val) &#123; this.val = val; &#125; *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">ListNode</span> <span class="token function">swapPairs</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span> head<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//base case</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> head<span class="token punctuation">.</span>next <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> head<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">//本级递归</span>        <span class="token class-name">ListNode</span> second <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        head<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">swapPairs</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>        second<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">return</span> second<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hexo + Github + TecentCloud + PicGo + AliCloud OSS 搭建个人博客</title>
      <link href="/2021/12/21/Build_A_Blog/"/>
      <url>/2021/12/21/Build_A_Blog/</url>
      
        <content type="html"><![CDATA[<p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/blog.png" alt="blog"></p>]]></content>
      
      
      <categories>
          
          <category> tech </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World(Hexo Docs)</title>
      <link href="/2021/12/21/hello-world/"/>
      <url>/2021/12/21/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.Quick Start</p><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> tech </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>事务基础知识</title>
      <link href="/2021/01/14/%E4%BA%8B%E5%8A%A1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2021/01/14/%E4%BA%8B%E5%8A%A1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="事务基础知识"><a href="#事务基础知识" class="headerlink" title="事务基础知识"></a>事务基础知识</h1><h2 id="1-数据库事务概述"><a href="#1-数据库事务概述" class="headerlink" title="1.数据库事务概述"></a>1.数据库事务概述</h2><h3 id="1-1-存储引擎支持情况"><a href="#1-1-存储引擎支持情况" class="headerlink" title="1.1 存储引擎支持情况"></a>1.1 存储引擎支持情况</h3><p><code>SHOW ENGINES</code> 命令来查看当前 MySQL 支持的存储引擎都有哪些，以及这些存储引擎是否支持事务。  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220114114705699.png" alt="image-20220114114705699"></p><p>能看出在 MySQL 中，只有<code>InnoDB</code> 是支持事务的。  </p><h3 id="1-2-基本概念"><a href="#1-2-基本概念" class="headerlink" title="1.2 基本概念"></a>1.2 基本概念</h3><p><strong>事务</strong>：一组逻辑操作单元，使数据从一种状态变换到另一种状态。</p><p><strong>事务处理的原则</strong>：保证所有事务都作为 一个工作单元 来执行，即使出现了故障，都不能改变这种执行方式。当在一个事务中执行多个操作时，要么所有的事务都被提交( commit )，那么这些修改就 永久 地保存下来；要么数据库管理系统将 放弃 所作的所有 修改 ，整个事务回滚( rollback )到最初状态。  </p><h3 id="1-3-事务的ACID特性"><a href="#1-3-事务的ACID特性" class="headerlink" title="1.3 事务的ACID特性"></a>1.3 事务的ACID特性</h3><ul><li><strong>原子性（atomicity）：</strong></li></ul><p>原子性是指事务是一个不可分割的工作单位，要么全部提交，要么全部失败回滚。</p><ul><li><strong>一致性（consistency）：</strong></li></ul><p>（国内很多网站上对一致性的阐述有误，具体你可以参考 Wikipedia 对<code>Consistency</code>的阐述）根据定义，一致性是指事务执行前后，数据从一个 合法性状态 变换到另外一个 合法性状态 。这种状态是 语义上 的而不是语法上的，跟具体的业务有关。</p><p>那什么是合法的数据状态呢？满足 预定的约束 的状态就叫做合法的状态。通俗一点，这状态是由你自己来定义的（比如满足现实世界中的约束）。满足这个状态，数据就是一致的，不满足这个状态，数据就是不一致的！如果事务中的某个操作失败了，系统就会自动撤销当前正在执行的事务，返回到事务操作之前的状态。</p><ul><li><strong>隔离型（isolation）：</strong></li></ul><p>事务的隔离性是指一个事务的执行 <strong>不能被其他事务干扰</strong> ，即一个事务内部的操作及使用的数据对 <strong>并发</strong> 的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</p><p>如果无法保证隔离性会怎么样？假设A账户有200元，B账户0元。A账户往B账户转账两次，每次金额为50<br>元，分别在两个事务中执行。如果无法保证隔离性，会出现下面的情形：  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">UPDATE</span> accounts <span class="token keyword">SET</span> money <span class="token operator">=</span> money <span class="token operator">-</span> <span class="token number">50</span> <span class="token keyword">WHERE</span> NAME <span class="token operator">=</span> <span class="token string">'AA'</span><span class="token punctuation">;</span><span class="token keyword">UPDATE</span> accounts <span class="token keyword">SET</span> money <span class="token operator">=</span> money <span class="token operator">+</span> <span class="token number">50</span> <span class="token keyword">WHERE</span> NAME <span class="token operator">=</span> <span class="token string">'BB'</span><span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220114115057584.png" alt="image-20220114115057584"></p><ul><li><strong>持久性（durability）：</strong></li></ul><p>持久性是指一个事务一旦被提交，它对数据库中数据的改变就是 <strong>永久性</strong>的 ，接下来的其他操作和数据库故障不应该对其有任何影响。</p><p>持久性是通过 <strong>事务日志</strong> 来保证的。日志包括了 <code>重做日志</code> 和 <code>回滚日志</code> 。当我们通过事务对数据进行修改的时候，首先会将数据库的变化信息记录到重做日志中，然后再对数据库中对应的行进行修改。这样做的好处是，即使数据库系统崩溃，数据库重启后也能找到没有更新到数据库系统中的重做日志，重新执行，从而使事务具有持久性。  </p><h3 id="1-4-事务的状态"><a href="#1-4-事务的状态" class="headerlink" title="1.4 事务的状态"></a>1.4 事务的状态</h3><p>我们现在知道 <strong>事务</strong> 是一个抽象的概念，它其实对应着一个或多个数据库操作，MySQL根据这些操作所执行的不同阶段把 <strong>事务</strong> 大致划分成几个状态：</p><ul><li><strong>活动的（active）</strong></li></ul><p>事务对应的数据库操作正在执行过程中时，我们就说该事务处在 <strong>活动的</strong> 状态。</p><ul><li><strong>部分提交的（partially committed）</strong></li></ul><p>当事务中的最后一个操作执行完成，但由于操作都在内存中执行，所造成的影响并 <strong>没有刷新到磁盘</strong>时，我们就说该事务处在 <strong>部分提交</strong>的 状态。</p><ul><li><strong>失败的（failed）</strong></li></ul><p>当事务处在 <strong>活动的</strong> 或者 部分提交的 状态时，可能遇到了某些错误（数据库自身的错误、操作系统错误或者直接断电等）而无法继续执行，或者人为的停止当前事务的执行，我们就说该事务处在 <strong>失败的</strong> 状态。  </p><ul><li><strong>中止的（aborted）</strong></li></ul><p>如果事务执行了一部分而变为 <strong>失败的</strong> 状态，那么就需要把已经修改的事务中的操作还原到事务执行前的状态。换句话说，就是要撤销失败事务对当前数据库造成的影响。我们把这个撤销的过程称之为 <strong>回滚</strong> 。当 回滚 操作执行完毕时，也就是数据库恢复到了执行事务之前的状态，我们就说该事务处在了 <strong>中止的</strong> 状态。<br>举例：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">UPDATE</span> accounts <span class="token keyword">SET</span> money <span class="token operator">=</span> money <span class="token operator">-</span> <span class="token number">50</span> <span class="token keyword">WHERE</span> NAME <span class="token operator">=</span> <span class="token string">'AA'</span><span class="token punctuation">;</span><span class="token keyword">UPDATE</span> accounts <span class="token keyword">SET</span> money <span class="token operator">=</span> money <span class="token operator">+</span> <span class="token number">50</span> <span class="token keyword">WHERE</span> NAME <span class="token operator">=</span> <span class="token string">'BB'</span><span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><strong>提交的（committed）</strong></li></ul><p>当一个处在 <strong>部分提交的</strong> 状态的事务将修改过的数据都 <strong>同步到磁盘</strong> 上之后，我们就可以说该事务处在了 <strong>提交的</strong> 状态。</p><p>一个基本的状态转换图如下所示：  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220114115758371.png" alt="image-20220114115758371"></p><h2 id="2-如何使用事务"><a href="#2-如何使用事务" class="headerlink" title="2. 如何使用事务"></a>2. 如何使用事务</h2><p>使用事务有两种方式，分别为 <strong>显式事务</strong> 和 <strong>隐式事务</strong> 。</p><h3 id="2-1-显式事务"><a href="#2-1-显式事务" class="headerlink" title="2.1 显式事务"></a>2.1 显式事务</h3><p><strong>步骤1</strong>： <code>START TRANSACTION </code>或者 <code>BEGIN</code> ，作用是显式开启一个事务。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">BEGIN</span><span class="token punctuation">;</span><span class="token comment">#或者</span>mysql<span class="token operator">></span> <span class="token keyword">START</span> <span class="token keyword">TRANSACTION</span><span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p> <code>START TRANSACTION</code> 语句相较于 <code>BEGIN</code> 特别之处在于，后边能跟随几个 <strong>修饰符</strong> ：</p><p>① <code>READ ONLY</code> ：标识当前事务是一个 <strong>只读事务</strong> ，也就是属于该事务的数据库操作只能读取数据，而不能修改数据。</p><p>② <code>READ WRITE</code> ：标识当前事务是一个 <strong>读写事务</strong> ，也就是属于该事务的数据库操作既可以读取数据，也可以修改数据。</p><p>③ <code>WITH CONSISTENT SNAPSHOT</code> ：启动一致性读。</p><p><strong>步骤2</strong>：一系列事务中的操作（主要是DML，不含DDL）</p><p><strong>步骤3</strong>：提交事务 或 中止事务（即回滚事务）  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># 提交事务。当提交事务后，对数据库的修改是永久性的。</span>mysql<span class="token operator">></span> <span class="token keyword">COMMIT</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># 回滚事务。即撤销正在进行的所有没有提交的修改</span>mysql<span class="token operator">></span> <span class="token keyword">ROLLBACK</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># 将事务回滚到某个保存点。</span>mysql<span class="token operator">></span> <span class="token keyword">ROLLBACK</span> <span class="token keyword">TO</span> <span class="token punctuation">[</span><span class="token keyword">SAVEPOINT</span><span class="token punctuation">]</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="2-2-隐式事务"><a href="#2-2-隐式事务" class="headerlink" title="2.2 隐式事务"></a>2.2 隐式事务</h3><p>MySQL中有一个系统变量 <code>autocommit</code> ：</p><pre class="line-numbers language-none"><code class="language-none">mysql&gt; SHOW VARIABLES LIKE &#39;autocommit&#39;;+---------------+-------+| Variable_name | Value |+---------------+-------+| autocommit | ON |+---------------+-------+1 row in set (0.01 sec)  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当然，如果我们想关闭这种 <strong>自动提交</strong> 的功能，可以使用下边两种方法之一：</p><ul><li><p>显式的的使用 <code>START TRANSACTION</code> 或者<code>BEGIN</code>语句开启一个事务。这样<strong>在本次事务提交或者回滚前会暂时关闭掉自动提交的功能</strong>。</p></li><li><p>把系统变量 <code>autocommit </code>的值设置为 <code>OFF</code> ，就像这样：</p></li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SET</span> autocommit <span class="token operator">=</span> <span class="token keyword">OFF</span><span class="token punctuation">;</span><span class="token comment">#或</span><span class="token keyword">SET</span> autocommit <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="2-3-隐式提交数据的情况"><a href="#2-3-隐式提交数据的情况" class="headerlink" title="2.3 隐式提交数据的情况"></a>2.3 隐式提交数据的情况</h3><ul><li><p>数据定义语言（Data definition language，缩写为：DDL）</p></li><li><p>隐式使用或修改mysql数据库中的表</p></li><li><p>事务控制或关于锁定的语句</p></li></ul><p>​    ① 当我们在一个事务还没提交或者回滚时就又使用 START TRANSACTION 或者 BEGIN 语句开启了另一个事务时，会 隐式的提交 上一个事务。即：</p><p>​    ② 当前的 autocommit 系统变量的值为 OFF ，我们手动把它调为 ON 时，也会 隐式的提交 前边语句所属的事务。</p><p>​    ③ 使用 LOCK TABLES 、 UNLOCK TABLES 等关于锁定的语句也会 隐式的提交 前边语句所属的事务。</p><ul><li>加载数据的语句</li><li>关于MySQL复制的一些语句</li><li>其它的一些语句</li></ul><h3 id="2-4-使用举例1：提交与回滚"><a href="#2-4-使用举例1：提交与回滚" class="headerlink" title="2.4 使用举例1：提交与回滚"></a>2.4 使用举例1：提交与回滚</h3><p>我们看下在 MySQL 的默认状态下，下面这个事务最后的处理结果是什么。</p><p><strong>情况1</strong>：  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token keyword">user</span><span class="token punctuation">(</span>name <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span><span class="token punctuation">;</span><span class="token keyword">BEGIN</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token keyword">user</span> <span class="token keyword">SELECT</span> <span class="token string">'张三'</span><span class="token punctuation">;</span><span class="token keyword">COMMIT</span><span class="token punctuation">;</span><span class="token keyword">BEGIN</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token keyword">user</span> <span class="token keyword">SELECT</span> <span class="token string">'李四'</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token keyword">user</span> <span class="token keyword">SELECT</span> <span class="token string">'李四'</span><span class="token punctuation">;</span><span class="token keyword">ROLLBACK</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> <span class="token keyword">user</span><span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果（1 行数据）：  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">commit</span><span class="token punctuation">;</span>Query OK<span class="token punctuation">,</span> <span class="token number">0</span> <span class="token keyword">rows</span> affected <span class="token punctuation">(</span><span class="token number">0.00</span> 秒<span class="token punctuation">)</span>mysql<span class="token operator">></span> <span class="token keyword">BEGIN</span><span class="token punctuation">;</span>Query OK<span class="token punctuation">,</span> <span class="token number">0</span> <span class="token keyword">rows</span> affected <span class="token punctuation">(</span><span class="token number">0.00</span> 秒<span class="token punctuation">)</span>mysql<span class="token operator">></span> <span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token keyword">user</span> <span class="token keyword">SELECT</span> <span class="token string">'李四'</span><span class="token punctuation">;</span>Query OK<span class="token punctuation">,</span> <span class="token number">1</span> <span class="token keyword">rows</span> affected <span class="token punctuation">(</span><span class="token number">0.00</span> 秒<span class="token punctuation">)</span>mysql<span class="token operator">></span> <span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token keyword">user</span> <span class="token keyword">SELECT</span> <span class="token string">'李四'</span><span class="token punctuation">;</span><span class="token keyword">Duplicate</span> entry <span class="token string">'李四'</span> <span class="token keyword">for</span> <span class="token keyword">key</span> <span class="token string">'user.PRIMARY'</span>mysql<span class="token operator">></span> <span class="token keyword">ROLLBACK</span><span class="token punctuation">;</span>Query OK<span class="token punctuation">,</span> <span class="token number">0</span> <span class="token keyword">rows</span> affected <span class="token punctuation">(</span><span class="token number">0.01</span> 秒<span class="token punctuation">)</span>mysql<span class="token operator">></span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">user</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">--------+</span><span class="token operator">|</span> name   <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">--------+</span><span class="token operator">|</span> 张三    <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">--------+</span><span class="token number">1</span> 行于数据集 <span class="token punctuation">(</span><span class="token number">0.01</span> 秒<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>情况2</strong>：  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token keyword">user</span> <span class="token punctuation">(</span>name <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span><span class="token punctuation">;</span><span class="token keyword">BEGIN</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token keyword">user</span> <span class="token keyword">SELECT</span> <span class="token string">'张三'</span><span class="token punctuation">;</span><span class="token keyword">COMMIT</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token keyword">user</span> <span class="token keyword">SELECT</span> <span class="token string">'李四'</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token keyword">user</span> <span class="token keyword">SELECT</span> <span class="token string">'李四'</span><span class="token punctuation">;</span><span class="token keyword">ROLLBACK</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果（2 行数据）：  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> <span class="token keyword">user</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">--------+</span><span class="token operator">|</span> name   <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">--------+</span><span class="token operator">|</span>  张三   <span class="token operator">|</span> <span class="token operator">|</span>  李四   <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">--------+</span><span class="token number">2</span> 行于数据集 <span class="token punctuation">(</span><span class="token number">0.01</span> 秒<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>情况3</strong>：  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token keyword">user</span><span class="token punctuation">(</span>name <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span><span class="token punctuation">;</span><span class="token keyword">SET</span> @<span class="token variable">@completion_type</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">BEGIN</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token keyword">user</span> <span class="token keyword">SELECT</span> <span class="token string">'张三'</span><span class="token punctuation">;</span><span class="token keyword">COMMIT</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token keyword">user</span> <span class="token keyword">SELECT</span> <span class="token string">'李四'</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token keyword">user</span> <span class="token keyword">SELECT</span> <span class="token string">'李四'</span><span class="token punctuation">;</span><span class="token keyword">ROLLBACK</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> <span class="token keyword">user</span><span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果（1 行数据）：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> <span class="token keyword">user</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">--------+</span><span class="token operator">|</span> name   <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">--------+</span><span class="token operator">|</span> 张三    <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">--------+</span><span class="token number">1</span> 行于数据集 <span class="token punctuation">(</span><span class="token number">0.01</span> 秒<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注</strong>：</p><p>当我们设置 <code> autocommit=0</code> 时，不论是否采用 START TRANSACTION 或者 BEGIN 的方式来开启事务，都需要用 <code>COMMIT </code>进行提交，让事务生效，使用 <code>ROLLBACK</code> 对事务进行回滚。</p><p>当我们设置 <code>autocommit=1</code> 时，每条 SQL 语句都会自动进行提交。 不过这时，如果你采用<code>START TRANSACTION</code>或者 <code>BEGIN</code> 的方式来显式地开启事务，那么这个事务只有在 COMMIT 时才会生效，在 <code>ROLLBACK </code>时才会回滚。  </p><h2 id="3-事务隔离级别"><a href="#3-事务隔离级别" class="headerlink" title="3. 事务隔离级别"></a>3. 事务隔离级别</h2><p>MySQL是一个<code>客户端／服务器</code> 架构的软件，对于同一个服务器来说，可以有若干个客户端与之连接，每个客户端与服务器连接上之后，就可以称为一个会话（ <strong>Session</strong> ）。每个客户端都可以在自己的会话中向服务器发出请求语句，一个请求语句可能是某个事务的一部分，也就是<strong>对于服务器来说可能同时处理多个事务</strong>。事务有 <code>隔离性</code>的特性，理论上在某个事务 对某个数据进行访问 时，其他事务应该进行 排<br>队 ，当该事务提交之后，其他事务才可以继续访问这个数据。但是这样对 <strong>性能影响</strong>太大 ，我们既想保持事务的隔离性，又想让服务器在处理访问同一数据的多个事务时 <code>性能尽量高些</code> ，那就看二者如何权衡取舍了。</p><h3 id="3-1-数据准备"><a href="#3-1-数据准备" class="headerlink" title="3.1 数据准备"></a>3.1 数据准备</h3><p>我们需要创建一个表：  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> student <span class="token punctuation">(</span>studentno <span class="token keyword">INT</span><span class="token punctuation">,</span>name <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">,</span>class <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>studentno<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">Engine</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8<span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后向这个表里插入一条数据：  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> student <span class="token keyword">VALUES</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'小谷'</span><span class="token punctuation">,</span> <span class="token string">'1班'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>现在表里的数据就是这样的：  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> student<span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">-----------+--------+-------+</span><span class="token operator">|</span> studentno <span class="token operator">|</span> name   <span class="token operator">|</span> class <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">-----------+--------+-------+ </span><span class="token operator">|</span>         <span class="token number">1</span> <span class="token operator">|</span> 小谷    <span class="token operator">|</span> <span class="token number">1</span>班   <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">-----------+--------+-------+</span><span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-2-数据并发问题"><a href="#3-2-数据并发问题" class="headerlink" title="3.2 数据并发问题"></a>3.2 数据并发问题</h3><p>针对事务的隔离性和并发性，我们怎么做取舍呢？先看一下访问相同数据的事务在 <strong>不保证串行执行</strong> （也就是不保证执行完一个再执行另一个）的情况下可能会出现哪些问题：  </p><p><strong>1. 脏写（ Dirty Write ）</strong></p><p>对于两个事务 Session A、Session B，如果事务Session A <strong>修改了</strong> 另一个 <strong>未提交</strong> 事务Session B <strong>修改过</strong> 的数据，那就意味着发生了 <strong>脏写</strong></p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220114123217362.png" alt="image-20220114123217362"></p><p>Session A和Session B各开启了一个事务，Session B中的事务先将 studentno 列为1的记录的name列更新为’李四’，然后Session A中的事务接着又把这条 studentno 列为1的记录的name列更新为’张三’。如果之后Session B中的事务进行了回滚，那么Session A中的更新也将不复存在，这种现象就称之为脏写。这时Session A中的事务就没有效果了，明明把数据更新了，最后也提交事务了，最后看到的数据什么变化也没有。这里大家对事务的隔离级比较了解的话，会发现默认隔离级别下，上面 sessionA 中的更新语句会处于等待状态，这里只是跟大家说明一下会出现这样现象。</p><p><strong>2. 脏读（ Dirty Read ）</strong></p><p>对于两个事务 Session A、Session B，Session A <strong>读取</strong> 了已经被 Session B <strong>更新</strong> 但还 没有被提交 的字段。之后若 Session B <strong>回滚</strong>,Session A 读取 的内容就是 <strong>临时且无效</strong> 的。</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220114123457085.png" alt="image-20220114123457085"></p><p>Session A和Session B各开启了一个事务，Session B中的事务先将studentno列为1的记录的name列更新为’张三’，然后Session A中的事务再去查询这条studentno为1的记录，如果读到列name的值为’张三’，而Session B中的事务稍后进行了回滚，那么Session A中的事务相当于读到了一个不存在的数据，这种现象就称之为 <strong>脏读</strong> 。</p><p><strong>3. 不可重复读（ Non-Repeatable Read ）</strong></p><p>对于两个事务Session A、Session B，Session A <strong>读取</strong> 了一个字段，然后 Session B <strong>更新</strong> 了该字段。 之后Session A 再次读取 同一个字段， <strong>值就不同</strong> 了。那就意味着发生了不可重复读。</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220114123733312.png" alt="image-20220114123733312"></p><p>我们在Session B中提交了几个 <strong>隐式事务</strong> （注意是隐式事务，意味着语句结束事务就提交了），这些事务都修改了studentno列为1的记录的列name的值，每次事务提交之后，如果Session A中的事务都可以查看到最新的值，这种现象也被称之为 <strong>不可重复读</strong> 。</p><p><strong>4. 幻读（ Phantom ）</strong></p><p>对于两个事务Session A、Session B, Session A 从一个表中 <strong>读取</strong> 了一个字段, 然后 Session B 在该表中 <strong>插入</strong> 了一些新的行。 之后, 如果 Session A 再次读取 <strong>同一个表</strong>, 就会多出几行。那就意味着发生了幻读。</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220114123846351.png" alt="image-20220114123846351"></p><p>Session A中的事务先根据条件 studentno &gt; 0这个条件查询表student，得到了name列值为’张三’的记录；之后Session B中提交了一个 <strong>隐式事务</strong> ，该事务向表student中插入了一条新记录；之后Session A中的事务再根据相同的条件 studentno &gt; 0查询表student，得到的结果集中包含Session B中的事务新插入的那条记录，这种现象也被称之为 <strong>幻读</strong> 。我们把新插入的那些记录称之为 <strong>幻影记录</strong> 。</p><h3 id="3-3-SQL中的四种隔离级别"><a href="#3-3-SQL中的四种隔离级别" class="headerlink" title="3.3 SQL中的四种隔离级别"></a>3.3 SQL中的四种隔离级别</h3><p>上面介绍了几种并发事务执行过程中可能遇到的一些问题，这些问题有轻重缓急之分，我们给这些问题按照严重性来排一下序：</p><pre class="line-numbers language-none"><code class="language-none">脏写 &gt; 脏读 &gt; 不可重复读 &gt; 幻读  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们愿意舍弃一部分隔离性来换取一部分性能在这里就体现在：设立一些隔离级别，隔离级别越低，并发问题发生的就越多。 SQL标准 中设立了<strong>4个 隔离级别</strong> ：</p><ul><li><strong>READ UNCOMMITTED</strong> ：<strong>读未提交</strong>，在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。不能避免脏读、不可重复读、幻读。</li><li><strong>READ COMMITTED</strong> ：<strong>读已提交</strong>，它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。<strong>可以避免脏读</strong>，但不可重复读、幻读问题仍然存在。</li><li><strong>REPEATABLE READ</strong> ：<strong>可重复读</strong>，事务A在读到一条数据之后，此时事务B对该数据进行了修改并提交，那么事务A再读该数据，读到的还是原来的内容。可以避免脏读、不可重复读，但幻读问题仍然存在。这是<strong>MySQL的默认隔离级别</strong>。</li></ul><p><strong>可重复读应用场景</strong>：假设你在管理一个个人银行账户表。一个表存了账户余额，一个表存了账单明细。到了月底你要做数据校对，也就是判断上个月的余额和当前余额的差额，是否与本月的账单明细一致。你一定希望在校对过程中，即使有用户发生了一笔新的交易，也不影响你的校对结果。</p><ul><li><strong>SERIALIZABLE</strong> ：<strong>可串行化</strong>，顾名思义是<strong>对于同一行记录，“写”会加“写锁”，“读”会加“读锁”</strong>。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。确保事务可以从一个表中读取相同的行。在这个事务持续期间，禁止其他事务对该表执行插入、更新和删除操作。所有的并发问题都可以避免，但性能十分低下。能避免脏读、不可重复读和幻读。</li></ul><p><strong>SQL标准</strong> 中规定，针对不同的隔离级别，并发事务可以发生不同严重程度的问题，具体情况如下：  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220114124428542.png" alt="image-20220114124428542"></p><p><strong>脏写</strong> 怎么没涉及到？因为脏写这个问题太严重了，<strong>不论是哪种隔离级别，都不允许脏写的情况发生</strong>。</p><p>不同的隔离级别有不同的现象，并有不同的锁和并发机制，隔离级别越高，数据库的并发性能就越差，4种事务隔离级别与并发性能的关系如下：  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220114124452423.png" alt="image-20220114124452423"></p><h3 id="3-4-MySQL支持的四种隔离级别"><a href="#3-4-MySQL支持的四种隔离级别" class="headerlink" title="3.4 MySQL支持的四种隔离级别"></a>3.4 MySQL支持的四种隔离级别</h3><p><strong>MySQL的默认隔离级别为REPEATABLE READ</strong>，我们可以手动修改一下事务的隔离级别。  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># 查看隔离级别，MySQL 5.7.20的版本之前：</span>mysql<span class="token operator">></span> <span class="token keyword">SHOW</span> VARIABLES <span class="token operator">LIKE</span> <span class="token string">'tx_isolation'</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">---------------+-----------------+</span><span class="token operator">|</span> Variable_name <span class="token operator">|</span> <span class="token keyword">Value</span>           <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">---------------+-----------------+ </span><span class="token operator">|</span> tx_isolation  <span class="token operator">|</span> <span class="token keyword">REPEATABLE</span><span class="token operator">-</span><span class="token keyword">READ</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">---------------+-----------------+</span><span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span><span class="token comment"># MySQL 5.7.20版本之后，引入transaction_isolation来替换tx_isolation</span><span class="token comment"># 查看隔离级别，MySQL 5.7.20的版本及之后：</span>mysql<span class="token operator">></span> <span class="token keyword">SHOW</span> VARIABLES <span class="token operator">LIKE</span> <span class="token string">'transaction_isolation'</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">-----------------------+-----------------+</span><span class="token operator">|</span> Variable_name <span class="token operator">|</span> <span class="token keyword">Value</span> <span class="token operator">|</span>                 <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">-----------------------+-----------------+</span><span class="token operator">|</span> transaction_isolation <span class="token operator">|</span> <span class="token keyword">REPEATABLE</span><span class="token operator">-</span><span class="token keyword">READ</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">-----------------------+-----------------+</span><span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.02</span> sec<span class="token punctuation">)</span><span class="token comment">#或者不同MySQL版本中都可以使用的：</span><span class="token keyword">SELECT</span> @<span class="token variable">@transaction_isolation</span><span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-5-如何设置事务的隔离级别"><a href="#3-5-如何设置事务的隔离级别" class="headerlink" title="3.5 如何设置事务的隔离级别"></a>3.5 如何设置事务的隔离级别</h3><p>通过下面的语句修改事务的隔离级别：  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SET</span> <span class="token punctuation">[</span><span class="token keyword">GLOBAL</span><span class="token operator">|</span><span class="token keyword">SESSION</span><span class="token punctuation">]</span> <span class="token keyword">TRANSACTION</span> <span class="token keyword">ISOLATION</span> <span class="token keyword">LEVEL</span> 隔离级别<span class="token punctuation">;</span><span class="token comment">#其中，隔离级别格式：</span><span class="token operator">></span> <span class="token keyword">READ</span> <span class="token keyword">UNCOMMITTED</span><span class="token operator">></span> <span class="token keyword">READ</span> <span class="token keyword">COMMITTED</span><span class="token operator">></span> <span class="token keyword">REPEATABLE</span> <span class="token keyword">READ</span><span class="token operator">></span> <span class="token keyword">SERIALIZABLE</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>或者：  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SET</span> <span class="token punctuation">[</span><span class="token keyword">GLOBAL</span><span class="token operator">|</span><span class="token keyword">SESSION</span><span class="token punctuation">]</span> TRANSACTION_ISOLATION <span class="token operator">=</span> <span class="token string">'隔离级别'</span><span class="token comment">#其中，隔离级别格式：</span><span class="token operator">></span> <span class="token keyword">READ</span><span class="token operator">-</span><span class="token keyword">UNCOMMITTED</span><span class="token operator">></span> <span class="token keyword">READ</span><span class="token operator">-</span><span class="token keyword">COMMITTED</span><span class="token operator">></span> <span class="token keyword">REPEATABLE</span><span class="token operator">-</span><span class="token keyword">READ</span><span class="token operator">></span> <span class="token keyword">SERIALIZABLE</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>关于设置时使用GLOBAL或SESSION的影响：</strong>  </p><ul><li>使用 <code>GLOBAL</code> 关键字（在全局范围影响）：  </li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SET</span> <span class="token keyword">GLOBAL</span> <span class="token keyword">TRANSACTION</span> <span class="token keyword">ISOLATION</span> <span class="token keyword">LEVEL</span> <span class="token keyword">SERIALIZABLE</span><span class="token punctuation">;</span><span class="token comment">#或</span><span class="token keyword">SET</span> <span class="token keyword">GLOBAL</span> TRANSACTION_ISOLATION <span class="token operator">=</span> <span class="token string">'SERIALIZABLE'</span><span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>使用 <code>SESSION </code>关键字（在会话范围影响）:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SET</span> <span class="token keyword">SESSION</span> <span class="token keyword">TRANSACTION</span> <span class="token keyword">ISOLATION</span> <span class="token keyword">LEVEL</span> <span class="token keyword">SERIALIZABLE</span><span class="token punctuation">;</span><span class="token comment">#或</span><span class="token keyword">SET</span> <span class="token keyword">SESSION</span> TRANSACTION_ISOLATION <span class="token operator">=</span> <span class="token string">'SERIALIZABLE'</span><span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>则：</p><ul><li><strong>对当前会话的所有后续的事务有效</strong></li><li>如果在事务之间执行，则对后续的事务有效该语句可以在已经开启的事务中间</li><li>行，但不会影响当前正在执行的事务  </li></ul><h3 id="3-6-不同隔离级别举例"><a href="#3-6-不同隔离级别举例" class="headerlink" title="3.6 不同隔离级别举例"></a>3.6 不同隔离级别举例</h3><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220114140424937.png" alt="image-20220114140424937"></p><p><strong>演示1. 读未提交之脏读</strong><br>例一：</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220114135908854.png" alt="image-20220114135908854"></p><p>例二：</p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220114135928302.png" alt="image-20220114135928302"></p><p><strong>演示2：读已提交</strong>  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220114135945107.png" alt="image-20220114135945107"></p><p>虽然已经解决脏读，但仍会发生不可重复读的情况。</p><p><strong>演示3. 可重复读</strong></p><p>设置隔离级别为可重复读，事务的执行流程如下：  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220114135954500.png" alt="image-20220114135954500"></p><p><strong>演示4：幻读</strong>  </p><p><img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220114140102345.png" alt="image-20220114140102345"></p><h2 id="面试造火箭计划！！！"><a href="#面试造火箭计划！！！" class="headerlink" title="面试造火箭计划！！！"></a>面试造火箭计划！！！</h2><p><strong>1.事务的概念是什么?</strong></p><p>事务是对数据库中数据操作的保证数据逻辑一致的最小操作单位。</p><p><strong>2.mysql的事务隔离级别读未提交, 读已提交, 可重复读, 串行各是什么意思?</strong></p><p>读未提交：一个事务读取到了其他事务未提交的操作。</p><p>读已提交：一个事务读取到了其他事务已经提交的操作。</p><p>可重复读：一个事务从它开始到结束整个生命周期中，所能读取到的数据内容和它启动的时候所能读到的数据内容是相同的。不会出现在事务运行的整个过程中，不同的时间点读取到的数据不一样的情况。</p><p>串行化：所有的事务都进行排队执行，事务之间不存才并发的情况。读有读锁，写有写锁。读、读之间不影响，读、写和写、写之间互相排斥，当遇到排斥的情况后，后发生的事务需要等待先发生的事务执行完成后才可以执行。</p><p><strong>3.读已提交, 可重复读是怎么通过视图构建实现的?</strong></p><p>读已提交：会在事务中的每一个SQL语句执行的时候都为对应的SQL创建一个一致性视图。此时这个SQL能读取到已经提交的事务对数据的操作。</p><p>可重复读：会在事务启动的时候，为整个事务创建一个一致性视图，这个视图会贯穿到这个事务执行结束。在整个事务执行过程中，都使用这个视图中的数据作为一致性读的依据。</p><p><strong>4.可重复读的使用场景举例?</strong></p><p>对账的时候：假设你在管理一个个人银行账户表。一个表存了账户余额，一个表存了账单明细。到了月底你要做数据校对，也就是判断上个月的余额和当前余额的差额，是否与本月的账单明细一致。你一定希望在校对过程中，即使有用户发生了一笔新的交易，也不影响你的校对结果。</p><p>库管盘货</p><p><strong>5.事务隔离是怎么通过read-view(读视图)实现的?</strong></p><p>每一行数有多个版本，当我们要去读取数据的时候，要判断这个数据的版本号，对当前事务而言，是否可见，如果不可见，则要根据undolog计算得到上一个版本。如果上一个版本也不符合要求，则要找到再上一个版本，<br>直到找到对应正确的数据版本。</p><p><strong>6.并发版本控制(MCVV)的概念是什么, 是怎么实现的?</strong></p><p><strong>7.使用长事务的弊病? 为什么使用常事务可能拖垮整个库?</strong></p><p>长事务导致表空间持续增长，即便是事务提交或者回滚后，回滚表空间被是否后，表空间大小仍然不会被缩小。</p><p>长事务的存在导致锁发生冲突或等待的几率大大增加。</p><p>如果某个应用有发生锁等待后尝试重新建立连接的机制，那么在发生锁等待或冲突的时候，应用就会不断地发起新的连接，导致MySQL的连接数被占用爆满。MySQL不能在提供连接服务，就挂掉了。</p><p><strong>8.事务的启动方式有哪几种?</strong></p><p>begin;–一致性读的视图不会马上创建，而是在执行begin后面的第一个操作innodb表的SQL语句时生成。这个SQL可以是</p><p>select,update,delete,insert。事务ID也是此时被分配的</p><p>start transaction;–和begin的功能效果一样。</p><p>start transaciton with consistent snapshot;–该语句执行后，会马上创建一致性读的视图。这个是它和begin的区别。事务ID也是此时被</p><p>分配的。</p><p><strong>9.commit work and chain的语法是做什么用的?</strong></p><p>提交上一个事务，并且再开启一个新的事务。它的功能等效于：commit + begin。</p><p><strong>10.怎么查询各个表中的长事务?</strong></p><p>select * from information_schema.innodb_trx;</p><p>这个表中记录了所有正在运行的事务信息，里面有事务的开始时间。可以从这里看出哪些事务运行的时间比较长。</p><p><strong>11.如何避免长事务的出现?</strong></p><p>从数据库方面：</p><ul><li>  a.设置autocommit=1，不要设置为0。</li><li>  b.写脚本监控information_schemal.innodb_trx表中数据内容，发现长事务，kill掉它。</li><li>  c.配置SQL语句所能执行的最大运行时间，如果查过最大运行时间后，中断这个运行事情长的SQL语句。</li><li>  d.设置回滚表空单独存放，便于回收表空间。</li></ul><p>从业务代码方面：</p><ul><li>  a.确认是否使用了autocommit=0的配置，如果有关闭它，然后再业务代码中手动的使用begin;commit来操作。</li><li>  b.检查业务逻辑代码，能拆分为小事务的不要用大事务。</li><li>  c.检查代码，把没有必要的select语句被事务包裹的情况去掉。</li></ul>]]></content>
      
      
      <categories>
          
          <category> database </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
